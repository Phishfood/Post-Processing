; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Simon\Documents\GitHub\Post-Processing\CTimer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0CTimer@@QAE@XZ				; CTimer::CTimer
PUBLIC	?Start@CTimer@@QAEXXZ				; CTimer::Start
PUBLIC	?Stop@CTimer@@QAEXXZ				; CTimer::Stop
PUBLIC	?Reset@CTimer@@QAEXXZ				; CTimer::Reset
PUBLIC	?GetFrequency@CTimer@@QAEMXZ			; CTimer::GetFrequency
PUBLIC	?GetTime@CTimer@@QAEMXZ				; CTimer::GetTime
PUBLIC	?GetLapTime@CTimer@@QAEMXZ			; CTimer::GetLapTime
PUBLIC	__real@447a0000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__ltod3:PROC
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\ctimer.cpp
;	COMDAT ?GetLapTime@CTimer@@QAEMXZ
_TEXT	SEGMENT
tv93 = -8						; size = 8
_newHighResTime$1 = -8					; size = 8
_fTime$ = -4						; size = 4
?GetLapTime@CTimer@@QAEMXZ PROC				; CTimer::GetLapTime, COMDAT
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 148  : 	float fTime;
; 149  : 	if (m_HighRes)

	cmp	BYTE PTR [esi+1], 0
	je	SHORT $LN6@GetLapTime

; 150  : 	{
; 151  : 		LARGE_INTEGER newHighResTime;
; 152  : 		if (m_Running)

	cmp	BYTE PTR [esi], 0
	push	ebx
	push	edi
	je	SHORT $LN5@GetLapTime

; 153  : 		{
; 154  : 			QueryPerformanceCounter( &newHighResTime );

	lea	eax, DWORD PTR _newHighResTime$1[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 155  : 		}
; 156  : 		else

	mov	edi, DWORD PTR _newHighResTime$1[ebp+4]
	mov	ebx, DWORD PTR _newHighResTime$1[ebp]
	jmp	SHORT $LN4@GetLapTime
$LN5@GetLapTime:

; 157  : 		{
; 158  : 			newHighResTime = m_HighResStop;

	mov	ebx, DWORD PTR [esi+32]
	mov	edi, DWORD PTR [esi+36]
$LN4@GetLapTime:

; 159  : 		}
; 160  : 		double dTime = static_cast<double>(newHighResTime.QuadPart - m_HighResLap.QuadPart) /
; 161  : 			           static_cast<double>(m_HighResFreq.QuadPart);

	mov	ecx, ebx
	mov	edx, edi
	sub	ecx, DWORD PTR [esi+24]
	sbb	edx, DWORD PTR [esi+28]
	call	__ltod3
	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	movsd	QWORD PTR tv93[ebp], xmm0
	call	__ltod3
	movsd	xmm1, QWORD PTR tv93[ebp]
	divsd	xmm1, xmm0

; 162  : 		fTime = static_cast<float>(dTime);
; 163  : 		m_HighResLap = newHighResTime;

	mov	DWORD PTR [esi+28], edi
	pop	edi
	mov	DWORD PTR [esi+24], ebx
	pop	ebx
	pop	esi
	cvtpd2ps xmm0, xmm1

; 175  : 		}
; 176  : 		fTime = static_cast<float>(newLowResTime - m_LowResLap) / 1000.0f;

	movss	DWORD PTR _fTime$[ebp], xmm0

; 178  : 	}
; 179  : 	return fTime;

	fld	DWORD PTR _fTime$[ebp]

; 180  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@GetLapTime:

; 164  : 	}
; 165  : 	else
; 166  : 	{
; 167  : 		DWORD newLowResTime;
; 168  : 		if (m_Running)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN2@GetLapTime

; 169  : 		{
; 170  : 			newLowResTime = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0
	mov	ecx, eax

; 171  : 		}
; 172  : 		else

	jmp	SHORT $LN1@GetLapTime
$LN2@GetLapTime:

; 173  : 		{
; 174  : 			newLowResTime = m_LowResStop;

	mov	ecx, DWORD PTR [esi+48]
$LN1@GetLapTime:

; 175  : 		}
; 176  : 		fTime = static_cast<float>(newLowResTime - m_LowResLap) / 1000.0f;

	mov	eax, ecx
	sub	eax, DWORD PTR [esi+44]

; 177  : 		m_LowResLap = newLowResTime;

	mov	DWORD PTR [esi+44], ecx
	pop	esi
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _fTime$[ebp], xmm0

; 178  : 	}
; 179  : 	return fTime;

	fld	DWORD PTR _fTime$[ebp]

; 180  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLapTime@CTimer@@QAEMXZ ENDP				; CTimer::GetLapTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\ctimer.cpp
;	COMDAT ?GetTime@CTimer@@QAEMXZ
_TEXT	SEGMENT
tv133 = -8						; size = 8
_newHighResTime$1 = -8					; size = 8
_fTime$ = -4						; size = 4
?GetTime@CTimer@@QAEMXZ PROC				; CTimer::GetTime, COMDAT
; _this$ = ecx

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 110  : 	float fTime;
; 111  : 	if (m_HighRes)

	cmp	BYTE PTR [esi+1], 0
	je	SHORT $LN6@GetTime

; 112  : 	{
; 113  : 
; 114  : 		LARGE_INTEGER newHighResTime;
; 115  : 		if (m_Running)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN5@GetTime

; 116  : 		{
; 117  : 			QueryPerformanceCounter( &newHighResTime );

	lea	eax, DWORD PTR _newHighResTime$1[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 118  : 		}
; 119  : 		else

	mov	edx, DWORD PTR _newHighResTime$1[ebp+4]
	mov	ecx, DWORD PTR _newHighResTime$1[ebp]
	jmp	SHORT $LN4@GetTime
$LN5@GetTime:

; 120  : 		{
; 121  : 			newHighResTime = m_HighResStop;

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [esi+36]
$LN4@GetTime:

; 122  : 		}
; 123  : 		double dTime = static_cast<double>(newHighResTime.QuadPart - m_HighResStart.QuadPart) /
; 124  : 			           static_cast<double>(m_HighResFreq.QuadPart);

	sub	ecx, DWORD PTR [esi+16]
	sbb	edx, DWORD PTR [esi+20]
	call	__ltod3
	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	movsd	QWORD PTR tv133[ebp], xmm0
	call	__ltod3
	movsd	xmm1, QWORD PTR tv133[ebp]
	divsd	xmm1, xmm0
	pop	esi

; 125  : 		fTime = static_cast<float>(dTime);

	cvtpd2ps xmm0, xmm1

; 137  : 		}
; 138  : 		fTime = static_cast<float>(newLowResTime - m_LowResStart) / 1000.0f;

	movss	DWORD PTR _fTime$[ebp], xmm0

; 139  : 	}
; 140  : 
; 141  : 	return fTime;

	fld	DWORD PTR _fTime$[ebp]

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@GetTime:

; 126  : 	}
; 127  : 	else
; 128  : 	{
; 129  : 		DWORD newLowResTime;
; 130  : 		if (m_Running)

	cmp	BYTE PTR [esi], 0
	je	SHORT $LN2@GetTime

; 131  : 		{
; 132  : 			newLowResTime = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0

; 133  : 		}
; 134  : 		else

	jmp	SHORT $LN1@GetTime
$LN2@GetTime:

; 135  : 		{
; 136  : 			newLowResTime = m_LowResStop;

	mov	eax, DWORD PTR [esi+48]
$LN1@GetTime:

; 137  : 		}
; 138  : 		fTime = static_cast<float>(newLowResTime - m_LowResStart) / 1000.0f;

	sub	eax, DWORD PTR [esi+40]
	pop	esi
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _fTime$[ebp], xmm0

; 139  : 	}
; 140  : 
; 141  : 	return fTime;

	fld	DWORD PTR _fTime$[ebp]

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTime@CTimer@@QAEMXZ ENDP				; CTimer::GetTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\ctimer.cpp
;	COMDAT ?GetFrequency@CTimer@@QAEMXZ
_TEXT	SEGMENT
tv132 = -4						; size = 4
?GetFrequency@CTimer@@QAEMXZ PROC			; CTimer::GetFrequency, COMDAT
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 96   : 	// Select high or low-resolution timer
; 97   : 	if (m_HighRes)

	cmp	BYTE PTR [ecx+1], 0
	je	SHORT $LN2@GetFrequen

; 98   : 	{
; 99   : 		return static_cast<float>(m_HighResFreq.QuadPart);

	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+8]
	call	__ltod3
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv132[ebp], xmm0
	fld	DWORD PTR tv132[ebp]

; 104  : 	}
; 105  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@GetFrequen:

; 100  : 	}
; 101  : 	else
; 102  : 	{
; 103  : 		return 1000.0f;

	fld	DWORD PTR __real@447a0000

; 104  : 	}
; 105  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrequency@CTimer@@QAEMXZ ENDP			; CTimer::GetFrequency
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\ctimer.cpp
;	COMDAT ?Reset@CTimer@@QAEXXZ
_TEXT	SEGMENT
?Reset@CTimer@@QAEXXZ PROC				; CTimer::Reset, COMDAT
; _this$ = ecx

; 72   : {

	push	edi
	mov	edi, ecx

; 73   : 	// Reset start, lap and stop times to current time
; 74   : 	// Select high or low-resolution timer
; 75   : 	if (m_HighRes)

	cmp	BYTE PTR [edi+1], 0
	je	SHORT $LN2@Reset

; 76   : 	{
; 77   : 		QueryPerformanceCounter( &m_HighResStart );

	push	esi
	lea	esi, DWORD PTR [edi+16]
	push	esi
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 78   : 		m_HighResLap = m_HighResStart;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi+24], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+28], eax

; 79   : 		m_HighResStop = m_HighResStart;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi+32], eax
	mov	eax, DWORD PTR [esi+4]
	pop	esi
	mov	DWORD PTR [edi+36], eax
	pop	edi

; 86   : 	}
; 87   : }

	ret	0
$LN2@Reset:

; 80   : 	}
; 81   : 	else
; 82   : 	{
; 83   : 		m_LowResStart = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR [edi+40], eax

; 84   : 		m_LowResLap = m_LowResStart;

	mov	DWORD PTR [edi+44], eax

; 85   : 		m_LowResStop = m_LowResStart;

	mov	DWORD PTR [edi+48], eax
	pop	edi

; 86   : 	}
; 87   : }

	ret	0
?Reset@CTimer@@QAEXXZ ENDP				; CTimer::Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\ctimer.cpp
;	COMDAT ?Stop@CTimer@@QAEXXZ
_TEXT	SEGMENT
?Stop@CTimer@@QAEXXZ PROC				; CTimer::Stop, COMDAT
; _this$ = ecx

; 55   : {

	push	esi
	mov	esi, ecx

; 56   : 	m_Running = false;
; 57   : 
; 58   : 	// Get stop time
; 59   : 	// Select high or low-resolution timer
; 60   : 	if (m_HighRes)

	cmp	BYTE PTR [esi+1], 0
	mov	BYTE PTR [esi], 0
	je	SHORT $LN2@Stop

; 61   : 	{
; 62   : 		QueryPerformanceCounter( &m_HighResStop );

	lea	eax, DWORD PTR [esi+32]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	pop	esi

; 67   : 	}
; 68   : }

	ret	0
$LN2@Stop:

; 63   : 	}
; 64   : 	else
; 65   : 	{
; 66   : 		m_LowResStop = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR [esi+48], eax
	pop	esi

; 67   : 	}
; 68   : }

	ret	0
?Stop@CTimer@@QAEXXZ ENDP				; CTimer::Stop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\ctimer.cpp
;	COMDAT ?Start@CTimer@@QAEXXZ
_TEXT	SEGMENT
_newHighResTime$1 = -12					; size = 8
_this$1$ = -4						; size = 4
?Start@CTimer@@QAEXXZ PROC				; CTimer::Start, COMDAT
; _this$ = ecx

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 30   : 	if (!m_Running)

	cmp	BYTE PTR [ebx], 0
	jne	SHORT $LN1@Start

; 31   : 	{
; 32   : 		m_Running = true;
; 33   : 
; 34   : 		// Get restart time - add time passed since stop time to the start and lap times
; 35   : 		// Select high or low-resolution timer
; 36   : 		if (m_HighRes)

	cmp	BYTE PTR [ebx+1], 0
	mov	BYTE PTR [ebx], 1
	je	SHORT $LN2@Start

; 37   : 		{
; 38   : 			LARGE_INTEGER newHighResTime;
; 39   : 			QueryPerformanceCounter( &newHighResTime );

	push	esi
	push	edi
	lea	eax, DWORD PTR _newHighResTime$1[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 40   : 			m_HighResStart.QuadPart += (newHighResTime.QuadPart - m_HighResStop.QuadPart);

	mov	edi, DWORD PTR [ebx+32]
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR _newHighResTime$1[ebp]
	mov	edx, DWORD PTR _newHighResTime$1[ebp+4]
	sub	ecx, edi
	mov	ebx, DWORD PTR [ebx+36]
	mov	eax, edx
	sbb	eax, ebx
	add	DWORD PTR [esi+16], ecx
	mov	ecx, esi

; 41   : 			m_HighResLap.QuadPart += (newHighResTime.QuadPart - m_HighResStop.QuadPart);

	mov	esi, DWORD PTR _newHighResTime$1[ebp]
	adc	DWORD PTR [ecx+20], eax
	sub	esi, edi
	pop	edi
	sbb	edx, ebx
	add	DWORD PTR [ecx+24], esi
	pop	esi
	adc	DWORD PTR [ecx+28], edx
	pop	ebx

; 49   : 		}
; 50   : 	}
; 51   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@Start:

; 42   : 		}
; 43   : 		else
; 44   : 		{
; 45   : 			DWORD newLowResTime;
; 46   : 			newLowResTime = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0

; 47   : 			m_LowResStart += (newLowResTime - m_LowResStop);

	mov	ecx, eax

; 48   : 			m_LowResLap += (newLowResTime - m_LowResStop);

	sub	eax, DWORD PTR [ebx+48]
	sub	ecx, DWORD PTR [ebx+48]
	add	DWORD PTR [ebx+40], ecx
	add	DWORD PTR [ebx+44], eax
$LN1@Start:
	pop	ebx

; 49   : 		}
; 50   : 	}
; 51   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Start@CTimer@@QAEXXZ ENDP				; CTimer::Start
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\ctimer.cpp
;	COMDAT ??0CTimer@@QAE@XZ
_TEXT	SEGMENT
??0CTimer@@QAE@XZ PROC					; CTimer::CTimer, COMDAT
; _this$ = ecx

; 14   : {

	push	edi
	mov	edi, ecx

; 15   : 	// Try to initialise performance timer, will use low-resolution timer on failure
; 16   : 	m_HighRes = (QueryPerformanceFrequency( &m_HighResFreq ) != 0);

	lea	eax, DWORD PTR [edi+8]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	test	eax, eax
	setne	al
	mov	BYTE PTR [edi+1], al

; 22   : 
; 23   : 
; 24   : //////////////////////////////
; 25   : // Timer control
; 26   : 
; 27   : // Start the timer running
; 28   : void CTimer::Start()
; 29   : {
; 30   : 	if (!m_Running)
; 31   : 	{
; 32   : 		m_Running = true;
; 33   : 
; 34   : 		// Get restart time - add time passed since stop time to the start and lap times
; 35   : 		// Select high or low-resolution timer
; 36   : 		if (m_HighRes)
; 37   : 		{
; 38   : 			LARGE_INTEGER newHighResTime;
; 39   : 			QueryPerformanceCounter( &newHighResTime );
; 40   : 			m_HighResStart.QuadPart += (newHighResTime.QuadPart - m_HighResStop.QuadPart);
; 41   : 			m_HighResLap.QuadPart += (newHighResTime.QuadPart - m_HighResStop.QuadPart);
; 42   : 		}
; 43   : 		else
; 44   : 		{
; 45   : 			DWORD newLowResTime;
; 46   : 			newLowResTime = timeGetTime();
; 47   : 			m_LowResStart += (newLowResTime - m_LowResStop);
; 48   : 			m_LowResLap += (newLowResTime - m_LowResStop);
; 49   : 		}
; 50   : 	}
; 51   : }
; 52   : 
; 53   : // Stop the timer running
; 54   : void CTimer::Stop()
; 55   : {
; 56   : 	m_Running = false;
; 57   : 
; 58   : 	// Get stop time
; 59   : 	// Select high or low-resolution timer
; 60   : 	if (m_HighRes)
; 61   : 	{
; 62   : 		QueryPerformanceCounter( &m_HighResStop );
; 63   : 	}
; 64   : 	else
; 65   : 	{
; 66   : 		m_LowResStop = timeGetTime();
; 67   : 	}
; 68   : }
; 69   : 
; 70   : // Reset the timer to zero
; 71   : void CTimer::Reset()
; 72   : {
; 73   : 	// Reset start, lap and stop times to current time
; 74   : 	// Select high or low-resolution timer
; 75   : 	if (m_HighRes)

	test	al, al
	je	SHORT $LN4@CTimer
	push	esi

; 76   : 	{
; 77   : 		QueryPerformanceCounter( &m_HighResStart );

	lea	esi, DWORD PTR [edi+16]
	push	esi
	call	DWORD PTR __imp__QueryPerformanceCounter@4

; 78   : 		m_HighResLap = m_HighResStart;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi+24], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+28], eax

; 79   : 		m_HighResStop = m_HighResStart;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi+32], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+36], eax

; 17   : 
; 18   : 	// Reset and start the timer
; 19   : 	Reset();
; 20   : 	m_Running = true;
; 21   : }

	mov	eax, edi
	pop	esi
	mov	BYTE PTR [edi], 1
	pop	edi
	ret	0
$LN4@CTimer:

; 80   : 	}
; 81   : 	else
; 82   : 	{
; 83   : 		m_LowResStart = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR [edi+40], eax

; 84   : 		m_LowResLap = m_LowResStart;

	mov	DWORD PTR [edi+44], eax

; 85   : 		m_LowResStop = m_LowResStart;

	mov	DWORD PTR [edi+48], eax

; 17   : 
; 18   : 	// Reset and start the timer
; 19   : 	Reset();
; 20   : 	m_Running = true;
; 21   : }

	mov	eax, edi
	mov	BYTE PTR [edi], 1
	pop	edi
	ret	0
??0CTimer@@QAE@XZ ENDP					; CTimer::CTimer
_TEXT	ENDS
END
