; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Simon\Documents\GitHub\Post-Processing\Colours.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Min@@YAMMMM@Z					; Min
PUBLIC	?Max@@YAMMMM@Z					; Max
PUBLIC	?RGBToHSL@@YAXHHHAAH00@Z			; RGBToHSL
PUBLIC	?HSLToRGB@@YAXHHHAAH00@Z			; HSLToRGB
PUBLIC	?fHSLToRGB@@YAXMMMAAM00@Z			; fHSLToRGB
PUBLIC	?AdvanceHue@@YAXHAAM00@Z			; AdvanceHue
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@42480000
PUBLIC	__real@42700000
PUBLIC	__real@42c80000
PUBLIC	__real@42f00000
PUBLIC	__real@43700000
PUBLIC	__real@437f0000
PUBLIC	__real@43b40000
EXTRN	__fltused:DWORD
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43700000
CONST	SEGMENT
__real@43700000 DD 043700000r			; 240
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\colours.cpp
;	COMDAT ?AdvanceHue@@YAXHAAM00@Z
_TEXT	SEGMENT
_S$ = -12						; size = 4
_L$ = -8						; size = 4
_H$ = -4						; size = 4
_amount$ = 8						; size = 4
_newB$ = 12						; size = 4
_R$ = 12						; size = 4
_newG$ = 16						; size = 4
_G$ = 16						; size = 4
_newR$ = 20						; size = 4
_B$ = 20						; size = 4
?AdvanceHue@@YAXHAAM00@Z PROC				; AdvanceHue, COMDAT

; 8    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 9    : 	int H, S, L;
; 10   : 	RGBToHSL( int(R*255.0f), int(G*255.0f), int(B*255.0f), H, S, L);

	movss	xmm1, DWORD PTR __real@437f0000
	lea	eax, DWORD PTR _L$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _B$[ebp]
	push	esi
	mov	esi, DWORD PTR _R$[ebp]
	push	edi
	movss	xmm0, DWORD PTR [ebx]
	mov	edi, DWORD PTR _G$[ebp]
	push	eax
	mulss	xmm0, xmm1
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	lea	eax, DWORD PTR _H$[ebp]
	push	eax
	cvttss2si eax, xmm0
	movss	xmm0, DWORD PTR [edi]
	mulss	xmm0, xmm1
	push	eax
	cvttss2si eax, xmm0
	movss	xmm0, DWORD PTR [esi]
	mulss	xmm0, xmm1
	push	eax
	cvttss2si eax, xmm0
	push	eax
	call	?RGBToHSL@@YAXHHHAAH00@Z		; RGBToHSL

; 11   : 	H += amount;

	mov	ecx, DWORD PTR _H$[ebp]

; 12   : 	H %= 360;

	mov	eax, 1240768329				; 49f49f49H
	add	ecx, DWORD PTR _amount$[ebp]
	imul	ecx
	sub	edx, ecx
	sar	edx, 8
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	imul	eax, eax, 360
	add	ecx, eax

; 13   : 	int newR, newG, newB;
; 14   : 	HSLToRGB( H, S, L, newR, newG, newB);

	lea	eax, DWORD PTR _newB$[ebp]
	push	eax
	lea	eax, DWORD PTR _newG$[ebp]
	push	eax
	lea	eax, DWORD PTR _newR$[ebp]
	push	eax
	push	DWORD PTR _L$[ebp]
	push	DWORD PTR _S$[ebp]
	push	ecx
	call	?HSLToRGB@@YAXHHHAAH00@Z		; HSLToRGB
	movd	xmm0, DWORD PTR _newR$[ebp]
	add	esp, 48					; 00000030H

; 15   : 	R = float( newR/255.0f );

	movss	xmm1, DWORD PTR __real@437f0000
	cvtdq2ps xmm0, xmm0
	divss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0
	movd	xmm0, DWORD PTR _newG$[ebp]

; 16   : 	G = float( newG/255.0f );

	cvtdq2ps xmm0, xmm0
	divss	xmm0, xmm1
	movss	DWORD PTR [edi], xmm0
	movd	xmm0, DWORD PTR _newB$[ebp]

; 17   : 	B = float( newB/255.0f );

	cvtdq2ps xmm0, xmm0
	pop	edi
	pop	esi
	divss	xmm0, xmm1
	movss	DWORD PTR [ebx], xmm0
	pop	ebx

; 18   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AdvanceHue@@YAXHAAM00@Z ENDP				; AdvanceHue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\colours.cpp
;	COMDAT ?fHSLToRGB@@YAXMMMAAM00@Z
_TEXT	SEGMENT
_h$ = 8							; size = 4
_sl$ = 12						; size = 4
_l$ = 16						; size = 4
_r$ = 20						; size = 4
_g$ = 24						; size = 4
_b$ = 28						; size = 4
?fHSLToRGB@@YAXMMMAAM00@Z PROC				; fHSLToRGB, COMDAT

; 167  : {

	push	ebp
	mov	ebp, esp

; 168  :     float v;
; 169  : 
; 170  :     r = l;   // default to gray

	movss	xmm4, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR _r$[ebp]

; 171  :     g = l;

	mov	ecx, DWORD PTR _g$[ebp]

; 172  :     b = l;

	mov	edx, DWORD PTR _b$[ebp]

; 173  :     v = (l <= 0.5f) ? (l * (1.0f + sl)) : (l + sl - l * sl);

	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, xmm4
	movss	DWORD PTR [eax], xmm4
	movss	DWORD PTR [ecx], xmm4
	movss	DWORD PTR [edx], xmm4
	jb	SHORT $LN12@fHSLToRGB
	movss	xmm3, DWORD PTR _sl$[ebp]
	addss	xmm3, DWORD PTR __real@3f800000
	mulss	xmm3, xmm4
	jmp	SHORT $LN13@fHSLToRGB
$LN12@fHSLToRGB:
	movss	xmm0, DWORD PTR _sl$[ebp]
	movaps	xmm3, xmm0
	mulss	xmm0, xmm4
	addss	xmm3, xmm4
	subss	xmm3, xmm0
$LN13@fHSLToRGB:

; 174  :     if (v > 0)

	comiss	xmm3, DWORD PTR __real@00000000
	push	esi
	jbe	$LN7@fHSLToRGB

; 175  :     {
; 176  :             float m;
; 177  :             float sv;
; 178  :             int sextant;
; 179  :             float fract, vsf, mid1, mid2;
; 180  :  
; 181  :             m = l + l - v;

	movss	xmm0, DWORD PTR _h$[ebp]
	addss	xmm4, xmm4

; 182  :             sv = (v - m ) / v;
; 183  :             h *= 6.0;

	cvtps2pd xmm0, xmm0
	subss	xmm4, xmm3
	movaps	xmm2, xmm3
	mulsd	xmm0, QWORD PTR __real@4018000000000000
	subss	xmm2, xmm4
	cvtpd2ps xmm1, xmm0
	divss	xmm2, xmm3

; 184  :             sextant = (int)h;

	cvttss2si esi, xmm1

; 185  :             fract = h - sextant;
; 186  :             vsf = v * sv * fract;

	mulss	xmm2, xmm3
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	subss	xmm1, xmm0
	mulss	xmm2, xmm1

; 187  :             mid1 = m + vsf;
; 188  :             mid2 = v - vsf;

	movaps	xmm1, xmm3
	subss	xmm1, xmm2
	movaps	xmm0, xmm2
	addss	xmm0, xmm4

; 189  :             switch (sextant)

	cmp	esi, 5
	ja	SHORT $LN7@fHSLToRGB
	jmp	DWORD PTR $LN15@fHSLToRGB[esi*4]
$LN6@fHSLToRGB:

; 190  :             {
; 191  :                 case 0:
; 192  :                         r = v;

	movss	DWORD PTR [eax], xmm3

; 193  :                         g = mid1;

	movss	DWORD PTR [ecx], xmm0

; 194  :                         b = m;

	movss	DWORD PTR [edx], xmm4
	pop	esi

; 220  :                         break;
; 221  :             }
; 222  :     }
; 223  :     return;
; 224  : }

	pop	ebp
	ret	0
$LN5@fHSLToRGB:

; 195  :                         break;
; 196  :                 case 1:
; 197  :                         r = mid2;

	movss	DWORD PTR [eax], xmm1

; 198  :                         g = v;

	movss	DWORD PTR [ecx], xmm3

; 199  :                         b = m;

	movss	DWORD PTR [edx], xmm4
	pop	esi

; 220  :                         break;
; 221  :             }
; 222  :     }
; 223  :     return;
; 224  : }

	pop	ebp
	ret	0
$LN4@fHSLToRGB:

; 200  :                         break;
; 201  :                 case 2:
; 202  :                         r = m;

	movss	DWORD PTR [eax], xmm4

; 203  :                         g = v;

	movss	DWORD PTR [ecx], xmm3

; 204  :                         b = mid1;

	movss	DWORD PTR [edx], xmm0
	pop	esi

; 220  :                         break;
; 221  :             }
; 222  :     }
; 223  :     return;
; 224  : }

	pop	ebp
	ret	0
$LN3@fHSLToRGB:

; 205  :                         break;
; 206  :                 case 3:
; 207  :                         r = m;

	movss	DWORD PTR [eax], xmm4

; 208  :                         g = mid2;

	movss	DWORD PTR [ecx], xmm1

; 209  :                         b = v;

	movss	DWORD PTR [edx], xmm3
	pop	esi

; 220  :                         break;
; 221  :             }
; 222  :     }
; 223  :     return;
; 224  : }

	pop	ebp
	ret	0
$LN2@fHSLToRGB:

; 210  :                         break;
; 211  :                 case 4:
; 212  :                         r = mid1;

	movss	DWORD PTR [eax], xmm0

; 213  :                         g = m;

	movss	DWORD PTR [ecx], xmm4

; 214  :                         b = v;

	movss	DWORD PTR [edx], xmm3
	pop	esi

; 220  :                         break;
; 221  :             }
; 222  :     }
; 223  :     return;
; 224  : }

	pop	ebp
	ret	0
$LN1@fHSLToRGB:

; 215  :                         break;
; 216  :                 case 5:
; 217  :                         r = v;

	movss	DWORD PTR [eax], xmm3

; 218  :                         g = m;

	movss	DWORD PTR [ecx], xmm4

; 219  :                         b = mid2;

	movss	DWORD PTR [edx], xmm1
$LN7@fHSLToRGB:
	pop	esi

; 220  :                         break;
; 221  :             }
; 222  :     }
; 223  :     return;
; 224  : }

	pop	ebp
	ret	0
	npad	3
$LN15@fHSLToRGB:
	DD	$LN6@fHSLToRGB
	DD	$LN5@fHSLToRGB
	DD	$LN4@fHSLToRGB
	DD	$LN3@fHSLToRGB
	DD	$LN2@fHSLToRGB
	DD	$LN1@fHSLToRGB
?fHSLToRGB@@YAXMMMAAM00@Z ENDP				; fHSLToRGB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\colours.cpp
;	COMDAT ?HSLToRGB@@YAXHHHAAH00@Z
_TEXT	SEGMENT
_hin$ = 8						; size = 4
_slin$ = 12						; size = 4
_lin$ = 16						; size = 4
_rout$ = 20						; size = 4
_gout$ = 24						; size = 4
_bout$ = 28						; size = 4
?HSLToRGB@@YAXHHHAAH00@Z PROC				; HSLToRGB, COMDAT

; 100  : {

	push	ebp
	mov	ebp, esp
	movd	xmm4, DWORD PTR _lin$[ebp]

; 101  : 	float h = hin / 360.0f;
; 102  : 	float sl = slin / 100.0f;
; 103  : 	float l = lin / 100.0f;

	cvtdq2ps xmm4, xmm4
	movd	xmm2, DWORD PTR _hin$[ebp]
	divss	xmm4, DWORD PTR __real@42c80000
	movd	xmm3, DWORD PTR _slin$[ebp]

; 104  :     float v;
; 105  :     float r,g,b;
; 106  :  
; 107  :     r = l;   // default to gray
; 108  :     g = l;
; 109  :     b = l;
; 110  :     v = (l <= 0.5f) ? (l * (1.0f + sl)) : (l + sl - l * sl);

	movss	xmm0, DWORD PTR __real@3f000000
	movaps	xmm5, xmm4
	comiss	xmm0, xmm4
	cvtdq2ps xmm2, xmm2
	cvtdq2ps xmm3, xmm3
	divss	xmm2, DWORD PTR __real@43b40000
	divss	xmm3, DWORD PTR __real@42c80000
	movaps	xmm6, xmm4
	jb	SHORT $LN12@HSLToRGB
	addss	xmm3, DWORD PTR __real@3f800000
	mulss	xmm3, xmm4
	jmp	SHORT $LN13@HSLToRGB
$LN12@HSLToRGB:
	movaps	xmm1, xmm4
	movaps	xmm0, xmm4
	addss	xmm1, xmm3
	mulss	xmm0, xmm3
	subss	xmm1, xmm0
	movaps	xmm3, xmm1
$LN13@HSLToRGB:

; 111  :     if (v > 0)

	comiss	xmm3, DWORD PTR __real@00000000
	jbe	$LN7@HSLToRGB

; 112  :     {
; 113  :             float m;
; 114  :             float sv;
; 115  :             int sextant;
; 116  :             float fract, vsf, mid1, mid2;
; 117  :  
; 118  :             m = l + l - v;

	movaps	xmm7, xmm4
	addss	xmm7, xmm4

; 119  :             sv = (v - m ) / v;
; 120  :             h *= 6.0;

	cvtps2pd xmm0, xmm2
	subss	xmm7, xmm3
	movaps	xmm2, xmm3
	mulsd	xmm0, QWORD PTR __real@4018000000000000
	subss	xmm2, xmm7
	cvtpd2ps xmm1, xmm0
	divss	xmm2, xmm3

; 121  :             sextant = (int)h;

	cvttss2si eax, xmm1

; 122  :             fract = h - sextant;
; 123  :             vsf = v * sv * fract;

	mulss	xmm2, xmm3
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm1, xmm0
	mulss	xmm2, xmm1

; 124  :             mid1 = m + vsf;
; 125  :             mid2 = v - vsf;

	movaps	xmm1, xmm3
	subss	xmm1, xmm2
	movaps	xmm0, xmm2
	addss	xmm0, xmm7

; 126  :             switch (sextant)

	cmp	eax, 5
	ja	SHORT $LN7@HSLToRGB
	jmp	DWORD PTR $LN16@HSLToRGB[eax*4]
$LN6@HSLToRGB:

; 127  :             {
; 128  :                 case 0:
; 129  :                         r = v;
; 130  :                         g = mid1;

	movaps	xmm5, xmm0

; 131  :                         b = m;

	movaps	xmm6, xmm7

; 132  :                         break;

	jmp	SHORT $LN14@HSLToRGB
$LN5@HSLToRGB:

; 133  :                 case 1:
; 134  :                         r = mid2;

	movaps	xmm4, xmm1

; 135  :                         g = v;

	movaps	xmm5, xmm3

; 136  :                         b = m;

	movaps	xmm6, xmm7

; 137  :                         break;

	jmp	SHORT $LN7@HSLToRGB
$LN4@HSLToRGB:

; 138  :                 case 2:
; 139  :                         r = m;

	movaps	xmm4, xmm7

; 140  :                         g = v;

	movaps	xmm5, xmm3

; 141  :                         b = mid1;

	movaps	xmm6, xmm0

; 142  :                         break;

	jmp	SHORT $LN7@HSLToRGB
$LN3@HSLToRGB:

; 143  :                 case 3:
; 144  :                         r = m;

	movaps	xmm4, xmm7

; 145  :                         g = mid2;

	movaps	xmm5, xmm1

; 146  :                         b = v;

	movaps	xmm6, xmm3

; 147  :                         break;

	jmp	SHORT $LN7@HSLToRGB
$LN2@HSLToRGB:

; 148  :                 case 4:
; 149  :                         r = mid1;

	movaps	xmm4, xmm0

; 150  :                         g = m;

	movaps	xmm5, xmm7

; 151  :                         b = v;

	movaps	xmm6, xmm3

; 152  :                         break;

	jmp	SHORT $LN7@HSLToRGB
$LN1@HSLToRGB:

; 155  :                         g = m;

	movaps	xmm5, xmm7

; 156  :                         b = mid2;

	movaps	xmm6, xmm1
$LN14@HSLToRGB:

; 153  :                 case 5:
; 154  :                         r = v;

	movaps	xmm4, xmm3
$LN7@HSLToRGB:

; 157  :                         break;
; 158  :             }
; 159  :     }
; 160  : 	rout = int( r * 255.0f );

	movss	xmm0, DWORD PTR __real@437f0000
	mov	eax, DWORD PTR _rout$[ebp]
	mulss	xmm4, xmm0

; 161  : 	bout = int( b * 255.0f );

	mulss	xmm6, xmm0
	cvttss2si ecx, xmm4

; 162  : 	gout = int( g * 255.0f );

	mulss	xmm5, xmm0
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _bout$[ebp]
	cvttss2si ecx, xmm6
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _gout$[ebp]
	cvttss2si ecx, xmm5
	mov	DWORD PTR [eax], ecx

; 163  :     return;
; 164  : }

	pop	ebp
	ret	0
	npad	2
$LN16@HSLToRGB:
	DD	$LN6@HSLToRGB
	DD	$LN5@HSLToRGB
	DD	$LN4@HSLToRGB
	DD	$LN3@HSLToRGB
	DD	$LN2@HSLToRGB
	DD	$LN1@HSLToRGB
?HSLToRGB@@YAXHHHAAH00@Z ENDP				; HSLToRGB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\colours.cpp
;	COMDAT ?RGBToHSL@@YAXHHHAAH00@Z
_TEXT	SEGMENT
tv306 = 8						; size = 4
_R$ = 8							; size = 4
_G$ = 12						; size = 4
_B$ = 16						; size = 4
_H$ = 20						; size = 4
_S$ = 24						; size = 4
_L$ = 28						; size = 4
?RGBToHSL@@YAXHHHAAH00@Z PROC				; RGBToHSL, COMDAT

; 52   : {

	push	ebp
	mov	ebp, esp
	movd	xmm4, DWORD PTR _R$[ebp]
	movd	xmm5, DWORD PTR _G$[ebp]

; 53   : 	// Fill in the correct code here for question 4, the functions Min and Max above will help
; 54   : 	float fR, fG, fB, fMax, fMin;
; 55   : 	
; 56   : 	//convert int to float 0-1
; 57   : 	fR = (float) R / 255.0f;

	movss	xmm0, DWORD PTR __real@437f0000
	cvtdq2ps xmm4, xmm4

; 58   : 	fG = (float) G / 255.0f;

	cvtdq2ps xmm5, xmm5
	movd	xmm3, DWORD PTR _B$[ebp]
	divss	xmm4, xmm0
	divss	xmm5, xmm0

; 59   : 	fB = (float) B / 255.0f;

	cvtdq2ps xmm3, xmm3

; 24   : 	if (f2 < fMin)

	comiss	xmm4, xmm5

; 59   : 	fB = (float) B / 255.0f;

	divss	xmm3, xmm0

; 23   : 	float fMin = f1;

	movaps	xmm1, xmm4

; 24   : 	if (f2 < fMin)

	jbe	SHORT $LN12@RGBToHSL

; 25   : 	{
; 26   : 		fMin = f2;

	movaps	xmm1, xmm5
$LN12@RGBToHSL:

; 27   : 	}
; 28   : 	if (f3 < fMin)

	comiss	xmm1, xmm3
	jbe	SHORT $LN11@RGBToHSL

; 29   : 	{
; 30   : 		fMin = f3;

	movaps	xmm1, xmm3
$LN11@RGBToHSL:

; 31   : 	}
; 32   : 	return fMin;
; 33   : }
; 34   : 
; 35   : // Find the maximum of three numbers
; 36   : float Max( float f1, float f2, float f3 )
; 37   : {
; 38   : 	float fMax = f1;
; 39   : 	if (f2 > fMax)

	comiss	xmm5, xmm4
	movaps	xmm6, xmm4
	jbe	SHORT $LN16@RGBToHSL

; 40   : 	{
; 41   : 		fMax = f2;

	movaps	xmm6, xmm5
$LN16@RGBToHSL:

; 42   : 	}
; 43   : 	if (f3 > fMax)

	comiss	xmm3, xmm6
	jbe	SHORT $LN15@RGBToHSL

; 44   : 	{
; 45   : 		fMax = f3;

	movaps	xmm6, xmm3
$LN15@RGBToHSL:

; 60   : 
; 61   : 	//find max and min values
; 62   : 	fMin = Min(fR, fG, fB);
; 63   : 	fMax = Max(fR, fG, fB);
; 64   : 
; 65   : 
; 66   : 	L = int( 50 * (fMax +fMin) );

	mov	eax, DWORD PTR _L$[ebp]
	movaps	xmm2, xmm6
	addss	xmm2, xmm1

; 67   : 	
; 68   : 	//greys - catch div/0 error
; 69   : 	if(fMax == fMin){

	ucomiss	xmm6, xmm1
	movaps	xmm0, xmm2
	movss	DWORD PTR tv306[ebp], xmm2
	mulss	xmm0, DWORD PTR __real@42480000
	cvttss2si ecx, xmm0
	mov	DWORD PTR [eax], ecx
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@RGBToHSL

; 70   : 		H=0;

	mov	eax, DWORD PTR _H$[ebp]
	mov	DWORD PTR [eax], 0

; 71   : 		S=0;

	mov	eax, DWORD PTR _S$[ebp]
	mov	DWORD PTR [eax], 0

; 92   : 	}
; 93   : 	return;
; 94   : 
; 95   : }

	pop	ebp
	ret	0
$LN8@RGBToHSL:

; 72   : 		 return;
; 73   : 	}
; 74   : 
; 75   : 	if(L < 50){
; 76   : 		S = int ( 100 * (fMax - fMin) / (fMax + fMin) );

	mov	eax, DWORD PTR _S$[ebp]
	movaps	xmm7, xmm6
	subss	xmm7, xmm1
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR __real@42c80000
	cmp	ecx, 50					; 00000032H
	jge	SHORT $LN7@RGBToHSL
	divss	xmm0, xmm2
	cvttss2si ecx, xmm0

; 77   : 	}else{

	jmp	SHORT $LN19@RGBToHSL
$LN7@RGBToHSL:

; 78   : 		S = int (100 * (fMax - fMin) / (2.0 - (fMax + fMin)) );

	movsd	xmm1, QWORD PTR __real@4000000000000000
	cvtps2pd xmm2, xmm0
	movss	xmm0, DWORD PTR tv306[ebp]
	cvtps2pd xmm0, xmm0
	subsd	xmm1, xmm0
	divsd	xmm2, xmm1
	cvttsd2si ecx, xmm2
$LN19@RGBToHSL:

; 79   : 	}
; 80   : 
; 81   : 
; 82   : 	if(fMax == fR){

	ucomiss	xmm6, xmm4
	mov	DWORD PTR [eax], ecx
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@RGBToHSL

; 83   : 		H = int ( 60 * ( (fG - fB) / (fMax - fMin) ) );

	subss	xmm5, xmm3
	divss	xmm5, xmm7
	mulss	xmm5, DWORD PTR __real@42700000
	cvttss2si eax, xmm5
	jmp	SHORT $LN20@RGBToHSL
$LN5@RGBToHSL:

; 84   : 	}else if(fMax == fG){

	ucomiss	xmm6, xmm5
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@RGBToHSL

; 85   : 		H = int ( 60 * ( (fB - fR) / (fMax - fMin) ) + 120 );

	subss	xmm3, xmm4
	divss	xmm3, xmm7
	mulss	xmm3, DWORD PTR __real@42700000
	addss	xmm3, DWORD PTR __real@42f00000
	cvttss2si eax, xmm3

; 86   : 	}else{

	jmp	SHORT $LN20@RGBToHSL
$LN3@RGBToHSL:

; 87   : 		H = int ( 60 * ( (fR - fG) / (fMax - fMin) ) + 240 );

	subss	xmm4, xmm5
	divss	xmm4, xmm7
	mulss	xmm4, DWORD PTR __real@42700000
	addss	xmm4, DWORD PTR __real@43700000
	cvttss2si eax, xmm4
$LN20@RGBToHSL:
	mov	ecx, DWORD PTR _H$[ebp]
	mov	DWORD PTR [ecx], eax

; 88   : 	}
; 89   : 
; 90   : 	if(H < 0){

	test	eax, eax
	jns	SHORT $LN1@RGBToHSL

; 91   : 		H += 360;

	add	eax, 360				; 00000168H
	mov	DWORD PTR [ecx], eax
$LN1@RGBToHSL:

; 92   : 	}
; 93   : 	return;
; 94   : 
; 95   : }

	pop	ebp
	ret	0
?RGBToHSL@@YAXHHHAAH00@Z ENDP				; RGBToHSL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\colours.cpp
;	COMDAT ?Max@@YAMMMM@Z
_TEXT	SEGMENT
_fMax$ = 8						; size = 4
_f1$ = 8						; size = 4
_f2$ = 12						; size = 4
_f3$ = 16						; size = 4
?Max@@YAMMMM@Z PROC					; Max, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp

; 38   : 	float fMax = f1;

	movss	xmm0, DWORD PTR _f1$[ebp]

; 39   : 	if (f2 > fMax)

	movss	xmm1, DWORD PTR _f2$[ebp]
	comiss	xmm1, xmm0
	movss	DWORD PTR _fMax$[ebp], xmm0
	jbe	SHORT $LN2@Max

; 40   : 	{
; 41   : 		fMax = f2;

	movaps	xmm0, xmm1
	movss	DWORD PTR _fMax$[ebp], xmm0
$LN2@Max:

; 42   : 	}
; 43   : 	if (f3 > fMax)

	movss	xmm1, DWORD PTR _f3$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@Max

; 44   : 	{
; 45   : 		fMax = f3;

	movss	DWORD PTR _fMax$[ebp], xmm1
$LN5@Max:

; 46   : 	}
; 47   : 	return fMax;

	fld	DWORD PTR _fMax$[ebp]

; 48   : }

	pop	ebp
	ret	0
?Max@@YAMMMM@Z ENDP					; Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\colours.cpp
;	COMDAT ?Min@@YAMMMM@Z
_TEXT	SEGMENT
_fMin$ = 8						; size = 4
_f1$ = 8						; size = 4
_f2$ = 12						; size = 4
_f3$ = 16						; size = 4
?Min@@YAMMMM@Z PROC					; Min, COMDAT

; 22   : {

	push	ebp
	mov	ebp, esp

; 23   : 	float fMin = f1;

	movss	xmm0, DWORD PTR _f1$[ebp]

; 24   : 	if (f2 < fMin)

	movss	xmm1, DWORD PTR _f2$[ebp]
	comiss	xmm0, xmm1
	movss	DWORD PTR _fMin$[ebp], xmm0
	jbe	SHORT $LN2@Min

; 25   : 	{
; 26   : 		fMin = f2;

	movaps	xmm0, xmm1
	movss	DWORD PTR _fMin$[ebp], xmm0
$LN2@Min:

; 27   : 	}
; 28   : 	if (f3 < fMin)

	movss	xmm1, DWORD PTR _f3$[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN5@Min

; 29   : 	{
; 30   : 		fMin = f3;

	movss	DWORD PTR _fMin$[ebp], xmm1
$LN5@Min:

; 31   : 	}
; 32   : 	return fMin;

	fld	DWORD PTR _fMin$[ebp]

; 33   : }

	pop	ebp
	ret	0
?Min@@YAMMMM@Z ENDP					; Min
_TEXT	ENDS
END
