; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Simon\Documents\GitHub\Post-Processing\Scene.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__GUID_9b7e4c04_342c_4106_a19f_4f2704f689f0
PUBLIC	_LIBID_ATLLib
PUBLIC	??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@	; `string'
PUBLIC	??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@ ; `string'
PUBLIC	__GUID_0002e012_0000_0000_c000_000000000046
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?value@?$integral_constant@I$07@std@@2IB	; std::integral_constant<unsigned int,8>::value
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?MAX_VERTEX_ELTS@CModel@@0HB			; CModel::MAX_VERTEX_ELTS
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	_IID_IInternalConnection
PUBLIC	?value@?$integral_constant@I$03@std@@2IB	; std::integral_constant<unsigned int,4>::value
PUBLIC	??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?mViewportWidth@CScene@@0HA			; CScene::mViewportWidth
PUBLIC	?mViewportHeight@CScene@@0HA			; CScene::mViewportHeight
PUBLIC	?MAX_LIGHTS@CScene@@0HB				; CScene::MAX_LIGHTS
PUBLIC	??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?MAX_SHADER_LIGHTS@CScene@@0HB			; CScene::MAX_SHADER_LIGHTS
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?MAX_OBJECTS@CScene@@0HB			; CScene::MAX_OBJECTS
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?value@?$integral_constant@I$01@std@@2IB	; std::integral_constant<unsigned int,2>::value
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	??_C@_13HADIAKP@?$AAS?$AA?$AA@			; `string'
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	??_C@_13LHMFKAAD@?$AAM?$AA?$AA@			; `string'
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@			; `string'
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	??_C@_13OPKGLAFF@?$AAB?$AA?$AA@			; `string'
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@	; `string'
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?value@?$integral_constant@I$00@std@@2IB	; std::integral_constant<unsigned int,1>::value
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA	; ATL::CComApartment::ATL_CREATE_OBJECT
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?value@?$_Maximum@$S@std@@2IB			; std::_Maximum<>::value
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?VT@?$CVarTypeInfo@D@ATL@@2GB			; ATL::CVarTypeInfo<char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ ; ATL::CVarTypeInfo<char>::pmField
PUBLIC	?VT@?$CVarTypeInfo@E@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char>::VT
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ ; ATL::CVarTypeInfo<unsigned char>::pmField
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	_CLSID_Registrar
PUBLIC	?VT@?$CVarTypeInfo@PAD@ATL@@2GB			; ATL::CVarTypeInfo<char *>::VT
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ ; ATL::CVarTypeInfo<char *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAE@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ ; ATL::CVarTypeInfo<unsigned char *>::pmField
PUBLIC	__GUID_00000109_0000_0000_c000_000000000046
PUBLIC	__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
PUBLIC	?VT@?$CVarTypeInfo@F@ATL@@2GB			; ATL::CVarTypeInfo<short>::VT
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ ; ATL::CVarTypeInfo<short>::pmField
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	_IID_IRegistrar
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?VT@?$CVarTypeInfo@PAF@ATL@@2GB			; ATL::CVarTypeInfo<short *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ ; ATL::CVarTypeInfo<short *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@G@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short>::VT
PUBLIC	?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ ; ATL::CVarTypeInfo<unsigned short>::pmField
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?VT@?$CVarTypeInfo@PAG@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ ; ATL::CVarTypeInfo<unsigned short *>::pmField
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?VT@?$CVarTypeInfo@H@ATL@@2GB			; ATL::CVarTypeInfo<int>::VT
PUBLIC	?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ ; ATL::CVarTypeInfo<int>::pmField
PUBLIC	?MAX_VALUE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_VALUE
PUBLIC	?VT@?$CVarTypeInfo@PAH@ATL@@2GB			; ATL::CVarTypeInfo<int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ ; ATL::CVarTypeInfo<int *>::pmField
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?VT@?$CVarTypeInfo@I@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int>::VT
PUBLIC	?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ ; ATL::CVarTypeInfo<unsigned int>::pmField
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?VT@?$CVarTypeInfo@PAI@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int *>::VT
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ ; ATL::CVarTypeInfo<unsigned int *>::pmField
PUBLIC	?cbNeverDelete@CRegParser@ATL@@1HB		; ATL::CRegParser::cbNeverDelete
PUBLIC	?MAX_TYPE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_TYPE
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?VT@?$CVarTypeInfo@J@ATL@@2GB			; ATL::CVarTypeInfo<long>::VT
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ ; ATL::CVarTypeInfo<long>::pmField
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?VT@?$CVarTypeInfo@PAJ@ATL@@2GB			; ATL::CVarTypeInfo<long *>::VT
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ ; ATL::CVarTypeInfo<long *>::pmField
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?VT@?$CVarTypeInfo@K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long>::VT
PUBLIC	?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ ; ATL::CVarTypeInfo<unsigned long>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAK@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ ; ATL::CVarTypeInfo<unsigned long *>::pmField
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?VT@?$CVarTypeInfo@_J@ATL@@2GB			; ATL::CVarTypeInfo<__int64>::VT
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ ; ATL::CVarTypeInfo<__int64>::pmField
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?VT@?$CVarTypeInfo@PA_J@ATL@@2GB		; ATL::CVarTypeInfo<__int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ ; ATL::CVarTypeInfo<__int64 *>::pmField
PUBLIC	?_Min@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Min
PUBLIC	?_Max@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Max
PUBLIC	?VT@?$CVarTypeInfo@_K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned __int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64>::pmField
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?_Min@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Min
PUBLIC	?_Max@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Max
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?VT@?$CVarTypeInfo@PA_K@ATL@@2GB		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?_Min@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Min
PUBLIC	?_Max@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Max
PUBLIC	?VT@?$CVarTypeInfo@M@ATL@@2GB			; ATL::CVarTypeInfo<float>::VT
PUBLIC	?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ ; ATL::CVarTypeInfo<float>::pmField
PUBLIC	?_Min@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Min
PUBLIC	?_Max@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Max
PUBLIC	?VT@?$CVarTypeInfo@PAM@ATL@@2GB			; ATL::CVarTypeInfo<float *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ ; ATL::CVarTypeInfo<float *>::pmField
PUBLIC	?_Min@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Min
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?_Max@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Max
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?VT@?$CVarTypeInfo@N@ATL@@2GB			; ATL::CVarTypeInfo<double>::VT
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ ; ATL::CVarTypeInfo<double>::pmField
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?_Min@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Min
PUBLIC	?_Max@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Max
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?VT@?$CVarTypeInfo@PAN@ATL@@2GB			; ATL::CVarTypeInfo<double *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ ; ATL::CVarTypeInfo<double *>::pmField
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB	; ATL::CVarTypeInfo<tagVARIANT *>::VT
PUBLIC	?VT@?$CVarTypeInfo@PA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ ; ATL::CVarTypeInfo<wchar_t *>::pmField
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t * *>::VT
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ ; ATL::CVarTypeInfo<wchar_t * *>::pmField
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown *>::VT
PUBLIC	__GUID_b196b284_bab4_101a_b69c_00aa00341d07
PUBLIC	?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown *>::pmField
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown * *>::VT
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch *>::pmField
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch * *>::VT
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch * *>::pmField
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY>::VT
PUBLIC	__GUID_00000000_0000_0000_c000_000000000046
PUBLIC	?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY>::pmField
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY *>::pmField
PUBLIC	__GUID_00020400_0000_0000_c000_000000000046
PUBLIC	__GUID_00000146_0000_0000_c000_000000000046
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	_IID_IAxWinAmbientDispatch
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
_BSS	SEGMENT
?mViewportWidth@CScene@@0HA DD 01H DUP (?)		; CScene::mViewportWidth
?mViewportHeight@CScene@@0HA DD 01H DUP (?)		; CScene::mViewportHeight
_BSS	ENDS
;	COMDAT ?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA
_BSS	SEGMENT
?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA DD 01H DUP (?) ; ATL::CComApartment::ATL_CREATE_OBJECT
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT __GUID_00000146_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000146_0000_0000_c000_000000000046 DD 0146H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_00020400_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00020400_0000_0000_c000_000000000046 DD 020400H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB DW 04006H	; ATL::CVarTypeInfo<tagCY *>::VT
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY>::pmField
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000000_0000_0000_c000_000000000046 DD 00H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB DW 06H		; ATL::CVarTypeInfo<tagCY>::VT
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch * *>::pmField
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB DW 04009H	; ATL::CVarTypeInfo<IDispatch * *>::VT
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB DW 09H	; ATL::CVarTypeInfo<IDispatch *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB DW 0400dH	; ATL::CVarTypeInfo<IUnknown * *>::VT
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown *>::pmField
CONST	ENDS
;	COMDAT __GUID_b196b284_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b284_bab4_101a_b69c_00aa00341d07 DD 0b196b284H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB DW 0dH	; ATL::CVarTypeInfo<IUnknown *>::VT
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t * *>::pmField
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB DW 04008H		; ATL::CVarTypeInfo<wchar_t * *>::VT
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_W@ATL@@2GB DW 08H			; ATL::CVarTypeInfo<wchar_t *>::VT
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB DW 0400cH	; ATL::CVarTypeInfo<tagVARIANT *>::VT
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ DD 08H ; ATL::CVarTypeInfo<double *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAN@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAN@ATL@@2GB DW 04005H		; ATL::CVarTypeInfo<double *>::VT
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Max@?$AtlLimits@_K@ATL@@2_KB DQ ffffffffffffffffH	; ATL::AtlLimits<unsigned __int64>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Min@?$AtlLimits@_K@ATL@@2_KB DQ 0000000000000000H	; ATL::AtlLimits<unsigned __int64>::_Min
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ DD 08H ; ATL::CVarTypeInfo<double>::pmField
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@N@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@N@ATL@@2GB DW 05H			; ATL::CVarTypeInfo<double>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Max@?$AtlLimits@_J@ATL@@2_JB DQ 7fffffffffffffffH	; ATL::AtlLimits<__int64>::_Max
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Min@?$AtlLimits@_J@ATL@@2_JB DQ 8000000000000000H	; ATL::AtlLimits<__int64>::_Min
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ DD 08H ; ATL::CVarTypeInfo<float *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAM@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAM@ATL@@2GB DW 04004H		; ATL::CVarTypeInfo<float *>::VT
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Max@?$AtlLimits@K@ATL@@2KB DD 0ffffffffH		; ATL::AtlLimits<unsigned long>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Min@?$AtlLimits@K@ATL@@2KB DD 00H			; ATL::AtlLimits<unsigned long>::_Min
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ DD 08H ; ATL::CVarTypeInfo<float>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@M@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@M@ATL@@2GB DW 04H			; ATL::CVarTypeInfo<float>::VT
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Max@?$AtlLimits@J@ATL@@2JB DD 07fffffffH		; ATL::AtlLimits<long>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Min@?$AtlLimits@J@ATL@@2JB DD 080000000H		; ATL::AtlLimits<long>::_Min
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_K@ATL@@2GB DW 04015H		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Max@?$AtlLimits@I@ATL@@2IB DD 0ffffffffH		; ATL::AtlLimits<unsigned int>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Min@?$AtlLimits@I@ATL@@2IB DD 00H			; ATL::AtlLimits<unsigned int>::_Min
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_K@ATL@@2GB DW 015H			; ATL::CVarTypeInfo<unsigned __int64>::VT
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Max@?$AtlLimits@H@ATL@@2HB DD 07fffffffH		; ATL::AtlLimits<int>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Min@?$AtlLimits@H@ATL@@2HB DD 080000000H		; ATL::AtlLimits<int>::_Min
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_J@ATL@@2GB DW 04014H		; ATL::CVarTypeInfo<__int64 *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64>::pmField
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_J@ATL@@2GB DW 014H			; ATL::CVarTypeInfo<__int64>::VT
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAK@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAK@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned long *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@K@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned long>::VT
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ DD 08H ; ATL::CVarTypeInfo<long *>::pmField
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAJ@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAJ@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<long *>::VT
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ DD 08H ; ATL::CVarTypeInfo<long>::pmField
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@J@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<long>::VT
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?MAX_TYPE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_TYPE@CRegParser@ATL@@1HB DD 01000H			; ATL::CRegParser::MAX_TYPE
CONST	ENDS
;	COMDAT ?cbNeverDelete@CRegParser@ATL@@1HB
CONST	SEGMENT
?cbNeverDelete@CRegParser@ATL@@1HB DD 0cH		; ATL::CRegParser::cbNeverDelete
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int *>::pmField
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB DD FLAT:??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ ; ATL::CRegParser::rgszNeverDelete
	DD	FLAT:??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@
	DD	FLAT:??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@
	DD	FLAT:??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
	DD	FLAT:??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@
	DD	FLAT:??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@
	DD	FLAT:??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@
	DD	FLAT:??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@
	DD	FLAT:??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
	DD	FLAT:??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAI@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAI@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned int *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@I@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@I@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned int>::VT
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ DD 08H ; ATL::CVarTypeInfo<int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAH@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAH@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<int *>::VT
CONST	ENDS
;	COMDAT ?MAX_VALUE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_VALUE@CRegParser@ATL@@1HB DD 01000H		; ATL::CRegParser::MAX_VALUE
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ DD 08H ; ATL::CVarTypeInfo<int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@H@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@H@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<int>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAG@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAG@ATL@@2GB DW 04012H		; ATL::CVarTypeInfo<unsigned short *>::VT
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@G@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@G@ATL@@2GB DW 012H			; ATL::CVarTypeInfo<unsigned short>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ DD 08H ; ATL::CVarTypeInfo<short *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAF@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAF@ATL@@2GB DW 04002H		; ATL::CVarTypeInfo<short *>::VT
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ DD 08H ; ATL::CVarTypeInfo<short>::pmField
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@F@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@F@ATL@@2GB DW 02H			; ATL::CVarTypeInfo<short>::VT
CONST	ENDS
;	COMDAT __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
CONST	SEGMENT
__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713 DD 07fd52380H
	DW	04e07H
	DW	0101bH
	DB	0aeH
	DB	02dH
	DB	08H
	DB	00H
	DB	02bH
	DB	02eH
	DB	0c7H
	DB	013H
CONST	ENDS
;	COMDAT __GUID_00000109_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000109_0000_0000_c000_000000000046 DD 0109H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAE@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAE@ATL@@2GB DW 04011H		; ATL::CVarTypeInfo<unsigned char *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ DD 08H ; ATL::CVarTypeInfo<char *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAD@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAD@ATL@@2GB DW 04010H		; ATL::CVarTypeInfo<char *>::VT
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char>::pmField
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@E@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@E@ATL@@2GB DW 011H			; ATL::CVarTypeInfo<unsigned char>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ DD 08H ; ATL::CVarTypeInfo<char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@D@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@D@ATL@@2GB DW 010H			; ATL::CVarTypeInfo<char>::VT
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?value@?$_Maximum@$S@std@@2IB
CONST	SEGMENT
?value@?$_Maximum@$S@std@@2IB DD 00H			; std::_Maximum<>::value
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$00@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$00@std@@2IB DD 01H		; std::integral_constant<unsigned int,1>::value
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ DB 'D', 00H, 'e', 00H
	DB	'l', 00H, 'e', 00H, 't', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ ; ATL::szDelete
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ DB 'N'
	DB	00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; ATL::szNoRemove
CONST	ENDS
;	COMDAT ??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; ATL::szForceRemove
CONST	ENDS
;	COMDAT ??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@ DB 'V', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@ ; ATL::szValToken
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ??_C@_13OPKGLAFF@?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_13OPKGLAFF@?$AAB?$AA?$AA@ DB 'B', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:??_C@_13OPKGLAFF@?$AAB?$AA?$AA@ ; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@ DB 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@ ; ATL::szDwordVal
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ??_C@_13LHMFKAAD@?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_13LHMFKAAD@?$AAM?$AA?$AA@ DB 'M', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:??_C@_13LHMFKAAD@?$AAM?$AA?$AA@ ; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ??_C@_13HADIAKP@?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_13HADIAKP@?$AAS?$AA?$AA@ DB 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:??_C@_13HADIAKP@?$AAS?$AA?$AA@ ; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT __GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
CONST	SEGMENT
__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352 DD 0fc4801a3H
	DW	02ba9H
	DW	011cfH
	DB	0a2H
	DB	029H
	DB	00H
	DB	0aaH
	DB	00H
	DB	03dH
	DB	073H
	DB	052H
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$01@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$01@std@@2IB DD 02H		; std::integral_constant<unsigned int,2>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?MAX_OBJECTS@CScene@@0HB
CONST	SEGMENT
?MAX_OBJECTS@CScene@@0HB DD 0c8H			; CScene::MAX_OBJECTS
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?MAX_SHADER_LIGHTS@CScene@@0HB
CONST	SEGMENT
?MAX_SHADER_LIGHTS@CScene@@0HB DD 0cH			; CScene::MAX_SHADER_LIGHTS
CONST	ENDS
;	COMDAT ??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ DB 'A', 00H, 'p', 00H
	DB	'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?MAX_LIGHTS@CScene@@0HB
CONST	SEGMENT
?MAX_LIGHTS@CScene@@0HB DD 01eH				; CScene::MAX_LIGHTS
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@ DB 'C', 00H, 'L', 00H
	DB	'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$03@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$03@std@@2IB DD 04H		; std::integral_constant<unsigned int,4>::value
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?MAX_VERTEX_ELTS@CModel@@0HB
CONST	SEGMENT
?MAX_VERTEX_ELTS@CModel@@0HB DD 040H			; CModel::MAX_VERTEX_ELTS
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$07@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$07@std@@2IB DD 08H		; std::integral_constant<unsigned int,8>::value
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT __GUID_0002e012_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0002e012_0000_0000_c000_000000000046 DD 02e012H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@ DB 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ DB 'S'
	DB	00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@ DB 'S', 00H, 'Y'
	DB	00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@ DB 'S'
	DB	00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H, 'T', 00H
	DB	'Y', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@ DB 'S', 00H, 'A', 00H, 'M', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@ DB 'M', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ DB 'H'
	DB	00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@ DB 'I'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@ DB 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT __GUID_9b7e4c04_342c_4106_a19f_4f2704f689f0
CONST	SEGMENT
__GUID_9b7e4c04_342c_4106_a19f_4f2704f689f0 DD 09b7e4c04H
	DW	0342cH
	DW	04106H
	DB	0a1H
	DB	09fH
	DB	04fH
	DB	027H
	DB	04H
	DB	0f6H
	DB	089H
	DB	0f0H
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	_hypot
PUBLIC	_fmodf
PUBLIC	_sinf
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@PBM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXVECTOR3@@QAE@MMM@Z			; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??BD3DXVECTOR3@@QAEPAMXZ			; D3DXVECTOR3::operator float *
PUBLIC	??0D3DXVECTOR4@@QAE@XZ				; D3DXVECTOR4::D3DXVECTOR4
PUBLIC	??0D3DXVECTOR4@@QAE@ABU_D3DVECTOR@@M@Z		; D3DXVECTOR4::D3DXVECTOR4
PUBLIC	??0D3DXVECTOR4@@QAE@MMMM@Z			; D3DXVECTOR4::D3DXVECTOR4
PUBLIC	??BD3DXVECTOR4@@QAEPAMXZ			; D3DXVECTOR4::operator float *
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??0D3DXMATRIX@@QAE@ABU_D3DMATRIX@@@Z		; D3DXMATRIX::D3DXMATRIX
PUBLIC	??RD3DXMATRIX@@QAEAAMII@Z			; D3DXMATRIX::operator()
PUBLIC	??BD3DXMATRIX@@QAEPAMXZ				; D3DXMATRIX::operator float *
PUBLIC	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z			; D3DXMATRIX::operator*
PUBLIC	??0_D3DXMATRIXA16@@QAE@XZ			; _D3DXMATRIXA16::_D3DXMATRIXA16
PUBLIC	??0_D3DXMATRIXA16@@QAE@ABU_D3DMATRIX@@@Z	; _D3DXMATRIXA16::_D3DXMATRIXA16
PUBLIC	??0D3DXPLANE@@QAE@XZ				; D3DXPLANE::D3DXPLANE
PUBLIC	??BD3DXPLANE@@QAEPAMXZ				; D3DXPLANE::operator float *
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?ToRadians@@YAMM@Z				; ToRadians
PUBLIC	?square@@YAMM@Z					; square
PUBLIC	?SetDevice@CModel@@SAXPAUID3D10Device@@@Z	; CModel::SetDevice
PUBLIC	?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ	; CModel::GetPosition
PUBLIC	?GetWorldMatrix@CModel@@QAE?AU_D3DXMATRIXA16@@XZ ; CModel::GetWorldMatrix
PUBLIC	?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z	; CModel::SetPosition
PUBLIC	?SetRotation@CModel@@QAEXUD3DXVECTOR3@@@Z	; CModel::SetRotation
PUBLIC	?SetScale@CModel@@QAEXM@Z			; CModel::SetScale
PUBLIC	?SetViewport@CCamera@@SAXHH@Z			; CCamera::SetViewport
PUBLIC	?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@XZ	; CCamera::GetPosition
PUBLIC	?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ ; CCamera::GetViewMatrix
PUBLIC	?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ ; CCamera::GetProjectionMatrix
PUBLIC	?SetPosition@CCamera@@QAEXUD3DXVECTOR3@@@Z	; CCamera::SetPosition
PUBLIC	?SetRotation@CCamera@@QAEXUD3DXVECTOR3@@@Z	; CCamera::SetRotation
PUBLIC	?SetNearClip@CCamera@@QAEXM@Z			; CCamera::SetNearClip
PUBLIC	?GetColourV@CLight@@QAE?AUD3DXVECTOR3@@XZ	; CLight::GetColourV
PUBLIC	?GetModel@CLight@@QAEPAVCModel@@XZ		; CLight::GetModel
PUBLIC	?SetModel@CLight@@QAEXPAVCModel@@@Z		; CLight::SetModel
PUBLIC	?GetBrightness@CLight@@QAEMXZ			; CLight::GetBrightness
PUBLIC	?SetBrightness@CLight@@QAEXM@Z			; CLight::SetBrightness
PUBLIC	?SetDisco@CLight@@QAEXXZ			; CLight::SetDisco
PUBLIC	??_GCLight@@QAEPAXI@Z				; CLight::`scalar deleting destructor'
PUBLIC	?GetModel@CRenderObject@@QAEPAVCModel@@XZ	; CRenderObject::GetModel
PUBLIC	?GetColourV@CRenderObject@@QAE?AUD3DXVECTOR3@@XZ ; CRenderObject::GetColourV
PUBLIC	?GetTexture@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ; CRenderObject::GetTexture
PUBLIC	?GetNormalMap@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ; CRenderObject::GetNormalMap
PUBLIC	?IsLit@CRenderObject@@QAE_NXZ			; CRenderObject::IsLit
PUBLIC	?IsTransparent@CRenderObject@@QAE_NXZ		; CRenderObject::IsTransparent
PUBLIC	?Render@CRenderObject@@QAEXXZ			; CRenderObject::Render
PUBLIC	?RenderMirror@CRenderObject@@QAEXXZ		; CRenderObject::RenderMirror
PUBLIC	?SetColourCycle@CRenderObject@@QAEXXZ		; CRenderObject::SetColourCycle
PUBLIC	?SetSpinX@CRenderObject@@QAEXM@Z		; CRenderObject::SetSpinX
PUBLIC	?SetSpinY@CRenderObject@@QAEXM@Z		; CRenderObject::SetSpinY
PUBLIC	?SetSpinZ@CRenderObject@@QAEXM@Z		; CRenderObject::SetSpinZ
PUBLIC	?SetWiggle@CRenderObject@@QAEXM@Z		; CRenderObject::SetWiggle
PUBLIC	?GetWiggle@CRenderObject@@QAEMXZ		; CRenderObject::GetWiggle
PUBLIC	?GetOutlineThickness@CRenderObject@@QAEMXZ	; CRenderObject::GetOutlineThickness
PUBLIC	??_GCRenderObject@@QAEPAXI@Z			; CRenderObject::`scalar deleting destructor'
PUBLIC	?BasicItems@CScene@@AAE_NXZ			; CScene::BasicItems
PUBLIC	?SceneItems@CScene@@AAE_NXZ			; CScene::SceneItems
PUBLIC	?TestItems@CScene@@AAE_NXZ			; CScene::TestItems
PUBLIC	?SetLights@CScene@@AAEXUD3DXVECTOR3@@QAPAVCLight@@H@Z ; CScene::SetLights
PUBLIC	?compareLights@CScene@@CAHPBX0@Z		; CScene::compareLights
PUBLIC	?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z		; CScene::WndProc
PUBLIC	?DrawObject@CScene@@AAEXH_N@Z			; CScene::DrawObject
PUBLIC	?DrawAllObjects@CScene@@AAEX_N@Z		; CScene::DrawAllObjects
PUBLIC	?UpdateImpact@CScene@@AAEXM@Z			; CScene::UpdateImpact
PUBLIC	?RenderImpact@CScene@@AAEXXZ			; CScene::RenderImpact
PUBLIC	?StartImpact@CScene@@QAEXXZ			; CScene::StartImpact
PUBLIC	??0CScene@@QAE@XZ				; CScene::CScene
PUBLIC	??1CScene@@QAE@XZ				; CScene::~CScene
PUBLIC	?ResetShock@CScene@@QAEXXZ			; CScene::ResetShock
PUBLIC	?SetSinglePP@CScene@@QAEXH@Z			; CScene::SetSinglePP
PUBLIC	?InitDevice@CScene@@QAE_NXZ			; CScene::InitDevice
PUBLIC	?ReleaseResources@CScene@@QAEXXZ		; CScene::ReleaseResources
PUBLIC	?LoadEffectFile@CScene@@QAE_NXZ			; CScene::LoadEffectFile
PUBLIC	?InitScene@CScene@@QAE_NXZ			; CScene::InitScene
PUBLIC	?InitPP@CScene@@QAE_NXZ				; CScene::InitPP
PUBLIC	?InitATB@CScene@@QAE_NXZ			; CScene::InitATB
PUBLIC	?UpdateScene@CScene@@QAEXM@Z			; CScene::UpdateScene
PUBLIC	?RenderScene@CScene@@QAEXXZ			; CScene::RenderScene
PUBLIC	?RenderMirrors@CScene@@QAEXXZ			; CScene::RenderMirrors
PUBLIC	?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z	; CScene::InitWindow
PUBLIC	?ToggleSingle@@YGXPAX@Z				; ToggleSingle
PUBLIC	?SetPP00@@YGXPAX@Z				; SetPP00
PUBLIC	?SetPP01@@YGXPAX@Z				; SetPP01
PUBLIC	?SetPP02@@YGXPAX@Z				; SetPP02
PUBLIC	?SetPP03@@YGXPAX@Z				; SetPP03
PUBLIC	?SetPP04@@YGXPAX@Z				; SetPP04
PUBLIC	?SetPP05@@YGXPAX@Z				; SetPP05
PUBLIC	?SetPP06@@YGXPAX@Z				; SetPP06
PUBLIC	?SetPP07@@YGXPAX@Z				; SetPP07
PUBLIC	?SetPP08@@YGXPAX@Z				; SetPP08
PUBLIC	?SetPP09@@YGXPAX@Z				; SetPP09
PUBLIC	?SetPP10@@YGXPAX@Z				; SetPP10
PUBLIC	?SetPP11@@YGXPAX@Z				; SetPP11
PUBLIC	?SetPP12@@YGXPAX@Z				; SetPP12
PUBLIC	?SetGauss@@YGXPAX@Z				; SetGauss
PUBLIC	?TWImpact@@YGXPAX@Z				; TWImpact
PUBLIC	??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z		; ATL::CA2WEX<128>::CA2WEX<128>
PUBLIC	??1?$CA2WEX@$0IA@@ATL@@QAE@XZ			; ATL::CA2WEX<128>::~CA2WEX<128>
PUBLIC	??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ		; ATL::CA2WEX<128>::operator wchar_t *
PUBLIC	?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z		; ATL::CA2WEX<128>::Init
PUBLIC	??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z		; strcpy_s<100>
PUBLIC	??$_itoa_s@$05@@YAHHAAY05DH@Z			; _itoa_s<6>
PUBLIC	??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z		; strcat_s<100>
PUBLIC	??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z	; ATL::AtlConvFreeMemory<wchar_t>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z	; ATL::AtlConvAllocMemory<wchar_t>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_1DC@LOBNDLGH@?$AAS?$AAt?$AAo?$AAn?$AAe?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@IEJEKIPL@?$AAW?$AAo?$AAo?$AAd?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@MACPKMCG@?$AAM?$AAo?$AAo?$AAn?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@GABNFLNL@?$AAW?$AAa?$AAl?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@HJHILCKN@?$AAW?$AAa?$AAl?$AAl?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@DJHFCGLD@?$AAM?$AAe?$AAt?$AAa?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@GOOKDEDK@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@NOLHING@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@DADLEHEK@?$AAG?$AAl?$AAa?$AAs?$AAs?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@DFEKPPGN@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA1?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@NHBHEBO@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA2?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@KMEIPAPA@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA3?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@HNAGGCPI@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA4?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@ONLGGDNI@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@IHOPDIJ@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@PPEMIMM@?$AAB?$AAl?$AAo?$AAo?$AAd?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_08MLPDMJMG@Mirror?4x?$AA@			; `string'
PUBLIC	??_C@_0P@MPKDMNGJ@PostProcessing?$AA@		; `string'
PUBLIC	??_C@_0CA@HAEMFPIM@?5PostProcessing?5position?$DN?85?55?8?5?$AA@ ; `string'
PUBLIC	??_C@_0BI@BNBHPOAI@min?$DN0?41?5max?$DN30?5step?$DN0?41?$AA@ ; `string'
PUBLIC	??_C@_0BA@LEBMNMMI@Tint?5Cycle?5Time?$AA@	; `string'
PUBLIC	??_C@_0BL@PGFPMOIN@min?$DN0?401?5max?$DN0?45?5step?$DN0?401?$AA@ ; `string'
PUBLIC	??_C@_0P@HMIPNKPE@Shock?5Strength?$AA@		; `string'
PUBLIC	??_C@_0M@BCFLJLDD@Shock?5Speed?$AA@		; `string'
PUBLIC	??_C@_0BH@GEGIJDLI@min?$DN0?41?5max?$DN5?5step?$DN0?41?$AA@ ; `string'
PUBLIC	??_C@_0N@BBJEPOMH@Shock?5Length?$AA@		; `string'
PUBLIC	??_C@_0BE@BKDAFDIA@min?$DN2?5max?$DN50?5step?$DN1?$AA@ ; `string'
PUBLIC	??_C@_0M@DOKJBODC@Blur?5Radius?$AA@		; `string'
PUBLIC	??_C@_0BJ@BKHNEING@min?$DN0?5max?$DN0?45?5step?$DN0?4005?$AA@ ; `string'
PUBLIC	??_C@_0BF@OKIMCMFP@Double?5Vision?5Radius?$AA@	; `string'
PUBLIC	??_C@_0BI@JONKBOAH@min?$DN?9128?5max?$DN128?5step?$DN1?$AA@ ; `string'
PUBLIC	??_C@_0P@COCHJCAA@Contrast?5Shift?$AA@		; `string'
PUBLIC	??_C@_0BG@BHAGHJLA@min?$DN0?5max?$DN1?5step?$DN0?405?$AA@ ; `string'
PUBLIC	??_C@_09CINOGBPL@Jamminess?$AA@			; `string'
PUBLIC	??_C@_0BG@NEFNJEOO@min?$DN32?5max?$DN222?5step?$DN1?$AA@ ; `string'
PUBLIC	??_C@_0BD@GCNLHPML@Solarise?5Threshold?$AA@	; `string'
PUBLIC	??_C@_0BB@IGJPDDCA@Using?5multiple?3?5?$AA@	; `string'
PUBLIC	??_C@_0O@NMGOIPCC@Toggle?5Single?$AA@		; `string'
PUBLIC	??_C@_0BD@BGGKKCGG@Single?5Pass?5Select?$AA@	; `string'
PUBLIC	??_C@_0CI@LLGGHJJD@?5?8Single?5Pass?5Select?8?5position?$DN?8@ ; `string'
PUBLIC	??_C@_05BGDIAJAG@No?5PP?$AA@			; `string'
PUBLIC	??_C@_04LLHKIDLI@Tint?$AA@			; `string'
PUBLIC	??_C@_05MCLIDIMJ@Shock?$AA@			; `string'
PUBLIC	??_C@_0N@DFJGHPEG@Box?5Blur?5?$CI3?$CJ?$AA@	; `string'
PUBLIC	??_C@_0N@DBBLADPE@Box?5Blur?5?$CI5?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BC@BBINBACJ@Box?5Blur?5?$CICustom?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0O@OAINAAFK@Double?5Vision?$AA@		; `string'
PUBLIC	??_C@_05JBOFPIEK@Edges?$AA@			; `string'
PUBLIC	??_C@_08KBHEFHNJ@Contrast?$AA@			; `string'
PUBLIC	??_C@_0BC@EACNFBOP@Jam?5on?5the?5screen?$AA@	; `string'
PUBLIC	??_C@_06OHLCGMJD@Invert?$AA@			; `string'
PUBLIC	??_C@_0BB@OBDMAHBK@Solarise?5?$CIAbove?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BB@LIMCDIOE@Solarise?5?$CIBelow?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BF@FHPJJGJD@Toggle?5Gaussian?5Blur?$AA@	; `string'
PUBLIC	??_C@_0BE@DKPHBODF@Multi?5Pass?5Controls?$AA@	; `string'
PUBLIC	??_C@_0DI@PFMGMAKO@?5?8Multi?5Pass?5Controls?8?5position?$DN@ ; `string'
PUBLIC	??_C@_0CC@BOCCMAEA@Stop?5trying?5to?5hit?5me?5and?5hit?5me@ ; `string'
PUBLIC	??_C@_06BACILOGA@fx_4_0?$AA@			; `string'
PUBLIC	??_C@_1BO@KFFLPJBB@?$AAP?$AAo?$AAs?$AAt?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?4?$AAf?$AAx?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1MK@NLJNNCIH@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAo?$AAs?$AAt?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX@ ; `string'
PUBLIC	??_C@_06JLNCKOOC@PPCopy?$AA@			; `string'
PUBLIC	??_C@_06MPGPEKJL@PPTint?$AA@			; `string'
PUBLIC	??_C@_07GAKLFMHC@PPShock?$AA@			; `string'
PUBLIC	??_C@_0L@JCFHKKCO@PPBoxBlur3?$AA@		; `string'
PUBLIC	??_C@_0L@MEANANKI@PPBoxBlur5?$AA@		; `string'
PUBLIC	??_C@_0L@IKNNDFMM@PPBoxBlurV?$AA@		; `string'
PUBLIC	??_C@_0P@PBCAEHNN@PPDoubleVision?$AA@		; `string'
PUBLIC	??_C@_06DMINDEOL@PPEdge?$AA@			; `string'
PUBLIC	??_C@_0L@ONFAKJPH@PPContrast?$AA@		; `string'
PUBLIC	??_C@_07NDCDMOCH@PPBlood?$AA@			; `string'
PUBLIC	??_C@_08LLKDBFPD@PPInvert?$AA@			; `string'
PUBLIC	??_C@_0M@LHKPPOCI@PPSolariseA?$AA@		; `string'
PUBLIC	??_C@_0M@JMICKNOL@PPSolariseB?$AA@		; `string'
PUBLIC	??_C@_0P@CCPNLBHC@InitialTexture?$AA@		; `string'
PUBLIC	??_C@_0N@BCJCHFBA@BloodTexture?$AA@		; `string'
PUBLIC	??_C@_0L@DBKDBEOO@TintColour?$AA@		; `string'
PUBLIC	??_C@_06JIEINOID@PixelX?$AA@			; `string'
PUBLIC	??_C@_06IBFDOPMC@PixelY?$AA@			; `string'
PUBLIC	??_C@_09MINFFJCE@BlurRange?$AA@			; `string'
PUBLIC	??_C@_07BMPAAFHK@DVRange?$AA@			; `string'
PUBLIC	??_C@_05HBDAKKJM@Blood?$AA@			; `string'
PUBLIC	??_C@_0BC@KBOPGDGH@SolariseThreshold?$AA@	; `string'
PUBLIC	??_C@_0BH@BEMLJPBO@Post?5Processing?5?9?5FPS?5?$AA@ ; `string'
PUBLIC	??_C@_04IHBDCLGJ@?5O?3?5?$AA@			; `string'
PUBLIC	??_C@_04JFKGIEIH@?5L?3?5?$AA@			; `string'
PUBLIC	??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EO@IKJJOGJD@?$AAC?$AAO?$AA2?$AA4?$AA0?$AA9?$AA?5?$AA?9?$AA?5?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AA?5?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?9?$AA?5?$AAS@ ; `string'
PUBLIC	??_C@_1CG@MCKIKNIO@?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA1?$AA?4?$AAf?$AAx?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KK@KKJBPFMN@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?4?$AA?5?$AAE?$AAn?$AAs?$AAu?$AAr?$AAe?$AA?5?$AAy?$AAo@ ; `string'
PUBLIC	??_C@_0N@BLACAFBJ@tPlainColour?$AA@		; `string'
PUBLIC	??_C@_0O@CBIDLEEF@tPlainTexture?$AA@		; `string'
PUBLIC	??_C@_0BF@HOFAMMJK@tColourChangeTexture?$AA@	; `string'
PUBLIC	??_C@_0M@PFGJBPP@tLitTexture?$AA@		; `string'
PUBLIC	??_C@_0N@DBNJLAPA@t4LitTexture?$AA@		; `string'
PUBLIC	??_C@_0BC@EBBNGCN@t4LitAttenTexture?$AA@	; `string'
PUBLIC	??_C@_0BB@NDOCHMBG@t4LitSpecularMap?$AA@	; `string'
PUBLIC	??_C@_0N@FAEPMAEM@tParallaxMap?$AA@		; `string'
PUBLIC	??_C@_06ELGFLNMO@tJelly?$AA@			; `string'
PUBLIC	??_C@_0N@HPAFDOEN@tCellShading?$AA@		; `string'
PUBLIC	??_C@_0BC@IHNCMDEH@tCellShadingWrong?$AA@	; `string'
PUBLIC	??_C@_05JGDPNHEJ@tHalo?$AA@			; `string'
PUBLIC	??_C@_0P@FEDIONCO@tSpaceHaloPara?$AA@		; `string'
PUBLIC	??_C@_0BC@NABDBAIK@tSpaceOutlinePara?$AA@	; `string'
PUBLIC	??_C@_09JDFCMBBC@tLitGlass?$AA@			; `string'
PUBLIC	??_C@_0L@MOJEDPIK@tSpaceHalo?$AA@		; `string'
PUBLIC	??_C@_0O@GOICGJFK@tSpaceOutline?$AA@		; `string'
PUBLIC	??_C@_0O@CIOABDO@tTextureMorph?$AA@		; `string'
PUBLIC	??_C@_0M@NCEALFAM@MirrorClear?$AA@		; `string'
PUBLIC	??_C@_0O@CFAHMOKA@MirrorSurface?$AA@		; `string'
PUBLIC	??_C@_0BD@EAMCFOMD@tPlainColourMirror?$AA@	; `string'
PUBLIC	??_C@_0BE@GKDAAGPD@tPlainTextureMirror?$AA@	; `string'
PUBLIC	??_C@_0BL@BDPLHMPN@tColourChangeTextureMirror?$AA@ ; `string'
PUBLIC	??_C@_0BC@PLBJLENF@tLitTextureMirror?$AA@	; `string'
PUBLIC	??_C@_0BD@GNCBGOED@t4LitTextureMirror?$AA@	; `string'
PUBLIC	??_C@_0BI@EEKKACMN@t4LitAttenTextureMirror?$AA@	; `string'
PUBLIC	??_C@_0BH@MJFOIGI@t4LitSpecularMapMirror?$AA@	; `string'
PUBLIC	??_C@_0BD@CIMFECON@tParallaxMapMirror?$AA@	; `string'
PUBLIC	??_C@_0N@KFADNAIL@tJellyMirror?$AA@		; `string'
PUBLIC	??_C@_0BD@NDCFMGPA@tCellShadingMirror?$AA@	; `string'
PUBLIC	??_C@_0BI@MCEONCDC@tCellShadingWrongMirror?$AA@	; `string'
PUBLIC	??_C@_0M@FENFNCKC@tHaloMirror?$AA@		; `string'
PUBLIC	??_C@_0BF@KFEJDHPA@tSpaceHaloParaMirror?$AA@	; `string'
PUBLIC	??_C@_0BI@GGPGLIH@tSpaceOutlineParaMirror?$AA@	; `string'
PUBLIC	??_C@_0BA@BCLLKFIB@tLitGlassMirror?$AA@		; `string'
PUBLIC	??_C@_0BB@CDMINDKK@tSpaceHaloMirror?$AA@	; `string'
PUBLIC	??_C@_0BE@CKKPKAMN@tSpaceOutlineMirror?$AA@	; `string'
PUBLIC	??_C@_0BE@BLJDFMPB@tTextureMorphMirror?$AA@	; `string'
PUBLIC	??_C@_0M@JIFPIELG@WorldMatrix?$AA@		; `string'
PUBLIC	??_C@_0L@BCBAMPKD@ViewMatrix?$AA@		; `string'
PUBLIC	??_C@_0L@FHHLNBJL@ProjMatrix?$AA@		; `string'
PUBLIC	??_C@_0L@ILIGHKAJ@DiffuseMap?$AA@		; `string'
PUBLIC	??_C@_09ILPGELJF@NormalMap?$AA@			; `string'
PUBLIC	??_C@_09JBPBDAII@cameraPos?$AA@			; `string'
PUBLIC	??_C@_0M@FMIDCGNI@ModelColour?$AA@		; `string'
PUBLIC	??_C@_08EGHFDCKI@lightPos?$AA@			; `string'
PUBLIC	??_C@_0M@ICIEANMG@lightColour?$AA@		; `string'
PUBLIC	??_C@_0M@NEELCHAN@lightBright?$AA@		; `string'
PUBLIC	??_C@_0O@OODJBMLI@ambientColour?$AA@		; `string'
PUBLIC	??_C@_06LAADFJPH@wiggle?$AA@			; `string'
PUBLIC	??_C@_0BB@HDLHOHKD@OutlineThickness?$AA@	; `string'
PUBLIC	??_C@_09HJHGEJDE@ClipPlane?$AA@			; `string'
PUBLIC	??_C@_06HGKAGIBP@Cube?4x?$AA@			; `string'
PUBLIC	??_C@_08KCKKFACH@Teapot?4x?$AA@			; `string'
PUBLIC	??_C@_08EEMGLHJD@Sphere?4x?$AA@			; `string'
PUBLIC	??_C@_07DBODOLME@Troll?4x?$AA@			; `string'
PUBLIC	??_C@_07MPPKGAHN@Floor?4x?$AA@			; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e685697
PUBLIC	__real@3ea0d97c
PUBLIC	__real@3f000000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3fc00000
PUBLIC	__real@40000000
PUBLIC	__real@40490fdb
PUBLIC	__real@40a00000
PUBLIC	__real@41200000
PUBLIC	__real@41700000
PUBLIC	__real@418c0000
PUBLIC	__real@41a00000
PUBLIC	__real@41c80000
PUBLIC	__real@41f00000
PUBLIC	__real@42200000
PUBLIC	__real@42480000
PUBLIC	__real@425c0000
PUBLIC	__real@42a00000
PUBLIC	__real@42aa0000
PUBLIC	__real@43340000
PUBLIC	__real@43480000
PUBLIC	__real@437a0000
PUBLIC	__real@437f0000
PUBLIC	__real@43818000
PUBLIC	__real@c1700000
PUBLIC	__real@c1a00000
PUBLIC	__real@c3000000
PUBLIC	__real@c37a0000
PUBLIC	__xmm@000003c0000007800000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_strcpy_s:PROC
EXTRN	_strcat_s:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__DefWindowProcW@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__RegisterClassExW@4:PROC
EXTRN	__imp__CreateWindowExW@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__AdjustWindowRect@12:PROC
EXTRN	__imp__MessageBoxW@16:PROC
EXTRN	__imp__LoadCursorW@8:PROC
EXTRN	__imp__LoadIconW@8:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_qsort:PROC
EXTRN	__itoa_s:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	__recalloc:PROC
EXTRN	_D3D10CreateDeviceAndSwapChain@32:PROC
EXTRN	__hypot:PROC
EXTRN	_D3DXVec3Transform@12:PROC
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixReflect@8:PROC
EXTRN	_D3DXPlaneFromPointNormal@12:PROC
EXTRN	_D3DX10CreateShaderResourceViewFromFileW@24:PROC
EXTRN	_D3DX10CreateEffectFromFileW@48:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?KeyDownEvent@@YAXW4EKeyState@@@Z:PROC		; KeyDownEvent
EXTRN	?KeyUpEvent@@YAXW4EKeyState@@@Z:PROC		; KeyUpEvent
EXTRN	?KeyHit@@YA_NW4EKeyCode@@@Z:PROC		; KeyHit
EXTRN	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z:PROC		; CModel::CModel
EXTRN	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z:PROC ; CModel::Load
EXTRN	?UpdateMatrix@CModel@@QAEXXZ:PROC		; CModel::UpdateMatrix
EXTRN	?Control@CModel@@QAEXMW4EKeyCode@@0000000@Z:PROC ; CModel::Control
EXTRN	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z:PROC ; CModel::Render
EXTRN	??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z:PROC	; CCamera::CCamera
EXTRN	?UpdateMatrices@CCamera@@QAEXXZ:PROC		; CCamera::UpdateMatrices
EXTRN	?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z:PROC ; CCamera::Control
EXTRN	?fHSLToRGB@@YAXMMMAAM00@Z:PROC			; fHSLToRGB
EXTRN	??0CLight@@QAE@XZ:PROC				; CLight::CLight
EXTRN	??1CLight@@QAE@XZ:PROC				; CLight::~CLight
EXTRN	?SetColour@CLight@@QAEXMMM@Z:PROC		; CLight::SetColour
EXTRN	?SetOrbit@CLight@@QAEXUD3DXVECTOR3@@MM@Z:PROC	; CLight::SetOrbit
EXTRN	?SetColourCycle@CLight@@QAEXM@Z:PROC		; CLight::SetColourCycle
EXTRN	?SetFade@CLight@@QAEXM@Z:PROC			; CLight::SetFade
EXTRN	?Update@CLight@@QAEXM@Z:PROC			; CLight::Update
EXTRN	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z:PROC ; CRenderObject::CRenderObject
EXTRN	??1CRenderObject@@QAE@XZ:PROC			; CRenderObject::~CRenderObject
EXTRN	?Update@CRenderObject@@QAEXM@Z:PROC		; CRenderObject::Update
EXTRN	__imp__TwNewBar@4:PROC
EXTRN	__imp__TwAddVarRW@20:PROC
EXTRN	__imp__TwAddVarRO@20:PROC
EXTRN	__imp__TwAddButton@20:PROC
EXTRN	__imp__TwAddSeparator@12:PROC
EXTRN	__imp__TwDefine@4:PROC
EXTRN	__imp__TwInit@8:PROC
EXTRN	__imp__TwDraw@0:PROC
EXTRN	__imp__TwWindowSize@8:PROC
EXTRN	__imp__TwEventWin@16:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIfmod:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	___ImageBase:BYTE
EXTRN	?mpd3dDev@CModel@@0PAUID3D10Device@@A:DWORD	; CModel::mpd3dDev
EXTRN	?mViewportWidth@CCamera@@0HA:DWORD		; CCamera::mViewportWidth
EXTRN	?mViewportHeight@CCamera@@0HA:DWORD		; CCamera::mViewportHeight
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
__AtlComModule$initializer$ DD FLAT:??__E_AtlComModule@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@000003c0000007800000000000000000
CONST	SEGMENT
__xmm@000003c0000007800000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 080H, 07H, 00H, 00H, 0c0H, 03H, 00H, 00H
CONST	ENDS
;	COMDAT __real@c37a0000
CONST	SEGMENT
__real@c37a0000 DD 0c37a0000r			; -250
CONST	ENDS
;	COMDAT __real@c3000000
CONST	SEGMENT
__real@c3000000 DD 0c3000000r			; -128
CONST	ENDS
;	COMDAT __real@c1a00000
CONST	SEGMENT
__real@c1a00000 DD 0c1a00000r			; -20
CONST	ENDS
;	COMDAT __real@c1700000
CONST	SEGMENT
__real@c1700000 DD 0c1700000r			; -15
CONST	ENDS
;	COMDAT __real@43818000
CONST	SEGMENT
__real@43818000 DD 043818000r			; 259
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@437a0000
CONST	SEGMENT
__real@437a0000 DD 0437a0000r			; 250
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@43340000
CONST	SEGMENT
__real@43340000 DD 043340000r			; 180
CONST	ENDS
;	COMDAT __real@42aa0000
CONST	SEGMENT
__real@42aa0000 DD 042aa0000r			; 85
CONST	ENDS
;	COMDAT __real@42a00000
CONST	SEGMENT
__real@42a00000 DD 042a00000r			; 80
CONST	ENDS
;	COMDAT __real@425c0000
CONST	SEGMENT
__real@425c0000 DD 0425c0000r			; 55
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c80000
CONST	SEGMENT
__real@41c80000 DD 041c80000r			; 25
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@418c0000
CONST	SEGMENT
__real@418c0000 DD 0418c0000r			; 17.5
CONST	ENDS
;	COMDAT __real@41700000
CONST	SEGMENT
__real@41700000 DD 041700000r			; 15
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ea0d97c
CONST	SEGMENT
__real@3ea0d97c DD 03ea0d97cr			; 0.314159
CONST	ENDS
;	COMDAT __real@3e685697
CONST	SEGMENT
__real@3e685697 DD 03e685697r			; 0.226893
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MPPKGAHN@Floor?4x?$AA@
CONST	SEGMENT
??_C@_07MPPKGAHN@Floor?4x?$AA@ DB 'Floor.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBODOLME@Troll?4x?$AA@
CONST	SEGMENT
??_C@_07DBODOLME@Troll?4x?$AA@ DB 'Troll.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EEMGLHJD@Sphere?4x?$AA@
CONST	SEGMENT
??_C@_08EEMGLHJD@Sphere?4x?$AA@ DB 'Sphere.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCKKFACH@Teapot?4x?$AA@
CONST	SEGMENT
??_C@_08KCKKFACH@Teapot?4x?$AA@ DB 'Teapot.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGKAGIBP@Cube?4x?$AA@
CONST	SEGMENT
??_C@_06HGKAGIBP@Cube?4x?$AA@ DB 'Cube.x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJHGEJDE@ClipPlane?$AA@
CONST	SEGMENT
??_C@_09HJHGEJDE@ClipPlane?$AA@ DB 'ClipPlane', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HDLHOHKD@OutlineThickness?$AA@
CONST	SEGMENT
??_C@_0BB@HDLHOHKD@OutlineThickness?$AA@ DB 'OutlineThickness', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LAADFJPH@wiggle?$AA@
CONST	SEGMENT
??_C@_06LAADFJPH@wiggle?$AA@ DB 'wiggle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OODJBMLI@ambientColour?$AA@
CONST	SEGMENT
??_C@_0O@OODJBMLI@ambientColour?$AA@ DB 'ambientColour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NEELCHAN@lightBright?$AA@
CONST	SEGMENT
??_C@_0M@NEELCHAN@lightBright?$AA@ DB 'lightBright', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ICIEANMG@lightColour?$AA@
CONST	SEGMENT
??_C@_0M@ICIEANMG@lightColour?$AA@ DB 'lightColour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EGHFDCKI@lightPos?$AA@
CONST	SEGMENT
??_C@_08EGHFDCKI@lightPos?$AA@ DB 'lightPos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FMIDCGNI@ModelColour?$AA@
CONST	SEGMENT
??_C@_0M@FMIDCGNI@ModelColour?$AA@ DB 'ModelColour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JBPBDAII@cameraPos?$AA@
CONST	SEGMENT
??_C@_09JBPBDAII@cameraPos?$AA@ DB 'cameraPos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILPGELJF@NormalMap?$AA@
CONST	SEGMENT
??_C@_09ILPGELJF@NormalMap?$AA@ DB 'NormalMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ILIGHKAJ@DiffuseMap?$AA@
CONST	SEGMENT
??_C@_0L@ILIGHKAJ@DiffuseMap?$AA@ DB 'DiffuseMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FHHLNBJL@ProjMatrix?$AA@
CONST	SEGMENT
??_C@_0L@FHHLNBJL@ProjMatrix?$AA@ DB 'ProjMatrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCBAMPKD@ViewMatrix?$AA@
CONST	SEGMENT
??_C@_0L@BCBAMPKD@ViewMatrix?$AA@ DB 'ViewMatrix', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JIFPIELG@WorldMatrix?$AA@
CONST	SEGMENT
??_C@_0M@JIFPIELG@WorldMatrix?$AA@ DB 'WorldMatrix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BLJDFMPB@tTextureMorphMirror?$AA@
CONST	SEGMENT
??_C@_0BE@BLJDFMPB@tTextureMorphMirror?$AA@ DB 'tTextureMorphMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CKKPKAMN@tSpaceOutlineMirror?$AA@
CONST	SEGMENT
??_C@_0BE@CKKPKAMN@tSpaceOutlineMirror?$AA@ DB 'tSpaceOutlineMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CDMINDKK@tSpaceHaloMirror?$AA@
CONST	SEGMENT
??_C@_0BB@CDMINDKK@tSpaceHaloMirror?$AA@ DB 'tSpaceHaloMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BCLLKFIB@tLitGlassMirror?$AA@
CONST	SEGMENT
??_C@_0BA@BCLLKFIB@tLitGlassMirror?$AA@ DB 'tLitGlassMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GGPGLIH@tSpaceOutlineParaMirror?$AA@
CONST	SEGMENT
??_C@_0BI@GGPGLIH@tSpaceOutlineParaMirror?$AA@ DB 'tSpaceOutlineParaMirro'
	DB	'r', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KFEJDHPA@tSpaceHaloParaMirror?$AA@
CONST	SEGMENT
??_C@_0BF@KFEJDHPA@tSpaceHaloParaMirror?$AA@ DB 'tSpaceHaloParaMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FENFNCKC@tHaloMirror?$AA@
CONST	SEGMENT
??_C@_0M@FENFNCKC@tHaloMirror?$AA@ DB 'tHaloMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MCEONCDC@tCellShadingWrongMirror?$AA@
CONST	SEGMENT
??_C@_0BI@MCEONCDC@tCellShadingWrongMirror?$AA@ DB 'tCellShadingWrongMirr'
	DB	'or', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NDCFMGPA@tCellShadingMirror?$AA@
CONST	SEGMENT
??_C@_0BD@NDCFMGPA@tCellShadingMirror?$AA@ DB 'tCellShadingMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFADNAIL@tJellyMirror?$AA@
CONST	SEGMENT
??_C@_0N@KFADNAIL@tJellyMirror?$AA@ DB 'tJellyMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CIMFECON@tParallaxMapMirror?$AA@
CONST	SEGMENT
??_C@_0BD@CIMFECON@tParallaxMapMirror?$AA@ DB 'tParallaxMapMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MJFOIGI@t4LitSpecularMapMirror?$AA@
CONST	SEGMENT
??_C@_0BH@MJFOIGI@t4LitSpecularMapMirror?$AA@ DB 't4LitSpecularMapMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EEKKACMN@t4LitAttenTextureMirror?$AA@
CONST	SEGMENT
??_C@_0BI@EEKKACMN@t4LitAttenTextureMirror?$AA@ DB 't4LitAttenTextureMirr'
	DB	'or', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNCBGOED@t4LitTextureMirror?$AA@
CONST	SEGMENT
??_C@_0BD@GNCBGOED@t4LitTextureMirror?$AA@ DB 't4LitTextureMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PLBJLENF@tLitTextureMirror?$AA@
CONST	SEGMENT
??_C@_0BC@PLBJLENF@tLitTextureMirror?$AA@ DB 'tLitTextureMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BDPLHMPN@tColourChangeTextureMirror?$AA@
CONST	SEGMENT
??_C@_0BL@BDPLHMPN@tColourChangeTextureMirror?$AA@ DB 'tColourChangeTextu'
	DB	'reMirror', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GKDAAGPD@tPlainTextureMirror?$AA@
CONST	SEGMENT
??_C@_0BE@GKDAAGPD@tPlainTextureMirror?$AA@ DB 'tPlainTextureMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EAMCFOMD@tPlainColourMirror?$AA@
CONST	SEGMENT
??_C@_0BD@EAMCFOMD@tPlainColourMirror?$AA@ DB 'tPlainColourMirror', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFAHMOKA@MirrorSurface?$AA@
CONST	SEGMENT
??_C@_0O@CFAHMOKA@MirrorSurface?$AA@ DB 'MirrorSurface', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NCEALFAM@MirrorClear?$AA@
CONST	SEGMENT
??_C@_0M@NCEALFAM@MirrorClear?$AA@ DB 'MirrorClear', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CIOABDO@tTextureMorph?$AA@
CONST	SEGMENT
??_C@_0O@CIOABDO@tTextureMorph?$AA@ DB 'tTextureMorph', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GOICGJFK@tSpaceOutline?$AA@
CONST	SEGMENT
??_C@_0O@GOICGJFK@tSpaceOutline?$AA@ DB 'tSpaceOutline', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MOJEDPIK@tSpaceHalo?$AA@
CONST	SEGMENT
??_C@_0L@MOJEDPIK@tSpaceHalo?$AA@ DB 'tSpaceHalo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JDFCMBBC@tLitGlass?$AA@
CONST	SEGMENT
??_C@_09JDFCMBBC@tLitGlass?$AA@ DB 'tLitGlass', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NABDBAIK@tSpaceOutlinePara?$AA@
CONST	SEGMENT
??_C@_0BC@NABDBAIK@tSpaceOutlinePara?$AA@ DB 'tSpaceOutlinePara', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FEDIONCO@tSpaceHaloPara?$AA@
CONST	SEGMENT
??_C@_0P@FEDIONCO@tSpaceHaloPara?$AA@ DB 'tSpaceHaloPara', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JGDPNHEJ@tHalo?$AA@
CONST	SEGMENT
??_C@_05JGDPNHEJ@tHalo?$AA@ DB 'tHalo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IHNCMDEH@tCellShadingWrong?$AA@
CONST	SEGMENT
??_C@_0BC@IHNCMDEH@tCellShadingWrong?$AA@ DB 'tCellShadingWrong', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HPAFDOEN@tCellShading?$AA@
CONST	SEGMENT
??_C@_0N@HPAFDOEN@tCellShading?$AA@ DB 'tCellShading', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ELGFLNMO@tJelly?$AA@
CONST	SEGMENT
??_C@_06ELGFLNMO@tJelly?$AA@ DB 'tJelly', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FAEPMAEM@tParallaxMap?$AA@
CONST	SEGMENT
??_C@_0N@FAEPMAEM@tParallaxMap?$AA@ DB 'tParallaxMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NDOCHMBG@t4LitSpecularMap?$AA@
CONST	SEGMENT
??_C@_0BB@NDOCHMBG@t4LitSpecularMap?$AA@ DB 't4LitSpecularMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EBBNGCN@t4LitAttenTexture?$AA@
CONST	SEGMENT
??_C@_0BC@EBBNGCN@t4LitAttenTexture?$AA@ DB 't4LitAttenTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DBNJLAPA@t4LitTexture?$AA@
CONST	SEGMENT
??_C@_0N@DBNJLAPA@t4LitTexture?$AA@ DB 't4LitTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PFGJBPP@tLitTexture?$AA@
CONST	SEGMENT
??_C@_0M@PFGJBPP@tLitTexture?$AA@ DB 'tLitTexture', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOFAMMJK@tColourChangeTexture?$AA@
CONST	SEGMENT
??_C@_0BF@HOFAMMJK@tColourChangeTexture?$AA@ DB 'tColourChangeTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBIDLEEF@tPlainTexture?$AA@
CONST	SEGMENT
??_C@_0O@CBIDLEEF@tPlainTexture?$AA@ DB 'tPlainTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BLACAFBJ@tPlainColour?$AA@
CONST	SEGMENT
??_C@_0N@BLACAFBJ@tPlainColour?$AA@ DB 'tPlainColour', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KK@KKJBPFMN@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?4?$AA?5?$AAE?$AAn?$AAs?$AAu?$AAr?$AAe?$AA?5?$AAy?$AAo@
CONST	SEGMENT
??_C@_1KK@KKJBPFMN@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?4?$AA?5?$AAE?$AAn?$AAs?$AAu?$AAr?$AAe?$AA?5?$AAy?$AAo@ DB 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'F', 00H, 'X', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 's', 00H, 'u'
	DB	00H, 'r', 00H, 'e', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H
	DB	'r', 00H, ' ', 00H, 'F', 00H, 'X', 00H, ' ', 00H, 'f', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, 's', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'f', 00H
	DB	'o', 00H, 'l', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'a'
	DB	00H, 's', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H
	DB	' ', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MCKIKNIO@?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA1?$AA?4?$AAf?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@MCKIKNIO@?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA1?$AA?4?$AAf?$AAx?$AA?$AA@ DB 'G'
	DB	00H, 'r', 00H, 'a', 00H, 'p', 00H, 'h', 00H, 'i', 00H, 'c', 00H
	DB	's', 00H, 'A', 00H, 's', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n'
	DB	00H, '1', 00H, '.', 00H, 'f', 00H, 'x', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@IKJJOGJD@?$AAC?$AAO?$AA2?$AA4?$AA0?$AA9?$AA?5?$AA?9?$AA?5?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AA?5?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?9?$AA?5?$AAS@
CONST	SEGMENT
??_C@_1EO@IKJJOGJD@?$AAC?$AAO?$AA2?$AA4?$AA0?$AA9?$AA?5?$AA?9?$AA?5?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AA?5?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?9?$AA?5?$AAS@ DB 'C'
	DB	00H, 'O', 00H, '2', 00H, '4', 00H, '0', 00H, '9', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, 'G', 00H, 'r', 00H, 'a', 00H, 'p', 00H, 'h'
	DB	00H, 'i', 00H, 'c', 00H, 's', 00H, ' ', 00H, 'A', 00H, 's', 00H
	DB	's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'm', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, ' ', 00H, '-', 00H, ' ', 00H, 'S', 00H, 'h', 00H
	DB	'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'u', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'C', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFKGIEIH@?5L?3?5?$AA@
CONST	SEGMENT
??_C@_04JFKGIEIH@?5L?3?5?$AA@ DB ' L: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHBDCLGJ@?5O?3?5?$AA@
CONST	SEGMENT
??_C@_04IHBDCLGJ@?5O?3?5?$AA@ DB ' O: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BEMLJPBO@Post?5Processing?5?9?5FPS?5?$AA@
CONST	SEGMENT
??_C@_0BH@BEMLJPBO@Post?5Processing?5?9?5FPS?5?$AA@ DB 'Post Processing -'
	DB	' FPS ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBOPGDGH@SolariseThreshold?$AA@
CONST	SEGMENT
??_C@_0BC@KBOPGDGH@SolariseThreshold?$AA@ DB 'SolariseThreshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HBDAKKJM@Blood?$AA@
CONST	SEGMENT
??_C@_05HBDAKKJM@Blood?$AA@ DB 'Blood', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BMPAAFHK@DVRange?$AA@
CONST	SEGMENT
??_C@_07BMPAAFHK@DVRange?$AA@ DB 'DVRange', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MINFFJCE@BlurRange?$AA@
CONST	SEGMENT
??_C@_09MINFFJCE@BlurRange?$AA@ DB 'BlurRange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IBFDOPMC@PixelY?$AA@
CONST	SEGMENT
??_C@_06IBFDOPMC@PixelY?$AA@ DB 'PixelY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JIEINOID@PixelX?$AA@
CONST	SEGMENT
??_C@_06JIEINOID@PixelX?$AA@ DB 'PixelX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DBKDBEOO@TintColour?$AA@
CONST	SEGMENT
??_C@_0L@DBKDBEOO@TintColour?$AA@ DB 'TintColour', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BCJCHFBA@BloodTexture?$AA@
CONST	SEGMENT
??_C@_0N@BCJCHFBA@BloodTexture?$AA@ DB 'BloodTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CCPNLBHC@InitialTexture?$AA@
CONST	SEGMENT
??_C@_0P@CCPNLBHC@InitialTexture?$AA@ DB 'InitialTexture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMICKNOL@PPSolariseB?$AA@
CONST	SEGMENT
??_C@_0M@JMICKNOL@PPSolariseB?$AA@ DB 'PPSolariseB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LHKPPOCI@PPSolariseA?$AA@
CONST	SEGMENT
??_C@_0M@LHKPPOCI@PPSolariseA?$AA@ DB 'PPSolariseA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLKDBFPD@PPInvert?$AA@
CONST	SEGMENT
??_C@_08LLKDBFPD@PPInvert?$AA@ DB 'PPInvert', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NDCDMOCH@PPBlood?$AA@
CONST	SEGMENT
??_C@_07NDCDMOCH@PPBlood?$AA@ DB 'PPBlood', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ONFAKJPH@PPContrast?$AA@
CONST	SEGMENT
??_C@_0L@ONFAKJPH@PPContrast?$AA@ DB 'PPContrast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DMINDEOL@PPEdge?$AA@
CONST	SEGMENT
??_C@_06DMINDEOL@PPEdge?$AA@ DB 'PPEdge', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PBCAEHNN@PPDoubleVision?$AA@
CONST	SEGMENT
??_C@_0P@PBCAEHNN@PPDoubleVision?$AA@ DB 'PPDoubleVision', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IKNNDFMM@PPBoxBlurV?$AA@
CONST	SEGMENT
??_C@_0L@IKNNDFMM@PPBoxBlurV?$AA@ DB 'PPBoxBlurV', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEANANKI@PPBoxBlur5?$AA@
CONST	SEGMENT
??_C@_0L@MEANANKI@PPBoxBlur5?$AA@ DB 'PPBoxBlur5', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JCFHKKCO@PPBoxBlur3?$AA@
CONST	SEGMENT
??_C@_0L@JCFHKKCO@PPBoxBlur3?$AA@ DB 'PPBoxBlur3', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GAKLFMHC@PPShock?$AA@
CONST	SEGMENT
??_C@_07GAKLFMHC@PPShock?$AA@ DB 'PPShock', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MPGPEKJL@PPTint?$AA@
CONST	SEGMENT
??_C@_06MPGPEKJL@PPTint?$AA@ DB 'PPTint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JLNCKOOC@PPCopy?$AA@
CONST	SEGMENT
??_C@_06JLNCKOOC@PPCopy?$AA@ DB 'PPCopy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1MK@NLJNNCIH@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAo?$AAs?$AAt?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX@
CONST	SEGMENT
??_C@_1MK@NLJNNCIH@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAo?$AAs?$AAt?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX@ DB 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'P', 00H, 'o', 00H, 's', 00H, 't', 00H, ' ', 00H, 'P', 00H
	DB	'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, ' ', 00H, 'F', 00H, 'X', 00H, ' ', 00H
	DB	'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '.', 00H, ' ', 00H, 'E'
	DB	00H, 'n', 00H, 's', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ' ', 00H
	DB	'y', 00H, 'o', 00H, 'u', 00H, 'r', 00H, ' ', 00H, 'F', 00H, 'X'
	DB	00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H
	DB	'i', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 't'
	DB	00H, 'h', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'l', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, 'a', 00H, 's', 00H, ' ', 00H, 't', 00H
	DB	'h', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'e', 00H, 'x', 00H, 'e'
	DB	00H, 'c', 00H, 'u', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@ DB 'E', 00H, 'r', 00H
	DB	'r', 00H, 'o', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@KFFLPJBB@?$AAP?$AAo?$AAs?$AAt?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?4?$AAf?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@KFFLPJBB@?$AAP?$AAo?$AAs?$AAt?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?4?$AAf?$AAx?$AA?$AA@ DB 'P'
	DB	00H, 'o', 00H, 's', 00H, 't', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'c', 00H, 'e', 00H, 's', 00H, 's', 00H, '.', 00H, 'f', 00H, 'x'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06BACILOGA@fx_4_0?$AA@
CONST	SEGMENT
??_C@_06BACILOGA@fx_4_0?$AA@ DB 'fx_4_0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BOCCMAEA@Stop?5trying?5to?5hit?5me?5and?5hit?5me@
CONST	SEGMENT
??_C@_0CC@BOCCMAEA@Stop?5trying?5to?5hit?5me?5and?5hit?5me@ DB 'Stop tryi'
	DB	'ng to hit me and hit me!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PFMGMAKO@?5?8Multi?5Pass?5Controls?8?5position?$DN@
CONST	SEGMENT
??_C@_0DI@PFMGMAKO@?5?8Multi?5Pass?5Controls?8?5position?$DN@ DB ' ''Mult'
	DB	'i Pass Controls'' position=''415 5'' size=''300 320'' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DKPHBODF@Multi?5Pass?5Controls?$AA@
CONST	SEGMENT
??_C@_0BE@DKPHBODF@Multi?5Pass?5Controls?$AA@ DB 'Multi Pass Controls', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FHPJJGJD@Toggle?5Gaussian?5Blur?$AA@
CONST	SEGMENT
??_C@_0BF@FHPJJGJD@Toggle?5Gaussian?5Blur?$AA@ DB 'Toggle Gaussian Blur', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LIMCDIOE@Solarise?5?$CIBelow?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@LIMCDIOE@Solarise?5?$CIBelow?$CJ?$AA@ DB 'Solarise (Below)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OBDMAHBK@Solarise?5?$CIAbove?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@OBDMAHBK@Solarise?5?$CIAbove?$CJ?$AA@ DB 'Solarise (Above)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OHLCGMJD@Invert?$AA@
CONST	SEGMENT
??_C@_06OHLCGMJD@Invert?$AA@ DB 'Invert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EACNFBOP@Jam?5on?5the?5screen?$AA@
CONST	SEGMENT
??_C@_0BC@EACNFBOP@Jam?5on?5the?5screen?$AA@ DB 'Jam on the screen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBHEFHNJ@Contrast?$AA@
CONST	SEGMENT
??_C@_08KBHEFHNJ@Contrast?$AA@ DB 'Contrast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JBOFPIEK@Edges?$AA@
CONST	SEGMENT
??_C@_05JBOFPIEK@Edges?$AA@ DB 'Edges', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OAINAAFK@Double?5Vision?$AA@
CONST	SEGMENT
??_C@_0O@OAINAAFK@Double?5Vision?$AA@ DB 'Double Vision', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BBINBACJ@Box?5Blur?5?$CICustom?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@BBINBACJ@Box?5Blur?5?$CICustom?$CJ?$AA@ DB 'Box Blur (Custom)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DBBLADPE@Box?5Blur?5?$CI5?$CJ?$AA@
CONST	SEGMENT
??_C@_0N@DBBLADPE@Box?5Blur?5?$CI5?$CJ?$AA@ DB 'Box Blur (5)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DFJGHPEG@Box?5Blur?5?$CI3?$CJ?$AA@
CONST	SEGMENT
??_C@_0N@DFJGHPEG@Box?5Blur?5?$CI3?$CJ?$AA@ DB 'Box Blur (3)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MCLIDIMJ@Shock?$AA@
CONST	SEGMENT
??_C@_05MCLIDIMJ@Shock?$AA@ DB 'Shock', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLHKIDLI@Tint?$AA@
CONST	SEGMENT
??_C@_04LLHKIDLI@Tint?$AA@ DB 'Tint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BGDIAJAG@No?5PP?$AA@
CONST	SEGMENT
??_C@_05BGDIAJAG@No?5PP?$AA@ DB 'No PP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LLGGHJJD@?5?8Single?5Pass?5Select?8?5position?$DN?8@
CONST	SEGMENT
??_C@_0CI@LLGGHJJD@?5?8Single?5Pass?5Select?8?5position?$DN?8@ DB ' ''Sin'
	DB	'gle Pass Select'' position=''210 5'' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BGGKKCGG@Single?5Pass?5Select?$AA@
CONST	SEGMENT
??_C@_0BD@BGGKKCGG@Single?5Pass?5Select?$AA@ DB 'Single Pass Select', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NMGOIPCC@Toggle?5Single?$AA@
CONST	SEGMENT
??_C@_0O@NMGOIPCC@Toggle?5Single?$AA@ DB 'Toggle Single', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IGJPDDCA@Using?5multiple?3?5?$AA@
CONST	SEGMENT
??_C@_0BB@IGJPDDCA@Using?5multiple?3?5?$AA@ DB 'Using multiple: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GCNLHPML@Solarise?5Threshold?$AA@
CONST	SEGMENT
??_C@_0BD@GCNLHPML@Solarise?5Threshold?$AA@ DB 'Solarise Threshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NEFNJEOO@min?$DN32?5max?$DN222?5step?$DN1?$AA@
CONST	SEGMENT
??_C@_0BG@NEFNJEOO@min?$DN32?5max?$DN222?5step?$DN1?$AA@ DB 'min=32 max=2'
	DB	'22 step=1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09CINOGBPL@Jamminess?$AA@
CONST	SEGMENT
??_C@_09CINOGBPL@Jamminess?$AA@ DB 'Jamminess', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BHAGHJLA@min?$DN0?5max?$DN1?5step?$DN0?405?$AA@
CONST	SEGMENT
??_C@_0BG@BHAGHJLA@min?$DN0?5max?$DN1?5step?$DN0?405?$AA@ DB 'min=0 max=1'
	DB	' step=0.05', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@COCHJCAA@Contrast?5Shift?$AA@
CONST	SEGMENT
??_C@_0P@COCHJCAA@Contrast?5Shift?$AA@ DB 'Contrast Shift', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JONKBOAH@min?$DN?9128?5max?$DN128?5step?$DN1?$AA@
CONST	SEGMENT
??_C@_0BI@JONKBOAH@min?$DN?9128?5max?$DN128?5step?$DN1?$AA@ DB 'min=-128 '
	DB	'max=128 step=1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OKIMCMFP@Double?5Vision?5Radius?$AA@
CONST	SEGMENT
??_C@_0BF@OKIMCMFP@Double?5Vision?5Radius?$AA@ DB 'Double Vision Radius', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BKHNEING@min?$DN0?5max?$DN0?45?5step?$DN0?4005?$AA@
CONST	SEGMENT
??_C@_0BJ@BKHNEING@min?$DN0?5max?$DN0?45?5step?$DN0?4005?$AA@ DB 'min=0 m'
	DB	'ax=0.5 step=0.005', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DOKJBODC@Blur?5Radius?$AA@
CONST	SEGMENT
??_C@_0M@DOKJBODC@Blur?5Radius?$AA@ DB 'Blur Radius', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BKDAFDIA@min?$DN2?5max?$DN50?5step?$DN1?$AA@
CONST	SEGMENT
??_C@_0BE@BKDAFDIA@min?$DN2?5max?$DN50?5step?$DN1?$AA@ DB 'min=2 max=50 s'
	DB	'tep=1', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBJEPOMH@Shock?5Length?$AA@
CONST	SEGMENT
??_C@_0N@BBJEPOMH@Shock?5Length?$AA@ DB 'Shock Length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GEGIJDLI@min?$DN0?41?5max?$DN5?5step?$DN0?41?$AA@
CONST	SEGMENT
??_C@_0BH@GEGIJDLI@min?$DN0?41?5max?$DN5?5step?$DN0?41?$AA@ DB 'min=0.1 m'
	DB	'ax=5 step=0.1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCFLJLDD@Shock?5Speed?$AA@
CONST	SEGMENT
??_C@_0M@BCFLJLDD@Shock?5Speed?$AA@ DB 'Shock Speed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HMIPNKPE@Shock?5Strength?$AA@
CONST	SEGMENT
??_C@_0P@HMIPNKPE@Shock?5Strength?$AA@ DB 'Shock Strength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PGFPMOIN@min?$DN0?401?5max?$DN0?45?5step?$DN0?401?$AA@
CONST	SEGMENT
??_C@_0BL@PGFPMOIN@min?$DN0?401?5max?$DN0?45?5step?$DN0?401?$AA@ DB 'min='
	DB	'0.01 max=0.5 step=0.01', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LEBMNMMI@Tint?5Cycle?5Time?$AA@
CONST	SEGMENT
??_C@_0BA@LEBMNMMI@Tint?5Cycle?5Time?$AA@ DB 'Tint Cycle Time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BNBHPOAI@min?$DN0?41?5max?$DN30?5step?$DN0?41?$AA@
CONST	SEGMENT
??_C@_0BI@BNBHPOAI@min?$DN0?41?5max?$DN30?5step?$DN0?41?$AA@ DB 'min=0.1 '
	DB	'max=30 step=0.1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HAEMFPIM@?5PostProcessing?5position?$DN?85?55?8?5?$AA@
CONST	SEGMENT
??_C@_0CA@HAEMFPIM@?5PostProcessing?5position?$DN?85?55?8?5?$AA@ DB ' Pos'
	DB	'tProcessing position=''5 5'' ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MPKDMNGJ@PostProcessing?$AA@
CONST	SEGMENT
??_C@_0P@MPKDMNGJ@PostProcessing?$AA@ DB 'PostProcessing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPDMJMG@Mirror?4x?$AA@
CONST	SEGMENT
??_C@_08MLPDMJMG@Mirror?4x?$AA@ DB 'Mirror.x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@PPEMIMM@?$AAB?$AAl?$AAo?$AAo?$AAd?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@PPEMIMM@?$AAB?$AAl?$AAo?$AAo?$AAd?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@ DB 'B'
	DB	00H, 'l', 00H, 'o', 00H, 'o', 00H, 'd', 00H, '.', 00H, 'j', 00H
	DB	'p', 00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@IHOPDIJ@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@IHOPDIJ@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'B'
	DB	00H, 'r', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'N', 00H, 'o', 00H
	DB	'r', 00H, 'm', 00H, 'a', 00H, 'l', 00H, 'D', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'h', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@ONLGGDNI@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@ONLGGDNI@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'B'
	DB	00H, 'r', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'D', 00H, 'i', 00H
	DB	'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S', 00H, 'p'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r', 00H
	DB	'.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@HNAGGCPI@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA4?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@HNAGGCPI@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA4?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'o', 00H, 'l', 00H, 'l', 00H, '4', 00H, 'D', 00H
	DB	'i', 00H, 'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H
	DB	'r', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@KMEIPAPA@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA3?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@KMEIPAPA@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA3?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'o', 00H, 'l', 00H, 'l', 00H, '3', 00H, 'D', 00H
	DB	'i', 00H, 'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H
	DB	'r', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@NHBHEBO@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA2?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@NHBHEBO@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA2?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'o', 00H, 'l', 00H, 'l', 00H, '2', 00H, 'D', 00H
	DB	'i', 00H, 'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H
	DB	'r', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@DFEKPPGN@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA1?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@DFEKPPGN@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA1?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'o', 00H, 'l', 00H, 'l', 00H, '1', 00H, 'D', 00H
	DB	'i', 00H, 'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S'
	DB	00H, 'p', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H
	DB	'r', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@DADLEHEK@?$AAG?$AAl?$AAa?$AAs?$AAs?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@DADLEHEK@?$AAG?$AAl?$AAa?$AAs?$AAs?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@ DB 'G'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, '.', 00H, 'j', 00H
	DB	'p', 00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@NOLHING@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@NOLHING@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'P'
	DB	00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H
	DB	'N', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 'l', 00H, 'D'
	DB	00H, 'e', 00H, 'p', 00H, 't', 00H, 'h', 00H, '.', 00H, 'd', 00H
	DB	'd', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@GOOKDEDK@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@GOOKDEDK@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'P'
	DB	00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H
	DB	'D', 00H, 'i', 00H, 'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e'
	DB	00H, 'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H
	DB	'a', 00H, 'r', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@DJHFCGLD@?$AAM?$AAe?$AAt?$AAa?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@DJHFCGLD@?$AAM?$AAe?$AAt?$AAa?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'M'
	DB	00H, 'e', 00H, 't', 00H, 'a', 00H, 'l', 00H, 'D', 00H, 'i', 00H
	DB	'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S', 00H, 'p'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r', 00H
	DB	'.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@HJHILCKN@?$AAW?$AAa?$AAl?$AAl?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@HJHILCKN@?$AAW?$AAa?$AAl?$AAl?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'W'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'N', 00H, 'o', 00H, 'r', 00H
	DB	'm', 00H, 'a', 00H, 'l', 00H, 'D', 00H, 'e', 00H, 'p', 00H, 't'
	DB	00H, 'h', 00H, '.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@GABNFLNL@?$AAW?$AAa?$AAl?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@GABNFLNL@?$AAW?$AAa?$AAl?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'W'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'D', 00H, 'i', 00H, 'f', 00H
	DB	'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S', 00H, 'p', 00H, 'e'
	DB	00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r', 00H, '.', 00H
	DB	'd', 00H, 'd', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@MACPKMCG@?$AAM?$AAo?$AAo?$AAn?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@MACPKMCG@?$AAM?$AAo?$AAo?$AAn?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@ DB 'M'
	DB	00H, 'o', 00H, 'o', 00H, 'n', 00H, '.', 00H, 'j', 00H, 'p', 00H
	DB	'g', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@IEJEKIPL@?$AAW?$AAo?$AAo?$AAd?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@IEJEKIPL@?$AAW?$AAo?$AAo?$AAd?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'W'
	DB	00H, 'o', 00H, 'o', 00H, 'd', 00H, 'D', 00H, 'i', 00H, 'f', 00H
	DB	'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S', 00H, 'p', 00H, 'e'
	DB	00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r', 00H, '.', 00H
	DB	'd', 00H, 'd', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@LOBNDLGH@?$AAS?$AAt?$AAo?$AAn?$AAe?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@LOBNDLGH@?$AAS?$AAt?$AAo?$AAn?$AAe?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@ DB 'S'
	DB	00H, 't', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 'D', 00H, 'i', 00H
	DB	'f', 00H, 'f', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'S', 00H, 'p'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'l', 00H, 'a', 00H, 'r', 00H
	DB	'.', 00H, 'd', 00H, 'd', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_DATA	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD FLAT:??_7_System_error_category@std@@6B@ ; std::_Error_objects<int>::_System_object
_DATA	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_DATA	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD FLAT:??_7_Iostream_error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object
_DATA	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_DATA	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD FLAT:??_7_Generic_error_category@std@@6B@ ; std::_Error_objects<int>::_Generic_object
_DATA	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_DATA	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 04H DUP (?)
	DD	FLAT:___ImageBase			; ATL::_AtlComModule
	DD	FLAT:___pobjMapEntryFirst+4
	DD	FLAT:___pobjMapEntryLast
_DATA	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
data$r	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
data$r	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InitScene@CScene@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitScene@CScene@@QAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitScene@CScene@@QAE_NXZ$1
__ehfuncinfo$?InitScene@CScene@@QAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?InitScene@CScene@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?TestItems@CScene@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TestItems@CScene@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TestItems@CScene@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TestItems@CScene@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TestItems@CScene@@AAE_NXZ$3
__ehfuncinfo$?TestItems@CScene@@AAE_NXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?TestItems@CScene@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SceneItems@CScene@@AAE_NXZ DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$?SceneItems@CScene@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SceneItems@CScene@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$13
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?BasicItems@CScene@@AAE_NXZ DD 019930522H
	DD	018H
	DD	FLAT:__unwindtable$?BasicItems@CScene@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?BasicItems@CScene@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$21
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$22
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$23
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
__AtlWinModule$initializer$ DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT

; 159  : 		{	// destroy the object

	mov	DWORD PTR ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_System_object
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	pop	ecx
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 159  : 		{	// destroy the object

	mov	DWORD PTR ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	pop	ecx
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 159  : 		{	// destroy the object

	mov	DWORD PTR ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_Generic_object
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	pop	ecx
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN1@Allocate
	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	jne	SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	jmp	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, ecx

; 32   : 	}

	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z
_TEXT	SEGMENT
_ppBuff$ = 8						; size = 4
_nLength$ = 12						; size = 4
_pszFixedBuffer$ = 16					; size = 4
_nFixedBufferLength$ = 20				; size = 4
??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z PROC	; ATL::AtlConvAllocMemory<wchar_t>, COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 120  : 	ATLENSURE_THROW(ppBuff != NULL, E_INVALIDARG);

	mov	esi, DWORD PTR _ppBuff$[ebp]
	push	edi
	test	esi, esi
	je	SHORT $LN33@AtlConvAll

; 121  : 	ATLENSURE_THROW(nLength >= 0, E_INVALIDARG);

	mov	eax, DWORD PTR _nLength$[ebp]
	test	eax, eax
	js	SHORT $LN35@AtlConvAll

; 122  : 	ATLENSURE_THROW(pszFixedBuffer != NULL, E_INVALIDARG);

	mov	edi, DWORD PTR _pszFixedBuffer$[ebp]
	test	edi, edi
	je	SHORT $LN36@AtlConvAll

; 123  : 
; 124  : 	//if buffer malloced, try to realloc.
; 125  : 	if (*ppBuff != pszFixedBuffer)

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, edi
	je	SHORT $LN8@AtlConvAll

; 126  : 	{
; 127  : 		if( nLength > nFixedBufferLength )

	cmp	eax, DWORD PTR _nFixedBufferLength$[ebp]
	jle	SHORT $LN7@AtlConvAll

; 128  : 		{
; 129  : 			_CharType* ppReallocBuf = static_cast< _CharType* >( _recalloc(*ppBuff, nLength,sizeof( _CharType ) ) );

	push	2
	push	eax
	push	ecx
	call	__recalloc
	add	esp, 12					; 0000000cH

; 130  : 			if (ppReallocBuf == NULL) 

	test	eax, eax
	jne	SHORT $LN6@AtlConvAll
	jmp	SHORT $LN37@AtlConvAll
$LN7@AtlConvAll:

; 133  : 			}
; 134  : 			*ppBuff = ppReallocBuf;
; 135  : 		} else
; 136  : 		{
; 137  : 			free(*ppBuff);

	push	ecx
	call	_free
	add	esp, 4
$LN3@AtlConvAll:

; 147  : 		{			
; 148  : 			*ppBuff=pszFixedBuffer;

	mov	DWORD PTR [esi], edi
$LN2@AtlConvAll:

; 149  : 		}
; 150  : 	}
; 151  : 
; 152  : 	if (*ppBuff == NULL)

	cmp	DWORD PTR [esi], 0
	pop	edi
	pop	esi
	jne	SHORT $LN1@AtlConvAll
	jmp	SHORT $LN38@AtlConvAll
$LN8@AtlConvAll:

; 138  : 			*ppBuff=pszFixedBuffer;
; 139  : 		}
; 140  : 
; 141  : 	} else //Buffer is not currently malloced.
; 142  : 	{
; 143  : 		if( nLength > nFixedBufferLength )

	cmp	eax, DWORD PTR _nFixedBufferLength$[ebp]
	jle	SHORT $LN3@AtlConvAll

; 144  : 		{
; 145  : 			*ppBuff = static_cast< _CharType* >( calloc(nLength,sizeof( _CharType ) ) );

	push	2
	push	eax
	call	_calloc
	add	esp, 8
$LN6@AtlConvAll:
	mov	DWORD PTR [esi], eax

; 146  : 		} else

	jmp	SHORT $LN2@AtlConvAll
$LN1@AtlConvAll:

; 155  : 	}
; 156  : }

	pop	ebp
	ret	0
$LN33@AtlConvAll:

; 120  : 	ATLENSURE_THROW(ppBuff != NULL, E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN39@AtlConvAll:
$LN35@AtlConvAll:

; 121  : 	ATLENSURE_THROW(nLength >= 0, E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN40@AtlConvAll:
$LN36@AtlConvAll:

; 122  : 	ATLENSURE_THROW(pszFixedBuffer != NULL, E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN41@AtlConvAll:
$LN37@AtlConvAll:

; 131  : 			{
; 132  : 				AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN42@AtlConvAll:
$LN38@AtlConvAll:

; 153  : 	{
; 154  : 		AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN43@AtlConvAll:
$LN32@AtlConvAll:
	int	3
??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z ENDP	; ATL::AtlConvAllocMemory<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z
_TEXT	SEGMENT
_pBuff$ = 8						; size = 4
_pszFixedBuffer$ = 12					; size = 4
_nFixedBufferLength$ = 16				; size = 4
??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z PROC		; ATL::AtlConvFreeMemory<wchar_t>, COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  : 	(nFixedBufferLength);
; 165  : 	if( pBuff != pszFixedBuffer )

	mov	eax, DWORD PTR _pBuff$[ebp]
	cmp	eax, DWORD PTR _pszFixedBuffer$[ebp]
	je	SHORT $LN1@AtlConvFre

; 166  : 	{
; 167  : 		free( pBuff );

	push	eax
	call	_free
	add	esp, 4
$LN1@AtlConvFre:

; 168  : 	} 	
; 169  : #ifdef _DEBUG
; 170  : 	else
; 171  : 	{		
; 172  : 		memset(pszFixedBuffer,ATLCONV_DEADLAND_FILL,nFixedBufferLength*sizeof(_CharType));
; 173  : 	}
; 174  : #endif
; 175  : }

	pop	ebp
	ret	0
??$AtlConvFreeMemory@_W@ATL@@YAXPA_W0H@Z ENDP		; ATL::AtlConvFreeMemory<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Source$ = 12						; size = 4
??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z PROC		; strcat_s<100>, COMDAT

; 116  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcat_s, char, _Dest, _In_z_ const char *, _Source)

	push	ebp
	mov	ebp, esp
	push	DWORD PTR __Source$[ebp]
	push	100					; 00000064H
	push	DWORD PTR __Dest$[ebp]
	call	_strcat_s
	add	esp, 12					; 0000000cH
	pop	ebp
	ret	0
??$strcat_s@$0GE@@@YAHAAY0GE@DPBD@Z ENDP		; strcat_s<100>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h
;	COMDAT ??$_itoa_s@$05@@YAHHAAY05DH@Z
_TEXT	SEGMENT
__Value$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Radix$ = 16						; size = 4
??$_itoa_s@$05@@YAHHAAY05DH@Z PROC			; _itoa_s<6>, COMDAT

; 480  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itoa_s, _In_ int, _Value, char, _Dest, _In_ int, _Radix)

	push	ebp
	mov	ebp, esp
	push	DWORD PTR __Radix$[ebp]
	push	6
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Value$[ebp]
	call	__itoa_s
	add	esp, 16					; 00000010H
	pop	ebp
	ret	0
??$_itoa_s@$05@@YAHHAAY05DH@Z ENDP			; _itoa_s<6>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Source$ = 12						; size = 4
??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z PROC		; strcpy_s<100>, COMDAT

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	push	ebp
	mov	ebp, esp
	push	DWORD PTR __Source$[ebp]
	push	100					; 00000064H
	push	DWORD PTR __Dest$[ebp]
	call	_strcpy_s
	add	esp, 12					; 0000000cH
	pop	ebp
	ret	0
??$strcpy_s@$0GE@@@YAHAAY0GE@DPBD@Z ENDP		; strcpy_s<100>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z
_TEXT	SEGMENT
_nLengthA$1$ = 8					; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z PROC		; ATL::CA2WEX<128>::Init, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi

; 377  : 		if (psz == NULL)

	mov	edi, DWORD PTR _psz$[ebp]
	mov	ebx, ecx
	test	edi, edi
	jne	SHORT $LN4@Init

; 378  : 		{
; 379  : 			m_psz = NULL;

	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	ebx

; 402  : 		}		
; 403  : 	}

	pop	ebp
	ret	8
$LN4@Init:

; 380  : 			return;
; 381  : 		}
; 382  : 		int nLengthA = static_cast<int>(strlen( psz ))+1;

	mov	ecx, edi
	lea	edx, DWORD PTR [ecx+1]
	npad	5
$LL7@Init:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL7@Init
	push	esi
	sub	ecx, edx

; 383  : 		int nLengthW = nLengthA;
; 384  : 
; 385  : 		AtlConvAllocMemory(&m_psz,nLengthW,m_szBuffer,t_nBufferLength);

	lea	eax, DWORD PTR [ebx+4]
	push	128					; 00000080H
	push	eax
	lea	esi, DWORD PTR [ecx+1]
	push	esi
	push	ebx
	mov	DWORD PTR _nLengthA$1$[ebp], esi
	call	??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z ; ATL::AtlConvAllocMemory<wchar_t>
	add	esp, 16					; 00000010H

; 386  : 
; 387  : 		BOOL bFailed=(0 == ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW ) );

	push	esi
	push	DWORD PTR [ebx]
	push	esi
	push	edi
	push	0
	push	DWORD PTR _nCodePage$[ebp]
	call	DWORD PTR __imp__MultiByteToWideChar@24
	mov	esi, eax
	neg	esi
	sbb	esi, esi
	inc	esi

; 388  : 		if (bFailed)

	je	SHORT $LN8@Init

; 389  : 		{
; 390  : 			if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)

	call	DWORD PTR __imp__GetLastError@0
	cmp	eax, 122				; 0000007aH
	jne	SHORT $LN2@Init

; 391  : 			{
; 392  : 				nLengthW = ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, NULL, 0);

	push	0
	push	0
	push	DWORD PTR _nLengthA$1$[ebp]
	push	edi
	push	0
	push	DWORD PTR _nCodePage$[ebp]
	call	DWORD PTR __imp__MultiByteToWideChar@24
	mov	esi, eax

; 393  : ATLPREFAST_SUPPRESS(6102)                
; 394  : 				AtlConvAllocMemory(&m_psz,nLengthW,m_szBuffer,t_nBufferLength);

	lea	eax, DWORD PTR [ebx+4]
	push	128					; 00000080H
	push	eax
	push	esi
	push	ebx
	call	??$AtlConvAllocMemory@_W@ATL@@YAXPAPA_WHPA_WH@Z ; ATL::AtlConvAllocMemory<wchar_t>
	add	esp, 16					; 00000010H

; 395  : ATLPREFAST_UNSUPPRESS()
; 396  : 				bFailed=(0 == ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW ) );

	push	esi
	push	DWORD PTR [ebx]
	push	DWORD PTR _nLengthA$1$[ebp]
	push	edi
	push	0
	push	DWORD PTR _nCodePage$[ebp]
	call	DWORD PTR __imp__MultiByteToWideChar@24
	mov	esi, eax
	neg	esi
	sbb	esi, esi
	inc	esi
$LN2@Init:

; 397  : 			}			
; 398  : 		}
; 399  : 		if (bFailed)

	test	esi, esi
	jne	SHORT $LN10@Init
$LN8@Init:
	pop	esi
	pop	edi
	pop	ebx

; 402  : 		}		
; 403  : 	}

	pop	ebp
	ret	8
$LN10@Init:

; 400  : 		{
; 401  : 			AtlThrowLastWin32();

	call	?AtlThrowLastWin32@ATL@@YGXXZ		; ATL::AtlThrowLastWin32
$LN12@Init:
$LN9@Init:
	int	3
?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z ENDP		; ATL::CA2WEX<128>::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ PROC			; ATL::CA2WEX<128>::operator wchar_t *, COMDAT
; _this$ = ecx

; 369  : 		return( m_psz );

	mov	eax, DWORD PTR [ecx]

; 370  : 	}

	ret	0
??B?$CA2WEX@$0IA@@ATL@@QBEPA_WXZ ENDP			; ATL::CA2WEX<128>::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??1?$CA2WEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CA2WEX@$0IA@@ATL@@QAE@XZ PROC			; ATL::CA2WEX<128>::~CA2WEX<128>, COMDAT
; _this$ = ecx

; 364  : 		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+4]

; 165  : 	if( pBuff != pszFixedBuffer )

	cmp	edx, eax
	je	SHORT $LN3@CA2WEX

; 166  : 	{
; 167  : 		free( pBuff );

	push	edx
	call	_free
	pop	ecx
$LN3@CA2WEX:

; 365  : 	}

	ret	0
??1?$CA2WEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CA2WEX<128>::~CA2WEX<128>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z PROC			; ATL::CA2WEX<128>::CA2WEX<128>, COMDAT
; _this$ = ecx

; 352  : 	{

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 353  : 		Init( psz, _AtlGetConversionACP() );

	push	3
	push	DWORD PTR _psz$[ebp]
	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	call	?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z	; ATL::CA2WEX<128>::Init

; 354  : 	}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CA2WEX@$0IA@@ATL@@QAE@PBD@Z ENDP			; ATL::CA2WEX<128>::CA2WEX<128>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?TWImpact@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?TWImpact@@YGXPAX@Z PROC				; TWImpact, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp

; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;
; 213  : }
; 214  : 
; 215  : void CScene::ResetShock()
; 216  : {
; 217  : 	mShockTime = mShockLength;	
; 218  : }
; 219  : 
; 220  : bool CScene::InitATB()
; 221  : {
; 222  : 	TwInit(TW_DIRECT3D10, mpd3dDevice);
; 223  : 	TwWindowSize(mViewportWidth, mViewportHeight);
; 224  : 
; 225  : 	mtwBarPP = TwNewBar("PostProcessing");
; 226  : 	TwDefine(" PostProcessing position='5 5' ");
; 227  : 	TwAddVarRW(mtwBarPP, "Tint Cycle Time", TW_TYPE_FLOAT, &mTintCycleTime, "min=0.1 max=30 step=0.1");
; 228  : 	TwAddSeparator(mtwBarPP, "", "");
; 229  : 	TwAddVarRW(mtwBarPP, "Shock Strength", TW_TYPE_FLOAT, &mShockStrength, "min=0.01 max=0.5 step=0.01");
; 230  : 	TwAddVarRW(mtwBarPP, "Shock Speed", TW_TYPE_FLOAT, &mShockSpeed, "min=0.1 max=30 step=0.1");
; 231  : 	TwAddVarRW(mtwBarPP, "Shock Length", TW_TYPE_FLOAT, &mShockLength, "min=0.1 max=5 step=0.1");
; 232  : 	TwAddSeparator(mtwBarPP, "", "");
; 233  : 	TwAddVarRW(mtwBarPP, "Blur Radius", TW_TYPE_INT32, &mBlurRadius, "min=2 max=50 step=1");
; 234  : 	TwAddSeparator(mtwBarPP, "", "");
; 235  : 	TwAddVarRW(mtwBarPP, "Double Vision Radius", TW_TYPE_FLOAT, &mDoubleVisionRadius, "min=0 max=0.5 step=0.005");
; 236  : 	TwAddSeparator(mtwBarPP, "", "");
; 237  : 	TwAddVarRW(mtwBarPP, "Contrast Shift", TW_TYPE_FLOAT, &mContrastChange, "min=-128 max=128 step=1");
; 238  : 	//TwAddVarRO(mtwBarPP, "Contrast Factor", TW_TYPE_FLOAT, &mContrastFactor, "");
; 239  : 	TwAddVarRW(mtwBarPP, "Jamminess", TW_TYPE_FLOAT, &mBlood, "min=0 max=1 step=0.05");
; 240  : 	TwAddSeparator(mtwBarPP, "", "");
; 241  : 	TwAddVarRW(mtwBarPP, "Solarise Threshold", TW_TYPE_INT32, &mSolariseInt, "min=32 max=222 step=1");
; 242  : 	TwAddSeparator(mtwBarPP, "", "");
; 243  : 	TwAddVarRO(mtwBarPP, "Using multiple: ", TW_TYPE_BOOLCPP, &multiprocess, "");
; 244  : 	TwAddButton( mtwBarPP, "Toggle Single", ToggleSingle, this, "");
; 245  : 	
; 246  : 	mtwBarSinglePP = TwNewBar("Single Pass Select");
; 247  : 	TwDefine(" 'Single Pass Select' position='210 5' ");
; 248  : 	TwAddButton(mtwBarSinglePP, "No PP", SetPP00, this, "");
; 249  : 	TwAddButton(mtwBarSinglePP, "Tint", SetPP01, this, "");
; 250  : 	TwAddButton(mtwBarSinglePP, "Shock", SetPP02, this, "");
; 251  : 	TwAddButton(mtwBarSinglePP, "Box Blur (3)", SetPP03, this, "");
; 252  : 	TwAddButton(mtwBarSinglePP, "Box Blur (5)", SetPP04, this, "");
; 253  : 	TwAddButton(mtwBarSinglePP, "Box Blur (Custom)", SetPP05, this, "");
; 254  : 	TwAddButton(mtwBarSinglePP, "Double Vision", SetPP06, this, "");
; 255  : 	TwAddButton(mtwBarSinglePP, "Edges", SetPP07, this, "");
; 256  : 	TwAddButton(mtwBarSinglePP, "Contrast", SetPP08, this, "");
; 257  : 	TwAddButton(mtwBarSinglePP, "Jam on the screen", SetPP09, this, "");
; 258  : 	TwAddButton(mtwBarSinglePP, "Invert", SetPP10, this, "");
; 259  : 	TwAddButton(mtwBarSinglePP, "Solarise (Above)", SetPP11, this, "");
; 260  : 	TwAddButton(mtwBarSinglePP, "Solarise (Below)", SetPP12, this, "");
; 261  : 	TwAddSeparator(mtwBarSinglePP, "", "");
; 262  : 	TwAddButton(mtwBarSinglePP, "Toggle Gaussian Blur", SetGauss, this, "");
; 263  : 
; 264  : 	mtwBarMultiPP = TwNewBar("Multi Pass Controls");
; 265  : 	TwDefine(" 'Multi Pass Controls' position='415 5' size='300 320' ");
; 266  : 	TwAddButton(mtwBarMultiPP, "Stop trying to hit me and hit me!", TWImpact, this, "");
; 267  : 
; 268  : 	return true;
; 269  : }
; 270  : 
; 271  : bool CScene::InitPP()
; 272  : {
; 273  : 	mInitialTextureDesc.Width = mViewportWidth;
; 274  : 	mInitialTextureDesc.Height = mViewportHeight;
; 275  : 	mInitialTextureDesc.MipLevels = 1;
; 276  : 	mInitialTextureDesc.ArraySize = 1;
; 277  : 	mInitialTextureDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
; 278  : 	mInitialTextureDesc.SampleDesc.Count = 1;
; 279  : 	mInitialTextureDesc.SampleDesc.Quality = 0;
; 280  : 	mInitialTextureDesc.Usage = D3D10_USAGE_DEFAULT;
; 281  : 	mInitialTextureDesc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
; 282  : 	mInitialTextureDesc.CPUAccessFlags = 0;
; 283  : 	mInitialTextureDesc.MiscFlags = 0;
; 284  : 	if( FAILED( mpd3dDevice->CreateTexture2D( &mInitialTextureDesc, NULL, &mInitialTexture) ) ) return false;
; 285  : 	if (FAILED( mpd3dDevice->CreateTexture2D( &mInitialTextureDesc, NULL, &mTextureOne ) ) ) return false;
; 286  : 	if (FAILED( mpd3dDevice->CreateTexture2D( &mInitialTextureDesc, NULL, &mTextureTwo ) ) ) return false;
; 287  : 
; 288  : 	if( FAILED( mpd3dDevice->CreateRenderTargetView( mInitialTexture, NULL, &mInitialRenderTarget ) ) ) return false;
; 289  : 	if (FAILED( mpd3dDevice->CreateRenderTargetView( mTextureOne, NULL, &mRenderTargetOne) ) ) return false;
; 290  : 	if (FAILED( mpd3dDevice->CreateRenderTargetView( mTextureTwo, NULL, &mRenderTargetTwo) ) ) return false;
; 291  : 
; 292  : 	mInitialShaderDesc.Format = mInitialTextureDesc.Format;
; 293  : 	mInitialShaderDesc.ViewDimension = D3D10_SRV_DIMENSION_TEXTURE2D;
; 294  : 	mInitialShaderDesc.Texture2D.MostDetailedMip = 0;
; 295  : 	mInitialShaderDesc.Texture2D.MipLevels = 1;
; 296  : 	if( FAILED( mpd3dDevice->CreateShaderResourceView( mInitialTexture, &mInitialShaderDesc, &mInitialShaderResource ) ) ) return false;
; 297  : 	if (FAILED( mpd3dDevice->CreateShaderResourceView( mTextureOne, &mInitialShaderDesc, &mTextureOneShader))) return false;
; 298  : 	if (FAILED( mpd3dDevice->CreateShaderResourceView( mTextureTwo, &mInitialShaderDesc, &mTextureTwoShader))) return false;
; 299  : 
; 300  : 	ID3D10Blob* pErrors; // This strangely typed variable collects any errors when compiling the effect file
; 301  : 	DWORD dwShaderFlags = D3D10_SHADER_ENABLE_STRICTNESS; // These "flags" are used to set the compiler options
; 302  : 
; 303  : 	// Load and compile the effect file
; 304  : 	HRESULT hr = D3DX10CreateEffectFromFile( L"PostProcess.fx", NULL, NULL, "fx_4_0", dwShaderFlags, 0, mpd3dDevice, NULL, NULL, &mPPEffect, &pErrors, NULL );
; 305  : 	if( FAILED( hr ) )
; 306  : 	{
; 307  : 		if (pErrors != 0)  MessageBox( NULL, CA2CT(reinterpret_cast<char*>(pErrors->GetBufferPointer())), L"Error", MB_OK ); // Compiler error: display error message
; 308  : 		else               MessageBox( NULL, L"Error loading Post Processing FX file. Ensure your FX file is in the same folder as this executable.", L"Error", MB_OK );  // No error message - probably file not found
; 309  : 		return false;
; 310  : 	}
; 311  : 
; 312  : 	mPPTechniques[0]  = mPPEffect->GetTechniqueByName( "PPCopy" );
; 313  : 	mPPTechniques[1]  = mPPEffect->GetTechniqueByName( "PPTint" );
; 314  : 	mPPTechniques[2]  = mPPEffect->GetTechniqueByName( "PPShock" );
; 315  : 	mPPTechniques[3]  = mPPEffect->GetTechniqueByName( "PPBoxBlur3" );
; 316  : 	mPPTechniques[4]  = mPPEffect->GetTechniqueByName( "PPBoxBlur5" );
; 317  : 	mPPTechniques[5]  = mPPEffect->GetTechniqueByName( "PPBoxBlurV" );
; 318  : 	mPPTechniques[6]  = mPPEffect->GetTechniqueByName( "PPDoubleVision" );
; 319  : 	mPPTechniques[7]  = mPPEffect->GetTechniqueByName( "PPEdge" );
; 320  : 	mPPTechniques[8]  = mPPEffect->GetTechniqueByName( "PPContrast" );
; 321  : 	mPPTechniques[9]  = mPPEffect->GetTechniqueByName( "PPBlood" );
; 322  : 	mPPTechniques[10] = mPPEffect->GetTechniqueByName( "PPInvert" );
; 323  : 	mPPTechniques[11] = mPPEffect->GetTechniqueByName( "PPSolariseA" );
; 324  : 	mPPTechniques[12] = mPPEffect->GetTechniqueByName( "PPSolariseB" );
; 325  : 
; 326  : 	mInitialTextureVar = mPPEffect->GetVariableByName( "InitialTexture" )->AsShaderResource();
; 327  : 	mPostProcessMapVar = mPPEffect->GetVariableByName( "BloodTexture" )->AsShaderResource();
; 328  : 
; 329  : 	mdxPPTintColour = mPPEffect->GetVariableByName( "TintColour" )->AsVector();
; 330  : 
; 331  : 	mdxPPShock = mPPEffect->GetVariableByName( "Shock" )->AsScalar();
; 332  : 
; 333  : 	mPPEffect->GetVariableByName( "PixelX" )->AsScalar()->SetFloat(1.0f/mViewportWidth);
; 334  : 	mPPEffect->GetVariableByName( "PixelY" )->AsScalar()->SetFloat(1.0f/mViewportHeight);
; 335  : 
; 336  : 	mdxBlurRadius = mPPEffect->GetVariableByName( "BlurRange" )->AsScalar();
; 337  : 
; 338  : 	mdxDoubleVisionRadius = mPPEffect->GetVariableByName( "DVRange" )->AsScalar();
; 339  : 
; 340  : 	mdxContrastFactor = mPPEffect->GetVariableByName( "Contrast" )->AsScalar();
; 341  : 
; 342  : 	mdxBlood = mPPEffect->GetVariableByName( "Blood" )->AsScalar();
; 343  : 
; 344  : 	mdxSolariseFloat = mPPEffect->GetVariableByName("SolariseThreshold")->AsScalar();
; 345  : 
; 346  : 	return true;
; 347  : 
; 348  : }
; 349  : // Update the scene - move/rotate each model and the camera, then update their matrices
; 350  : void CScene::UpdateScene( float frameTime )
; 351  : {
; 352  : 	//Show Framerate
; 353  : 	char caption[100];
; 354  : 	char buffer[6];
; 355  : 	
; 356  : 	//copy in base text
; 357  : 	strcpy_s( caption,  "Post Processing - FPS ");
; 358  : 	
; 359  : 	//calculate FPS
; 360  : 	int FPS = int ( 1.0f / frameTime );
; 361  : 	
; 362  : 	//convert to string in base 10 and add to caption
; 363  : 	_itoa_s( FPS,buffer,10 );
; 364  : 	strcat_s( caption, buffer );
; 365  : 	
; 366  : 	//add in object and light counts as above
; 367  : 	strcat_s( caption, " O: " );
; 368  : 	_itoa_s( miNumObjects, buffer, 10 );
; 369  : 	strcat_s( caption, buffer );
; 370  : 
; 371  : 	strcat_s( caption, " L: " );
; 372  : 	_itoa_s( miNumLights, buffer, 10 );
; 373  : 	strcat_s( caption, buffer );
; 374  : 
; 375  : 	//pass the new caption to the window
; 376  : 	SetWindowTextA( HWnd, caption );
; 377  : 
; 378  : 	// Control camera position and update its matrices (view matrix, projection matrix) each frame
; 379  : 	// Don't be deceived into thinking that this is a new method to control models - the same code we used previously is in the camera class
; 380  : 	Camera->Control( frameTime, Key_Up, Key_Down, Key_Left, Key_Right, Key_W, Key_S, Key_A, Key_D );
; 381  : 	Camera->UpdateMatrices();
; 382  : 	
; 383  : 	// Control cube position and update its world matrix each frame
; 384  : 	mpObjects[mControlObject]->GetModel()->Control( frameTime, Key_I, Key_K, Key_J, Key_L, Key_U, Key_O, Key_Period, Key_Comma );
; 385  : 
; 386  : 	if (impact)
; 387  : 	{
; 388  : 		UpdateImpact(frameTime);
; 389  : 	}
; 390  : 	else
; 391  : 	{
; 392  : 		mCumulativeFTime += frameTime;
; 393  : 
; 394  : 		//Tint colour cycle
; 395  : 		float hue = fmodf(mCumulativeFTime, mTintCycleTime) / mTintCycleTime;
; 396  : 		fHSLToRGB(hue, 0.5f, 0.5f, mTintColour.x, mTintColour.y, mTintColour.z);
; 397  : 
; 398  : 		//Shock update
; 399  : 		if (mShockTime > 0)
; 400  : 		{
; 401  : 			mShockTime -= frameTime;
; 402  : 			mShock = sin(mShockSpeed * mShockTime);
; 403  : 			mShock -= 0.5f;
; 404  : 			mShock *= mShockStrength;
; 405  : 		}
; 406  : 		else
; 407  : 		{
; 408  : 			mShock = 0;
; 409  : 		}
; 410  : 
; 411  : 		//Calculate contrast factor
; 412  : 		mContrastFactor = (259 * (mContrastChange + 255.0f)) / (255.0f * (259.0f - mContrastChange));
; 413  : 
; 414  : 		mSolariseFloat = mSolariseInt / 255.0f;
; 415  : 
; 416  : 	}//end if impact
; 417  : 
; 418  : 	//update all the objects, including calculating the matrix
; 419  : 	for(int i = 0; i < miNumObjects; i++)
; 420  : 	{
; 421  : 		mpObjects[i]->Update(frameTime);
; 422  : 	}
; 423  : 
; 424  : 	//same for the lights
; 425  : 	for(int i = 0; i < miNumLights; i++)
; 426  : 	{
; 427  : 		mpLights[i]->Update(frameTime);
; 428  : 	}
; 429  : 
; 430  : 
; 431  : 	// Allow user to quit with escape key
; 432  : 	if (KeyHit( Key_Escape )) 
; 433  : 	{
; 434  : 		DestroyWindow( HWnd );
; 435  : 	}
; 436  : 
; 437  : 	if( KeyHit( Key_F1  ) ) { mCurrentPP = 0; }
; 438  : 	if( KeyHit( Key_F2  ) ) { mCurrentPP = 1; }
; 439  : 	if( KeyHit( Key_F3  ) ) { mCurrentPP = 2;ResetShock();}
; 440  : 	if( KeyHit( Key_F4  ) ) { mCurrentPP = 3; }
; 441  : 	if( KeyHit( Key_F5  ) ) { mCurrentPP = 4; }
; 442  : 	if( KeyHit( Key_F6  ) ) { mCurrentPP = 5; }
; 443  : 	if( KeyHit( Key_F7  ) ) { mCurrentPP = 6; }
; 444  : 	if( KeyHit( Key_F8  ) ) { mCurrentPP = 7; }
; 445  : 	if( KeyHit( Key_F9  ) ) { mCurrentPP = 8; }
; 446  : 	if( KeyHit( Key_F10 ) ) { mCurrentPP = 9; }
; 447  : 	if( KeyHit( Key_F11 ) ) { mCurrentPP = 10; }
; 448  : 	if( KeyHit( Key_F12 ) ) { mCurrentPP = 11; }
; 449  : 
; 450  : 	//change the controlled object
; 451  : 	if( KeyHit( Key_1 ) )
; 452  : 	{
; 453  : 		mControlObject = 0;
; 454  : 	}
; 455  : 
; 456  : 	if( KeyHit( Key_2 ) )
; 457  : 	{
; 458  : 		mControlObject = 1;
; 459  : 	}
; 460  : 
; 461  : 	if( KeyHit( Key_3 ) )
; 462  : 	{
; 463  : 		mControlObject = 2;
; 464  : 	}
; 465  : 
; 466  : 	if( KeyHit( Key_4 ) )
; 467  : 	{
; 468  : 		mControlObject = 3;
; 469  : 	}
; 470  : 
; 471  : 	if( KeyHit( Key_5 ) )
; 472  : 	{
; 473  : 		mControlObject = 4;
; 474  : 	}
; 475  : 
; 476  : 	if( KeyHit( Key_6 ) )
; 477  : 	{
; 478  : 		mControlObject = 5;
; 479  : 	}
; 480  : 
; 481  : 	if( KeyHit( Key_7 ) )
; 482  : 	{
; 483  : 		mControlObject = 6;
; 484  : 	}
; 485  : 
; 486  : 	if( KeyHit( Key_8 ) )
; 487  : 	{
; 488  : 		mControlObject = 7;
; 489  : 	}
; 490  : 
; 491  : 	if( KeyHit( Key_9 ) )
; 492  : 	{
; 493  : 		mControlObject = 8;
; 494  : 	}
; 495  : 
; 496  : 	if( KeyHit( Key_0 ) )
; 497  : 	{
; 498  : 		mControlObject = 9;
; 499  : 	}
; 500  : 
; 501  : 	if( KeyHit ( Key_Minus ) )
; 502  : 	{
; 503  : 		if ( mControlObject == 0 )
; 504  : 		{
; 505  : 			mControlObject = miNumObjects-1;
; 506  : 		}
; 507  : 		else
; 508  : 		{
; 509  : 			mControlObject--;
; 510  : 		}
; 511  : 	}
; 512  : 
; 513  : 	if( KeyHit ( Key_Plus ) )
; 514  : 	{
; 515  : 		if ( mControlObject == miNumObjects-1 )
; 516  : 		{
; 517  : 			mControlObject = 0;
; 518  : 		}
; 519  : 		else
; 520  : 		{
; 521  : 			mControlObject++;
; 522  : 		}
; 523  : 	}
; 524  : }
; 525  : 
; 526  : //function to pass data to the shaders and render the object.
; 527  : void CScene::DrawObject(int i, bool mirror)
; 528  : {
; 529  : 	//first the wiggle value
; 530  : 	float wiggle =  mpObjects[i]->GetWiggle();
; 531  : 	dxWiggle->SetRawValue( &wiggle, 0, 4);
; 532  : 
; 533  : 	//outline thickness
; 534  : 	float thickness = mpObjects[i]->GetOutlineThickness();
; 535  : 	dxOutlineThickness->SetRawValue( &thickness, 0, 4);
; 536  : 
; 537  : 	//pass the matrix
; 538  : 	WorldMatrixVar->SetMatrix( (float*)mpObjects[i]->GetModel()->GetWorldMatrix() );
; 539  : 	
; 540  : 	//pass the textures and maps, if there are any. 
; 541  : 	if( mpObjects[i]->GetTexture() != nullptr )
; 542  : 	{
; 543  : 		DiffuseMapVar->SetResource( mpObjects[i]->GetTexture() );
; 544  : 	}
; 545  : 	if( mpObjects[i]->GetNormalMap() != nullptr )
; 546  : 	{
; 547  : 		NormalMapVar->SetResource( mpObjects[i]->GetNormalMap() );
; 548  : 	}
; 549  : 
; 550  : 	//pass the model colour - used for untextured models, texture colour change and outline colour in cell shading
; 551  : 	ModelColourVar->SetRawValue( mpObjects[i]->GetColourV(), 0, 12 );
; 552  : 	
; 553  : 	//if the object is lit, pass over the 12 closest lights. 
; 554  : 	if( mpObjects[i]->IsLit() )
; 555  : 	{
; 556  : 		SetLights( mpObjects[i]->GetModel()->GetPosition(), mpLights, miNumLights);
; 557  : 	}
; 558  : 
; 559  : 	// choose how to render the model based on where we are rendering it. 
; 560  : 	if( mirror )
; 561  : 	{
; 562  : 		mpObjects[i]->RenderMirror();
; 563  : 	}
; 564  : 	else
; 565  : 	{
; 566  : 		mpObjects[i]->Render();
; 567  : 		
; 568  : 	}
; 569  : }
; 570  : 
; 571  : // function to render everything in the scene
; 572  : void CScene::DrawAllObjects(bool mirror)
; 573  : {
; 574  : 	//
; 575  : 	// Solid objects
; 576  : 	//
; 577  : 	//start rendering AFTER the mirror.
; 578  : 	for(int i = 1; i < miNumObjects; i++)
; 579  : 	{
; 580  : 		if( !mpObjects[i]->IsTransparent() )
; 581  : 		{
; 582  : 			DrawObject(i, mirror);
; 583  : 		}
; 584  : 	}
; 585  : 
; 586  : 	//
; 587  : 	// Light objects
; 588  : 	//
; 589  : 
; 590  : 
; 591  : 	for(int i = 0; i < miNumLights; i++)
; 592  : 	{
; 593  : 		WorldMatrixVar->SetMatrix( (float*)mpLights[i]->GetModel()->GetWorldMatrix() );
; 594  : 		D3DXVECTOR3 mColour =  mpLights[i]->GetColourV();
; 595  : 		ModelColourVar->SetRawValue(mColour, 0, 12 );
; 596  : 		if( mirror )
; 597  : 		{
; 598  : 			mpLights[i]->GetModel()->Render( mTechniquesMirror[0] );
; 599  : 		}
; 600  : 		else
; 601  : 		{
; 602  : 			mpLights[i]->GetModel()->Render( mTechniques[0] );
; 603  : 		}
; 604  : 	}
; 605  : 
; 606  : 	//
; 607  : 	// Transparent objects
; 608  : 	//
; 609  : 
; 610  : 	for(int i = 1; i < miNumObjects; i++)
; 611  : 	{
; 612  : 		if( mpObjects[i]->IsTransparent() )
; 613  : 		{
; 614  : 			DrawObject(i, mirror);
; 615  : 		}
; 616  : 	}
; 617  : }
; 618  : 
; 619  : // Render everything in the scene
; 620  : void CScene::RenderScene()
; 621  : {
; 622  : 	//set render target to a texture for post processing
; 623  : 	mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);
; 624  : 	mpd3dDevice->ClearRenderTargetView(mInitialRenderTarget, AmbientColour);
; 625  : 	mpd3dDevice->ClearDepthStencilView(DepthStencilView, D3D10_CLEAR_DEPTH | D3D10_CLEAR_STENCIL, 1.0f, 0); // Clear the depth buffer too
; 626  : 
; 627  : 	mpd3dDevice->OMSetRenderTargets( 1, &mInitialRenderTarget, DepthStencilView);
; 628  : 
; 629  : 	// Clear the back buffer - before drawing the geometry clear the entire window to a fixed colour
; 630  : 	//float ClearColor[4] = { 0.2f, 0.2f, 0.3f, 1.0f }; // Good idea to match background to ambient colour
; 631  : 	mpd3dDevice->ClearRenderTargetView( mInitialRenderTarget, AmbientColour );
; 632  : 	mpd3dDevice->ClearDepthStencilView( DepthStencilView, D3D10_CLEAR_DEPTH | D3D10_CLEAR_STENCIL , 1.0f, 0 ); // Clear the depth buffer too
; 633  : 
; 634  : 	//---------------------------
; 635  : 	// Common rendering settings
; 636  : 
; 637  : 	// Common features for all models, set these once only
; 638  : 
; 639  : 	// Pass the camera's matrices to the vertex shader
; 640  : 	ViewMatrixVar->SetMatrix( (float*)&Camera->GetViewMatrix() );
; 641  : 	ProjMatrixVar->SetMatrix( (float*)&Camera->GetProjectionMatrix() );
; 642  : 
; 643  : 	//pass the camera position
; 644  : 	dxCameraPos->SetRawValue( D3DXVECTOR3( Camera->GetPosition()), 0, 12);
; 645  : 
; 646  : 	//pass the lighting colours
; 647  : 	dxAmbientColour->SetRawValue( AmbientColour, 0, 12  );
; 648  : 
; 649  : 	//---------------------------
; 650  : 	// Render each model
; 651  : 	
; 652  : 	RenderMirrors();
; 653  : 	DrawAllObjects(false);
; 654  : 
; 655  : 	/////////////////////////////
; 656  : 	// POST PROCESS PASS
; 657  : 	/////////////////////////////
; 658  : 	
; 659  : 	//Pass the tint colour
; 660  : 	mdxPPTintColour->SetRawValue( mTintColour, 0, 12 );
; 661  : 
; 662  : 	//Pass the shock value
; 663  : 	mdxPPShock->SetRawValue( &mShock, 0, 4 );
; 664  : 
; 665  : 	//Pass the blur radius
; 666  : 	mdxBlurRadius->SetRawValue( &mBlurRadius, 0, 4 );
; 667  : 
; 668  : 	//Pass the double vision radius
; 669  : 	mdxDoubleVisionRadius->SetRawValue( &mDoubleVisionRadius, 0, 4 );
; 670  : 
; 671  : 	//Pass the contrast factor
; 672  : 	mdxContrastFactor->SetRawValue(&mContrastFactor, 0, 4);
; 673  : 
; 674  : 	//Only one person would dare give me the raspberry....LONESTAR!!
; 675  : 	mdxBlood->SetRawValue(&mBlood, 0, 4);
; 676  : 	mPostProcessMapVar->SetResource(mpMaps[15]);
; 677  : 
; 678  : 	mdxSolariseFloat->SetRawValue(&mSolariseFloat, 0, 4);
; 679  : 
; 680  : 	if(mCurrentPP < 0) mCurrentPP = 0;
; 681  : 	if(mCurrentPP > NumPostProcesses ) mCurrentPP = 0;
; 682  : 
; 683  : 	if (impact)
; 684  : 	{
; 685  : 		RenderImpact();
; 686  : 	}
; 687  : 	else
; 688  : 	{
; 689  : 		if (mbGaussian)
; 690  : 		{
; 691  : 
; 692  : 		}
; 693  : 
; 694  : 		if (!multiprocess)
; 695  : 		{
; 696  : 			//Set render target back to output
; 697  : 			mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);
; 698  : 			//send rendered scene to shader as a texture
; 699  : 			mInitialTextureVar->SetResource(mInitialShaderResource);
; 700  : 
; 701  : 			//Apply Post Processing Effect
; 702  : 			mpd3dDevice->IASetInputLayout(NULL);
; 703  : 			mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
; 704  : 			mPPTechniques[mCurrentPP]->GetPassByIndex(0)->Apply(0);
; 705  : 
; 706  : 			mpd3dDevice->Draw(4, 0);
; 707  : 
; 708  : 			mInitialTextureVar->SetResource(0);
; 709  : 			mPPTechniques[mCurrentPP]->GetPassByIndex(0)->Apply(0);
; 710  : 		}
; 711  : 		else
; 712  : 		{
; 713  : 
; 714  : 			//Box Blur
; 715  : 			mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);
; 716  : 			mInitialTextureVar->SetResource(mInitialShaderResource);
; 717  : 			mpd3dDevice->IASetInputLayout(NULL);
; 718  : 			mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
; 719  : 			mPPTechniques[5]->GetPassByIndex(0)->Apply(0);
; 720  : 			mpd3dDevice->Draw(4, 0);
; 721  : 			mInitialTextureVar->SetResource(0);
; 722  : 			mPPTechniques[5]->GetPassByIndex(0)->Apply(0);
; 723  : 
; 724  : 			//Double Vision
; 725  : 			mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);
; 726  : 			mInitialTextureVar->SetResource(mTextureOneShader);
; 727  : 			mpd3dDevice->IASetInputLayout(NULL);
; 728  : 			mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
; 729  : 			mPPTechniques[6]->GetPassByIndex(0)->Apply(0);
; 730  : 			mpd3dDevice->Draw(4, 0);
; 731  : 			mInitialTextureVar->SetResource(0);
; 732  : 			mPPTechniques[6]->GetPassByIndex(0)->Apply(0);
; 733  : 
; 734  : 			//Copy to Output
; 735  : 			/*mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);
; 736  : 			mInitialTextureVar->SetResource(mTextureTwoShader);
; 737  : 			mpd3dDevice->IASetInputLayout(NULL);
; 738  : 			mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
; 739  : 			mPPTechniques[0]->GetPassByIndex(0)->Apply(0);
; 740  : 			mpd3dDevice->Draw(4, 0);
; 741  : 			mInitialTextureVar->SetResource(0);
; 742  : 			mPPTechniques[0]->GetPassByIndex(0)->Apply(0);
; 743  : 			*/
; 744  : 		}
; 745  : 	}//end else impact
; 746  : 	//---------------------------
; 747  : 	// Display the Scene
; 748  : 
; 749  : 	// After we've finished drawing to the off-screen back buffer, we "present" it to the front buffer (the screen)
; 750  : 	TwDraw();
; 751  : 	SwapChain->Present( 0, 0 );
; 752  : }
; 753  : 
; 754  : void CScene::StartImpact()
; 755  : {
; 756  : 	if (!impact)

	mov	ecx, DWORD PTR _clientData$[ebp]
	cmp	BYTE PTR [ecx+3084], 0
	jne	SHORT $LN3@TWImpact

; 757  : 	{
; 758  : 		impact = true;
; 759  : 		mShockTime = mShockLength;

	mov	eax, DWORD PTR [ecx+2976]
	mov	BYTE PTR [ecx+3084], 1
	mov	DWORD PTR [ecx+2968], eax
$LN3@TWImpact:

; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }

	pop	ebp
	ret	4
?TWImpact@@YGXPAX@Z ENDP				; TWImpact
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetGauss@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetGauss@@YGXPAX@Z PROC				; SetGauss, COMDAT

; 187  : {

	push	ebp
	mov	ebp, esp

; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;

	mov	ecx, DWORD PTR _clientData$[ebp]
	cmp	BYTE PTR [ecx+3185], 0
	sete	al
	mov	BYTE PTR [ecx+3185], al

; 190  : }

	pop	ebp
	ret	4
?SetGauss@@YGXPAX@Z ENDP				; SetGauss
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP12@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP12@@YGXPAX@Z PROC					; SetPP12, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp

; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 12		; 0000000cH

; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }

	pop	ebp
	ret	4
?SetPP12@@YGXPAX@Z ENDP					; SetPP12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP11@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP11@@YGXPAX@Z PROC					; SetPP11, COMDAT

; 175  : {

	push	ebp
	mov	ebp, esp

; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 11		; 0000000bH

; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }

	pop	ebp
	ret	4
?SetPP11@@YGXPAX@Z ENDP					; SetPP11
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP10@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP10@@YGXPAX@Z PROC					; SetPP10, COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp

; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 10		; 0000000aH

; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }

	pop	ebp
	ret	4
?SetPP10@@YGXPAX@Z ENDP					; SetPP10
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP09@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP09@@YGXPAX@Z PROC					; SetPP09, COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 9

; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }

	pop	ebp
	ret	4
?SetPP09@@YGXPAX@Z ENDP					; SetPP09
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP08@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP08@@YGXPAX@Z PROC					; SetPP08, COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp

; 161  : 
; 162  : void TW_CALL SetPP09(void* clientData)
; 163  : {
; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }
; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 8

; 158  : 	CScene* temp = static_cast<CScene*>(clientData);
; 159  : 	temp->SetSinglePP( 8 );
; 160  : }

	pop	ebp
	ret	4
?SetPP08@@YGXPAX@Z ENDP					; SetPP08
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP07@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP07@@YGXPAX@Z PROC					; SetPP07, COMDAT

; 151  : {

	push	ebp
	mov	ebp, esp

; 155  : 
; 156  : void TW_CALL SetPP08(void* clientData)
; 157  : {
; 158  : 	CScene* temp = static_cast<CScene*>(clientData);
; 159  : 	temp->SetSinglePP( 8 );
; 160  : }
; 161  : 
; 162  : void TW_CALL SetPP09(void* clientData)
; 163  : {
; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }
; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 7

; 152  : 	CScene* temp = static_cast<CScene*>(clientData);
; 153  : 	temp->SetSinglePP( 7 );
; 154  : }

	pop	ebp
	ret	4
?SetPP07@@YGXPAX@Z ENDP					; SetPP07
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP06@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP06@@YGXPAX@Z PROC					; SetPP06, COMDAT

; 145  : {

	push	ebp
	mov	ebp, esp

; 149  : 
; 150  : void TW_CALL SetPP07(void* clientData)
; 151  : {
; 152  : 	CScene* temp = static_cast<CScene*>(clientData);
; 153  : 	temp->SetSinglePP( 7 );
; 154  : }
; 155  : 
; 156  : void TW_CALL SetPP08(void* clientData)
; 157  : {
; 158  : 	CScene* temp = static_cast<CScene*>(clientData);
; 159  : 	temp->SetSinglePP( 8 );
; 160  : }
; 161  : 
; 162  : void TW_CALL SetPP09(void* clientData)
; 163  : {
; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }
; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 6

; 146  : 	CScene* temp = static_cast<CScene*>(clientData);
; 147  : 	temp->SetSinglePP( 6 );
; 148  : }

	pop	ebp
	ret	4
?SetPP06@@YGXPAX@Z ENDP					; SetPP06
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP05@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP05@@YGXPAX@Z PROC					; SetPP05, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp

; 143  : 
; 144  : void TW_CALL SetPP06(void* clientData)
; 145  : {
; 146  : 	CScene* temp = static_cast<CScene*>(clientData);
; 147  : 	temp->SetSinglePP( 6 );
; 148  : }
; 149  : 
; 150  : void TW_CALL SetPP07(void* clientData)
; 151  : {
; 152  : 	CScene* temp = static_cast<CScene*>(clientData);
; 153  : 	temp->SetSinglePP( 7 );
; 154  : }
; 155  : 
; 156  : void TW_CALL SetPP08(void* clientData)
; 157  : {
; 158  : 	CScene* temp = static_cast<CScene*>(clientData);
; 159  : 	temp->SetSinglePP( 8 );
; 160  : }
; 161  : 
; 162  : void TW_CALL SetPP09(void* clientData)
; 163  : {
; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }
; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 5

; 140  : 	CScene* temp = static_cast<CScene*>(clientData);
; 141  : 	temp->SetSinglePP( 5 );
; 142  : }

	pop	ebp
	ret	4
?SetPP05@@YGXPAX@Z ENDP					; SetPP05
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP04@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP04@@YGXPAX@Z PROC					; SetPP04, COMDAT

; 133  : {

	push	ebp
	mov	ebp, esp

; 137  : 
; 138  : void TW_CALL SetPP05(void* clientData)
; 139  : {
; 140  : 	CScene* temp = static_cast<CScene*>(clientData);
; 141  : 	temp->SetSinglePP( 5 );
; 142  : }
; 143  : 
; 144  : void TW_CALL SetPP06(void* clientData)
; 145  : {
; 146  : 	CScene* temp = static_cast<CScene*>(clientData);
; 147  : 	temp->SetSinglePP( 6 );
; 148  : }
; 149  : 
; 150  : void TW_CALL SetPP07(void* clientData)
; 151  : {
; 152  : 	CScene* temp = static_cast<CScene*>(clientData);
; 153  : 	temp->SetSinglePP( 7 );
; 154  : }
; 155  : 
; 156  : void TW_CALL SetPP08(void* clientData)
; 157  : {
; 158  : 	CScene* temp = static_cast<CScene*>(clientData);
; 159  : 	temp->SetSinglePP( 8 );
; 160  : }
; 161  : 
; 162  : void TW_CALL SetPP09(void* clientData)
; 163  : {
; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }
; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 4

; 134  : 	CScene* temp = static_cast<CScene*>(clientData);
; 135  : 	temp->SetSinglePP( 4 );
; 136  : }

	pop	ebp
	ret	4
?SetPP04@@YGXPAX@Z ENDP					; SetPP04
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP03@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP03@@YGXPAX@Z PROC					; SetPP03, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp

; 131  : 
; 132  : void TW_CALL SetPP04(void* clientData)
; 133  : {
; 134  : 	CScene* temp = static_cast<CScene*>(clientData);
; 135  : 	temp->SetSinglePP( 4 );
; 136  : }
; 137  : 
; 138  : void TW_CALL SetPP05(void* clientData)
; 139  : {
; 140  : 	CScene* temp = static_cast<CScene*>(clientData);
; 141  : 	temp->SetSinglePP( 5 );
; 142  : }
; 143  : 
; 144  : void TW_CALL SetPP06(void* clientData)
; 145  : {
; 146  : 	CScene* temp = static_cast<CScene*>(clientData);
; 147  : 	temp->SetSinglePP( 6 );
; 148  : }
; 149  : 
; 150  : void TW_CALL SetPP07(void* clientData)
; 151  : {
; 152  : 	CScene* temp = static_cast<CScene*>(clientData);
; 153  : 	temp->SetSinglePP( 7 );
; 154  : }
; 155  : 
; 156  : void TW_CALL SetPP08(void* clientData)
; 157  : {
; 158  : 	CScene* temp = static_cast<CScene*>(clientData);
; 159  : 	temp->SetSinglePP( 8 );
; 160  : }
; 161  : 
; 162  : void TW_CALL SetPP09(void* clientData)
; 163  : {
; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }
; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 3

; 128  : 	CScene* temp = static_cast<CScene*>(clientData);
; 129  : 	temp->SetSinglePP( 3 );
; 130  : }

	pop	ebp
	ret	4
?SetPP03@@YGXPAX@Z ENDP					; SetPP03
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP02@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP02@@YGXPAX@Z PROC					; SetPP02, COMDAT

; 120  : {

	push	ebp
	mov	ebp, esp

; 125  : 
; 126  : void TW_CALL SetPP03(void* clientData)
; 127  : {
; 128  : 	CScene* temp = static_cast<CScene*>(clientData);
; 129  : 	temp->SetSinglePP( 3 );
; 130  : }
; 131  : 
; 132  : void TW_CALL SetPP04(void* clientData)
; 133  : {
; 134  : 	CScene* temp = static_cast<CScene*>(clientData);
; 135  : 	temp->SetSinglePP( 4 );
; 136  : }
; 137  : 
; 138  : void TW_CALL SetPP05(void* clientData)
; 139  : {
; 140  : 	CScene* temp = static_cast<CScene*>(clientData);
; 141  : 	temp->SetSinglePP( 5 );
; 142  : }
; 143  : 
; 144  : void TW_CALL SetPP06(void* clientData)
; 145  : {
; 146  : 	CScene* temp = static_cast<CScene*>(clientData);
; 147  : 	temp->SetSinglePP( 6 );
; 148  : }
; 149  : 
; 150  : void TW_CALL SetPP07(void* clientData)
; 151  : {
; 152  : 	CScene* temp = static_cast<CScene*>(clientData);
; 153  : 	temp->SetSinglePP( 7 );
; 154  : }
; 155  : 
; 156  : void TW_CALL SetPP08(void* clientData)
; 157  : {
; 158  : 	CScene* temp = static_cast<CScene*>(clientData);
; 159  : 	temp->SetSinglePP( 8 );
; 160  : }
; 161  : 
; 162  : void TW_CALL SetPP09(void* clientData)
; 163  : {
; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }
; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	ecx, DWORD PTR _clientData$[ebp]

; 213  : }
; 214  : 
; 215  : void CScene::ResetShock()
; 216  : {
; 217  : 	mShockTime = mShockLength;	

	mov	eax, DWORD PTR [ecx+2976]

; 125  : 
; 126  : void TW_CALL SetPP03(void* clientData)
; 127  : {
; 128  : 	CScene* temp = static_cast<CScene*>(clientData);
; 129  : 	temp->SetSinglePP( 3 );
; 130  : }
; 131  : 
; 132  : void TW_CALL SetPP04(void* clientData)
; 133  : {
; 134  : 	CScene* temp = static_cast<CScene*>(clientData);
; 135  : 	temp->SetSinglePP( 4 );
; 136  : }
; 137  : 
; 138  : void TW_CALL SetPP05(void* clientData)
; 139  : {
; 140  : 	CScene* temp = static_cast<CScene*>(clientData);
; 141  : 	temp->SetSinglePP( 5 );
; 142  : }
; 143  : 
; 144  : void TW_CALL SetPP06(void* clientData)
; 145  : {
; 146  : 	CScene* temp = static_cast<CScene*>(clientData);
; 147  : 	temp->SetSinglePP( 6 );
; 148  : }
; 149  : 
; 150  : void TW_CALL SetPP07(void* clientData)
; 151  : {
; 152  : 	CScene* temp = static_cast<CScene*>(clientData);
; 153  : 	temp->SetSinglePP( 7 );
; 154  : }
; 155  : 
; 156  : void TW_CALL SetPP08(void* clientData)
; 157  : {
; 158  : 	CScene* temp = static_cast<CScene*>(clientData);
; 159  : 	temp->SetSinglePP( 8 );
; 160  : }
; 161  : 
; 162  : void TW_CALL SetPP09(void* clientData)
; 163  : {
; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }
; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	DWORD PTR [ecx+3040], 2

; 213  : }
; 214  : 
; 215  : void CScene::ResetShock()
; 216  : {
; 217  : 	mShockTime = mShockLength;	

	mov	DWORD PTR [ecx+2968], eax

; 121  : 	CScene* temp = static_cast<CScene*>(clientData);
; 122  : 	temp->SetSinglePP( 2 );
; 123  : 	temp->ResetShock();
; 124  : }

	pop	ebp
	ret	4
?SetPP02@@YGXPAX@Z ENDP					; SetPP02
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP01@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP01@@YGXPAX@Z PROC					; SetPP01, COMDAT

; 114  : {

	push	ebp
	mov	ebp, esp

; 118  : 
; 119  : void TW_CALL SetPP02(void* clientData)
; 120  : {
; 121  : 	CScene* temp = static_cast<CScene*>(clientData);
; 122  : 	temp->SetSinglePP( 2 );
; 123  : 	temp->ResetShock();
; 124  : }
; 125  : 
; 126  : void TW_CALL SetPP03(void* clientData)
; 127  : {
; 128  : 	CScene* temp = static_cast<CScene*>(clientData);
; 129  : 	temp->SetSinglePP( 3 );
; 130  : }
; 131  : 
; 132  : void TW_CALL SetPP04(void* clientData)
; 133  : {
; 134  : 	CScene* temp = static_cast<CScene*>(clientData);
; 135  : 	temp->SetSinglePP( 4 );
; 136  : }
; 137  : 
; 138  : void TW_CALL SetPP05(void* clientData)
; 139  : {
; 140  : 	CScene* temp = static_cast<CScene*>(clientData);
; 141  : 	temp->SetSinglePP( 5 );
; 142  : }
; 143  : 
; 144  : void TW_CALL SetPP06(void* clientData)
; 145  : {
; 146  : 	CScene* temp = static_cast<CScene*>(clientData);
; 147  : 	temp->SetSinglePP( 6 );
; 148  : }
; 149  : 
; 150  : void TW_CALL SetPP07(void* clientData)
; 151  : {
; 152  : 	CScene* temp = static_cast<CScene*>(clientData);
; 153  : 	temp->SetSinglePP( 7 );
; 154  : }
; 155  : 
; 156  : void TW_CALL SetPP08(void* clientData)
; 157  : {
; 158  : 	CScene* temp = static_cast<CScene*>(clientData);
; 159  : 	temp->SetSinglePP( 8 );
; 160  : }
; 161  : 
; 162  : void TW_CALL SetPP09(void* clientData)
; 163  : {
; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }
; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 1

; 115  : 	CScene* temp = static_cast<CScene*>(clientData);
; 116  : 	temp->SetSinglePP( 1 );
; 117  : }

	pop	ebp
	ret	4
?SetPP01@@YGXPAX@Z ENDP					; SetPP01
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetPP00@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?SetPP00@@YGXPAX@Z PROC					; SetPP00, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp

; 112  : 
; 113  : void TW_CALL SetPP01(void* clientData)
; 114  : {
; 115  : 	CScene* temp = static_cast<CScene*>(clientData);
; 116  : 	temp->SetSinglePP( 1 );
; 117  : }
; 118  : 
; 119  : void TW_CALL SetPP02(void* clientData)
; 120  : {
; 121  : 	CScene* temp = static_cast<CScene*>(clientData);
; 122  : 	temp->SetSinglePP( 2 );
; 123  : 	temp->ResetShock();
; 124  : }
; 125  : 
; 126  : void TW_CALL SetPP03(void* clientData)
; 127  : {
; 128  : 	CScene* temp = static_cast<CScene*>(clientData);
; 129  : 	temp->SetSinglePP( 3 );
; 130  : }
; 131  : 
; 132  : void TW_CALL SetPP04(void* clientData)
; 133  : {
; 134  : 	CScene* temp = static_cast<CScene*>(clientData);
; 135  : 	temp->SetSinglePP( 4 );
; 136  : }
; 137  : 
; 138  : void TW_CALL SetPP05(void* clientData)
; 139  : {
; 140  : 	CScene* temp = static_cast<CScene*>(clientData);
; 141  : 	temp->SetSinglePP( 5 );
; 142  : }
; 143  : 
; 144  : void TW_CALL SetPP06(void* clientData)
; 145  : {
; 146  : 	CScene* temp = static_cast<CScene*>(clientData);
; 147  : 	temp->SetSinglePP( 6 );
; 148  : }
; 149  : 
; 150  : void TW_CALL SetPP07(void* clientData)
; 151  : {
; 152  : 	CScene* temp = static_cast<CScene*>(clientData);
; 153  : 	temp->SetSinglePP( 7 );
; 154  : }
; 155  : 
; 156  : void TW_CALL SetPP08(void* clientData)
; 157  : {
; 158  : 	CScene* temp = static_cast<CScene*>(clientData);
; 159  : 	temp->SetSinglePP( 8 );
; 160  : }
; 161  : 
; 162  : void TW_CALL SetPP09(void* clientData)
; 163  : {
; 164  : 	CScene* temp = static_cast<CScene*>(clientData);
; 165  : 	temp->SetSinglePP( 9 );
; 166  : }
; 167  : 
; 168  : void TW_CALL SetPP10(void* clientData)
; 169  : {
; 170  : 	CScene* temp = static_cast<CScene*>(clientData);
; 171  : 	temp->SetSinglePP( 10 );
; 172  : }
; 173  : 
; 174  : void TW_CALL SetPP11(void* clientData)
; 175  : {
; 176  : 	CScene* temp = static_cast<CScene*>(clientData);
; 177  : 	temp->SetSinglePP( 11 );
; 178  : }
; 179  : 
; 180  : void TW_CALL SetPP12(void* clientData)
; 181  : {
; 182  : 	CScene* temp = static_cast<CScene*>(clientData);
; 183  : 	temp->SetSinglePP( 12 );
; 184  : }
; 185  : 
; 186  : void TW_CALL SetGauss(void* clientData)
; 187  : {
; 188  : 	CScene* temp = static_cast<CScene*>(clientData);
; 189  : 	temp->mbGaussian = !temp->mbGaussian;
; 190  : }
; 191  : 
; 192  : void TW_CALL TWImpact(void* clientData)
; 193  : {
; 194  : 	CScene* temp = static_cast<CScene*>(clientData);
; 195  : 	temp->StartImpact();
; 196  : }
; 197  : 
; 198  : void CScene::SetSinglePP(int index)
; 199  : {
; 200  : 	if(index < 0)
; 201  : 	{
; 202  : 		mCurrentPP = 0;
; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)
; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;

	mov	eax, DWORD PTR _clientData$[ebp]
	mov	DWORD PTR [eax+3040], 0

; 109  : 	CScene* temp = static_cast<CScene*>(clientData);
; 110  : 	temp->SetSinglePP( 0 );
; 111  : }

	pop	ebp
	ret	4
?SetPP00@@YGXPAX@Z ENDP					; SetPP00
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?ToggleSingle@@YGXPAX@Z
_TEXT	SEGMENT
_clientData$ = 8					; size = 4
?ToggleSingle@@YGXPAX@Z PROC				; ToggleSingle, COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  : 	CScene* temp = static_cast<CScene*>(clientData);
; 104  : 	temp->multiprocess = !temp->multiprocess;

	mov	ecx, DWORD PTR _clientData$[ebp]
	cmp	BYTE PTR [ecx+3184], 0
	sete	al
	mov	BYTE PTR [ecx+3184], al

; 105  : }

	pop	ebp
	ret	4
?ToggleSingle@@YGXPAX@Z ENDP				; ToggleSingle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z
_TEXT	SEGMENT
_wcex$ = -68						; size = 48
_rc$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_nCmdShow$ = 12						; size = 4
?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z PROC	; CScene::InitWindow, COMDAT
; _this$ = ecx

; 922  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	edi
	mov	edi, DWORD PTR _hInstance$[ebp]
	mov	ebx, ecx

; 923  : 	// Register class
; 924  : 	WNDCLASSEX wcex;
; 925  : 	wcex.cbSize = sizeof( WNDCLASSEX );
; 926  : 	wcex.style = CS_HREDRAW | CS_VREDRAW;
; 927  : 	wcex.lpfnWndProc = CScene::WndProc;
; 928  : 	wcex.cbClsExtra = 0;
; 929  : 	wcex.cbWndExtra = 0;
; 930  : 	wcex.hInstance = hInstance;
; 931  : 	wcex.hIcon = LoadIcon( hInstance, ( LPCTSTR )IDI_TUTORIAL1 );

	push	107					; 0000006bH
	push	edi
	mov	DWORD PTR _wcex$[ebp], 48		; 00000030H
	mov	DWORD PTR _wcex$[ebp+4], 3
	mov	DWORD PTR _wcex$[ebp+8], OFFSET ?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z ; CScene::WndProc
	mov	DWORD PTR _wcex$[ebp+12], 0
	mov	DWORD PTR _wcex$[ebp+16], 0
	mov	DWORD PTR _wcex$[ebp+20], edi
	call	DWORD PTR __imp__LoadIconW@8

; 932  : 	wcex.hCursor = LoadCursor( NULL, IDC_ARROW );

	push	32512					; 00007f00H
	push	0
	mov	DWORD PTR _wcex$[ebp+24], eax
	call	DWORD PTR __imp__LoadCursorW@8

; 933  : 	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
; 934  : 	wcex.lpszMenuName = NULL;
; 935  : 	wcex.lpszClassName = L"TutorialWindowClass";
; 936  : 	wcex.hIconSm = LoadIcon( wcex.hInstance, ( LPCTSTR )IDI_TUTORIAL1 );

	push	107					; 0000006bH
	push	DWORD PTR _wcex$[ebp+20]
	mov	DWORD PTR _wcex$[ebp+28], eax
	mov	DWORD PTR _wcex$[ebp+32], 6
	mov	DWORD PTR _wcex$[ebp+36], 0
	mov	DWORD PTR _wcex$[ebp+40], OFFSET ??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
	call	DWORD PTR __imp__LoadIconW@8
	mov	DWORD PTR _wcex$[ebp+44], eax

; 937  : 	if( !RegisterClassEx( &wcex ) )	return false;

	lea	eax, DWORD PTR _wcex$[ebp]
	push	eax
	call	DWORD PTR __imp__RegisterClassExW@4
	test	ax, ax
	jne	SHORT $LN2@InitWindow
$LN5@InitWindow:
	pop	edi
	xor	al, al
	pop	ebx

; 948  : 
; 949  : 	return true;
; 950  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@InitWindow:
	movdqa	xmm0, XMMWORD PTR __xmm@000003c0000007800000000000000000

; 938  : 
; 939  : 	// Create window
; 940  : 	HInst = hInstance;
; 941  : 	RECT rc = { 0, 0, 1920, 960 };
; 942  : 	AdjustWindowRect( &rc, WS_OVERLAPPEDWINDOW, FALSE );

	lea	eax, DWORD PTR _rc$[ebp]
	push	0
	push	13565952				; 00cf0000H
	push	eax
	mov	DWORD PTR [ebx+3164], edi
	movdqu	XMMWORD PTR _rc$[ebp], xmm0
	call	DWORD PTR __imp__AdjustWindowRect@12

; 943  : 	HWnd = CreateWindow( L"TutorialWindowClass", L"CO2409 - Graphics Assignment - Shaders", WS_OVERLAPPEDWINDOW,
; 944  : 	                     CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, NULL, NULL, hInstance, NULL );

	mov	eax, DWORD PTR _rc$[ebp+12]
	sub	eax, DWORD PTR _rc$[ebp+4]
	push	0
	push	edi
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR _rc$[ebp+8]
	sub	eax, DWORD PTR _rc$[ebp]
	push	eax
	push	-2147483648				; 80000000H
	push	-2147483648				; 80000000H
	push	13565952				; 00cf0000H
	push	OFFSET ??_C@_1EO@IKJJOGJD@?$AAC?$AAO?$AA2?$AA4?$AA0?$AA9?$AA?5?$AA?9?$AA?5?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AA?5?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?9?$AA?5?$AAS@
	push	OFFSET ??_C@_1CI@OKMLABGO@?$AAT?$AAu?$AAt?$AAo?$AAr?$AAi?$AAa?$AAl?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?$AA@
	push	0
	call	DWORD PTR __imp__CreateWindowExW@48
	mov	DWORD PTR [ebx+3168], eax

; 945  : 	if( !HWnd )	return false;

	test	eax, eax
	je	SHORT $LN5@InitWindow

; 946  : 
; 947  : 	ShowWindow( HWnd, nCmdShow );

	push	DWORD PTR _nCmdShow$[ebp]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 948  : 
; 949  : 	return true;
; 950  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	al, 1
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?InitWindow@CScene@@QAE_NPAUHINSTANCE__@@H@Z ENDP	; CScene::InitWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?RenderMirrors@CScene@@QAEXXZ
_TEXT	SEGMENT
_mirrorPlane$ = -432					; size = 16
_reflectCameraPos4$ = -416				; size = 16
_reflectMatrix$ = -400					; size = 64
_reflectViewMatrix$ = -336				; size = 64
$T1 = -272						; size = 64
_mirrorMatrix$ = -208					; size = 64
$T2 = -144						; size = 64
$T3 = -144						; size = 64
$T4 = -144						; size = 64
_cameraPos$ = -68					; size = 12
_reflectCameraPos$ = -56				; size = 12
_mirrorPoint$ = -44					; size = 12
_mirrorNormal$ = -32					; size = 12
$T5 = -20						; size = 16
$T6 = -16						; size = 12
$T7 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?RenderMirrors@CScene@@QAEXXZ PROC			; CScene::RenderMirrors, COMDAT
; _this$ = ecx

; 857  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, ecx

; 864  : 	WorldMatrixVar->SetMatrix( (float*)mirrorMatrix );

	lea	edx, DWORD PTR _mirrorMatrix$[ebp]
	push	edx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 100  : 		return m_WorldMatrix;

	movdqu	xmm0, XMMWORD PTR [eax+48]
	movdqu	XMMWORD PTR _mirrorMatrix$[ebp], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+64]
	movdqu	XMMWORD PTR _mirrorMatrix$[ebp+16], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+80]
	movdqu	XMMWORD PTR _mirrorMatrix$[ebp+32], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+96]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 864  : 	WorldMatrixVar->SetMatrix( (float*)mirrorMatrix );

	mov	eax, DWORD PTR [esi+3088]
	push	eax
; File c:\users\simon\documents\github\post-processing\model.h

; 100  : 		return m_WorldMatrix;

	movdqu	XMMWORD PTR _mirrorMatrix$[ebp+48], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 864  : 	WorldMatrixVar->SetMatrix( (float*)mirrorMatrix );

	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 865  : 	ModelColourVar->SetRawValue( mpObjects[0]->GetColourV(), 0, 12 );

	mov	eax, DWORD PTR [esi+8]
	lea	edx, DWORD PTR $T7[ebp]
	push	12					; 0000000cH
	push	0
	push	edx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 59   : 	D3DXVECTOR3 GetColourV(){ return D3DXVECTOR3( mr, mg, mb ); }

	movss	xmm1, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 865  : 	ModelColourVar->SetRawValue( mpObjects[0]->GetColourV(), 0, 12 );

	mov	eax, DWORD PTR [esi+3112]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	DWORD PTR $T7[ebp], xmm0

; 322  :     y = fy;

	movss	DWORD PTR $T7[ebp+4], xmm1

; 323  :     z = fz;

	movss	DWORD PTR $T7[ebp+8], xmm2
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 865  : 	ModelColourVar->SetRawValue( mpObjects[0]->GetColourV(), 0, 12 );

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+92]

; 866  : 	mpObjects[0]->Render();

	mov	ecx, DWORD PTR [esi+8]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 85   : 	void Render() { mModel->Render( mTechnique ); }

	push	DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [ecx]
	call	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z ; CModel::Render
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm0, DWORD PTR _mirrorMatrix$[ebp+48]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 877  : 	D3DXPlaneFromPointNormal( &mirrorPlane, &mirrorPoint, &mirrorNormal );

	lea	eax, DWORD PTR _mirrorNormal$[ebp]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	DWORD PTR _mirrorPoint$[ebp], xmm0

; 322  :     y = fy;

	movss	xmm0, DWORD PTR _mirrorMatrix$[ebp+52]
	movss	DWORD PTR _mirrorPoint$[ebp+4], xmm0

; 323  :     z = fz;

	movss	xmm0, DWORD PTR _mirrorMatrix$[ebp+56]
	movss	DWORD PTR _mirrorPoint$[ebp+8], xmm0

; 321  :     x = fx;

	movss	xmm0, DWORD PTR _mirrorMatrix$[ebp+32]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 877  : 	D3DXPlaneFromPointNormal( &mirrorPlane, &mirrorPoint, &mirrorNormal );

	push	eax
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	DWORD PTR _mirrorNormal$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 877  : 	D3DXPlaneFromPointNormal( &mirrorPlane, &mirrorPoint, &mirrorNormal );

	lea	eax, DWORD PTR _mirrorPoint$[ebp]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 322  :     y = fy;

	movss	xmm0, DWORD PTR _mirrorMatrix$[ebp+36]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 877  : 	D3DXPlaneFromPointNormal( &mirrorPlane, &mirrorPoint, &mirrorNormal );

	push	eax
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 322  :     y = fy;

	movss	DWORD PTR _mirrorNormal$[ebp+4], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 877  : 	D3DXPlaneFromPointNormal( &mirrorPlane, &mirrorPoint, &mirrorNormal );

	lea	eax, DWORD PTR _mirrorPlane$[ebp]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	movss	xmm0, DWORD PTR _mirrorMatrix$[ebp+40]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 877  : 	D3DXPlaneFromPointNormal( &mirrorPlane, &mirrorPoint, &mirrorNormal );

	push	eax
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	movss	DWORD PTR _mirrorNormal$[ebp+8], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 877  : 	D3DXPlaneFromPointNormal( &mirrorPlane, &mirrorPoint, &mirrorNormal );

	call	_D3DXPlaneFromPointNormal@12

; 878  : 	
; 879  : 	// Reflect the camera's view matrix in the mirror plane
; 880  : 	D3DXMATRIXA16 reflectMatrix;
; 881  : 	D3DXMatrixReflect( &reflectMatrix, &mirrorPlane );

	lea	eax, DWORD PTR _mirrorPlane$[ebp]
	push	eax
	lea	eax, DWORD PTR _reflectMatrix$[ebp]
	push	eax
	call	_D3DXMatrixReflect@8

; 882  : 	D3DXMATRIXA16 reflectViewMatrix = reflectMatrix * Camera->GetViewMatrix();

	mov	eax, DWORD PTR [esi+4]
; File c:\users\simon\documents\github\post-processing\camera.h

; 72   : 		return m_ViewMatrix;

	movdqu	xmm0, XMMWORD PTR [eax+112]
	movdqu	XMMWORD PTR $T1[ebp], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+128]
	movdqu	XMMWORD PTR $T1[ebp+16], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+144]
	movdqu	XMMWORD PTR $T1[ebp+32], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+160]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 898  :     D3DXMatrixMultiply(&matT, this, &mat);

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	eax, DWORD PTR _reflectMatrix$[ebp]
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
; File c:\users\simon\documents\github\post-processing\camera.h

; 72   : 		return m_ViewMatrix;

	movdqu	XMMWORD PTR $T1[ebp+48], xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 898  :     D3DXMatrixMultiply(&matT, this, &mat);

	call	_D3DXMatrixMultiply@12

; 770  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));

	movdqa	xmm0, XMMWORD PTR $T4[ebp]
	movdqa	XMMWORD PTR _reflectViewMatrix$[ebp], xmm0
	movdqa	xmm0, XMMWORD PTR $T4[ebp+16]
	movdqa	XMMWORD PTR _reflectViewMatrix$[ebp+16], xmm0
	movdqa	xmm0, XMMWORD PTR $T4[ebp+32]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 885  : 	D3DXVECTOR3 cameraPos = Camera->GetPosition();

	mov	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 770  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));

	movdqa	XMMWORD PTR _reflectViewMatrix$[ebp+32], xmm0
	movdqa	xmm0, XMMWORD PTR $T4[ebp+48]
	movdqa	XMMWORD PTR _reflectViewMatrix$[ebp+48], xmm0
; File c:\users\simon\documents\github\post-processing\camera.h

; 63   : 		return m_Position;

	movq	xmm0, QWORD PTR [eax+8]
	movq	QWORD PTR _cameraPos$[ebp], xmm0
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _cameraPos$[ebp+8], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 887  : 	D3DXVec3Transform( &reflectCameraPos4, &cameraPos, &reflectMatrix );

	lea	eax, DWORD PTR _reflectMatrix$[ebp]
	push	eax
	lea	eax, DWORD PTR _cameraPos$[ebp]
	push	eax
	lea	eax, DWORD PTR _reflectCameraPos4$[ebp]
	push	eax
	call	_D3DXVec3Transform@12
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 294  :     x = pf[0];

	movss	xmm0, DWORD PTR _reflectCameraPos4$[ebp]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 895  : 	ViewMatrixVar->SetMatrix( (float*)&reflectViewMatrix );

	lea	edx, DWORD PTR _reflectViewMatrix$[ebp]
	mov	eax, DWORD PTR [esi+3092]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 294  :     x = pf[0];

	movss	DWORD PTR _reflectCameraPos$[ebp], xmm0

; 295  :     y = pf[1];

	movss	xmm0, DWORD PTR _reflectCameraPos4$[ebp+4]
	movss	DWORD PTR _reflectCameraPos$[ebp+4], xmm0

; 296  :     z = pf[2];

	movss	xmm0, DWORD PTR _reflectCameraPos4$[ebp+8]
	movss	DWORD PTR _reflectCameraPos$[ebp+8], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 895  : 	ViewMatrixVar->SetMatrix( (float*)&reflectViewMatrix );

	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+100]

; 896  : 	dxCameraPos->SetRawValue( reflectCameraPos, 0, 12 );

	mov	eax, DWORD PTR [esi+3120]
	lea	edx, DWORD PTR _reflectCameraPos$[ebp]
	push	12					; 0000000cH
	push	0
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+92]

; 897  : 	ClipPlaneVar->SetRawValue( mirrorPlane, 0, 16 );

	mov	eax, DWORD PTR [esi+3144]
	lea	edx, DWORD PTR _mirrorPlane$[ebp]
	push	16					; 00000010H
	push	0
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+92]

; 898  : 
; 899  : 	// Need to use slightly different techniques to avoid mirror rendering being "inside out"
; 900  : 	
; 901  : 	DrawAllObjects(true);

	push	1
	mov	ecx, esi
	call	?DrawAllObjects@CScene@@AAEX_N@Z	; CScene::DrawAllObjects

; 904  : 	ViewMatrixVar->SetMatrix( (float*)&Camera->GetViewMatrix() );

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
; File c:\users\simon\documents\github\post-processing\camera.h

; 72   : 		return m_ViewMatrix;

	movdqu	xmm0, XMMWORD PTR [eax+112]
	movdqu	XMMWORD PTR $T3[ebp], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+128]
	movdqu	XMMWORD PTR $T3[ebp+16], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+144]
	movdqu	XMMWORD PTR $T3[ebp+32], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+160]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 904  : 	ViewMatrixVar->SetMatrix( (float*)&Camera->GetViewMatrix() );

	mov	eax, DWORD PTR [esi+3092]
	push	eax
; File c:\users\simon\documents\github\post-processing\camera.h

; 72   : 		return m_ViewMatrix;

	movdqu	XMMWORD PTR $T3[ebp+48], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 904  : 	ViewMatrixVar->SetMatrix( (float*)&Camera->GetViewMatrix() );

	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 905  : 	dxCameraPos->SetRawValue( Camera->GetPosition(), 0, 12 );

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR $T6[ebp]
	push	12					; 0000000cH
	push	0
	push	edx
; File c:\users\simon\documents\github\post-processing\camera.h

; 63   : 		return m_Position;

	movq	xmm0, QWORD PTR [eax+8]
	movq	QWORD PTR $T6[ebp], xmm0
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR $T6[ebp+8], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 905  : 	dxCameraPos->SetRawValue( Camera->GetPosition(), 0, 12 );

	mov	eax, DWORD PTR [esi+3120]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+92]

; 906  : 	ClipPlaneVar->SetRawValue( D3DXVECTOR4(0,0,0,0), 0, 16 );

	mov	eax, DWORD PTR [esi+3144]
	xorps	xmm0, xmm0
	push	16					; 00000010H
	movups	XMMWORD PTR $T5[ebp], xmm0
	push	0
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	push	eax
	call	DWORD PTR [ecx+92]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+8]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 913  : 	WorldMatrixVar->SetMatrix( (float*)mpObjects[0]->GetModel()->GetWorldMatrix() );

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 100  : 		return m_WorldMatrix;

	movdqu	xmm0, XMMWORD PTR [eax+48]
	movdqu	XMMWORD PTR $T2[ebp], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+64]
	movdqu	XMMWORD PTR $T2[ebp+16], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+80]
	movdqu	XMMWORD PTR $T2[ebp+32], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+96]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 913  : 	WorldMatrixVar->SetMatrix( (float*)mpObjects[0]->GetModel()->GetWorldMatrix() );

	mov	eax, DWORD PTR [esi+3088]
	push	eax
; File c:\users\simon\documents\github\post-processing\model.h

; 100  : 		return m_WorldMatrix;

	movdqu	XMMWORD PTR $T2[ebp+48], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 913  : 	WorldMatrixVar->SetMatrix( (float*)mpObjects[0]->GetModel()->GetWorldMatrix() );

	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 914  : 	mpObjects[0]->RenderMirror();

	mov	ecx, DWORD PTR [esi+8]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 86   : 	void RenderMirror() { mModel->Render( mMirrorTechnique ); }

	push	DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx]
	call	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z ; CModel::Render
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 915  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?RenderMirrors@CScene@@QAEXXZ ENDP			; CScene::RenderMirrors
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?RenderScene@CScene@@QAEXXZ
_TEXT	SEGMENT
$T1 = -80						; size = 64
$T2 = -80						; size = 64
$T3 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?RenderScene@CScene@@QAEXXZ PROC			; CScene::RenderScene, COMDAT
; _this$ = ecx

; 621  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 622  : 	//set render target to a texture for post processing
; 623  : 	mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);

	mov	edx, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [ebx+3160]
	push	DWORD PTR [ebx+3156]
	push	ecx
	mov	eax, DWORD PTR [edx]
	push	1
	push	edx
	call	DWORD PTR [eax+96]

; 624  : 	mpd3dDevice->ClearRenderTargetView(mInitialRenderTarget, AmbientColour);

	mov	ecx, DWORD PTR [ebx]
	lea	edi, DWORD PTR [ebx+2540]
	push	edi
	push	DWORD PTR [ebx+2908]
	lea	esi, DWORD PTR [ebx+2908]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+140]

; 625  : 	mpd3dDevice->ClearDepthStencilView(DepthStencilView, D3D10_CLEAR_DEPTH | D3D10_CLEAR_STENCIL, 1.0f, 0); // Clear the depth buffer too

	mov	eax, DWORD PTR [ebx]
	push	0
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	3
	push	DWORD PTR [ebx+3156]
	push	eax
	call	DWORD PTR [ecx+144]

; 626  : 
; 627  : 	mpd3dDevice->OMSetRenderTargets( 1, &mInitialRenderTarget, DepthStencilView);

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [ebx+3156]
	push	esi
	mov	ecx, DWORD PTR [eax]
	push	1
	push	eax
	call	DWORD PTR [ecx+96]

; 628  : 
; 629  : 	// Clear the back buffer - before drawing the geometry clear the entire window to a fixed colour
; 630  : 	//float ClearColor[4] = { 0.2f, 0.2f, 0.3f, 1.0f }; // Good idea to match background to ambient colour
; 631  : 	mpd3dDevice->ClearRenderTargetView( mInitialRenderTarget, AmbientColour );

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+140]

; 632  : 	mpd3dDevice->ClearDepthStencilView( DepthStencilView, D3D10_CLEAR_DEPTH | D3D10_CLEAR_STENCIL , 1.0f, 0 ); // Clear the depth buffer too

	mov	eax, DWORD PTR [ebx]
	push	0
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	3
	push	DWORD PTR [ebx+3156]
	push	eax
	call	DWORD PTR [ecx+144]

; 640  : 	ViewMatrixVar->SetMatrix( (float*)&Camera->GetViewMatrix() );

	mov	eax, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
; File c:\users\simon\documents\github\post-processing\camera.h

; 72   : 		return m_ViewMatrix;

	movdqu	xmm0, XMMWORD PTR [eax+112]
	movdqu	XMMWORD PTR $T2[ebp], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+128]
	movdqu	XMMWORD PTR $T2[ebp+16], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+144]
	movdqu	XMMWORD PTR $T2[ebp+32], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+160]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 640  : 	ViewMatrixVar->SetMatrix( (float*)&Camera->GetViewMatrix() );

	mov	eax, DWORD PTR [ebx+3092]
	push	eax
; File c:\users\simon\documents\github\post-processing\camera.h

; 72   : 		return m_ViewMatrix;

	movdqu	XMMWORD PTR $T2[ebp+48], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 640  : 	ViewMatrixVar->SetMatrix( (float*)&Camera->GetViewMatrix() );

	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 641  : 	ProjMatrixVar->SetMatrix( (float*)&Camera->GetProjectionMatrix() );

	mov	eax, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
; File c:\users\simon\documents\github\post-processing\camera.h

; 76   : 		return m_ProjMatrix;

	movdqu	xmm0, XMMWORD PTR [eax+176]
	movdqu	XMMWORD PTR $T1[ebp], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+192]
	movdqu	XMMWORD PTR $T1[ebp+16], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+208]
	movdqu	XMMWORD PTR $T1[ebp+32], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+224]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 641  : 	ProjMatrixVar->SetMatrix( (float*)&Camera->GetProjectionMatrix() );

	mov	eax, DWORD PTR [ebx+3096]
	push	eax
; File c:\users\simon\documents\github\post-processing\camera.h

; 76   : 		return m_ProjMatrix;

	movdqu	XMMWORD PTR $T1[ebp+48], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 641  : 	ProjMatrixVar->SetMatrix( (float*)&Camera->GetProjectionMatrix() );

	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 644  : 	dxCameraPos->SetRawValue( D3DXVECTOR3( Camera->GetPosition()), 0, 12);

	mov	eax, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR $T3[ebp]
	push	12					; 0000000cH
	push	0
	push	edx
; File c:\users\simon\documents\github\post-processing\camera.h

; 63   : 		return m_Position;

	movq	xmm0, QWORD PTR [eax+8]
	movq	QWORD PTR $T3[ebp], xmm0
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR $T3[ebp+8], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 644  : 	dxCameraPos->SetRawValue( D3DXVECTOR3( Camera->GetPosition()), 0, 12);

	mov	eax, DWORD PTR [ebx+3120]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+92]

; 645  : 
; 646  : 	//pass the lighting colours
; 647  : 	dxAmbientColour->SetRawValue( AmbientColour, 0, 12  );

	mov	eax, DWORD PTR [ebx+3128]
	push	12					; 0000000cH
	push	0
	push	edi
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+92]

; 648  : 
; 649  : 	//---------------------------
; 650  : 	// Render each model
; 651  : 	
; 652  : 	RenderMirrors();

	mov	ecx, ebx
	call	?RenderMirrors@CScene@@QAEXXZ		; CScene::RenderMirrors

; 653  : 	DrawAllObjects(false);

	push	0
	mov	ecx, ebx
	call	?DrawAllObjects@CScene@@AAEX_N@Z	; CScene::DrawAllObjects

; 654  : 
; 655  : 	/////////////////////////////
; 656  : 	// POST PROCESS PASS
; 657  : 	/////////////////////////////
; 658  : 	
; 659  : 	//Pass the tint colour
; 660  : 	mdxPPTintColour->SetRawValue( mTintColour, 0, 12 );

	mov	ecx, DWORD PTR [ebx+2988]
	lea	eax, DWORD PTR [ebx+2992]
	push	12					; 0000000cH
	push	0
	push	eax
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+92]

; 661  : 
; 662  : 	//Pass the shock value
; 663  : 	mdxPPShock->SetRawValue( &mShock, 0, 4 );

	mov	ecx, DWORD PTR [ebx+2980]
	lea	eax, DWORD PTR [ebx+2960]
	push	4
	push	0
	push	eax
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+92]

; 664  : 
; 665  : 	//Pass the blur radius
; 666  : 	mdxBlurRadius->SetRawValue( &mBlurRadius, 0, 4 );

	mov	ecx, DWORD PTR [ebx+3016]
	lea	eax, DWORD PTR [ebx+3008]
	push	4
	push	0
	push	eax
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+92]

; 667  : 
; 668  : 	//Pass the double vision radius
; 669  : 	mdxDoubleVisionRadius->SetRawValue( &mDoubleVisionRadius, 0, 4 );

	mov	ecx, DWORD PTR [ebx+3024]
	lea	eax, DWORD PTR [ebx+3020]
	push	4
	push	0
	push	eax
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+92]

; 670  : 
; 671  : 	//Pass the contrast factor
; 672  : 	mdxContrastFactor->SetRawValue(&mContrastFactor, 0, 4);

	mov	ecx, DWORD PTR [ebx+3036]
	lea	eax, DWORD PTR [ebx+3032]
	push	4
	push	0
	push	eax
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+92]

; 673  : 
; 674  : 	//Only one person would dare give me the raspberry....LONESTAR!!
; 675  : 	mdxBlood->SetRawValue(&mBlood, 0, 4);

	mov	ecx, DWORD PTR [ebx+2948]
	lea	eax, DWORD PTR [ebx+2944]
	push	4
	push	0
	push	eax
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+92]

; 676  : 	mPostProcessMapVar->SetResource(mpMaps[15]);

	mov	eax, DWORD PTR [ebx+2956]
	push	DWORD PTR [ebx+996]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 677  : 
; 678  : 	mdxSolariseFloat->SetRawValue(&mSolariseFloat, 0, 4);

	mov	ecx, DWORD PTR [ebx+3080]
	push	4
	mov	edx, DWORD PTR [ecx]
	push	0
	lea	eax, DWORD PTR [ebx+3076]
	push	eax
	push	ecx
	call	DWORD PTR [edx+92]

; 679  : 
; 680  : 	if(mCurrentPP < 0) mCurrentPP = 0;

	cmp	DWORD PTR [ebx+3040], 0
	jge	SHORT $LN7@RenderScen
	mov	DWORD PTR [ebx+3040], 0
$LN7@RenderScen:

; 681  : 	if(mCurrentPP > NumPostProcesses ) mCurrentPP = 0;

	cmp	DWORD PTR [ebx+3040], 13		; 0000000dH
	jle	SHORT $LN6@RenderScen
	mov	DWORD PTR [ebx+3040], 0
$LN6@RenderScen:

; 682  : 
; 683  : 	if (impact)

	cmp	BYTE PTR [ebx+3084], 0
	je	SHORT $LN5@RenderScen

; 684  : 	{
; 685  : 		RenderImpact();

	mov	ecx, ebx
	call	?RenderImpact@CScene@@AAEXXZ		; CScene::RenderImpact

; 686  : 	}
; 687  : 	else

	jmp	$LN1@RenderScen
$LN5@RenderScen:

; 688  : 	{
; 689  : 		if (mbGaussian)
; 690  : 		{
; 691  : 
; 692  : 		}
; 693  : 
; 694  : 		if (!multiprocess)

	cmp	BYTE PTR [ebx+3184], 0

; 695  : 		{
; 696  : 			//Set render target back to output
; 697  : 			mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);

	lea	esi, DWORD PTR [ebx+3160]
	push	DWORD PTR [ebx+3156]
	mov	eax, DWORD PTR [ebx]
	push	esi
	push	1
	push	eax
	mov	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@RenderScen
	call	DWORD PTR [ecx+96]

; 698  : 			//send rendered scene to shader as a texture
; 699  : 			mInitialTextureVar->SetResource(mInitialShaderResource);

	mov	eax, DWORD PTR [ebx+2940]
	push	DWORD PTR [ebx+2912]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 700  : 
; 701  : 			//Apply Post Processing Effect
; 702  : 			mpd3dDevice->IASetInputLayout(NULL);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]

; 703  : 			mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

	mov	eax, DWORD PTR [ebx]
	push	5
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+72]

; 704  : 			mPPTechniques[mCurrentPP]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+3040]
	push	0
	mov	eax, DWORD PTR [ebx+eax*4+2564]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 705  : 
; 706  : 			mpd3dDevice->Draw(4, 0);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	4
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+36]

; 707  : 
; 708  : 			mInitialTextureVar->SetResource(0);

	mov	eax, DWORD PTR [ebx+2940]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 709  : 			mPPTechniques[mCurrentPP]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+3040]
	mov	eax, DWORD PTR [ebx+eax*4+2564]

; 710  : 		}
; 711  : 		else

	jmp	$LN26@RenderScen
$LN2@RenderScen:

; 712  : 		{
; 713  : 
; 714  : 			//Box Blur
; 715  : 			mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);

	call	DWORD PTR [ecx+96]

; 716  : 			mInitialTextureVar->SetResource(mInitialShaderResource);

	mov	eax, DWORD PTR [ebx+2940]
	push	DWORD PTR [ebx+2912]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 717  : 			mpd3dDevice->IASetInputLayout(NULL);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]

; 718  : 			mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

	mov	eax, DWORD PTR [ebx]
	push	5
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+72]

; 719  : 			mPPTechniques[5]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2584]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 720  : 			mpd3dDevice->Draw(4, 0);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	4
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+36]

; 721  : 			mInitialTextureVar->SetResource(0);

	mov	eax, DWORD PTR [ebx+2940]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 722  : 			mPPTechniques[5]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2584]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 723  : 
; 724  : 			//Double Vision
; 725  : 			mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [ebx+3156]
	push	esi
	mov	ecx, DWORD PTR [eax]
	push	1
	push	eax
	call	DWORD PTR [ecx+96]

; 726  : 			mInitialTextureVar->SetResource(mTextureOneShader);

	mov	eax, DWORD PTR [ebx+2940]
	push	DWORD PTR [ebx+3060]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 727  : 			mpd3dDevice->IASetInputLayout(NULL);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]

; 728  : 			mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

	mov	eax, DWORD PTR [ebx]
	push	5
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+72]

; 729  : 			mPPTechniques[6]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2588]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 730  : 			mpd3dDevice->Draw(4, 0);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	4
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+36]

; 731  : 			mInitialTextureVar->SetResource(0);

	mov	eax, DWORD PTR [ebx+2940]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 732  : 			mPPTechniques[6]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2588]
$LN26@RenderScen:
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]
$LN1@RenderScen:

; 733  : 
; 734  : 			//Copy to Output
; 735  : 			/*mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);
; 736  : 			mInitialTextureVar->SetResource(mTextureTwoShader);
; 737  : 			mpd3dDevice->IASetInputLayout(NULL);
; 738  : 			mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
; 739  : 			mPPTechniques[0]->GetPassByIndex(0)->Apply(0);
; 740  : 			mpd3dDevice->Draw(4, 0);
; 741  : 			mInitialTextureVar->SetResource(0);
; 742  : 			mPPTechniques[0]->GetPassByIndex(0)->Apply(0);
; 743  : 			*/
; 744  : 		}
; 745  : 	}//end else impact
; 746  : 	//---------------------------
; 747  : 	// Display the Scene
; 748  : 
; 749  : 	// After we've finished drawing to the off-screen back buffer, we "present" it to the front buffer (the screen)
; 750  : 	TwDraw();

	call	DWORD PTR __imp__TwDraw@0

; 751  : 	SwapChain->Present( 0, 0 );

	mov	eax, DWORD PTR [ebx+3148]
	push	0
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+32]

; 752  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?RenderScene@CScene@@QAEXXZ ENDP			; CScene::RenderScene
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?UpdateScene@CScene@@QAEXM@Z
_TEXT	SEGMENT
tv695 = -120						; size = 8
tv692 = -120						; size = 8
tv686 = -120						; size = 8
_caption$ = -112					; size = 100
_buffer$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_frameTime$ = 8						; size = 4
?UpdateScene@CScene@@QAEXM@Z PROC			; CScene::UpdateScene, COMDAT
; _this$ = ecx

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	push	OFFSET ??_C@_0BH@BEMLJPBO@Post?5Processing?5?9?5FPS?5?$AA@
	lea	eax, DWORD PTR _caption$[ebp]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 351  : {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	push	100					; 00000064H
	push	eax
	call	_strcpy_s
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 360  : 	int FPS = int ( 1.0f / frameTime );

	movss	xmm0, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h

; 480  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itoa_s, _In_ int, _Value, char, _Dest, _In_ int, _Radix)

	lea	eax, DWORD PTR _buffer$[ebp]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 360  : 	int FPS = int ( 1.0f / frameTime );

	divss	xmm0, DWORD PTR _frameTime$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h

; 480  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itoa_s, _In_ int, _Value, char, _Dest, _In_ int, _Radix)

	push	10					; 0000000aH
	push	6
	push	eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 360  : 	int FPS = int ( 1.0f / frameTime );

	cvttss2si eax, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h

; 480  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itoa_s, _In_ int, _Value, char, _Dest, _In_ int, _Radix)

	push	eax
	call	__itoa_s
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 116  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcat_s, char, _Dest, _In_z_ const char *, _Source)

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	eax, DWORD PTR _caption$[ebp]
	push	100					; 00000064H
	push	eax
	call	_strcat_s
	push	OFFSET ??_C@_04IHBDCLGJ@?5O?3?5?$AA@
	lea	eax, DWORD PTR _caption$[ebp]
	push	100					; 00000064H
	push	eax
	call	_strcat_s
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h

; 480  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itoa_s, _In_ int, _Value, char, _Dest, _In_ int, _Radix)

	push	10					; 0000000aH
	push	6
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	DWORD PTR [esi+808]
	call	__itoa_s
	add	esp, 68					; 00000044H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 116  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcat_s, char, _Dest, _In_z_ const char *, _Source)

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	eax, DWORD PTR _caption$[ebp]
	push	100					; 00000064H
	push	eax
	call	_strcat_s
	push	OFFSET ??_C@_04JFKGIEIH@?5L?3?5?$AA@
	lea	eax, DWORD PTR _caption$[ebp]
	push	100					; 00000064H
	push	eax
	call	_strcat_s
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h

; 480  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itoa_s, _In_ int, _Value, char, _Dest, _In_ int, _Radix)

	push	10					; 0000000aH
	push	6
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	DWORD PTR [esi+932]
	call	__itoa_s
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 116  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcat_s, char, _Dest, _In_z_ const char *, _Source)

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	eax, DWORD PTR _caption$[ebp]
	push	100					; 00000064H
	push	eax
	call	_strcat_s
	add	esp, 52					; 00000034H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 376  : 	SetWindowTextA( HWnd, caption );

	lea	eax, DWORD PTR _caption$[ebp]
	push	eax
	push	DWORD PTR [esi+3168]
	call	DWORD PTR __imp__SetWindowTextA@8

; 377  : 
; 378  : 	// Control camera position and update its matrices (view matrix, projection matrix) each frame
; 379  : 	// Don't be deceived into thinking that this is a new method to control models - the same code we used previously is in the camera class
; 380  : 	Camera->Control( frameTime, Key_Up, Key_Down, Key_Left, Key_Right, Key_W, Key_S, Key_A, Key_D );

	movss	xmm0, DWORD PTR _frameTime$[ebp]
	push	68					; 00000044H
	push	65					; 00000041H
	push	83					; 00000053H
	push	87					; 00000057H
	push	39					; 00000027H
	push	37					; 00000025H
	push	40					; 00000028H
	push	38					; 00000026H
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	movss	DWORD PTR [esp], xmm0
	call	?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z ; CCamera::Control

; 381  : 	Camera->UpdateMatrices();

	mov	ecx, DWORD PTR [esi+4]
	call	?UpdateMatrices@CCamera@@QAEXXZ		; CCamera::UpdateMatrices

; 384  : 	mpObjects[mControlObject]->GetModel()->Control( frameTime, Key_I, Key_K, Key_J, Key_L, Key_U, Key_O, Key_Period, Key_Comma );

	push	188					; 000000bcH
	push	190					; 000000beH
	push	79					; 0000004fH
	push	85					; 00000055H
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+2552]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 384  : 	mpObjects[mControlObject]->GetModel()->Control( frameTime, Key_I, Key_K, Key_J, Key_L, Key_U, Key_O, Key_Period, Key_Comma );

	movss	xmm0, DWORD PTR _frameTime$[ebp]
	push	76					; 0000004cH
	push	74					; 0000004aH
	push	75					; 0000004bH
	push	73					; 00000049H
	push	ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	ecx, DWORD PTR [esi+eax*4+8]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 384  : 	mpObjects[mControlObject]->GetModel()->Control( frameTime, Key_I, Key_K, Key_J, Key_L, Key_U, Key_O, Key_Period, Key_Comma );

	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR [ecx]
	call	?Control@CModel@@QAEXMW4EKeyCode@@0000000@Z ; CModel::Control

; 385  : 
; 386  : 	if (impact)

	cmp	BYTE PTR [esi+3084], 0

; 387  : 	{
; 388  : 		UpdateImpact(frameTime);

	movss	xmm0, DWORD PTR _frameTime$[ebp]
	je	SHORT $LN39@UpdateScen
	push	ecx
	mov	ecx, esi
	movss	DWORD PTR [esp], xmm0
	call	?UpdateImpact@CScene@@AAEXM@Z		; CScene::UpdateImpact

; 389  : 	}
; 390  : 	else

	jmp	$LN38@UpdateScen
$LN39@UpdateScen:

; 391  : 	{
; 392  : 		mCumulativeFTime += frameTime;

	addss	xmm0, DWORD PTR [esi+2984]

; 396  : 		fHSLToRGB(hue, 0.5f, 0.5f, mTintColour.x, mTintColour.y, mTintColour.z);

	lea	eax, DWORD PTR [esi+3000]
	push	eax
	lea	eax, DWORD PTR [esi+2996]
	push	eax
	movss	DWORD PTR [esi+2984], xmm0
	lea	eax, DWORD PTR [esi+2992]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 706  :     return (float)fmod(_X, _Y);

	cvtps2pd xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 396  : 		fHSLToRGB(hue, 0.5f, 0.5f, mTintColour.x, mTintColour.y, mTintColour.z);

	push	eax
	sub	esp, 8
	mov	DWORD PTR [esp+4], 1056964608		; 3f000000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 706  :     return (float)fmod(_X, _Y);

	movsd	QWORD PTR tv695[ebp], xmm0
	movss	xmm0, DWORD PTR [esi+3004]
	fld	QWORD PTR tv695[ebp]
	cvtps2pd xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 396  : 		fHSLToRGB(hue, 0.5f, 0.5f, mTintColour.x, mTintColour.y, mTintColour.z);

	mov	DWORD PTR [esp], 1056964608		; 3f000000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 706  :     return (float)fmod(_X, _Y);

	movsd	QWORD PTR tv692[ebp], xmm0
	fld	QWORD PTR tv692[ebp]
	call	__CIfmod
	fstp	QWORD PTR tv686[ebp]
	movsd	xmm0, QWORD PTR tv686[ebp]
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 396  : 		fHSLToRGB(hue, 0.5f, 0.5f, mTintColour.x, mTintColour.y, mTintColour.z);

	push	ecx
	divss	xmm0, DWORD PTR [esi+3004]
	movss	DWORD PTR [esp], xmm0
	call	?fHSLToRGB@@YAXMMMAAM00@Z		; fHSLToRGB

; 397  : 
; 398  : 		//Shock update
; 399  : 		if (mShockTime > 0)

	movss	xmm1, DWORD PTR [esi+2968]
	xorps	xmm0, xmm0
	add	esp, 24					; 00000018H
	comiss	xmm1, xmm0
	jbe	SHORT $LN37@UpdateScen

; 400  : 		{
; 401  : 			mShockTime -= frameTime;

	subss	xmm1, DWORD PTR _frameTime$[ebp]

; 402  : 			mShock = sin(mShockSpeed * mShockTime);

	movss	xmm0, DWORD PTR [esi+2972]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+2968], xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 403  : 			mShock -= 0.5f;

	subss	xmm0, DWORD PTR __real@3f000000

; 404  : 			mShock *= mShockStrength;

	mulss	xmm0, DWORD PTR [esi+2964]
	movss	DWORD PTR [esi+2960], xmm0

; 405  : 		}
; 406  : 		else

	jmp	SHORT $LN36@UpdateScen
$LN37@UpdateScen:

; 407  : 		{
; 408  : 			mShock = 0;

	mov	DWORD PTR [esi+2960], 0
$LN36@UpdateScen:

; 409  : 		}
; 410  : 
; 411  : 		//Calculate contrast factor
; 412  : 		mContrastFactor = (259 * (mContrastChange + 255.0f)) / (255.0f * (259.0f - mContrastChange));

	movss	xmm1, DWORD PTR [esi+3028]
	movss	xmm3, DWORD PTR __real@437f0000
	movaps	xmm2, xmm1
	movss	xmm0, DWORD PTR __real@43818000
	addss	xmm2, xmm3
	mulss	xmm2, xmm0
	subss	xmm0, xmm1
	mulss	xmm0, xmm3
	divss	xmm2, xmm0
	movd	xmm0, DWORD PTR [esi+3072]

; 413  : 
; 414  : 		mSolariseFloat = mSolariseInt / 255.0f;

	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esi+3032], xmm2
	divss	xmm0, xmm3
	movss	DWORD PTR [esi+3076], xmm0
$LN38@UpdateScen:

; 415  : 
; 416  : 	}//end if impact
; 417  : 
; 418  : 	//update all the objects, including calculating the matrix
; 419  : 	for(int i = 0; i < miNumObjects; i++)

	push	ebx
	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+808], edi
	jle	SHORT $LN33@UpdateScen
	lea	ebx, DWORD PTR [esi+8]
	npad	6
$LL35@UpdateScen:

; 420  : 	{
; 421  : 		mpObjects[i]->Update(frameTime);

	movss	xmm0, DWORD PTR _frameTime$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	movss	DWORD PTR [esp], xmm0
	call	?Update@CRenderObject@@QAEXM@Z		; CRenderObject::Update
	inc	edi
	lea	ebx, DWORD PTR [ebx+4]
	cmp	edi, DWORD PTR [esi+808]
	jl	SHORT $LL35@UpdateScen
$LN33@UpdateScen:

; 422  : 	}
; 423  : 
; 424  : 	//same for the lights
; 425  : 	for(int i = 0; i < miNumLights; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+932], edi
	jle	SHORT $LN30@UpdateScen
	lea	ebx, DWORD PTR [esi+812]
	npad	2
$LL32@UpdateScen:

; 426  : 	{
; 427  : 		mpLights[i]->Update(frameTime);

	movss	xmm0, DWORD PTR _frameTime$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [ebx]
	movss	DWORD PTR [esp], xmm0
	call	?Update@CLight@@QAEXM@Z			; CLight::Update
	inc	edi
	lea	ebx, DWORD PTR [ebx+4]
	cmp	edi, DWORD PTR [esi+932]
	jl	SHORT $LL32@UpdateScen
$LN30@UpdateScen:

; 428  : 	}
; 429  : 
; 430  : 
; 431  : 	// Allow user to quit with escape key
; 432  : 	if (KeyHit( Key_Escape )) 

	push	27					; 0000001bH
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	pop	edi
	pop	ebx
	test	al, al
	je	SHORT $LN29@UpdateScen

; 433  : 	{
; 434  : 		DestroyWindow( HWnd );

	push	DWORD PTR [esi+3168]
	call	DWORD PTR __imp__DestroyWindow@4
$LN29@UpdateScen:

; 435  : 	}
; 436  : 
; 437  : 	if( KeyHit( Key_F1  ) ) { mCurrentPP = 0; }

	push	112					; 00000070H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN28@UpdateScen
	mov	DWORD PTR [esi+3040], 0
$LN28@UpdateScen:

; 438  : 	if( KeyHit( Key_F2  ) ) { mCurrentPP = 1; }

	push	113					; 00000071H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN27@UpdateScen
	mov	DWORD PTR [esi+3040], 1
$LN27@UpdateScen:

; 439  : 	if( KeyHit( Key_F3  ) ) { mCurrentPP = 2;ResetShock();}

	push	114					; 00000072H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN68@UpdateScen

; 217  : 	mShockTime = mShockLength;	

	mov	eax, DWORD PTR [esi+2976]

; 439  : 	if( KeyHit( Key_F3  ) ) { mCurrentPP = 2;ResetShock();}

	mov	DWORD PTR [esi+3040], 2

; 217  : 	mShockTime = mShockLength;	

	mov	DWORD PTR [esi+2968], eax
$LN68@UpdateScen:

; 440  : 	if( KeyHit( Key_F4  ) ) { mCurrentPP = 3; }

	push	115					; 00000073H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN25@UpdateScen
	mov	DWORD PTR [esi+3040], 3
$LN25@UpdateScen:

; 441  : 	if( KeyHit( Key_F5  ) ) { mCurrentPP = 4; }

	push	116					; 00000074H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN24@UpdateScen
	mov	DWORD PTR [esi+3040], 4
$LN24@UpdateScen:

; 442  : 	if( KeyHit( Key_F6  ) ) { mCurrentPP = 5; }

	push	117					; 00000075H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN23@UpdateScen
	mov	DWORD PTR [esi+3040], 5
$LN23@UpdateScen:

; 443  : 	if( KeyHit( Key_F7  ) ) { mCurrentPP = 6; }

	push	118					; 00000076H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN22@UpdateScen
	mov	DWORD PTR [esi+3040], 6
$LN22@UpdateScen:

; 444  : 	if( KeyHit( Key_F8  ) ) { mCurrentPP = 7; }

	push	119					; 00000077H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN21@UpdateScen
	mov	DWORD PTR [esi+3040], 7
$LN21@UpdateScen:

; 445  : 	if( KeyHit( Key_F9  ) ) { mCurrentPP = 8; }

	push	120					; 00000078H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN20@UpdateScen
	mov	DWORD PTR [esi+3040], 8
$LN20@UpdateScen:

; 446  : 	if( KeyHit( Key_F10 ) ) { mCurrentPP = 9; }

	push	121					; 00000079H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN19@UpdateScen
	mov	DWORD PTR [esi+3040], 9
$LN19@UpdateScen:

; 447  : 	if( KeyHit( Key_F11 ) ) { mCurrentPP = 10; }

	push	122					; 0000007aH
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN18@UpdateScen
	mov	DWORD PTR [esi+3040], 10		; 0000000aH
$LN18@UpdateScen:

; 448  : 	if( KeyHit( Key_F12 ) ) { mCurrentPP = 11; }

	push	123					; 0000007bH
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN17@UpdateScen
	mov	DWORD PTR [esi+3040], 11		; 0000000bH
$LN17@UpdateScen:

; 449  : 
; 450  : 	//change the controlled object
; 451  : 	if( KeyHit( Key_1 ) )

	push	49					; 00000031H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN16@UpdateScen

; 452  : 	{
; 453  : 		mControlObject = 0;

	mov	DWORD PTR [esi+2552], 0
$LN16@UpdateScen:

; 454  : 	}
; 455  : 
; 456  : 	if( KeyHit( Key_2 ) )

	push	50					; 00000032H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN15@UpdateScen

; 457  : 	{
; 458  : 		mControlObject = 1;

	mov	DWORD PTR [esi+2552], 1
$LN15@UpdateScen:

; 459  : 	}
; 460  : 
; 461  : 	if( KeyHit( Key_3 ) )

	push	51					; 00000033H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN14@UpdateScen

; 462  : 	{
; 463  : 		mControlObject = 2;

	mov	DWORD PTR [esi+2552], 2
$LN14@UpdateScen:

; 464  : 	}
; 465  : 
; 466  : 	if( KeyHit( Key_4 ) )

	push	52					; 00000034H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN13@UpdateScen

; 467  : 	{
; 468  : 		mControlObject = 3;

	mov	DWORD PTR [esi+2552], 3
$LN13@UpdateScen:

; 469  : 	}
; 470  : 
; 471  : 	if( KeyHit( Key_5 ) )

	push	53					; 00000035H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN12@UpdateScen

; 472  : 	{
; 473  : 		mControlObject = 4;

	mov	DWORD PTR [esi+2552], 4
$LN12@UpdateScen:

; 474  : 	}
; 475  : 
; 476  : 	if( KeyHit( Key_6 ) )

	push	54					; 00000036H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN11@UpdateScen

; 477  : 	{
; 478  : 		mControlObject = 5;

	mov	DWORD PTR [esi+2552], 5
$LN11@UpdateScen:

; 479  : 	}
; 480  : 
; 481  : 	if( KeyHit( Key_7 ) )

	push	55					; 00000037H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN10@UpdateScen

; 482  : 	{
; 483  : 		mControlObject = 6;

	mov	DWORD PTR [esi+2552], 6
$LN10@UpdateScen:

; 484  : 	}
; 485  : 
; 486  : 	if( KeyHit( Key_8 ) )

	push	56					; 00000038H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN9@UpdateScen

; 487  : 	{
; 488  : 		mControlObject = 7;

	mov	DWORD PTR [esi+2552], 7
$LN9@UpdateScen:

; 489  : 	}
; 490  : 
; 491  : 	if( KeyHit( Key_9 ) )

	push	57					; 00000039H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN8@UpdateScen

; 492  : 	{
; 493  : 		mControlObject = 8;

	mov	DWORD PTR [esi+2552], 8
$LN8@UpdateScen:

; 494  : 	}
; 495  : 
; 496  : 	if( KeyHit( Key_0 ) )

	push	48					; 00000030H
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN7@UpdateScen

; 497  : 	{
; 498  : 		mControlObject = 9;

	mov	DWORD PTR [esi+2552], 9
$LN7@UpdateScen:

; 499  : 	}
; 500  : 
; 501  : 	if( KeyHit ( Key_Minus ) )

	push	189					; 000000bdH
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN4@UpdateScen

; 502  : 	{
; 503  : 		if ( mControlObject == 0 )

	mov	eax, DWORD PTR [esi+2552]
	test	eax, eax
	jne	SHORT $LN5@UpdateScen

; 504  : 		{
; 505  : 			mControlObject = miNumObjects-1;

	mov	eax, DWORD PTR [esi+808]
$LN5@UpdateScen:

; 506  : 		}
; 507  : 		else
; 508  : 		{
; 509  : 			mControlObject--;

	dec	eax
	mov	DWORD PTR [esi+2552], eax
$LN4@UpdateScen:

; 510  : 		}
; 511  : 	}
; 512  : 
; 513  : 	if( KeyHit ( Key_Plus ) )

	push	187					; 000000bbH
	call	?KeyHit@@YA_NW4EKeyCode@@@Z		; KeyHit
	add	esp, 4
	test	al, al
	je	SHORT $LN1@UpdateScen

; 514  : 	{
; 515  : 		if ( mControlObject == miNumObjects-1 )

	mov	eax, DWORD PTR [esi+808]
	mov	ecx, DWORD PTR [esi+2552]
	dec	eax
	cmp	ecx, eax
	jne	SHORT $LN2@UpdateScen

; 516  : 		{
; 517  : 			mControlObject = 0;

	mov	DWORD PTR [esi+2552], 0
	pop	esi

; 522  : 		}
; 523  : 	}
; 524  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@UpdateScen:

; 518  : 		}
; 519  : 		else
; 520  : 		{
; 521  : 			mControlObject++;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+2552], eax
$LN1@UpdateScen:

; 522  : 		}
; 523  : 	}
; 524  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateScene@CScene@@QAEXM@Z ENDP			; CScene::UpdateScene
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?InitATB@CScene@@QAE_NXZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
?InitATB@CScene@@QAE_NXZ PROC				; CScene::InitATB, COMDAT
; _this$ = ecx

; 221  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 222  : 	TwInit(TW_DIRECT3D10, mpd3dDevice);

	push	DWORD PTR [edi]
	push	3
	call	DWORD PTR __imp__TwInit@8

; 223  : 	TwWindowSize(mViewportWidth, mViewportHeight);

	push	DWORD PTR ?mViewportHeight@CScene@@0HA	; CScene::mViewportHeight
	push	DWORD PTR ?mViewportWidth@CScene@@0HA	; CScene::mViewportWidth
	call	DWORD PTR __imp__TwWindowSize@8

; 224  : 
; 225  : 	mtwBarPP = TwNewBar("PostProcessing");

	push	OFFSET ??_C@_0P@MPKDMNGJ@PostProcessing?$AA@
	call	DWORD PTR __imp__TwNewBar@4

; 226  : 	TwDefine(" PostProcessing position='5 5' ");

	mov	ebx, DWORD PTR __imp__TwDefine@4
	push	OFFSET ??_C@_0CA@HAEMFPIM@?5PostProcessing?5position?$DN?85?55?8?5?$AA@
	mov	DWORD PTR [edi+3172], eax
	call	ebx

; 227  : 	TwAddVarRW(mtwBarPP, "Tint Cycle Time", TW_TYPE_FLOAT, &mTintCycleTime, "min=0.1 max=30 step=0.1");

	mov	esi, DWORD PTR __imp__TwAddVarRW@20
	lea	eax, DWORD PTR [edi+3004]
	push	OFFSET ??_C@_0BI@BNBHPOAI@min?$DN0?41?5max?$DN30?5step?$DN0?41?$AA@
	push	eax
	push	12					; 0000000cH
	push	OFFSET ??_C@_0BA@LEBMNMMI@Tint?5Cycle?5Time?$AA@
	push	DWORD PTR [edi+3172]
	call	esi

; 228  : 	TwAddSeparator(mtwBarPP, "", "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	DWORD PTR [edi+3172]
	mov	edi, DWORD PTR __imp__TwAddSeparator@12
	call	edi

; 229  : 	TwAddVarRW(mtwBarPP, "Shock Strength", TW_TYPE_FLOAT, &mShockStrength, "min=0.01 max=0.5 step=0.01");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0BL@PGFPMOIN@min?$DN0?401?5max?$DN0?45?5step?$DN0?401?$AA@
	lea	eax, DWORD PTR [ecx+2964]
	push	eax
	push	12					; 0000000cH
	push	OFFSET ??_C@_0P@HMIPNKPE@Shock?5Strength?$AA@
	push	DWORD PTR [ecx+3172]
	call	esi

; 230  : 	TwAddVarRW(mtwBarPP, "Shock Speed", TW_TYPE_FLOAT, &mShockSpeed, "min=0.1 max=30 step=0.1");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0BI@BNBHPOAI@min?$DN0?41?5max?$DN30?5step?$DN0?41?$AA@
	lea	eax, DWORD PTR [ecx+2972]
	push	eax
	push	12					; 0000000cH
	push	OFFSET ??_C@_0M@BCFLJLDD@Shock?5Speed?$AA@
	push	DWORD PTR [ecx+3172]
	call	esi

; 231  : 	TwAddVarRW(mtwBarPP, "Shock Length", TW_TYPE_FLOAT, &mShockLength, "min=0.1 max=5 step=0.1");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0BH@GEGIJDLI@min?$DN0?41?5max?$DN5?5step?$DN0?41?$AA@
	lea	eax, DWORD PTR [ecx+2976]
	push	eax
	push	12					; 0000000cH
	push	OFFSET ??_C@_0N@BBJEPOMH@Shock?5Length?$AA@
	push	DWORD PTR [ecx+3172]
	call	esi

; 232  : 	TwAddSeparator(mtwBarPP, "", "");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	DWORD PTR [ecx+3172]
	call	edi

; 233  : 	TwAddVarRW(mtwBarPP, "Blur Radius", TW_TYPE_INT32, &mBlurRadius, "min=2 max=50 step=1");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0BE@BKDAFDIA@min?$DN2?5max?$DN50?5step?$DN1?$AA@
	lea	eax, DWORD PTR [ecx+3008]
	push	eax
	push	10					; 0000000aH
	push	OFFSET ??_C@_0M@DOKJBODC@Blur?5Radius?$AA@
	push	DWORD PTR [ecx+3172]
	call	esi

; 234  : 	TwAddSeparator(mtwBarPP, "", "");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	DWORD PTR [ecx+3172]
	call	edi

; 235  : 	TwAddVarRW(mtwBarPP, "Double Vision Radius", TW_TYPE_FLOAT, &mDoubleVisionRadius, "min=0 max=0.5 step=0.005");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0BJ@BKHNEING@min?$DN0?5max?$DN0?45?5step?$DN0?4005?$AA@
	lea	eax, DWORD PTR [ecx+3020]
	push	eax
	push	12					; 0000000cH
	push	OFFSET ??_C@_0BF@OKIMCMFP@Double?5Vision?5Radius?$AA@
	push	DWORD PTR [ecx+3172]
	call	esi

; 236  : 	TwAddSeparator(mtwBarPP, "", "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	DWORD PTR [ecx+3172]
	call	edi

; 237  : 	TwAddVarRW(mtwBarPP, "Contrast Shift", TW_TYPE_FLOAT, &mContrastChange, "min=-128 max=128 step=1");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0BI@JONKBOAH@min?$DN?9128?5max?$DN128?5step?$DN1?$AA@
	lea	eax, DWORD PTR [ecx+3028]
	push	eax
	push	12					; 0000000cH
	push	OFFSET ??_C@_0P@COCHJCAA@Contrast?5Shift?$AA@
	push	DWORD PTR [ecx+3172]
	call	esi

; 238  : 	//TwAddVarRO(mtwBarPP, "Contrast Factor", TW_TYPE_FLOAT, &mContrastFactor, "");
; 239  : 	TwAddVarRW(mtwBarPP, "Jamminess", TW_TYPE_FLOAT, &mBlood, "min=0 max=1 step=0.05");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0BG@BHAGHJLA@min?$DN0?5max?$DN1?5step?$DN0?405?$AA@
	lea	eax, DWORD PTR [ecx+2944]
	push	eax
	push	12					; 0000000cH
	push	OFFSET ??_C@_09CINOGBPL@Jamminess?$AA@
	push	DWORD PTR [ecx+3172]
	call	esi

; 240  : 	TwAddSeparator(mtwBarPP, "", "");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	DWORD PTR [ecx+3172]
	call	edi

; 241  : 	TwAddVarRW(mtwBarPP, "Solarise Threshold", TW_TYPE_INT32, &mSolariseInt, "min=32 max=222 step=1");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_0BG@NEFNJEOO@min?$DN32?5max?$DN222?5step?$DN1?$AA@
	lea	eax, DWORD PTR [ecx+3072]
	push	eax
	push	10					; 0000000aH
	push	OFFSET ??_C@_0BD@GCNLHPML@Solarise?5Threshold?$AA@
	push	DWORD PTR [ecx+3172]
	call	esi

; 242  : 	TwAddSeparator(mtwBarPP, "", "");

	mov	esi, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	DWORD PTR [esi+3172]
	call	edi

; 243  : 	TwAddVarRO(mtwBarPP, "Using multiple: ", TW_TYPE_BOOLCPP, &multiprocess, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	eax, DWORD PTR [esi+3184]
	push	eax
	push	1
	push	OFFSET ??_C@_0BB@IGJPDDCA@Using?5multiple?3?5?$AA@
	push	DWORD PTR [esi+3172]
	call	DWORD PTR __imp__TwAddVarRO@20

; 244  : 	TwAddButton( mtwBarPP, "Toggle Single", ToggleSingle, this, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	esi
	push	OFFSET ?ToggleSingle@@YGXPAX@Z		; ToggleSingle
	push	OFFSET ??_C@_0O@NMGOIPCC@Toggle?5Single?$AA@
	push	DWORD PTR [esi+3172]
	mov	esi, DWORD PTR __imp__TwAddButton@20
	call	esi

; 245  : 	
; 246  : 	mtwBarSinglePP = TwNewBar("Single Pass Select");

	push	OFFSET ??_C@_0BD@BGGKKCGG@Single?5Pass?5Select?$AA@
	call	DWORD PTR __imp__TwNewBar@4
	mov	ecx, DWORD PTR _this$1$[ebp]

; 247  : 	TwDefine(" 'Single Pass Select' position='210 5' ");

	push	OFFSET ??_C@_0CI@LLGGHJJD@?5?8Single?5Pass?5Select?8?5position?$DN?8@
	mov	DWORD PTR [ecx+3176], eax
	call	ebx

; 248  : 	TwAddButton(mtwBarSinglePP, "No PP", SetPP00, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP00@@YGXPAX@Z		; SetPP00
	push	OFFSET ??_C@_05BGDIAJAG@No?5PP?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 249  : 	TwAddButton(mtwBarSinglePP, "Tint", SetPP01, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP01@@YGXPAX@Z		; SetPP01
	push	OFFSET ??_C@_04LLHKIDLI@Tint?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 250  : 	TwAddButton(mtwBarSinglePP, "Shock", SetPP02, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP02@@YGXPAX@Z		; SetPP02
	push	OFFSET ??_C@_05MCLIDIMJ@Shock?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 251  : 	TwAddButton(mtwBarSinglePP, "Box Blur (3)", SetPP03, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP03@@YGXPAX@Z		; SetPP03
	push	OFFSET ??_C@_0N@DFJGHPEG@Box?5Blur?5?$CI3?$CJ?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 252  : 	TwAddButton(mtwBarSinglePP, "Box Blur (5)", SetPP04, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP04@@YGXPAX@Z		; SetPP04
	push	OFFSET ??_C@_0N@DBBLADPE@Box?5Blur?5?$CI5?$CJ?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 253  : 	TwAddButton(mtwBarSinglePP, "Box Blur (Custom)", SetPP05, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP05@@YGXPAX@Z		; SetPP05
	push	OFFSET ??_C@_0BC@BBINBACJ@Box?5Blur?5?$CICustom?$CJ?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 254  : 	TwAddButton(mtwBarSinglePP, "Double Vision", SetPP06, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP06@@YGXPAX@Z		; SetPP06
	push	OFFSET ??_C@_0O@OAINAAFK@Double?5Vision?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 255  : 	TwAddButton(mtwBarSinglePP, "Edges", SetPP07, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP07@@YGXPAX@Z		; SetPP07
	push	OFFSET ??_C@_05JBOFPIEK@Edges?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 256  : 	TwAddButton(mtwBarSinglePP, "Contrast", SetPP08, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP08@@YGXPAX@Z		; SetPP08
	push	OFFSET ??_C@_08KBHEFHNJ@Contrast?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 257  : 	TwAddButton(mtwBarSinglePP, "Jam on the screen", SetPP09, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP09@@YGXPAX@Z		; SetPP09
	push	OFFSET ??_C@_0BC@EACNFBOP@Jam?5on?5the?5screen?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 258  : 	TwAddButton(mtwBarSinglePP, "Invert", SetPP10, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP10@@YGXPAX@Z		; SetPP10
	push	OFFSET ??_C@_06OHLCGMJD@Invert?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 259  : 	TwAddButton(mtwBarSinglePP, "Solarise (Above)", SetPP11, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP11@@YGXPAX@Z		; SetPP11
	push	OFFSET ??_C@_0BB@OBDMAHBK@Solarise?5?$CIAbove?$CJ?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 260  : 	TwAddButton(mtwBarSinglePP, "Solarise (Below)", SetPP12, this, "");

	mov	eax, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	eax
	push	OFFSET ?SetPP12@@YGXPAX@Z		; SetPP12
	push	OFFSET ??_C@_0BB@LIMCDIOE@Solarise?5?$CIBelow?$CJ?$AA@
	push	DWORD PTR [eax+3176]
	call	esi

; 261  : 	TwAddSeparator(mtwBarSinglePP, "", "");

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	DWORD PTR [ecx+3176]
	call	edi

; 262  : 	TwAddButton(mtwBarSinglePP, "Toggle Gaussian Blur", SetGauss, this, "");

	mov	edi, DWORD PTR _this$1$[ebp]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	edi
	push	OFFSET ?SetGauss@@YGXPAX@Z		; SetGauss
	push	OFFSET ??_C@_0BF@FHPJJGJD@Toggle?5Gaussian?5Blur?$AA@
	push	DWORD PTR [edi+3176]
	call	esi

; 263  : 
; 264  : 	mtwBarMultiPP = TwNewBar("Multi Pass Controls");

	push	OFFSET ??_C@_0BE@DKPHBODF@Multi?5Pass?5Controls?$AA@
	call	DWORD PTR __imp__TwNewBar@4

; 265  : 	TwDefine(" 'Multi Pass Controls' position='415 5' size='300 320' ");

	push	OFFSET ??_C@_0DI@PFMGMAKO@?5?8Multi?5Pass?5Controls?8?5position?$DN@
	mov	DWORD PTR [edi+3180], eax
	call	ebx

; 266  : 	TwAddButton(mtwBarMultiPP, "Stop trying to hit me and hit me!", TWImpact, this, "");

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	edi
	push	OFFSET ?TWImpact@@YGXPAX@Z		; TWImpact
	push	OFFSET ??_C@_0CC@BOCCMAEA@Stop?5trying?5to?5hit?5me?5and?5hit?5me@
	push	DWORD PTR [edi+3180]
	call	esi
	pop	edi
	pop	esi

; 267  : 
; 268  : 	return true;

	mov	al, 1
	pop	ebx

; 269  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitATB@CScene@@QAE_NXZ ENDP				; CScene::InitATB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?InitPP@CScene@@QAE_NXZ
_TEXT	SEGMENT
_pErrors$ = -268					; size = 4
$T1 = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
?InitPP@CScene@@QAE_NXZ PROC				; CScene::InitPP, COMDAT
; _this$ = ecx

; 272  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 273  : 	mInitialTextureDesc.Width = mViewportWidth;

	mov	eax, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	push	esi
	mov	esi, ecx
	push	edi
	lea	edi, DWORD PTR [esi+2864]
	mov	DWORD PTR [edi], eax

; 274  : 	mInitialTextureDesc.Height = mViewportHeight;

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight

; 275  : 	mInitialTextureDesc.MipLevels = 1;
; 276  : 	mInitialTextureDesc.ArraySize = 1;
; 277  : 	mInitialTextureDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
; 278  : 	mInitialTextureDesc.SampleDesc.Count = 1;
; 279  : 	mInitialTextureDesc.SampleDesc.Quality = 0;
; 280  : 	mInitialTextureDesc.Usage = D3D10_USAGE_DEFAULT;
; 281  : 	mInitialTextureDesc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
; 282  : 	mInitialTextureDesc.CPUAccessFlags = 0;
; 283  : 	mInitialTextureDesc.MiscFlags = 0;
; 284  : 	if( FAILED( mpd3dDevice->CreateTexture2D( &mInitialTextureDesc, NULL, &mInitialTexture) ) ) return false;

	lea	edx, DWORD PTR [esi+2860]
	mov	ecx, DWORD PTR [esi]
	push	edx
	push	0
	mov	DWORD PTR [esi+2868], eax
	mov	DWORD PTR [esi+2872], 1
	mov	DWORD PTR [esi+2876], 1
	mov	DWORD PTR [esi+2880], 28		; 0000001cH
	mov	DWORD PTR [esi+2884], 1
	mov	DWORD PTR [esi+2888], 0
	mov	DWORD PTR [esi+2892], 0
	mov	DWORD PTR [esi+2896], 40		; 00000028H
	mov	DWORD PTR [esi+2900], 0
	mov	DWORD PTR [esi+2904], 0
	mov	eax, DWORD PTR [ecx]
	push	edi
	push	ecx
	call	DWORD PTR [eax+292]
	test	eax, eax
	jns	SHORT $LN12@InitPP
	pop	edi
	xor	al, al
	pop	esi

; 345  : 
; 346  : 	return true;
; 347  : 
; 348  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@InitPP:

; 285  : 	if (FAILED( mpd3dDevice->CreateTexture2D( &mInitialTextureDesc, NULL, &mTextureOne ) ) ) return false;

	mov	ecx, DWORD PTR [esi]
	push	ebx
	lea	ebx, DWORD PTR [esi+3044]
	push	ebx
	mov	eax, DWORD PTR [ecx]
	push	0
	push	edi
	push	ecx
	call	DWORD PTR [eax+292]
	test	eax, eax
	js	$LN1@InitPP

; 286  : 	if (FAILED( mpd3dDevice->CreateTexture2D( &mInitialTextureDesc, NULL, &mTextureTwo ) ) ) return false;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [esi+3048]
	push	edx
	push	0
	push	edi
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+292]
	test	eax, eax
	js	$LN1@InitPP

; 287  : 
; 288  : 	if( FAILED( mpd3dDevice->CreateRenderTargetView( mInitialTexture, NULL, &mInitialRenderTarget ) ) ) return false;

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [esi+2908]
	push	eax
	push	0
	push	DWORD PTR [esi+2860]
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+304]
	test	eax, eax
	js	$LN1@InitPP

; 289  : 	if (FAILED( mpd3dDevice->CreateRenderTargetView( mTextureOne, NULL, &mRenderTargetOne) ) ) return false;

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [esi+3052]
	push	eax
	push	0
	push	DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+304]
	test	eax, eax
	js	$LN1@InitPP

; 290  : 	if (FAILED( mpd3dDevice->CreateRenderTargetView( mTextureTwo, NULL, &mRenderTargetTwo) ) ) return false;

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [esi+3056]
	push	eax
	push	0
	push	DWORD PTR [esi+3048]
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+304]
	test	eax, eax
	js	$LN1@InitPP

; 291  : 
; 292  : 	mInitialShaderDesc.Format = mInitialTextureDesc.Format;

	mov	eax, DWORD PTR [esi+2880]
	lea	edi, DWORD PTR [esi+2916]

; 293  : 	mInitialShaderDesc.ViewDimension = D3D10_SRV_DIMENSION_TEXTURE2D;
; 294  : 	mInitialShaderDesc.Texture2D.MostDetailedMip = 0;
; 295  : 	mInitialShaderDesc.Texture2D.MipLevels = 1;
; 296  : 	if( FAILED( mpd3dDevice->CreateShaderResourceView( mInitialTexture, &mInitialShaderDesc, &mInitialShaderResource ) ) ) return false;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	lea	eax, DWORD PTR [esi+2912]
	push	eax
	push	edi
	push	DWORD PTR [esi+2860]
	mov	DWORD PTR [esi+2920], 4
	mov	DWORD PTR [esi+2924], 0
	mov	DWORD PTR [esi+2928], 1
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+300]
	test	eax, eax
	js	$LN1@InitPP

; 297  : 	if (FAILED( mpd3dDevice->CreateShaderResourceView( mTextureOne, &mInitialShaderDesc, &mTextureOneShader))) return false;

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [esi+3060]
	push	eax
	push	edi
	push	DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+300]
	test	eax, eax
	js	$LN1@InitPP

; 298  : 	if (FAILED( mpd3dDevice->CreateShaderResourceView( mTextureTwo, &mInitialShaderDesc, &mTextureTwoShader))) return false;

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [esi+3064]
	push	eax
	push	edi
	push	DWORD PTR [esi+3048]
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+300]
	test	eax, eax
	js	$LN1@InitPP

; 299  : 
; 300  : 	ID3D10Blob* pErrors; // This strangely typed variable collects any errors when compiling the effect file
; 301  : 	DWORD dwShaderFlags = D3D10_SHADER_ENABLE_STRICTNESS; // These "flags" are used to set the compiler options
; 302  : 
; 303  : 	// Load and compile the effect file
; 304  : 	HRESULT hr = D3DX10CreateEffectFromFile( L"PostProcess.fx", NULL, NULL, "fx_4_0", dwShaderFlags, 0, mpd3dDevice, NULL, NULL, &mPPEffect, &pErrors, NULL );

	push	0
	lea	eax, DWORD PTR _pErrors$[ebp]
	push	eax
	lea	edi, DWORD PTR [esi+2560]
	push	edi
	push	0
	push	0
	push	DWORD PTR [esi]
	push	0
	push	2048					; 00000800H
	push	OFFSET ??_C@_06BACILOGA@fx_4_0?$AA@
	push	0
	push	0
	push	OFFSET ??_C@_1BO@KFFLPJBB@?$AAP?$AAo?$AAs?$AAt?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AA?4?$AAf?$AAx?$AA?$AA@
	call	_D3DX10CreateEffectFromFileW@48

; 305  : 	if( FAILED( hr ) )

	test	eax, eax
	jns	$LN3@InitPP

; 307  : 		if (pErrors != 0)  MessageBox( NULL, CA2CT(reinterpret_cast<char*>(pErrors->GetBufferPointer())), L"Error", MB_OK ); // Compiler error: display error message

	mov	ecx, DWORD PTR _pErrors$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@InitPP
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h

; 352  : 	{

	lea	ecx, DWORD PTR $T1[ebp+4]

; 353  : 		Init( psz, _AtlGetConversionACP() );

	push	3
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	push	eax
	call	?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z	; ATL::CA2WEX<128>::Init
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 307  : 		if (pErrors != 0)  MessageBox( NULL, CA2CT(reinterpret_cast<char*>(pErrors->GetBufferPointer())), L"Error", MB_OK ); // Compiler error: display error message

	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	DWORD PTR $T1[ebp]
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h

; 165  : 	if( pBuff != pszFixedBuffer )

	mov	eax, DWORD PTR $T1[ebp]
	lea	ecx, DWORD PTR $T1[ebp+4]
	cmp	eax, ecx
	je	SHORT $LN1@InitPP

; 166  : 	{
; 167  : 		free( pBuff );

	push	eax
	call	_free
	add	esp, 4
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 309  : 		return false;

	xor	al, al
	pop	ebx
	pop	edi
	pop	esi

; 345  : 
; 346  : 	return true;
; 347  : 
; 348  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@InitPP:

; 308  : 		else               MessageBox( NULL, L"Error loading Post Processing FX file. Ensure your FX file is in the same folder as this executable.", L"Error", MB_OK );  // No error message - probably file not found

	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	OFFSET ??_C@_1MK@NLJNNCIH@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAP?$AAo?$AAs?$AAt?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX@
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
$LN1@InitPP:

; 309  : 		return false;

	pop	ebx
	pop	edi
	xor	al, al
	pop	esi

; 345  : 
; 346  : 	return true;
; 347  : 
; 348  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@InitPP:

; 310  : 	}
; 311  : 
; 312  : 	mPPTechniques[0]  = mPPEffect->GetTechniqueByName( "PPCopy" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_06JLNCKOOC@PPCopy?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2564], eax

; 313  : 	mPPTechniques[1]  = mPPEffect->GetTechniqueByName( "PPTint" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_06MPGPEKJL@PPTint?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2568], eax

; 314  : 	mPPTechniques[2]  = mPPEffect->GetTechniqueByName( "PPShock" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_07GAKLFMHC@PPShock?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2572], eax

; 315  : 	mPPTechniques[3]  = mPPEffect->GetTechniqueByName( "PPBoxBlur3" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0L@JCFHKKCO@PPBoxBlur3?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2576], eax

; 316  : 	mPPTechniques[4]  = mPPEffect->GetTechniqueByName( "PPBoxBlur5" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0L@MEANANKI@PPBoxBlur5?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2580], eax

; 317  : 	mPPTechniques[5]  = mPPEffect->GetTechniqueByName( "PPBoxBlurV" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0L@IKNNDFMM@PPBoxBlurV?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2584], eax

; 318  : 	mPPTechniques[6]  = mPPEffect->GetTechniqueByName( "PPDoubleVision" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0P@PBCAEHNN@PPDoubleVision?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2588], eax

; 319  : 	mPPTechniques[7]  = mPPEffect->GetTechniqueByName( "PPEdge" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_06DMINDEOL@PPEdge?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2592], eax

; 320  : 	mPPTechniques[8]  = mPPEffect->GetTechniqueByName( "PPContrast" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0L@ONFAKJPH@PPContrast?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2596], eax

; 321  : 	mPPTechniques[9]  = mPPEffect->GetTechniqueByName( "PPBlood" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_07NDCDMOCH@PPBlood?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2600], eax

; 322  : 	mPPTechniques[10] = mPPEffect->GetTechniqueByName( "PPInvert" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_08LLKDBFPD@PPInvert?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2604], eax

; 323  : 	mPPTechniques[11] = mPPEffect->GetTechniqueByName( "PPSolariseA" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0M@LHKPPOCI@PPSolariseA?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2608], eax

; 324  : 	mPPTechniques[12] = mPPEffect->GetTechniqueByName( "PPSolariseB" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0M@JMICKNOL@PPSolariseB?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2612], eax

; 325  : 
; 326  : 	mInitialTextureVar = mPPEffect->GetVariableByName( "InitialTexture" )->AsShaderResource();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0P@CCPNLBHC@InitialTexture?$AA@
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+56]
	mov	DWORD PTR [esi+2940], eax

; 327  : 	mPostProcessMapVar = mPPEffect->GetVariableByName( "BloodTexture" )->AsShaderResource();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0N@BCJCHFBA@BloodTexture?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+56]
	mov	DWORD PTR [esi+2956], eax

; 328  : 
; 329  : 	mdxPPTintColour = mPPEffect->GetVariableByName( "TintColour" )->AsVector();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0L@DBKDBEOO@TintColour?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+2988], eax

; 330  : 
; 331  : 	mdxPPShock = mPPEffect->GetVariableByName( "Shock" )->AsScalar();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_05MCLIDIMJ@Shock?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	mov	DWORD PTR [esi+2980], eax

; 332  : 
; 333  : 	mPPEffect->GetVariableByName( "PixelX" )->AsScalar()->SetFloat(1.0f/mViewportWidth);

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_06JIEINOID@PixelX?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	movd	xmm0, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	movss	xmm1, DWORD PTR __real@3f800000
	cvtdq2ps xmm0, xmm0
	mov	ecx, DWORD PTR [eax]
	push	ecx
	divss	xmm1, xmm0
	movss	DWORD PTR [esp], xmm1
	push	eax
	call	DWORD PTR [ecx+100]

; 334  : 	mPPEffect->GetVariableByName( "PixelY" )->AsScalar()->SetFloat(1.0f/mViewportHeight);

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_06IBFDOPMC@PixelY?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	movd	xmm0, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	movss	xmm1, DWORD PTR __real@3f800000
	cvtdq2ps xmm0, xmm0
	mov	ecx, DWORD PTR [eax]
	push	ecx
	divss	xmm1, xmm0
	movss	DWORD PTR [esp], xmm1
	push	eax
	call	DWORD PTR [ecx+100]

; 335  : 
; 336  : 	mdxBlurRadius = mPPEffect->GetVariableByName( "BlurRange" )->AsScalar();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_09MINFFJCE@BlurRange?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	mov	DWORD PTR [esi+3016], eax

; 337  : 
; 338  : 	mdxDoubleVisionRadius = mPPEffect->GetVariableByName( "DVRange" )->AsScalar();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_07BMPAAFHK@DVRange?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+40]
	mov	DWORD PTR [esi+3024], eax

; 339  : 
; 340  : 	mdxContrastFactor = mPPEffect->GetVariableByName( "Contrast" )->AsScalar();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_08KBHEFHNJ@Contrast?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	mov	DWORD PTR [esi+3036], eax

; 341  : 
; 342  : 	mdxBlood = mPPEffect->GetVariableByName( "Blood" )->AsScalar();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_05HBDAKKJM@Blood?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	mov	DWORD PTR [esi+2948], eax

; 343  : 
; 344  : 	mdxSolariseFloat = mPPEffect->GetVariableByName("SolariseThreshold")->AsScalar();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BC@KBOPGDGH@SolariseThreshold?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]

; 345  : 
; 346  : 	return true;
; 347  : 
; 348  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	ebx
	mov	DWORD PTR [esi+3080], eax
	xor	ecx, ebp
	pop	edi
	mov	al, 1
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?InitPP@CScene@@QAE_NXZ ENDP				; CScene::InitPP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?InitScene@CScene@@QAE_NXZ
_TEXT	SEGMENT
$T2 = -56						; size = 12
$T3 = -56						; size = 12
$T4 = -44						; size = 12
$T5 = -40						; size = 8
$T6 = -32						; size = 4
$T7 = -32						; size = 4
$T8 = -28						; size = 12
$T9 = -28						; size = 12
$T10 = -28						; size = 12
$T11 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?InitScene@CScene@@QAE_NXZ PROC				; CScene::InitScene, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InitScene@CScene@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 60   : 	Camera = new CCamera();

	push	304					; 00000130H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T7[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	xorps	xmm1, xmm1
	test	edx, edx
	je	SHORT $LN22@InitScene
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T4[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 60   : 	Camera = new CCamera();

	mov	eax, DWORD PTR $T4[ebp+8]
	mov	ecx, esp
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T11[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 60   : 	Camera = new CCamera();

	unpcklps xmm0, xmm1
	mov	DWORD PTR [esp+20], 1176256512		; 461c4000H
	mov	DWORD PTR [esp+16], 1036831949		; 3dcccccdH
	mov	DWORD PTR [esp+12], 1061752795		; 3f490fdbH
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T11[ebp+8]
	unpcklps xmm1, xmm1
	movq	QWORD PTR [ecx], xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z	; CCamera::CCamera
	mov	ecx, eax
	jmp	SHORT $LN23@InitScene
$LN22@InitScene:
	xor	ecx, ecx
$LN23@InitScene:
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm1, DWORD PTR __real@c1700000

; 322  :     y = fy;

	movss	xmm0, DWORD PTR __real@41a00000
	mov	DWORD PTR [esi+4], ecx
; File c:\users\simon\documents\github\post-processing\camera.h

; 100  : 		m_Position = position;

	unpcklps xmm1, xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 322  :     y = fy;

	movss	xmm0, DWORD PTR __real@3ea0d97c
; File c:\users\simon\documents\github\post-processing\camera.h

; 100  : 		m_Position = position;

	movq	QWORD PTR [ecx+8], xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm1, DWORD PTR __real@3e685697

; 323  :     z = fz;

	mov	DWORD PTR $T10[ebp+8], -1038090240	; c2200000H
; File c:\users\simon\documents\github\post-processing\camera.h

; 100  : 		m_Position = position;

	mov	eax, DWORD PTR $T10[ebp+8]
	mov	DWORD PTR [ecx+16], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 62   : 	Camera->SetRotation( D3DXVECTOR3(ToRadians(13.0f), ToRadians(18.0f), 0.0f) ); // ToRadians is a new helper function to convert degrees to radians

	mov	ecx, DWORD PTR [esi+4]
; File c:\users\simon\documents\github\post-processing\camera.h

; 104  : 		m_Rotation = rotation;

	unpcklps xmm1, xmm0

; 112  : 		m_NearClip = nearClip;

	movss	xmm0, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T9[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\camera.h

; 104  : 		m_Rotation = rotation;

	mov	eax, DWORD PTR $T9[ebp+8]
	movq	QWORD PTR [ecx+20], xmm1
	mov	DWORD PTR [ecx+28], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 63   : 	Camera->SetNearClip( 1.0f );

	mov	eax, DWORD PTR [esi+4]

; 66   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"StoneDiffuseSpecular.dds",		NULL, NULL, &mpMaps[0],  NULL ) )) return false;

	push	0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\simon\documents\github\post-processing\camera.h

; 112  : 		m_NearClip = nearClip;

	movq	QWORD PTR $T5[ebp], xmm0
	mov	DWORD PTR [eax+36], 1065353216		; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 66   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"StoneDiffuseSpecular.dds",		NULL, NULL, &mpMaps[0],  NULL ) )) return false;

	lea	eax, DWORD PTR [esi+936]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DC@LOBNDLGH@?$AAS?$AAt?$AAo?$AAn?$AAe?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	jns	SHORT $LN19@InitScene
$LN59@InitScene:
	xor	al, al
	jmp	$LN1@InitScene
$LN19@InitScene:

; 67   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"WoodDiffuseSpecular.dds",		NULL, NULL, &mpMaps[1],  NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+940]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DA@IEJEKIPL@?$AAW?$AAo?$AAo?$AAd?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	SHORT $LN59@InitScene

; 68   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Moon.jpg",						NULL, NULL, &mpMaps[2],  NULL ) )) return false; 

	push	0
	lea	eax, DWORD PTR [esi+944]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1BC@MACPKMCG@?$AAM?$AAo?$AAo?$AAn?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	SHORT $LN59@InitScene

; 69   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"WallDiffuseSpecular.dds",		NULL, NULL, &mpMaps[3],  NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+948]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DA@GABNFLNL@?$AAW?$AAa?$AAl?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	SHORT $LN59@InitScene

; 70   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"WallNormalDepth.dds",			NULL, NULL, &mpMaps[4],  NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+952]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1CI@HJHILCKN@?$AAW?$AAa?$AAl?$AAl?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	SHORT $LN59@InitScene

; 71   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"MetalDiffuseSpecular.dds",		NULL, NULL, &mpMaps[5],  NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+956]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DC@DJHFCGLD@?$AAM?$AAe?$AAt?$AAa?$AAl?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 72   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"PatternDiffuseSpecular.dds",		NULL, NULL, &mpMaps[6],  NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+960]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DG@GOOKDEDK@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 73   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"PatternNormalDepth.dds",			NULL, NULL, &mpMaps[7],  NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+964]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1CO@NOLHING@?$AAP?$AAa?$AAt?$AAt?$AAe?$AAr?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 74   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Glass.jpg",						NULL, NULL, &mpMaps[8],  NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+968]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1BE@DADLEHEK@?$AAG?$AAl?$AAa?$AAs?$AAs?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 75   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Troll1DiffuseSpecular.dds",		NULL, NULL, &mpMaps[9],  NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+972]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DE@DFEKPPGN@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA1?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 76   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Troll2DiffuseSpecular.dds",		NULL, NULL, &mpMaps[10], NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+976]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DE@NHBHEBO@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA2?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 77   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Troll3DiffuseSpecular.dds",		NULL, NULL, &mpMaps[11], NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+980]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DE@KMEIPAPA@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA3?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 78   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Troll4DiffuseSpecular.dds",		NULL, NULL, &mpMaps[12], NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+984]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DE@HNAGGCPI@?$AAT?$AAr?$AAo?$AAl?$AAl?$AA4?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 79   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"BrainDiffuseSpecular.dds",		NULL, NULL, &mpMaps[13], NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+988]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1DC@ONLGGDNI@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAD?$AAi?$AAf?$AAf?$AAu?$AAs?$AAe?$AAS?$AAp?$AAe?$AAc?$AAu?$AAl?$AAa?$AAr?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 80   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"BrainNormalDepth.dds",			NULL, NULL, &mpMaps[14], NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+992]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1CK@IHOPDIJ@?$AAB?$AAr?$AAa?$AAi?$AAn?$AAN?$AAo?$AAr?$AAm?$AAa?$AAl?$AAD?$AAe?$AAp?$AAt?$AAh?$AA?4?$AAd?$AAd?$AAs?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 81   : 	if (FAILED( D3DX10CreateShaderResourceViewFromFile( mpd3dDevice, L"Blood.jpg",                      NULL, NULL, &mpMaps[15], NULL ) )) return false;

	push	0
	lea	eax, DWORD PTR [esi+996]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_1BE@PPEMIMM@?$AAB?$AAl?$AAo?$AAo?$AAd?$AA?4?$AAj?$AAp?$AAg?$AA?$AA@
	push	DWORD PTR [esi]
	call	_D3DX10CreateShaderResourceViewFromFileW@24
	test	eax, eax
	js	$LN59@InitScene

; 85   : 	mpObjects[0] = new CRenderObject("Mirror.x",	D3DXVECTOR3( -20, 30, 0 ),		D3DXVECTOR3(0.2f, 0.2f, 0.3f), mTechniquesMirror[18], mTechniquesMirror[19], NULL, NULL, false, false, false);

	push	72					; 00000048H
	mov	DWORD PTR [esi+2536], 16		; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T6[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	edx, edx
	je	SHORT $LN24@InitScene
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm1, DWORD PTR __real@3e4ccccd
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 85   : 	mpObjects[0] = new CRenderObject("Mirror.x",	D3DXVECTOR3( -20, 30, 0 ),		D3DXVECTOR3(0.2f, 0.2f, 0.3f), mTechniquesMirror[18], mTechniquesMirror[19], NULL, NULL, false, false, false);

	push	0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm2, DWORD PTR __real@c1a00000

; 322  :     y = fy;

	movss	xmm0, DWORD PTR __real@41f00000
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 85   : 	mpObjects[0] = new CRenderObject("Mirror.x",	D3DXVECTOR3( -20, 30, 0 ),		D3DXVECTOR3(0.2f, 0.2f, 0.3f), mTechniquesMirror[18], mTechniquesMirror[19], NULL, NULL, false, false, false);

	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR [esi+2812]
	unpcklps xmm1, xmm1
	push	DWORD PTR [esi+2808]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T8[ebp+8], 1050253722	; 3e99999aH
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 85   : 	mpObjects[0] = new CRenderObject("Mirror.x",	D3DXVECTOR3( -20, 30, 0 ),		D3DXVECTOR3(0.2f, 0.2f, 0.3f), mTechniquesMirror[18], mTechniquesMirror[19], NULL, NULL, false, false, false);

	mov	eax, DWORD PTR $T8[ebp+8]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	unpcklps xmm2, xmm0
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T3[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 85   : 	mpObjects[0] = new CRenderObject("Mirror.x",	D3DXVECTOR3( -20, 30, 0 ),		D3DXVECTOR3(0.2f, 0.2f, 0.3f), mTechniquesMirror[18], mTechniquesMirror[19], NULL, NULL, false, false, false);

	movq	QWORD PTR [ecx], xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T3[ebp+8]
	push	OFFSET ??_C@_08MLPDMJMG@Mirror?4x?$AA@
	movq	QWORD PTR [ecx], xmm2
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	jmp	SHORT $LN25@InitScene
$LN24@InitScene:
	xor	eax, eax
$LN25@InitScene:
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 322  :     y = fy;

	movss	xmm0, DWORD PTR __real@40000000
; File c:\users\simon\documents\github\post-processing\model.h

; 111  : 		m_Rotation = rotation;

	movq	xmm1, QWORD PTR $T5[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	ecx, DWORD PTR [eax]
	unpcklps xmm1, xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T2[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\model.h

; 111  : 		m_Rotation = rotation;

	mov	eax, DWORD PTR $T2[ebp+8]
	movq	QWORD PTR [ecx+20], xmm1
	mov	DWORD PTR [ecx+28], eax
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	ecx, DWORD PTR [esi+8]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 85   : 	mpObjects[0] = new CRenderObject("Mirror.x",	D3DXVECTOR3( -20, 30, 0 ),		D3DXVECTOR3(0.2f, 0.2f, 0.3f), mTechniquesMirror[18], mTechniquesMirror[19], NULL, NULL, false, false, false);

	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 86   : 	mpObjects[0]->GetModel()->SetRotation( D3DXVECTOR3(1, 2, 0)  );
; 87   : 	mpObjects[0]->GetModel()->UpdateMatrix();

	mov	ecx, DWORD PTR [ecx]
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 88   : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 89   : 
; 90   : 	//Load items for basic pass
; 91   : 	if(! BasicItems() ) return false;

	mov	ecx, esi
	call	?BasicItems@CScene@@AAE_NXZ		; CScene::BasicItems
	test	al, al
	je	$LN59@InitScene

; 92   : 	//Load test objects
; 93   : 	if(! TestItems() ) return false;

	mov	ecx, esi
	call	?TestItems@CScene@@AAE_NXZ		; CScene::TestItems
	test	al, al
	je	$LN59@InitScene

; 94   : 	//Load diarama
; 95   : 	if(! SceneItems() ) return false;

	mov	ecx, esi
	call	?SceneItems@CScene@@AAE_NXZ		; CScene::SceneItems
	test	al, al
	setne	al
$LN1@InitScene:

; 96   : 
; 97   : 	
; 98   : 	return true;
; 99   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitScene@CScene@@QAE_NXZ$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?InitScene@CScene@@QAE_NXZ$1:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InitScene@CScene@@QAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InitScene@CScene@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitScene@CScene@@QAE_NXZ ENDP				; CScene::InitScene
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?LoadEffectFile@CScene@@QAE_NXZ
_TEXT	SEGMENT
_pErrors$ = -268					; size = 4
$T1 = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
?LoadEffectFile@CScene@@QAE_NXZ PROC			; CScene::LoadEffectFile, COMDAT
; _this$ = ecx

; 1144 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1145 : 	ID3D10Blob* pErrors; // This strangely typed variable collects any errors when compiling the effect file
; 1146 : 	DWORD dwShaderFlags = D3D10_SHADER_ENABLE_STRICTNESS; // These "flags" are used to set the compiler options
; 1147 : 
; 1148 : 	// Load and compile the effect file
; 1149 : 	HRESULT hr = D3DX10CreateEffectFromFile( L"GraphicsAssign1.fx", NULL, NULL, "fx_4_0", dwShaderFlags, 0, mpd3dDevice, NULL, NULL, &Effect, &pErrors, NULL );

	push	0
	mov	esi, ecx
	lea	eax, DWORD PTR _pErrors$[ebp]
	push	eax
	lea	edi, DWORD PTR [esi+2556]
	push	edi
	push	0
	push	0
	push	DWORD PTR [esi]
	push	0
	push	2048					; 00000800H
	push	OFFSET ??_C@_06BACILOGA@fx_4_0?$AA@
	push	0
	push	0
	push	OFFSET ??_C@_1CG@MCKIKNIO@?$AAG?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AAs?$AAA?$AAs?$AAs?$AAi?$AAg?$AAn?$AA1?$AA?4?$AAf?$AAx?$AA?$AA@
	call	_D3DX10CreateEffectFromFileW@48

; 1150 : 	if( FAILED( hr ) )

	test	eax, eax
	jns	$LN3@LoadEffect

; 1152 : 		if (pErrors != 0)  MessageBox( NULL, CA2CT(reinterpret_cast<char*>(pErrors->GetBufferPointer())), L"Error", MB_OK ); // Compiler error: display error message

	mov	ecx, DWORD PTR _pErrors$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@LoadEffect
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h

; 352  : 	{

	lea	ecx, DWORD PTR $T1[ebp+4]

; 353  : 		Init( psz, _AtlGetConversionACP() );

	push	3
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	push	eax
	call	?Init@?$CA2WEX@$0IA@@ATL@@AAEXPBDI@Z	; ATL::CA2WEX<128>::Init
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1152 : 		if (pErrors != 0)  MessageBox( NULL, CA2CT(reinterpret_cast<char*>(pErrors->GetBufferPointer())), L"Error", MB_OK ); // Compiler error: display error message

	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	DWORD PTR $T1[ebp]
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h

; 165  : 	if( pBuff != pszFixedBuffer )

	mov	eax, DWORD PTR $T1[ebp]
	lea	ecx, DWORD PTR $T1[ebp+4]
	cmp	eax, ecx
	je	SHORT $LN1@LoadEffect

; 166  : 	{
; 167  : 		free( pBuff );

	push	eax
	call	_free
	add	esp, 4
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1154 : 		return false;

	xor	al, al
	pop	edi
	pop	esi

; 1230 : 
; 1231 : 	return true;
; 1232 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@LoadEffect:

; 1153 : 		else               MessageBox( NULL, L"Error loading FX file. Ensure your FX file is in the same folder as this executable.", L"Error", MB_OK );  // No error message - probably file not found

	push	0
	push	OFFSET ??_C@_1M@ILHOPKA@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?$AA@
	push	OFFSET ??_C@_1KK@KKJBPFMN@?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?5?$AAl?$AAo?$AAa?$AAd?$AAi?$AAn?$AAg?$AA?5?$AAF?$AAX?$AA?5?$AAf?$AAi?$AAl?$AAe?$AA?4?$AA?5?$AAE?$AAn?$AAs?$AAu?$AAr?$AAe?$AA?5?$AAy?$AAo@
	push	0
	call	DWORD PTR __imp__MessageBoxW@16
$LN1@LoadEffect:

; 1154 : 		return false;

	pop	edi
	xor	al, al
	pop	esi

; 1230 : 
; 1231 : 	return true;
; 1232 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@LoadEffect:

; 1155 : 	}
; 1156 : 
; 1157 : 	// Now we can select techniques from the compiled effect file
; 1158 : 	// Regular techniques for the main scene
; 1159 : 	mTechniques[ 0]	= Effect->GetTechniqueByName( "tPlainColour" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0N@BLACAFBJ@tPlainColour?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2616], eax

; 1160 : 	mTechniques[ 1]	= Effect->GetTechniqueByName( "tPlainTexture" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0O@CBIDLEEF@tPlainTexture?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2620], eax

; 1161 : 	mTechniques[ 2]	= Effect->GetTechniqueByName( "tColourChangeTexture" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BF@HOFAMMJK@tColourChangeTexture?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2624], eax

; 1162 : 	mTechniques[ 3]	= Effect->GetTechniqueByName( "tLitTexture" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0M@PFGJBPP@tLitTexture?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2628], eax

; 1163 : 	mTechniques[ 4]	= Effect->GetTechniqueByName( "t4LitTexture" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0N@DBNJLAPA@t4LitTexture?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2632], eax

; 1164 : 	mTechniques[ 5] = Effect->GetTechniqueByName( "t4LitAttenTexture" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BC@EBBNGCN@t4LitAttenTexture?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2636], eax

; 1165 : 	mTechniques[ 6]	= Effect->GetTechniqueByName( "t4LitSpecularMap" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BB@NDOCHMBG@t4LitSpecularMap?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2640], eax

; 1166 : 	mTechniques[ 7]	= Effect->GetTechniqueByName( "tParallaxMap" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0N@FAEPMAEM@tParallaxMap?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2644], eax

; 1167 : 	mTechniques[ 8]	= Effect->GetTechniqueByName( "tJelly" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_06ELGFLNMO@tJelly?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2648], eax

; 1168 : 	mTechniques[ 9]	= Effect->GetTechniqueByName( "tCellShading" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0N@HPAFDOEN@tCellShading?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2652], eax

; 1169 : 	mTechniques[10] = Effect->GetTechniqueByName( "tCellShadingWrong" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BC@IHNCMDEH@tCellShadingWrong?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2656], eax

; 1170 : 	mTechniques[11] = Effect->GetTechniqueByName( "tHalo" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_05JGDPNHEJ@tHalo?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2660], eax

; 1171 : 	mTechniques[12] = Effect->GetTechniqueByName( "tSpaceHaloPara" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0P@FEDIONCO@tSpaceHaloPara?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2664], eax

; 1172 : 	mTechniques[13] = Effect->GetTechniqueByName( "tSpaceOutlinePara" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BC@NABDBAIK@tSpaceOutlinePara?$AA@
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2668], eax

; 1173 : 	mTechniques[14] = Effect->GetTechniqueByName( "tLitGlass" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_09JDFCMBBC@tLitGlass?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2672], eax

; 1174 : 	mTechniques[15] = Effect->GetTechniqueByName( "tSpaceHalo" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0L@MOJEDPIK@tSpaceHalo?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2676], eax

; 1175 : 	mTechniques[16] = Effect->GetTechniqueByName( "tSpaceOutline" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0O@GOICGJFK@tSpaceOutline?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2680], eax

; 1176 : 	mTechniques[17] = Effect->GetTechniqueByName( "tTextureMorph" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0O@CIOABDO@tTextureMorph?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2684], eax

; 1177 : 	mTechniques[18] = Effect->GetTechniqueByName( "MirrorClear" );		//added to both just to keep the enum consistant.

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0M@NCEALFAM@MirrorClear?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2688], eax

; 1178 : 	mTechniques[19] = Effect->GetTechniqueByName( "MirrorSurface" );	

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0O@CFAHMOKA@MirrorSurface?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2692], eax

; 1179 : 	miNumTechniques = 20;
; 1180 : 
; 1181 : 	// Techniques for the mirrored objects
; 1182 : 	mTechniquesMirror[ 0] = Effect->GetTechniqueByName( "tPlainColourMirror" );

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+2856], 20		; 00000014H
	push	OFFSET ??_C@_0BD@EAMCFOMD@tPlainColourMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2736], eax

; 1183 : 	mTechniquesMirror[ 1] = Effect->GetTechniqueByName( "tPlainTextureMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BE@GKDAAGPD@tPlainTextureMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2740], eax

; 1184 : 	mTechniquesMirror[ 2] = Effect->GetTechniqueByName( "tColourChangeTextureMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BL@BDPLHMPN@tColourChangeTextureMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2744], eax

; 1185 : 	mTechniquesMirror[ 3] = Effect->GetTechniqueByName( "tLitTextureMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BC@PLBJLENF@tLitTextureMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2748], eax

; 1186 : 	mTechniquesMirror[ 4] = Effect->GetTechniqueByName( "t4LitTextureMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BD@GNCBGOED@t4LitTextureMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2752], eax

; 1187 : 	mTechniquesMirror[ 5] = Effect->GetTechniqueByName( "t4LitAttenTextureMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BI@EEKKACMN@t4LitAttenTextureMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2756], eax

; 1188 : 	mTechniquesMirror[ 6] = Effect->GetTechniqueByName( "t4LitSpecularMapMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BH@MJFOIGI@t4LitSpecularMapMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2760], eax

; 1189 : 	mTechniquesMirror[ 7] = Effect->GetTechniqueByName( "tParallaxMapMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BD@CIMFECON@tParallaxMapMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2764], eax

; 1190 : 	mTechniquesMirror[ 8] = Effect->GetTechniqueByName( "tJellyMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0N@KFADNAIL@tJellyMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2768], eax

; 1191 : 	mTechniquesMirror[ 9] = Effect->GetTechniqueByName( "tCellShadingMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BD@NDCFMGPA@tCellShadingMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2772], eax

; 1192 : 	mTechniquesMirror[10] = Effect->GetTechniqueByName( "tCellShadingWrongMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BI@MCEONCDC@tCellShadingWrongMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2776], eax

; 1193 : 	mTechniquesMirror[11] = Effect->GetTechniqueByName( "tHaloMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0M@FENFNCKC@tHaloMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2780], eax

; 1194 : 	mTechniquesMirror[12] = Effect->GetTechniqueByName( "tSpaceHaloParaMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BF@KFEJDHPA@tSpaceHaloParaMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2784], eax

; 1195 : 	mTechniquesMirror[13] = Effect->GetTechniqueByName( "tSpaceOutlineParaMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BI@GGPGLIH@tSpaceOutlineParaMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2788], eax

; 1196 : 	mTechniquesMirror[14] = Effect->GetTechniqueByName( "tLitGlassMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BA@BCLLKFIB@tLitGlassMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2792], eax

; 1197 : 	mTechniquesMirror[15] = Effect->GetTechniqueByName( "tSpaceHaloMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BB@CDMINDKK@tSpaceHaloMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2796], eax

; 1198 : 	mTechniquesMirror[16] = Effect->GetTechniqueByName( "tSpaceOutlineMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BE@CKKPKAMN@tSpaceOutlineMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2800], eax

; 1199 : 	mTechniquesMirror[17] = Effect->GetTechniqueByName( "tTextureMorphMirror" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BE@BLJDFMPB@tTextureMorphMirror?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2804], eax

; 1200 : 	mTechniquesMirror[18] = Effect->GetTechniqueByName( "MirrorClear" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0M@NCEALFAM@MirrorClear?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2808], eax

; 1201 : 	mTechniquesMirror[19] = Effect->GetTechniqueByName( "MirrorSurface" );

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0O@CFAHMOKA@MirrorSurface?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+52]
	mov	DWORD PTR [esi+2812], eax

; 1202 : 
; 1203 : 	// Create special variables to allow us to access global variables in the shaders from C++
; 1204 : 	WorldMatrixVar		= Effect->GetVariableByName( "WorldMatrix" )->AsMatrix();

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax]
	push	OFFSET ??_C@_0M@JIFPIELG@WorldMatrix?$AA@
	push	eax
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	mov	DWORD PTR [esi+3088], eax

; 1205 : 	ViewMatrixVar		= Effect->GetVariableByName( "ViewMatrix"  )->AsMatrix();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0L@BCBAMPKD@ViewMatrix?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	mov	DWORD PTR [esi+3092], eax

; 1206 : 	ProjMatrixVar		= Effect->GetVariableByName( "ProjMatrix"  )->AsMatrix();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0L@FHHLNBJL@ProjMatrix?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
	mov	DWORD PTR [esi+3096], eax

; 1207 : 
; 1208 : 	// We access the texture variable in the shader in the same way as we have before for matrices, light data etc.
; 1209 : 	// Only difference is that this variable is a "Shader Resource"
; 1210 : 	DiffuseMapVar = Effect->GetVariableByName( "DiffuseMap" )->AsShaderResource();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0L@ILIGHKAJ@DiffuseMap?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+56]
	mov	DWORD PTR [esi+3104], eax

; 1211 : 	NormalMapVar = Effect->GetVariableByName( "NormalMap" )->AsShaderResource();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_09ILPGELJF@NormalMap?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+56]
	mov	DWORD PTR [esi+3108], eax

; 1212 : 
; 1213 : 	//Camera Position
; 1214 : 	dxCameraPos = Effect->GetVariableByName( "cameraPos" )->AsVector();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_09JBPBDAII@cameraPos?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+3120], eax

; 1215 : 
; 1216 : 	// Other shader variables
; 1217 : 	ModelColourVar = Effect->GetVariableByName( "ModelColour"  )->AsVector();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0M@FMIDCGNI@ModelColour?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+3112], eax

; 1218 : 
; 1219 : 	//Lighting Values
; 1220 : 	dxLightPosA = Effect->GetVariableByName( "lightPos" )->AsVector();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_08EGHFDCKI@lightPos?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+3116], eax

; 1221 : 	dxLightColourA = Effect->GetVariableByName( "lightColour" )->AsVector();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0M@ICIEANMG@lightColour?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+3124], eax

; 1222 : 	dxLightBrightnessA = Effect->GetVariableByName( "lightBright" )->AsVector();

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax]
	push	OFFSET ??_C@_0M@NEELCHAN@lightBright?$AA@
	push	eax
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+3132], eax

; 1223 : 	
; 1224 : 	dxAmbientColour = Effect->GetVariableByName( "ambientColour" )->AsVector();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0O@OODJBMLI@ambientColour?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]
	mov	DWORD PTR [esi+3128], eax

; 1225 : 
; 1226 : 	dxWiggle = Effect->GetVariableByName( "wiggle" )->AsScalar();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_06LAADFJPH@wiggle?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	mov	DWORD PTR [esi+3136], eax

; 1227 : 	dxOutlineThickness = Effect->GetVariableByName( "OutlineThickness" )->AsScalar();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_0BB@HDLHOHKD@OutlineThickness?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	mov	DWORD PTR [esi+3140], eax

; 1228 : 
; 1229 : 	ClipPlaneVar      = Effect->GetVariableByName( "ClipPlane"      )->AsVector();

	mov	eax, DWORD PTR [edi]
	push	OFFSET ??_C@_09HJHGEJDE@ClipPlane?$AA@
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+40]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]

; 1230 : 
; 1231 : 	return true;
; 1232 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	DWORD PTR [esi+3144], eax
	xor	ecx, ebp
	pop	edi
	mov	al, 1
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadEffectFile@CScene@@QAE_NXZ ENDP			; CScene::LoadEffectFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?ReleaseResources@CScene@@QAEXXZ
_TEXT	SEGMENT
tv600 = -4						; size = 4
tv599 = -4						; size = 4
?ReleaseResources@CScene@@QAEXXZ PROC			; CScene::ReleaseResources, COMDAT
; _this$ = ecx

; 1100 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 1101 : 	// The D3D setup and preparation of the geometry created several objects that use up memory (e.g. textures, vertex/index buffers etc.)
; 1102 : 	// Each object that allocates memory (or hardware resources) needs to be "released" when we exit the program
; 1103 : 	// There is similar code in every D3D program, but the list of objects that need to be released depends on what was created
; 1104 : 	// Test each variable to see if it exists before deletion
; 1105 : 	if( mpd3dDevice )     mpd3dDevice->ClearState();

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN17@ReleaseRes
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+276]
$LN17@ReleaseRes:

; 1106 : 
; 1107 : 	delete Camera;

	push	ebx
	push	edi
	push	DWORD PTR [esi+4]
	call	??3@YAXPAX@Z				; operator delete

; 1108 : 
; 1109 : 	for(int i = 0; i < miNumObjects; i++)

	xor	ebx, ebx
	add	esp, 4
	cmp	DWORD PTR [esi+808], ebx
	jle	SHORT $LN14@ReleaseRes

; 1106 : 
; 1107 : 	delete Camera;

	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR tv600[ebp], eax
$LL16@ReleaseRes:

; 1110 : 	{
; 1111 : 		delete mpObjects[i];

	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN15@ReleaseRes
	mov	ecx, edi
	call	??1CRenderObject@@QAE@XZ		; CRenderObject::~CRenderObject
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR tv600[ebp]
	add	esp, 4
$LN15@ReleaseRes:

; 1108 : 
; 1109 : 	for(int i = 0; i < miNumObjects; i++)

	inc	ebx
	add	eax, 4
	mov	DWORD PTR tv600[ebp], eax
	cmp	ebx, DWORD PTR [esi+808]
	jl	SHORT $LL16@ReleaseRes
$LN14@ReleaseRes:

; 1112 : 	}
; 1113 : 
; 1114 : 	for(int i = 0; i < miNumLights; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+932], ebx
	jle	SHORT $LN11@ReleaseRes
	lea	eax, DWORD PTR [esi+812]
	mov	DWORD PTR tv599[ebp], eax
	npad	2
$LL13@ReleaseRes:

; 1115 : 	{
; 1116 : 		delete mpLights[i];

	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN12@ReleaseRes
	mov	ecx, edi
	call	??1CLight@@QAE@XZ			; CLight::~CLight
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR tv599[ebp]
	add	esp, 4
$LN12@ReleaseRes:

; 1112 : 	}
; 1113 : 
; 1114 : 	for(int i = 0; i < miNumLights; i++)

	inc	ebx
	add	eax, 4
	mov	DWORD PTR tv599[ebp], eax
	cmp	ebx, DWORD PTR [esi+932]
	jl	SHORT $LL13@ReleaseRes
$LN11@ReleaseRes:

; 1117 : 	}
; 1118 : 	
; 1119 : 	for(int i = 0; i < miNumMaps; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+2536], edi
	jle	SHORT $LN8@ReleaseRes
	lea	ebx, DWORD PTR [esi+936]
$LL10@ReleaseRes:

; 1120 : 	{
; 1121 : 		if ( mpMaps[i] )

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN9@ReleaseRes

; 1122 : 			mpMaps[i]->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN9@ReleaseRes:

; 1117 : 	}
; 1118 : 	
; 1119 : 	for(int i = 0; i < miNumMaps; i++)

	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR [esi+2536]
	jl	SHORT $LL10@ReleaseRes
$LN8@ReleaseRes:

; 1123 : 	}
; 1124 : 
; 1125 : 	if( Effect )           Effect->Release();

	mov	ecx, DWORD PTR [esi+2556]
	pop	edi
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN6@ReleaseRes
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN6@ReleaseRes:

; 1126 : 	if( DepthStencilView ) DepthStencilView->Release();

	mov	ecx, DWORD PTR [esi+3156]
	test	ecx, ecx
	je	SHORT $LN5@ReleaseRes
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN5@ReleaseRes:

; 1127 : 	if( RenderTargetView ) RenderTargetView->Release();

	mov	ecx, DWORD PTR [esi+3160]
	test	ecx, ecx
	je	SHORT $LN4@ReleaseRes
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@ReleaseRes:

; 1128 : 	if( DepthStencil )     DepthStencil->Release();

	mov	ecx, DWORD PTR [esi+3152]
	test	ecx, ecx
	je	SHORT $LN3@ReleaseRes
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN3@ReleaseRes:

; 1129 : 	if( SwapChain )        SwapChain->Release();

	mov	ecx, DWORD PTR [esi+3148]
	test	ecx, ecx
	je	SHORT $LN2@ReleaseRes
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@ReleaseRes:

; 1130 : 	if( mpd3dDevice )     mpd3dDevice->Release();

	mov	ecx, DWORD PTR [esi]
	pop	esi
	test	ecx, ecx
	je	SHORT $LN1@ReleaseRes
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN1@ReleaseRes:

; 1131 : 
; 1132 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ReleaseResources@CScene@@QAEXXZ ENDP			; CScene::ReleaseResources
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?InitDevice@CScene@@QAE_NXZ
_TEXT	SEGMENT
_descDSV$ = -172					; size = 20
_pBackBuffer$ = -152					; size = 4
_sd$ = -148						; size = 60
_vp$ = -88						; size = 24
_descDepth$ = -64					; size = 44
_rc$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?InitDevice@CScene@@QAE_NXZ PROC			; CScene::InitDevice, COMDAT
; _this$ = ecx

; 1003 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx

; 1004 : 	// Many DirectX functions return a "HRESULT" variable to indicate success or failure. Microsoft code often uses
; 1005 : 	// the FAILED macro to test this variable, you'll see it throughout the code - it's fairly self explanatory.
; 1006 : 	HRESULT hr = S_OK;
; 1007 : 
; 1008 : 
; 1009 : 	////////////////////////////////
; 1010 : 	// Initialise Direct3D
; 1011 : 
; 1012 : 	// Calculate the visible area the window we are using - the "client rectangle" refered to in the first function is the 
; 1013 : 	// size of the interior of the window, i.e. excluding the frame and title
; 1014 : 	RECT rc;
; 1015 : 	GetClientRect( HWnd, &rc );

	lea	eax, DWORD PTR _rc$[ebp]
	push	eax
	push	DWORD PTR [ebx+3168]
	call	DWORD PTR __imp__GetClientRect@8

; 1016 : 	mViewportWidth = rc.right - rc.left;

	mov	edi, DWORD PTR _rc$[ebp+8]

; 1017 : 	mViewportHeight = rc.bottom - rc.top;
; 1018 : 
; 1019 : 
; 1020 : 	// Create a Direct3D device (i.e. initialise D3D), and create a swap-chain (create a back buffer to render to)
; 1021 : 	DXGI_SWAP_CHAIN_DESC sd;         // Structure to contain all the information needed
; 1022 : 	ZeroMemory( &sd, sizeof( sd ) ); // Clear the structure to 0 - common Microsoft practice, not really good style

	lea	eax, DWORD PTR _sd$[ebp]
	mov	esi, DWORD PTR _rc$[ebp+12]
	sub	edi, DWORD PTR _rc$[ebp]
	sub	esi, DWORD PTR _rc$[ebp+4]
	push	60					; 0000003cH
	push	0
	push	eax
	mov	DWORD PTR ?mViewportWidth@CScene@@0HA, edi ; CScene::mViewportWidth
	mov	DWORD PTR ?mViewportHeight@CScene@@0HA, esi ; CScene::mViewportHeight
	call	_memset

; 1023 : 	sd.BufferCount = 1;
; 1024 : 	sd.BufferDesc.Width = mViewportWidth;             // Target window size
; 1025 : 	sd.BufferDesc.Height = mViewportHeight;           // --"--
; 1026 : 	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // Pixel format of target window
; 1027 : 	sd.BufferDesc.RefreshRate.Numerator = 60;          // Refresh rate of monitor
; 1028 : 	sd.BufferDesc.RefreshRate.Denominator = 1;         // --"--
; 1029 : 	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
; 1030 : 	sd.SampleDesc.Count = 1;
; 1031 : 	sd.SampleDesc.Quality = 0;
; 1032 : 	sd.OutputWindow = HWnd;                          // Target window

	mov	eax, DWORD PTR [ebx+3168]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sd$[ebp+4], esi

; 1033 : 	sd.Windowed = TRUE;                                // Whether to render in a window (TRUE) or go fullscreen (FALSE)
; 1034 : 	hr = D3D10CreateDeviceAndSwapChain( NULL, D3D10_DRIVER_TYPE_HARDWARE, NULL, D3D10_CREATE_DEVICE_DEBUG,
; 1035 : 										D3D10_SDK_VERSION, &sd, &SwapChain, &mpd3dDevice );

	lea	esi, DWORD PTR [ebx+3148]
	mov	DWORD PTR _sd$[ebp+44], eax
	lea	eax, DWORD PTR _sd$[ebp]
	mov	DWORD PTR _sd$[ebp+40], 1
	push	ebx
	push	esi
	push	eax
	push	29					; 0000001dH
	push	2
	push	0
	push	0
	push	0
	mov	DWORD PTR _sd$[ebp], edi
	mov	DWORD PTR _sd$[ebp+16], 28		; 0000001cH
	mov	DWORD PTR _sd$[ebp+8], 60		; 0000003cH
	mov	DWORD PTR _sd$[ebp+12], 1
	mov	DWORD PTR _sd$[ebp+36], 32		; 00000020H
	mov	DWORD PTR _sd$[ebp+28], 1
	mov	DWORD PTR _sd$[ebp+32], 0
	mov	DWORD PTR _sd$[ebp+48], 1
	call	_D3D10CreateDeviceAndSwapChain@32

; 1036 : 	if( FAILED( hr ) ) return false;

	test	eax, eax
	jns	SHORT $LN5@InitDevice
$LN12@InitDevice:
	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 1095 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@InitDevice:

; 1037 : 
; 1038 : 
; 1039 : 	// Specify the render target as the back-buffer - this is an advanced topic. This code almost always occurs in the standard D3D setup
; 1040 : 	ID3D10Texture2D* pBackBuffer;
; 1041 : 	hr = SwapChain->GetBuffer( 0, __uuidof( ID3D10Texture2D ), ( LPVOID* )&pBackBuffer );

	mov	eax, DWORD PTR [esi]
	lea	edx, DWORD PTR _pBackBuffer$[ebp]
	push	edx
	push	OFFSET __GUID_9b7e4c04_342c_4106_a19f_4f2704f689f0
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+36]

; 1042 : 	if( FAILED( hr ) ) return false;

	test	eax, eax
	js	SHORT $LN12@InitDevice

; 1043 : 	hr = mpd3dDevice->CreateRenderTargetView( pBackBuffer, NULL, &RenderTargetView );

	mov	ecx, DWORD PTR [ebx]
	lea	edx, DWORD PTR [ebx+3160]
	push	edx
	push	0
	push	DWORD PTR _pBackBuffer$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+304]

; 1044 : 	pBackBuffer->Release();

	mov	ecx, DWORD PTR _pBackBuffer$[ebp]
	mov	esi, eax
	push	ecx
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]

; 1045 : 	if( FAILED( hr ) ) return false;

	test	esi, esi
	js	SHORT $LN12@InitDevice

; 1046 : 
; 1047 : 
; 1048 : 	// Create a texture (bitmap) to use for a depth buffer
; 1049 : 	D3D10_TEXTURE2D_DESC descDepth;
; 1050 : 	descDepth.Width = mViewportWidth;
; 1051 : 	descDepth.Height = mViewportHeight;
; 1052 : 	descDepth.MipLevels = 1;
; 1053 : 	descDepth.ArraySize = 1;
; 1054 : 	descDepth.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;		// 24 bits for depth, 8 for stencil - more memory efficient
; 1055 : 	//descDepth.Format = DXGI_FORMAT_D32_FLOAT;				// 32 bit float depth only 
; 1056 : 	//descDepth.Format = DXGI_FORMAT_D32_FLOAT_S8X24_UINT;	// 32 bit depth + 8 for stencil, 24 unused bytes - more precise depth buffer
; 1057 : 	descDepth.SampleDesc.Count = 1;
; 1058 : 	descDepth.SampleDesc.Quality = 0;
; 1059 : 	descDepth.Usage = D3D10_USAGE_DEFAULT;
; 1060 : 	descDepth.BindFlags = D3D10_BIND_DEPTH_STENCIL;
; 1061 : 	descDepth.CPUAccessFlags = 0;
; 1062 : 	descDepth.MiscFlags = 0;
; 1063 : 	hr = mpd3dDevice->CreateTexture2D( &descDepth, NULL, &DepthStencil );

	mov	ecx, DWORD PTR [ebx]
	lea	esi, DWORD PTR [ebx+3152]
	mov	eax, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
	lea	edx, DWORD PTR _descDepth$[ebp]
	push	esi
	mov	DWORD PTR _descDepth$[ebp], eax
	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	push	0
	mov	DWORD PTR _descDepth$[ebp+4], eax
	mov	DWORD PTR _descDepth$[ebp+8], 1
	mov	DWORD PTR _descDepth$[ebp+12], 1
	mov	DWORD PTR _descDepth$[ebp+16], 45	; 0000002dH
	mov	DWORD PTR _descDepth$[ebp+20], 1
	mov	DWORD PTR _descDepth$[ebp+24], 0
	mov	DWORD PTR _descDepth$[ebp+28], 0
	mov	DWORD PTR _descDepth$[ebp+32], 64	; 00000040H
	mov	DWORD PTR _descDepth$[ebp+36], 0
	mov	DWORD PTR _descDepth$[ebp+40], 0
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	ecx
	call	DWORD PTR [eax+292]

; 1064 : 	if( FAILED( hr ) ) return false;

	test	eax, eax
	js	$LN12@InitDevice

; 1065 : 
; 1066 : 	// Create the depth stencil view, i.e. indicate that the texture just created is to be used as a depth buffer
; 1067 : 	D3D10_DEPTH_STENCIL_VIEW_DESC descDSV;
; 1068 : 	descDSV.Format = descDepth.Format;
; 1069 : 	descDSV.ViewDimension = D3D10_DSV_DIMENSION_TEXTURE2D;
; 1070 : 	descDSV.Texture2D.MipSlice = 0;
; 1071 : 	hr = mpd3dDevice->CreateDepthStencilView( DepthStencil, &descDSV, &DepthStencilView );

	mov	ecx, DWORD PTR [ebx]
	lea	edi, DWORD PTR [ebx+3156]
	mov	eax, DWORD PTR _descDepth$[ebp+16]
	lea	edx, DWORD PTR _descDSV$[ebp]
	push	edi
	push	edx
	push	DWORD PTR [esi]
	mov	DWORD PTR _descDSV$[ebp], eax
	mov	DWORD PTR _descDSV$[ebp+4], 3
	mov	DWORD PTR _descDSV$[ebp+8], 0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+308]

; 1072 : 	if( FAILED( hr ) ) return false;

	test	eax, eax
	js	$LN12@InitDevice

; 1073 : 
; 1074 : 	// Select the back buffer and depth buffer to use for rendering now
; 1075 : 	mpd3dDevice->OMSetRenderTargets( 1, &RenderTargetView, DepthStencilView );

	mov	eax, DWORD PTR [ebx]
	lea	edx, DWORD PTR [ebx+3160]
	push	DWORD PTR [edi]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	1
	push	eax
	call	DWORD PTR [ecx+96]

; 1076 : 
; 1077 : 
; 1078 : 	// Setup the viewport - defines which part of the window we will render to, almost always the whole window
; 1079 : 	D3D10_VIEWPORT vp;
; 1080 : 	vp.Width  = mViewportWidth;

	mov	eax, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth

; 1081 : 	vp.Height = mViewportHeight;
; 1082 : 	vp.MinDepth = 0.0f;
; 1083 : 	vp.MaxDepth = 1.0f;
; 1084 : 	vp.TopLeftX = 0;
; 1085 : 	vp.TopLeftY = 0;
; 1086 : 	mpd3dDevice->RSSetViewports( 1, &vp );

	lea	edx, DWORD PTR _vp$[ebp]
	mov	DWORD PTR _vp$[ebp+8], eax
	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	mov	DWORD PTR _vp$[ebp+12], eax
	mov	eax, DWORD PTR [ebx]
	push	edx
	mov	DWORD PTR _vp$[ebp+16], 0
	mov	DWORD PTR _vp$[ebp+20], 1065353216	; 3f800000H
	mov	DWORD PTR _vp$[ebp], 0
	mov	DWORD PTR _vp$[ebp+4], 0
	mov	ecx, DWORD PTR [eax]
	push	1
	push	eax
	call	DWORD PTR [ecx+120]
; File c:\users\simon\documents\github\post-processing\camera.h

; 48   : 	static void SetViewport( int width, int height ) { mViewportWidth = width; mViewportHeight = height; }

	mov	eax, DWORD PTR ?mViewportWidth@CScene@@0HA ; CScene::mViewportWidth
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1095 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
; File c:\users\simon\documents\github\post-processing\camera.h

; 48   : 	static void SetViewport( int width, int height ) { mViewportWidth = width; mViewportHeight = height; }

	mov	DWORD PTR ?mViewportWidth@CCamera@@0HA, eax ; CCamera::mViewportWidth
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1095 : }

	xor	ecx, ebp
; File c:\users\simon\documents\github\post-processing\camera.h

; 48   : 	static void SetViewport( int width, int height ) { mViewportWidth = width; mViewportHeight = height; }

	mov	eax, DWORD PTR ?mViewportHeight@CScene@@0HA ; CScene::mViewportHeight
	pop	edi
	mov	DWORD PTR ?mViewportHeight@CCamera@@0HA, eax ; CCamera::mViewportHeight
; File c:\users\simon\documents\github\post-processing\model.h

; 66   : 	static void SetDevice(ID3D10Device* newDevice) { mpd3dDev = newDevice; }

	mov	eax, DWORD PTR [ebx]
	pop	esi
	mov	DWORD PTR ?mpd3dDev@CModel@@0PAUID3D10Device@@A, eax ; CModel::mpd3dDev
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1094 : 	return true;

	mov	al, 1
	pop	ebx

; 1095 : }

	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?InitDevice@CScene@@QAE_NXZ ENDP			; CScene::InitDevice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetSinglePP@CScene@@QAEXH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?SetSinglePP@CScene@@QAEXH@Z PROC			; CScene::SetSinglePP, COMDAT
; _this$ = ecx

; 199  : {

	push	ebp
	mov	ebp, esp

; 200  : 	if(index < 0)

	mov	eax, DWORD PTR _index$[ebp]
	test	eax, eax
	jns	SHORT $LN2@SetSingleP

; 201  : 	{
; 202  : 		mCurrentPP = 0;

	mov	DWORD PTR [ecx+3040], 0

; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;
; 213  : }

	pop	ebp
	ret	4
$LN2@SetSingleP:

; 203  : 		return;
; 204  : 	}
; 205  : 
; 206  : 	if(index > NumPostProcesses)

	xor	edx, edx
	cmp	eax, 13					; 0000000dH
	cmovg	eax, edx
	mov	DWORD PTR [ecx+3040], eax

; 207  : 	{
; 208  : 		mCurrentPP = 0;
; 209  : 		return;
; 210  : 	}
; 211  : 
; 212  : 	mCurrentPP = index;
; 213  : }

	pop	ebp
	ret	4
?SetSinglePP@CScene@@QAEXH@Z ENDP			; CScene::SetSinglePP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?ResetShock@CScene@@QAEXXZ
_TEXT	SEGMENT
?ResetShock@CScene@@QAEXXZ PROC				; CScene::ResetShock, COMDAT
; _this$ = ecx

; 217  : 	mShockTime = mShockLength;	

	mov	eax, DWORD PTR [ecx+2976]
	mov	DWORD PTR [ecx+2968], eax

; 218  : }

	ret	0
?ResetShock@CScene@@QAEXXZ ENDP				; CScene::ResetShock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ??1CScene@@QAE@XZ
_TEXT	SEGMENT
??1CScene@@QAE@XZ PROC					; CScene::~CScene, COMDAT
; _this$ = ecx

; 48   : }

	ret	0
??1CScene@@QAE@XZ ENDP					; CScene::~CScene
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ??0CScene@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
??0CScene@@QAE@XZ PROC					; CScene::CScene, COMDAT
; _this$ = ecx

; 6    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm0, DWORD PTR __real@3e4ccccd
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 13   : 	AmbientColour = D3DXVECTOR3( 0.2f, 0.2f, 0.2f );

	unpcklps xmm0, xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T1[ebp+8], 1045220557	; 3e4ccccdH
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 13   : 	AmbientColour = D3DXVECTOR3( 0.2f, 0.2f, 0.2f );

	mov	eax, DWORD PTR $T1[ebp+8]
	movq	QWORD PTR [ecx+2540], xmm0
	mov	DWORD PTR [ecx+2548], eax

; 14   : 
; 15   : 	//set the controlled object to the mirror
; 16   : 	mControlObject = 0;
; 17   : 
; 18   : 	mCurrentPP = 0;
; 19   : 	mCumulativeFTime = 0.0f;
; 20   : 	
; 21   : 	mTintCycleTime = 8.0f;
; 22   : 
; 23   : 	mShockStrength = 0.2f;
; 24   : 	mShockSpeed = 20.0f;
; 25   : 	mShockLength = 2.0f;
; 26   : 
; 27   : 	mDoubleVisionRadius = 0.05f;
; 28   : 
; 29   : 	mBlurRadius = 10;
; 30   : 
; 31   : 	multiprocess = false;
; 32   : 	ppDirection = true;
; 33   : 
; 34   : 	mbGaussian = false;
; 35   : 
; 36   : 	mContrastChange = 0.0f;
; 37   : 	mContrastFactor = 0.0f;
; 38   : 
; 39   : 	mBlood = 0.5;
; 40   : 
; 41   : 	impact = false;
; 42   : 	mSolariseInt = 127;
; 43   : 	mSolariseFloat = 0.5f;
; 44   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+808], 0
	mov	DWORD PTR [ecx+932], 0
	mov	DWORD PTR [ecx+2536], 0
	mov	DWORD PTR [ecx+2552], 0
	mov	DWORD PTR [ecx+3040], 0
	mov	DWORD PTR [ecx+2984], 0
	mov	DWORD PTR [ecx+3004], 1090519040	; 41000000H
	mov	DWORD PTR [ecx+2964], 1045220557	; 3e4ccccdH
	mov	DWORD PTR [ecx+2972], 1101004800	; 41a00000H
	mov	DWORD PTR [ecx+2976], 1073741824	; 40000000H
	mov	DWORD PTR [ecx+3020], 1028443341	; 3d4ccccdH
	mov	DWORD PTR [ecx+3008], 10		; 0000000aH
	mov	WORD PTR [ecx+3184], 0
	mov	BYTE PTR [ecx+3068], 1
	mov	DWORD PTR [ecx+3028], 0
	mov	DWORD PTR [ecx+3032], 0
	mov	DWORD PTR [ecx+2944], 1056964608	; 3f000000H
	mov	BYTE PTR [ecx+3084], 0
	mov	DWORD PTR [ecx+3072], 127		; 0000007fH
	mov	DWORD PTR [ecx+3076], 1056964608	; 3f000000H
	mov	esp, ebp
	pop	ebp
	ret	0
??0CScene@@QAE@XZ ENDP					; CScene::CScene
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?StartImpact@CScene@@QAEXXZ
_TEXT	SEGMENT
?StartImpact@CScene@@QAEXXZ PROC			; CScene::StartImpact, COMDAT
; _this$ = ecx

; 756  : 	if (!impact)

	cmp	BYTE PTR [ecx+3084], 0
	jne	SHORT $LN1@StartImpac

; 757  : 	{
; 758  : 		impact = true;
; 759  : 		mShockTime = mShockLength;

	mov	eax, DWORD PTR [ecx+2976]
	mov	BYTE PTR [ecx+3084], 1
	mov	DWORD PTR [ecx+2968], eax
$LN1@StartImpac:

; 760  : 	}
; 761  : }

	ret	0
?StartImpact@CScene@@QAEXXZ ENDP			; CScene::StartImpact
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?RenderImpact@CScene@@AAEXXZ
_TEXT	SEGMENT
?RenderImpact@CScene@@AAEXXZ PROC			; CScene::RenderImpact, COMDAT
; _this$ = ecx

; 803  : {

	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 804  : 	//PP One - Initial -> One, Blur.
; 805  : 	mpd3dDevice->OMSetRenderTargets(1, &mRenderTargetOne, DepthStencilView);

	mov	edx, DWORD PTR [ebx]
	lea	edi, DWORD PTR [ebx+3052]
	push	DWORD PTR [ebx+3156]
	push	edi
	mov	eax, DWORD PTR [edx]
	push	1
	push	edx
	call	DWORD PTR [eax+96]

; 806  : 	mInitialTextureVar->SetResource(mInitialShaderResource);

	mov	eax, DWORD PTR [ebx+2940]
	push	DWORD PTR [ebx+2912]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 807  : 	mpd3dDevice->IASetInputLayout(NULL);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]

; 808  : 	mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

	mov	eax, DWORD PTR [ebx]
	push	5
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+72]

; 809  : 	mPPTechniques[5]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2584]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 810  : 	mpd3dDevice->Draw(4, 0);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	4
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+36]

; 811  : 	mInitialTextureVar->SetResource(0);

	mov	eax, DWORD PTR [ebx+2940]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 812  : 	mPPTechniques[5]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2584]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 813  : 
; 814  : 	//PP Two = One -> Two, Contrast
; 815  : 	mpd3dDevice->OMSetRenderTargets(1, &mRenderTargetTwo, DepthStencilView);

	mov	ecx, DWORD PTR [ebx]
	lea	esi, DWORD PTR [ebx+3056]
	push	DWORD PTR [ebx+3156]
	push	esi
	mov	eax, DWORD PTR [ecx]
	push	1
	push	ecx
	call	DWORD PTR [eax+96]

; 816  : 	mInitialTextureVar->SetResource(mTextureOneShader);

	mov	ecx, DWORD PTR [ebx+2940]
	push	DWORD PTR [ebx+3060]
	push	ecx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+100]

; 817  : 	mpd3dDevice->IASetInputLayout(NULL);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]

; 818  : 	mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

	mov	eax, DWORD PTR [ebx]
	push	5
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+72]

; 819  : 	mPPTechniques[8]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2596]
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 820  : 	mpd3dDevice->Draw(4, 0);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	4
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+36]

; 821  : 	mInitialTextureVar->SetResource(0);

	mov	eax, DWORD PTR [ebx+2940]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 822  : 	mPPTechniques[8]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2596]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 823  : 
; 824  : 	//PP Three = Two -> One, Tint
; 825  : 	mpd3dDevice->OMSetRenderTargets(1, &mRenderTargetOne, DepthStencilView);

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [ebx+3156]
	push	edi
	mov	ecx, DWORD PTR [eax]
	push	1
	push	eax
	call	DWORD PTR [ecx+96]

; 826  : 	mInitialTextureVar->SetResource(mTextureTwoShader);

	mov	ecx, DWORD PTR [ebx+2940]
	push	DWORD PTR [ebx+3064]
	push	ecx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+100]

; 827  : 	mpd3dDevice->IASetInputLayout(NULL);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]

; 828  : 	mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

	mov	eax, DWORD PTR [ebx]
	push	5
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+72]

; 829  : 	mPPTechniques[1]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2568]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 830  : 	mpd3dDevice->Draw(4, 0);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	4
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+36]

; 831  : 	mInitialTextureVar->SetResource(0);

	mov	eax, DWORD PTR [ebx+2940]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 832  : 	mPPTechniques[1]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2568]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 833  : 
; 834  : 	//PP Four = One -> Two, Shake
; 835  : 	mpd3dDevice->OMSetRenderTargets(1, &mRenderTargetTwo, DepthStencilView);

	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [ebx+3156]
	mov	ecx, DWORD PTR [eax]
	push	esi
	push	1
	push	eax
	call	DWORD PTR [ecx+96]

; 836  : 	mInitialTextureVar->SetResource(mTextureOneShader);

	mov	eax, DWORD PTR [ebx+2940]
	push	DWORD PTR [ebx+3060]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 837  : 	mpd3dDevice->IASetInputLayout(NULL);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]

; 838  : 	mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

	mov	eax, DWORD PTR [ebx]
	push	5
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+72]

; 839  : 	mPPTechniques[2]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2572]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 840  : 	mpd3dDevice->Draw(4, 0);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	4
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+36]

; 841  : 	mInitialTextureVar->SetResource(0);

	mov	eax, DWORD PTR [ebx+2940]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 842  : 	mPPTechniques[2]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2572]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 843  : 
; 844  : 	//Copy to Output
; 845  : 	mpd3dDevice->OMSetRenderTargets(1, &RenderTargetView, DepthStencilView);

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ebx+3160]
	push	DWORD PTR [ebx+3156]
	push	eax
	mov	edx, DWORD PTR [ecx]
	push	1
	push	ecx
	call	DWORD PTR [edx+96]

; 846  : 	mInitialTextureVar->SetResource(mTextureTwoShader);

	mov	eax, DWORD PTR [ebx+2940]
	push	DWORD PTR [ebx+3064]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 847  : 	mpd3dDevice->IASetInputLayout(NULL);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+44]

; 848  : 	mpd3dDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

	mov	eax, DWORD PTR [ebx]
	push	5
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+72]

; 849  : 	mPPTechniques[0]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2564]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]

; 850  : 	mpd3dDevice->Draw(4, 0);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax]
	push	0
	push	4
	push	eax
	call	DWORD PTR [ecx+36]

; 851  : 	mInitialTextureVar->SetResource(0);

	mov	eax, DWORD PTR [ebx+2940]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 852  : 	mPPTechniques[0]->GetPassByIndex(0)->Apply(0);

	mov	eax, DWORD PTR [ebx+2564]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+16]
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]
	pop	edi
	pop	esi
	pop	ebx

; 853  : 
; 854  : }

	ret	0
?RenderImpact@CScene@@AAEXXZ ENDP			; CScene::RenderImpact
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?UpdateImpact@CScene@@AAEXM@Z
_TEXT	SEGMENT
tv288 = -4						; size = 4
_frameTime$ = 8						; size = 4
?UpdateImpact@CScene@@AAEXM@Z PROC			; CScene::UpdateImpact, COMDAT
; _this$ = ecx

; 764  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 765  : 	if (mShockTime < 0.0f)

	movss	xmm1, DWORD PTR [esi+2968]
	comiss	xmm0, xmm1
	movss	DWORD PTR tv288[ebp], xmm1
	jbe	SHORT $LN3@UpdateImpa

; 766  : 	{
; 767  : 		impact = false; 

	mov	BYTE PTR [esi+3084], 0
	pop	esi

; 800  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@UpdateImpa:

; 768  : 		return;
; 769  : 	}
; 770  : 
; 771  : 	//mShock = sin(mShockSpeed * mShockTime);
; 772  : 	//mShock -= 0.5f;
; 773  : 	//mShock *= mShockStrength;
; 774  : 	
; 775  : 	
; 776  : 
; 777  : 	//build phase
; 778  : 	if (mShockTime > 1.0f)

	movss	xmm2, DWORD PTR __real@3f800000

; 779  : 	{
; 780  : 		mContrastChange = -128.0f * (1.0f - (mShockTime - 1.0f));

	movaps	xmm0, xmm1
	comiss	xmm1, xmm2

; 781  : 		mTintColour.x = 1.0f;

	mov	DWORD PTR [esi+2992], 1065353216	; 3f800000H
	jbe	SHORT $LN2@UpdateImpa

; 779  : 	{
; 780  : 		mContrastChange = -128.0f * (1.0f - (mShockTime - 1.0f));

	subss	xmm0, xmm2
	movaps	xmm1, xmm2
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
$LN2@UpdateImpa:

; 782  : 		mTintColour.y = 1.0f - (1.0f - (mShockTime - 1.0f));
; 783  : 		mTintColour.z = 1.0f - (1.0f - (mShockTime - 1.0f));
; 784  : 		mBlurRadius = 20 * (1.0f - (mShockTime - 1.0f));
; 785  : 		mShock = mShockStrength * sin( mShockSpeed * (1.0f - (mShockTime - 1.0f)) );
; 786  : 	}
; 787  : 	else //fade phase
; 788  : 	{
; 789  : 		mContrastChange = -128.0f * mShockTime;

	mulss	xmm0, DWORD PTR __real@c3000000

; 790  : 		mTintColour.x = 1.0f;
; 791  : 		mTintColour.y = 1.0f - mShockTime;

	subss	xmm2, xmm1
	movss	DWORD PTR [esi+3028], xmm0

; 792  : 		mTintColour.z = 1.0f - mShockTime;
; 793  : 		mBlurRadius = 20 * mShockTime;

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR [esi+2996], xmm2
	movss	DWORD PTR [esi+3000], xmm2
	cvttss2si eax, xmm0

; 794  : 		mShock = mShockStrength * sin(mShockSpeed * mShockTime);

	movss	xmm0, DWORD PTR [esi+2972]
	mulss	xmm0, xmm1
	mov	DWORD PTR [esi+3008], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 797  : 	mContrastFactor = (259 * (mContrastChange + 255.0f)) / (255.0f * (259.0f - mContrastChange));

	movss	xmm2, DWORD PTR [esi+3028]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 797  : 	mContrastFactor = (259 * (mContrastChange + 255.0f)) / (255.0f * (259.0f - mContrastChange));

	movaps	xmm3, xmm2

; 798  : 
; 799  : 	mShockTime -= (frameTime/2.0f);

	movss	xmm1, DWORD PTR tv288[ebp]
	mulss	xmm0, DWORD PTR [esi+2964]
	addss	xmm3, DWORD PTR __real@437f0000
	movss	DWORD PTR [esi+2960], xmm0
	movss	xmm0, DWORD PTR __real@43818000
	mulss	xmm3, xmm0
	subss	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@437f0000
	divss	xmm3, xmm0
	movss	xmm0, DWORD PTR _frameTime$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esi+3032], xmm3
	subss	xmm1, xmm0
	movss	DWORD PTR [esi+2968], xmm1
	pop	esi

; 800  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateImpact@CScene@@AAEXM@Z ENDP			; CScene::UpdateImpact
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?DrawAllObjects@CScene@@AAEX_N@Z
_TEXT	SEGMENT
$T1 = -80						; size = 64
_mColour$2 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_mirror$ = 8						; size = 1
?DrawAllObjects@CScene@@AAEX_N@Z PROC			; CScene::DrawAllObjects, COMDAT
; _this$ = ecx

; 573  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 574  : 	//
; 575  : 	// Solid objects
; 576  : 	//
; 577  : 	//start rendering AFTER the mirror.
; 578  : 	for(int i = 1; i < miNumObjects; i++)

	mov	edi, 1
	cmp	DWORD PTR [esi+808], edi
	jle	SHORT $LN11@DrawAllObj
	lea	ebx, DWORD PTR [esi+12]
$LL13@DrawAllObj:

; 579  : 	{
; 580  : 		if( !mpObjects[i]->IsTransparent() )

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+33], 0
	jne	SHORT $LN12@DrawAllObj

; 581  : 		{
; 582  : 			DrawObject(i, mirror);

	push	DWORD PTR _mirror$[ebp]
	mov	ecx, esi
	push	edi
	call	?DrawObject@CScene@@AAEXH_N@Z		; CScene::DrawObject
$LN12@DrawAllObj:

; 574  : 	//
; 575  : 	// Solid objects
; 576  : 	//
; 577  : 	//start rendering AFTER the mirror.
; 578  : 	for(int i = 1; i < miNumObjects; i++)

	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR [esi+808]
	jl	SHORT $LL13@DrawAllObj
$LN11@DrawAllObj:

; 583  : 		}
; 584  : 	}
; 585  : 
; 586  : 	//
; 587  : 	// Light objects
; 588  : 	//
; 589  : 
; 590  : 
; 591  : 	for(int i = 0; i < miNumLights; i++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+932], ebx
	jle	$LN7@DrawAllObj
	lea	edi, DWORD PTR [esi+812]
$LL9@DrawAllObj:
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [edi]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 593  : 		WorldMatrixVar->SetMatrix( (float*)mpLights[i]->GetModel()->GetWorldMatrix() );

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 100  : 		return m_WorldMatrix;

	movdqu	xmm0, XMMWORD PTR [eax+48]
	movdqu	XMMWORD PTR $T1[ebp], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+64]
	movdqu	XMMWORD PTR $T1[ebp+16], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+80]
	movdqu	XMMWORD PTR $T1[ebp+32], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+96]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 593  : 		WorldMatrixVar->SetMatrix( (float*)mpLights[i]->GetModel()->GetWorldMatrix() );

	mov	eax, DWORD PTR [esi+3088]
	push	eax
; File c:\users\simon\documents\github\post-processing\model.h

; 100  : 		return m_WorldMatrix;

	movdqu	XMMWORD PTR $T1[ebp+48], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 593  : 		WorldMatrixVar->SetMatrix( (float*)mpLights[i]->GetModel()->GetWorldMatrix() );

	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 594  : 		D3DXVECTOR3 mColour =  mpLights[i]->GetColourV();

	mov	eax, DWORD PTR [edi]

; 595  : 		ModelColourVar->SetRawValue(mColour, 0, 12 );

	lea	edx, DWORD PTR _mColour$2[ebp]
	push	12					; 0000000cH
	push	0
	push	edx
; File c:\users\simon\documents\github\post-processing\light.h

; 56   : 	D3DXVECTOR3 GetColourV(){ return D3DXVECTOR3( mr, mg, mb ); }

	movss	xmm1, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 595  : 		ModelColourVar->SetRawValue(mColour, 0, 12 );

	mov	eax, DWORD PTR [esi+3112]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	DWORD PTR _mColour$2[ebp], xmm0

; 322  :     y = fy;

	movss	DWORD PTR _mColour$2[ebp+4], xmm1

; 323  :     z = fz;

	movss	DWORD PTR _mColour$2[ebp+8], xmm2
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 595  : 		ModelColourVar->SetRawValue(mColour, 0, 12 );

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+92]

; 596  : 		if( mirror )

	cmp	BYTE PTR _mirror$[ebp], 0
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	ecx, DWORD PTR [edi]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 598  : 			mpLights[i]->GetModel()->Render( mTechniquesMirror[0] );

	mov	ecx, DWORD PTR [ecx]
	je	SHORT $LN6@DrawAllObj
	push	DWORD PTR [esi+2736]

; 599  : 		}
; 600  : 		else

	jmp	SHORT $LN48@DrawAllObj
$LN6@DrawAllObj:

; 601  : 		{
; 602  : 			mpLights[i]->GetModel()->Render( mTechniques[0] );

	push	DWORD PTR [esi+2616]
$LN48@DrawAllObj:
	call	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z ; CModel::Render
	inc	ebx
	add	edi, 4
	cmp	ebx, DWORD PTR [esi+932]
	jl	$LL9@DrawAllObj
$LN7@DrawAllObj:

; 603  : 		}
; 604  : 	}
; 605  : 
; 606  : 	//
; 607  : 	// Transparent objects
; 608  : 	//
; 609  : 
; 610  : 	for(int i = 1; i < miNumObjects; i++)

	mov	edi, 1
	cmp	DWORD PTR [esi+808], edi
	jle	SHORT $LN2@DrawAllObj
	lea	ebx, DWORD PTR [esi+12]
$LL4@DrawAllObj:

; 611  : 	{
; 612  : 		if( mpObjects[i]->IsTransparent() )

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+33], 0
	je	SHORT $LN3@DrawAllObj

; 613  : 		{
; 614  : 			DrawObject(i, mirror);

	push	DWORD PTR _mirror$[ebp]
	mov	ecx, esi
	push	edi
	call	?DrawObject@CScene@@AAEXH_N@Z		; CScene::DrawObject
$LN3@DrawAllObj:

; 603  : 		}
; 604  : 	}
; 605  : 
; 606  : 	//
; 607  : 	// Transparent objects
; 608  : 	//
; 609  : 
; 610  : 	for(int i = 1; i < miNumObjects; i++)

	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR [esi+808]
	jl	SHORT $LL4@DrawAllObj
$LN2@DrawAllObj:

; 615  : 		}
; 616  : 	}
; 617  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?DrawAllObjects@CScene@@AAEX_N@Z ENDP			; CScene::DrawAllObjects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?DrawObject@CScene@@AAEXH_N@Z
_TEXT	SEGMENT
_wiggle$ = -88						; size = 4
_thickness$ = -84					; size = 4
$T1 = -80						; size = 64
$T2 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_i$ = 8							; size = 4
_mirror$ = 12						; size = 1
?DrawObject@CScene@@AAEXH_N@Z PROC			; CScene::DrawObject, COMDAT
; _this$ = ecx

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	edi, DWORD PTR _i$[ebp]

; 529  : 	//first the wiggle value
; 530  : 	float wiggle =  mpObjects[i]->GetWiggle();
; 531  : 	dxWiggle->SetRawValue( &wiggle, 0, 4);

	lea	edx, DWORD PTR _wiggle$[ebp]
	mov	esi, ecx
	push	4
	push	0
	push	edx
	mov	eax, DWORD PTR [esi+edi*4+8]
	movss	xmm0, DWORD PTR [eax+64]
	mov	eax, DWORD PTR [esi+3136]
	movss	DWORD PTR _wiggle$[ebp], xmm0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+92]

; 532  : 
; 533  : 	//outline thickness
; 534  : 	float thickness = mpObjects[i]->GetOutlineThickness();

	mov	eax, DWORD PTR [esi+edi*4+8]

; 535  : 	dxOutlineThickness->SetRawValue( &thickness, 0, 4);

	lea	edx, DWORD PTR _thickness$[ebp]
	push	4
	push	0
	push	edx
	movss	xmm0, DWORD PTR [eax+68]
	mov	eax, DWORD PTR [esi+3140]
	movss	DWORD PTR _thickness$[ebp], xmm0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+92]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+edi*4+8]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 538  : 	WorldMatrixVar->SetMatrix( (float*)mpObjects[i]->GetModel()->GetWorldMatrix() );

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 100  : 		return m_WorldMatrix;

	movdqu	xmm0, XMMWORD PTR [eax+48]
	movdqu	XMMWORD PTR $T1[ebp], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+64]
	movdqu	XMMWORD PTR $T1[ebp+16], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+80]
	movdqu	XMMWORD PTR $T1[ebp+32], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+96]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 538  : 	WorldMatrixVar->SetMatrix( (float*)mpObjects[i]->GetModel()->GetWorldMatrix() );

	mov	eax, DWORD PTR [esi+3088]
	push	eax
; File c:\users\simon\documents\github\post-processing\model.h

; 100  : 		return m_WorldMatrix;

	movdqu	XMMWORD PTR $T1[ebp+48], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 538  : 	WorldMatrixVar->SetMatrix( (float*)mpObjects[i]->GetModel()->GetWorldMatrix() );

	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]

; 539  : 	
; 540  : 	//pass the textures and maps, if there are any. 
; 541  : 	if( mpObjects[i]->GetTexture() != nullptr )

	mov	eax, DWORD PTR [esi+edi*4+8]
	mov	edx, DWORD PTR [eax+24]
	test	edx, edx
	je	SHORT $LN5@DrawObject

; 542  : 	{
; 543  : 		DiffuseMapVar->SetResource( mpObjects[i]->GetTexture() );

	mov	eax, DWORD PTR [esi+3104]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]
$LN5@DrawObject:

; 544  : 	}
; 545  : 	if( mpObjects[i]->GetNormalMap() != nullptr )

	mov	eax, DWORD PTR [esi+edi*4+8]
	mov	edx, DWORD PTR [eax+28]
	test	edx, edx
	je	SHORT $LN4@DrawObject

; 546  : 	{
; 547  : 		NormalMapVar->SetResource( mpObjects[i]->GetNormalMap() );

	mov	eax, DWORD PTR [esi+3108]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+100]
$LN4@DrawObject:

; 551  : 	ModelColourVar->SetRawValue( mpObjects[i]->GetColourV(), 0, 12 );

	mov	eax, DWORD PTR [esi+edi*4+8]
	lea	edx, DWORD PTR $T2[ebp]
	push	12					; 0000000cH
	push	0
	push	edx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 59   : 	D3DXVECTOR3 GetColourV(){ return D3DXVECTOR3( mr, mg, mb ); }

	movss	xmm1, DWORD PTR [eax+8]
	movss	xmm2, DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 551  : 	ModelColourVar->SetRawValue( mpObjects[i]->GetColourV(), 0, 12 );

	mov	eax, DWORD PTR [esi+3112]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	DWORD PTR $T2[ebp], xmm0

; 322  :     y = fy;

	movss	DWORD PTR $T2[ebp+4], xmm1

; 323  :     z = fz;

	movss	DWORD PTR $T2[ebp+8], xmm2
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 551  : 	ModelColourVar->SetRawValue( mpObjects[i]->GetColourV(), 0, 12 );

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+92]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 75   : 	bool IsLit() { return mIsLit; }

	mov	edx, DWORD PTR [esi+edi*4+8]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 554  : 	if( mpObjects[i]->IsLit() )

	cmp	BYTE PTR [edx+32], 0
	je	SHORT $LN3@DrawObject

; 556  : 		SetLights( mpObjects[i]->GetModel()->GetPosition(), mpLights, miNumLights);

	push	DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	edx, DWORD PTR [edx]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 556  : 		SetLights( mpObjects[i]->GetModel()->GetPosition(), mpLights, miNumLights);

	lea	eax, DWORD PTR [esi+812]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	movq	xmm0, QWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+16]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esi
	call	?SetLights@CScene@@AAEXUD3DXVECTOR3@@QAPAVCLight@@H@Z ; CScene::SetLights
$LN3@DrawObject:

; 557  : 	}
; 558  : 
; 559  : 	// choose how to render the model based on where we are rendering it. 
; 560  : 	if( mirror )

	cmp	BYTE PTR _mirror$[ebp], 0

; 561  : 	{
; 562  : 		mpObjects[i]->RenderMirror();

	mov	ecx, DWORD PTR [esi+edi*4+8]
	je	SHORT $LN2@DrawObject
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 86   : 	void RenderMirror() { mModel->Render( mMirrorTechnique ); }

	push	DWORD PTR [ecx+20]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 564  : 	else

	jmp	SHORT $LN42@DrawObject
$LN2@DrawObject:
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 85   : 	void Render() { mModel->Render( mTechnique ); }

	push	DWORD PTR [ecx+16]
$LN42@DrawObject:
	mov	ecx, DWORD PTR [ecx]
	call	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z ; CModel::Render
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 569  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?DrawObject@CScene@@AAEXH_N@Z ENDP			; CScene::DrawObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\camera.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_ps$ = -84						; size = 64
_rc$1 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z PROC		; CScene::WndProc, COMDAT

; 956  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 957  : 	PAINTSTRUCT ps;
; 958  : 	HDC hdc;
; 959  : 	if( TwEventWin(hWnd, message, wParam, lParam) ) // send event message to AntTweakBar

	mov	ebx, DWORD PTR _wParam$[ebp]
	push	esi
	mov	esi, DWORD PTR _message$[ebp]
	push	edi
	push	DWORD PTR _lParam$[ebp]
	mov	edi, DWORD PTR _hWnd$[ebp]
	push	ebx
	push	esi
	push	edi
	call	DWORD PTR __imp__TwEventWin@16
	test	eax, eax
	jne	$LN7@WndProc

; 960  :         return 0;
; 961  : 
; 962  : 	switch( message )

	cmp	esi, 15					; 0000000fH
	ja	SHORT $LN12@WndProc
	je	SHORT $LN6@WndProc
	mov	eax, esi
	sub	eax, 2
	je	SHORT $LN5@WndProc
	sub	eax, 3
	jne	SHORT $LN1@WndProc

; 982  : 		// catch window resize
; 983  : 		case WM_SIZE:
; 984  : 			RECT rc;
; 985  : 			GetClientRect( hWnd, &rc );

	lea	eax, DWORD PTR _rc$1[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp__GetClientRect@8

; 986  : 			mViewportWidth = rc.right - rc.left;

	mov	ecx, DWORD PTR _rc$1[ebp+8]
	sub	ecx, DWORD PTR _rc$1[ebp]

; 987  : 			mViewportHeight = rc.bottom - rc.top;

	mov	eax, DWORD PTR _rc$1[ebp+12]
	sub	eax, DWORD PTR _rc$1[ebp+4]
	mov	DWORD PTR ?mViewportWidth@CScene@@0HA, ecx ; CScene::mViewportWidth
	mov	DWORD PTR ?mViewportHeight@CScene@@0HA, eax ; CScene::mViewportHeight
; File c:\users\simon\documents\github\post-processing\camera.h

; 48   : 	static void SetViewport( int width, int height ) { mViewportWidth = width; mViewportHeight = height; }

	mov	DWORD PTR ?mViewportWidth@CCamera@@0HA, ecx ; CCamera::mViewportWidth
	mov	DWORD PTR ?mViewportHeight@CCamera@@0HA, eax ; CCamera::mViewportHeight
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 990  : 			break;

	jmp	SHORT $LN7@WndProc
$LN5@WndProc:

; 968  : 
; 969  : 		case WM_DESTROY:
; 970  : 			PostQuitMessage( 0 );

	push	0
	call	DWORD PTR __imp__PostQuitMessage@4

; 971  : 			break;

	jmp	SHORT $LN7@WndProc
$LN6@WndProc:

; 963  : 	{
; 964  : 		case WM_PAINT:
; 965  : 			hdc = BeginPaint( hWnd, &ps );

	lea	eax, DWORD PTR _ps$[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp__BeginPaint@8

; 966  : 			EndPaint( hWnd, &ps );

	lea	eax, DWORD PTR _ps$[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp__EndPaint@8

; 967  : 			break;

	jmp	SHORT $LN7@WndProc
$LN12@WndProc:

; 960  :         return 0;
; 961  : 
; 962  : 	switch( message )

	mov	eax, esi
	sub	eax, 256				; 00000100H
	je	SHORT $LN4@WndProc
	dec	eax
	je	SHORT $LN3@WndProc
$LN1@WndProc:

; 991  : 		default:
; 992  : 			return DefWindowProc( hWnd, message, wParam, lParam );

	push	DWORD PTR _lParam$[ebp]
	push	ebx
	push	esi
	push	edi
	call	DWORD PTR __imp__DefWindowProcW@16
	pop	edi
	pop	esi
	pop	ebx

; 993  : 	}
; 994  : 
; 995  : 	return 0;
; 996  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@WndProc:

; 977  : 			break;
; 978  : 
; 979  : 		case WM_KEYUP:
; 980  : 			KeyUpEvent( static_cast<EKeyState>(wParam) );

	push	ebx
	call	?KeyUpEvent@@YAXW4EKeyState@@@Z		; KeyUpEvent

; 981  : 			break;

	jmp	SHORT $LN15@WndProc
$LN4@WndProc:

; 972  : 
; 973  : 		// These windows messages (WM_KEYXXXX) can be used to get keyboard input to the window
; 974  : 		// This application has added some simple functions (not DirectX) to process these messages (all in Input.cpp/h)
; 975  : 		case WM_KEYDOWN:
; 976  : 			KeyDownEvent( static_cast<EKeyState>(wParam) );

	push	ebx
	call	?KeyDownEvent@@YAXW4EKeyState@@@Z	; KeyDownEvent
$LN15@WndProc:
	add	esp, 4
$LN7@WndProc:

; 993  : 	}
; 994  : 
; 995  : 	return 0;
; 996  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	eax, eax
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?WndProc@CScene@@CGJPAUHWND__@@IIJ@Z ENDP		; CScene::WndProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?compareLights@CScene@@CAHPBX0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?compareLights@CScene@@CAHPBX0@Z PROC			; CScene::compareLights, COMDAT

; 1246 : {

	push	ebp
	mov	ebp, esp

; 1247 : 	LightIndex* x = (LightIndex*)a;
; 1248 : 	LightIndex* y = (LightIndex*)b;
; 1249 : 	return int(x->distance - y->distance);

	mov	eax, DWORD PTR _a$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _b$[ebp]
	subss	xmm0, DWORD PTR [eax+4]
	cvttss2si eax, xmm0

; 1250 : }

	pop	ebp
	ret	0
?compareLights@CScene@@CAHPBX0@Z ENDP			; CScene::compareLights
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\defines.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SetLights@CScene@@AAEXUD3DXVECTOR3@@QAPAVCLight@@H@Z
_TEXT	SEGMENT
$T1 = -880						; size = 16
$T2 = -864						; size = 16
$T3 = -848						; size = 16
$T4 = -832						; size = 12
_vLight$ = -832						; size = 12
_bright$ = -820						; size = 192
_colours$ = -628					; size = 192
_positions$ = -436					; size = 192
_indexes$ = -244					; size = 240
__$ArrayPad$ = -4					; size = 4
_source$ = 8						; size = 12
_lightsSource$ = 20					; size = 4
_lightCount$ = 24					; size = 4
?SetLights@CScene@@AAEXUD3DXVECTOR3@@QAPAVCLight@@H@Z PROC ; CScene::SetLights, COMDAT
; _this$ = ecx

; 1254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 880				; 00000370H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx

; 1255 : 	LightIndex indexes[MAX_LIGHTS];
; 1256 : 
; 1257 : 	for(int i = 0; i < MAX_LIGHTS; i++)

	xor	eax, eax
	npad	6
$LL11@SetLights:

; 1258 : 	{
; 1259 : 		indexes[i].distance = 777777777.0f;

	mov	DWORD PTR _indexes$[ebp+eax*8+4], 1312387018 ; 4e396fcaH
	inc	eax
	cmp	eax, 30					; 0000001eH
	jl	SHORT $LL11@SetLights

; 1260 : 	}
; 1261 : 
; 1262 : 	D3DXVECTOR3 vLight;
; 1263 : 	for(int i = 0; i < lightCount; i++)

	mov	edi, DWORD PTR _lightCount$[ebp]
	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN6@SetLights
	mov	edx, DWORD PTR _lightsSource$[ebp]
	movss	xmm3, DWORD PTR _source$[ebp+8]
	movss	xmm4, DWORD PTR _source$[ebp+4]
	movss	xmm5, DWORD PTR _source$[ebp]
	npad	4
$LL8@SetLights:
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [edx+ecx*4]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1265 : 		indexes[i].index = i;

	mov	DWORD PTR _indexes$[ebp+ecx*8], ecx
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1266 : 		vLight = lightsSource[i]->GetModel()->GetPosition();

	movq	xmm0, QWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+16]
	movq	QWORD PTR _vLight$[ebp], xmm0

; 1267 : 		indexes[i].distance = square(vLight.x - source.x) + square (vLight.y - source.y) + square(vLight.z - source.z);

	movss	xmm2, DWORD PTR _vLight$[ebp]
	movss	xmm0, DWORD PTR _vLight$[ebp+4]
	subss	xmm2, xmm5
	subss	xmm0, xmm4
	mov	DWORD PTR _vLight$[ebp+8], eax
	movss	xmm1, DWORD PTR _vLight$[ebp+8]
	subss	xmm1, xmm3
; File c:\users\simon\documents\github\post-processing\defines.h

; 25   : inline float square (float x) { return x * x; }

	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1267 : 		indexes[i].distance = square(vLight.x - source.x) + square (vLight.y - source.y) + square(vLight.z - source.z);

	addss	xmm2, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR _indexes$[ebp+ecx*8+4], xmm2
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL8@SetLights
$LN6@SetLights:

; 1268 : 	}
; 1269 : 
; 1270 : 	qsort( (void*) indexes, MAX_LIGHTS, sizeof(LightIndex), &CScene::compareLights);

	push	OFFSET ?compareLights@CScene@@CAHPBX0@Z	; CScene::compareLights
	push	8
	lea	eax, DWORD PTR _indexes$[ebp]
	push	30					; 0000001eH
	push	eax
	call	_qsort

; 1271 : 
; 1272 : 	int count;
; 1273 : 	
; 1274 : 	if( lightCount < MAX_SHADER_LIGHTS )

	mov	esi, 12					; 0000000cH
	add	esp, 16					; 00000010H
	cmp	edi, esi
	cmovl	esi, edi

; 1287 : 	for(int i = 0; i < count; i++)

	xor	edi, edi
	test	esi, esi
	jle	$LN1@SetLights
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 548  :     w = f;

	mov	DWORD PTR $T1[ebp+12], edi
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1287 : 	for(int i = 0; i < count; i++)

	xor	edx, edx
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 548  :     w = f;

	mov	DWORD PTR $T2[ebp+12], edi

; 555  :     y = fy;

	mov	DWORD PTR $T3[ebp+4], edi

; 556  :     z = fz;

	mov	DWORD PTR $T3[ebp+8], edi

; 557  :     w = fw;

	mov	DWORD PTR $T3[ebp+12], edi
$LL3@SetLights:
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1289 : 		int c = indexes[i].index;

	mov	eax, DWORD PTR _indexes$[ebp+edi*8]
	lea	edx, DWORD PTR [edx+16]
	inc	edi
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	ecx, DWORD PTR [ebx+eax*4+812]
	mov	eax, DWORD PTR [ecx]
; File c:\users\simon\documents\github\post-processing\model.h

; 87   : 		return m_Position;

	movq	xmm0, QWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+16]
	movq	QWORD PTR $T4[ebp], xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 545  :     x = v.x;

	movss	xmm0, DWORD PTR $T4[ebp]
	movss	DWORD PTR $T1[ebp], xmm0

; 546  :     y = v.y;

	movss	xmm0, DWORD PTR $T4[ebp+4]
	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\simon\documents\github\post-processing\model.h

; 87   : 		return m_Position;

	mov	DWORD PTR $T4[ebp+8], eax
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 547  :     z = v.z;

	movss	xmm0, DWORD PTR $T4[ebp+8]
	movss	DWORD PTR $T1[ebp+8], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1290 : 		positions[i] = D3DXVECTOR4 (mpLights[c]->GetModel()->GetPosition(), 0 );

	movdqu	xmm0, XMMWORD PTR $T1[ebp]
	movdqu	XMMWORD PTR _positions$[ebp+edx-16], xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm0, DWORD PTR [ecx+4]

; 322  :     y = fy;

	movss	xmm1, DWORD PTR [ecx+8]

; 323  :     z = fz;

	movss	xmm2, DWORD PTR [ecx+12]

; 545  :     x = v.x;

	movss	DWORD PTR $T2[ebp], xmm0

; 546  :     y = v.y;

	movss	DWORD PTR $T2[ebp+4], xmm1

; 547  :     z = v.z;

	movss	DWORD PTR $T2[ebp+8], xmm2
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1291 : 		colours[i] = D3DXVECTOR4 ( mpLights[c]->GetColourV(), 0 );

	movdqu	xmm0, XMMWORD PTR $T2[ebp]
	movdqu	XMMWORD PTR _colours$[ebp+edx-16], xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 554  :     x = fx;

	movss	xmm0, DWORD PTR [ecx+24]
	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1292 : 		bright[i] = D3DXVECTOR4( mpLights[c]->GetBrightness(), 0, 0, 0 );   // vector 4 for packing, remaining variables would be useful for light type and angle. 

	movdqu	xmm0, XMMWORD PTR $T3[ebp]
	movdqu	XMMWORD PTR _bright$[ebp+edx-16], xmm0
	cmp	edi, esi
	jl	$LL3@SetLights
$LN1@SetLights:

; 1293 : 	}
; 1294 : 
; 1295 : 	dxLightPosA->SetRawValue( positions, 0, 16 * count );

	mov	ecx, DWORD PTR [ebx+3116]
	lea	edx, DWORD PTR _positions$[ebp]
	shl	esi, 4
	push	esi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	edx
	push	ecx
	call	DWORD PTR [eax+92]

; 1296 : 	dxLightColourA->SetRawValue( colours, 0, 16 * count );

	mov	eax, DWORD PTR [ebx+3124]
	lea	edx, DWORD PTR _colours$[ebp]
	push	esi
	push	0
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+92]

; 1297 : 	dxLightBrightnessA->SetRawValue( bright, 0, 16 * count );

	mov	eax, DWORD PTR [ebx+3132]
	lea	edx, DWORD PTR _bright$[ebp]
	push	esi
	push	0
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+92]

; 1298 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?SetLights@CScene@@AAEXUD3DXVECTOR3@@QAPAVCLight@@H@Z ENDP ; CScene::SetLights
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?TestItems@CScene@@AAE_NXZ
_TEXT	SEGMENT
$T2 = -104						; size = 12
$T3 = -92						; size = 12
$T4 = -80						; size = 12
$T5 = -68						; size = 12
$T6 = -68						; size = 12
$T7 = -56						; size = 12
$T8 = -52						; size = 8
$T9 = -48						; size = 4
$T10 = -48						; size = 4
_i$1$ = -44						; size = 4
$T11 = -44						; size = 4
$T12 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?TestItems@CScene@@AAE_NXZ PROC				; CScene::TestItems, COMDAT
; _this$ = ecx

; 1447 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TestItems@CScene@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1448 : 	for( int i = 0; i < 30; i++)

	xor	edi, edi
	npad	1
$LL7@TestItems:

; 1450 : 		mpObjects[miNumObjects] = new CRenderObject("Teapot.x",D3DXVECTOR3(250, 10, i*30.0f), D3DXVECTOR3(1.0f, i/10.0f, i/10.0f), mTechniques[0], mTechniquesMirror[0], NULL, NULL, NULL, NULL);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T11[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edx, edx
	je	$LN10@TestItems
	movss	xmm2, DWORD PTR __real@41200000
	movd	xmm0, edi
	cvtdq2ps xmm0, xmm0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR [esi+2736]
	movaps	xmm1, xmm0
	mulss	xmm0, DWORD PTR __real@41f00000
	push	DWORD PTR [esi+2616]
	divss	xmm1, xmm2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	movss	DWORD PTR $T6[ebp+8], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1450 : 		mpObjects[miNumObjects] = new CRenderObject("Teapot.x",D3DXVECTOR3(250, 10, i*30.0f), D3DXVECTOR3(1.0f, i/10.0f, i/10.0f), mTechniques[0], mTechniquesMirror[0], NULL, NULL, NULL, NULL);

	movss	xmm0, DWORD PTR __real@3f800000
	unpcklps xmm0, xmm1
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __real@437a0000
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	movss	DWORD PTR $T7[ebp+8], xmm1
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1450 : 		mpObjects[miNumObjects] = new CRenderObject("Teapot.x",D3DXVECTOR3(250, 10, i*30.0f), D3DXVECTOR3(1.0f, i/10.0f, i/10.0f), mTechniques[0], mTechniquesMirror[0], NULL, NULL, NULL, NULL);

	mov	eax, DWORD PTR $T7[ebp+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T6[ebp+8]
	unpcklps xmm0, xmm2
	push	OFFSET ??_C@_08KCKKFACH@Teapot?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN11@TestItems
$LN10@TestItems:
	xor	ecx, ecx
$LN11@TestItems:
	mov	eax, DWORD PTR [esi+808]
	inc	edi
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx

; 1451 : 		miNumObjects++;

	inc	DWORD PTR [esi+808]
	cmp	edi, 30					; 0000001eH
	jl	$LL7@TestItems

; 1452 : 	}
; 1453 : 
; 1454 : 	CModel* temp;
; 1455 : 	for(int i = 0; i < 10; i++ )

	mov	DWORD PTR _i$1$[ebp], 0
	npad	6
$LL4@TestItems:

; 1457 : 		temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T10[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	edx, edx
	je	SHORT $LN12@TestItems
	sub	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T5[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1457 : 		temp = new CModel;

	mov	eax, DWORD PTR $T5[ebp+8]
	xorps	xmm1, xmm1
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T4[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1457 : 		temp = new CModel;

	movss	xmm0, xmm1
	mov	DWORD PTR [esp+12], 1065353216		; 3f800000H
	sub	esp, 12					; 0000000cH
	unpcklps xmm0, xmm1
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T4[ebp+8]
	unpcklps xmm0, xmm1
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	edi, eax
	jmp	SHORT $LN13@TestItems
$LN12@TestItems:
	xor	edi, edi
$LN13@TestItems:

; 1458 : 		mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN14@TestItems
	mov	ecx, eax
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	ecx, eax
	jmp	SHORT $LN15@TestItems
$LN14@TestItems:
	xor	ecx, ecx
$LN15@TestItems:
	mov	eax, DWORD PTR [esi+932]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	8
	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1458 : 		mpLights[miNumLights] = new CLight();

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+812], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	ecx, DWORD PTR $T12[ebp]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T12[ebp+20], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T12[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T12[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1459 : 		if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	0
	push	DWORD PTR [esi+2616]
	lea	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	eax
	mov	ecx, edi
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	test	al, al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	sete	bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T12[ebp+20], 16		; 00000010H
	jb	SHORT $LN92@TestItems
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T12[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN92@TestItems:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T12[ebp+20], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T12[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T12[ebp], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1459 : 		if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	test	bl, bl
	jne	$LN122@TestItems

; 1461 : 		mpLights[miNumLights]->SetColour(i/10.0f, i/10.0f, 1.0f);

	mov	ebx, DWORD PTR _i$1$[ebp]
	sub	esp, 12					; 0000000cH
; File c:\users\simon\documents\github\post-processing\light.h

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	mov	eax, DWORD PTR [esi+932]
	movd	xmm0, ebx
	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1461 : 		mpLights[miNumLights]->SetColour(i/10.0f, i/10.0f, 1.0f);

	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [esp+8], 1065353216		; 3f800000H
; File c:\users\simon\documents\github\post-processing\light.h

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	mov	DWORD PTR [eax], edi
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1461 : 		mpLights[miNumLights]->SetColour(i/10.0f, i/10.0f, 1.0f);

	mov	ecx, DWORD PTR [esi+932]
	divss	xmm0, DWORD PTR __real@41200000
	mov	ecx, DWORD PTR [esi+ecx*4+812]
	movss	DWORD PTR [esp+4], xmm0
	movq	QWORD PTR $T8[ebp], xmm0
	movss	DWORD PTR [esp], xmm0
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movss	xmm1, DWORD PTR __real@41200000
	movd	xmm0, ebx
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1462 : 		mpLights[miNumLights]->GetModel()->SetPosition( D3DXVECTOR3(200, 10, i*30.0f) );

	cvtdq2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1462 : 		mpLights[miNumLights]->GetModel()->SetPosition( D3DXVECTOR3(200, 10, i*30.0f) );

	mulss	xmm0, DWORD PTR __real@41f00000
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	movss	DWORD PTR $T2[ebp+8], xmm0
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movss	xmm0, DWORD PTR __real@43480000
	mov	eax, DWORD PTR $T2[ebp+8]
	unpcklps xmm0, xmm1
	movq	QWORD PTR [ecx+8], xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	movq	xmm0, QWORD PTR $T8[ebp]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	mov	DWORD PTR [ecx+16], eax
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	movss	DWORD PTR $T3[ebp+8], xmm0
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR $T3[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1464 : 		mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	ecx, DWORD PTR [ecx]
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 1465 : 		miNumLights++;

	inc	DWORD PTR [esi+932]
	inc	ebx
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	ebx, 10					; 0000000aH
	jl	$LL4@TestItems

; 1466 : 	}
; 1467 : 	return true;

	mov	al, 1
	jmp	SHORT $LN8@TestItems
$LN122@TestItems:

; 1459 : 		if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	xor	al, al
$LN8@TestItems:

; 1468 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TestItems@CScene@@AAE_NXZ$0:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?TestItems@CScene@@AAE_NXZ$1:
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?TestItems@CScene@@AAE_NXZ$2:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?TestItems@CScene@@AAE_NXZ$3:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?TestItems@CScene@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TestItems@CScene@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?TestItems@CScene@@AAE_NXZ ENDP				; CScene::TestItems
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?SceneItems@CScene@@AAE_NXZ
_TEXT	SEGMENT
$T2 = -128						; size = 8
$T3 = -120						; size = 8
$T4 = -112						; size = 12
$T5 = -112						; size = 12
$T6 = -108						; size = 8
$T7 = -100						; size = 12
$T8 = -100						; size = 12
$T9 = -96						; size = 8
$T10 = -96						; size = 8
$T11 = -88						; size = 8
$T12 = -80						; size = 12
$T13 = -80						; size = 12
$T14 = -80						; size = 12
$T15 = -80						; size = 12
$T16 = -80						; size = 12
$T17 = -80						; size = 12
$T18 = -80						; size = 12
$T19 = -68						; size = 4
$T20 = -68						; size = 4
$T21 = -68						; size = 4
$T22 = -68						; size = 4
$T23 = -68						; size = 4
$T24 = -68						; size = 4
$T25 = -68						; size = 4
$T26 = -68						; size = 4
$T27 = -68						; size = 4
$T28 = -68						; size = 4
$T29 = -68						; size = 4
$T30 = -64						; size = 24
$T31 = -40						; size = 24
$T32 = -40						; size = 24
$T33 = -28						; size = 12
$T34 = -28						; size = 12
$T35 = -28						; size = 12
$T36 = -28						; size = 12
$T37 = -28						; size = 12
$T38 = -28						; size = 12
$T39 = -28						; size = 12
$T40 = -28						; size = 12
$T41 = -28						; size = 12
$T42 = -28						; size = 12
$T43 = -28						; size = 12
$T44 = -28						; size = 12
$T45 = -28						; size = 12
$T46 = -28						; size = 12
$T47 = -28						; size = 12
$T48 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?SceneItems@CScene@@AAE_NXZ PROC			; CScene::SceneItems, COMDAT
; _this$ = ecx

; 1471 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SceneItems@CScene@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1478 : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T29[ebp], edx
	movss	xmm0, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	movq	QWORD PTR $T3[ebp], xmm1
	movq	QWORD PTR $T2[ebp], xmm0
	test	edx, edx
	je	SHORT $LN6@SceneItems
	sub	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T8[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1478 : 	temp = new CModel;

	mov	eax, DWORD PTR $T8[ebp+8]
	mov	ecx, esp
	movaps	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T5[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1478 : 	temp = new CModel;

	unpcklps xmm0, xmm1
	mov	DWORD PTR [esp+12], 1065353216		; 3f800000H
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T5[ebp+8]
	unpcklps xmm0, xmm1
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	edi, eax
	jmp	SHORT $LN7@SceneItems
$LN6@SceneItems:
	xor	edi, edi
$LN7@SceneItems:

; 1479 : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T28[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN8@SceneItems
	mov	ecx, eax
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	ecx, eax
	jmp	SHORT $LN9@SceneItems
$LN8@SceneItems:
	xor	ecx, ecx
$LN9@SceneItems:
	mov	eax, DWORD PTR [esi+932]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	8
	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1479 : 	mpLights[miNumLights] = new CLight();

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+812], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	ecx, DWORD PTR $T32[ebp]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T32[ebp+20], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T32[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T32[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1480 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	0
	push	DWORD PTR [esi+2616]
	lea	eax, DWORD PTR $T32[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	eax
	mov	ecx, edi
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	test	al, al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	sete	bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T32[ebp+20], 16		; 00000010H
	jb	SHORT $LN110@SceneItems
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T32[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN110@SceneItems:
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1480 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	test	bl, bl
	je	SHORT $LN3@SceneItems
$LN345@SceneItems:
	xor	al, al
	jmp	$LN4@SceneItems
$LN3@SceneItems:

; 1481 : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR [esi+932]

; 1482 : 	mpLights[miNumLights]->SetColour(1.0f, 1.0f, 1.0f);

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	DWORD PTR [esp+8], 1065353216		; 3f800000H
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\simon\documents\github\post-processing\light.h

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	mov	DWORD PTR [eax], edi
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1482 : 	mpLights[miNumLights]->SetColour(1.0f, 1.0f, 1.0f);

	mov	ecx, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR [esi+ecx*4+812]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm2, DWORD PTR __real@c37a0000

; 322  :     y = fy;

	movss	xmm1, DWORD PTR __real@425c0000
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movss	xmm0, xmm2
	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm1, DWORD PTR __real@3e4ccccd

; 323  :     z = fz;

	mov	DWORD PTR $T7[ebp+8], 1112014848	; 42480000H
	mov	DWORD PTR $T4[ebp+8], 1045220557	; 3e4ccccdH
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	mov	eax, DWORD PTR $T7[ebp+8]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movq	QWORD PTR $T11[ebp], xmm2
	movq	QWORD PTR $T10[ebp], xmm1
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movq	QWORD PTR [ecx+8], xmm0

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movss	xmm0, xmm1

; 107  : 		m_Position = position;

	mov	DWORD PTR [ecx+16], eax
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T4[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
; File c:\users\simon\documents\github\post-processing\light.h

; 71   : 	void SetBrightness(float brightness) { mBrightness = brightness; }

	movss	xmm0, DWORD PTR __real@41200000
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1485 : 	mpLights[miNumLights]->SetBrightness( 10.0f );

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\light.h

; 71   : 	void SetBrightness(float brightness) { mBrightness = brightness; }

	movq	QWORD PTR $T6[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1485 : 	mpLights[miNumLights]->SetBrightness( 10.0f );

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\light.h

; 71   : 	void SetBrightness(float brightness) { mBrightness = brightness; }

	mov	DWORD PTR [eax+24], 1092616192		; 41200000H

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1486 : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	ecx, DWORD PTR [eax]
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 1487 : 	miNumLights++;

	inc	DWORD PTR [esi+932]

; 1489 : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T27[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	edx, edx
	je	SHORT $LN10@SceneItems
	movq	xmm1, QWORD PTR $T3[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T18[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1489 : 	temp = new CModel;

	mov	eax, DWORD PTR $T18[ebp+8]
	movss	xmm0, xmm1
	unpcklps xmm0, xmm1
	mov	DWORD PTR [esp+12], 1065353216		; 3f800000H
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	unpcklps xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T48[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1489 : 	temp = new CModel;

	mov	eax, DWORD PTR $T48[ebp+8]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	edi, eax
	jmp	SHORT $LN11@SceneItems
$LN10@SceneItems:
	xor	edi, edi
$LN11@SceneItems:

; 1490 : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T26[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	eax, eax
	je	SHORT $LN12@SceneItems
	mov	ecx, eax
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	ecx, eax
	jmp	SHORT $LN13@SceneItems
$LN12@SceneItems:
	xor	ecx, ecx
$LN13@SceneItems:
	mov	eax, DWORD PTR [esi+932]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	8
	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1490 : 	mpLights[miNumLights] = new CLight();

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+812], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	ecx, DWORD PTR $T31[ebp]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T31[ebp+20], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T31[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T31[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1491 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	0
	push	DWORD PTR [esi+2616]
	lea	eax, DWORD PTR $T31[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	push	eax
	mov	ecx, edi
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	test	al, al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	sete	bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T31[ebp+20], 16		; 00000010H
	jb	SHORT $LN208@SceneItems
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T31[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN208@SceneItems:
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1491 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	test	bl, bl
	jne	$LN345@SceneItems

; 1492 : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR [esi+932]

; 1493 : 	mpLights[miNumLights]->SetColour(1.0f, 1.0f, 1.0f);

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	DWORD PTR [esp+8], 1065353216		; 3f800000H
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\simon\documents\github\post-processing\light.h

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	mov	DWORD PTR [eax], edi
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1493 : 	mpLights[miNumLights]->SetColour(1.0f, 1.0f, 1.0f);

	mov	ecx, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR [esi+ecx*4+812]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movss	xmm1, DWORD PTR __real@42aa0000
	movss	xmm0, DWORD PTR $T11[ebp]
	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm1, QWORD PTR $T10[ebp]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T47[ebp+8], 1117782016	; 42a00000H
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	mov	eax, DWORD PTR $T47[ebp+8]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T38[ebp+8], 1045220557	; 3e4ccccdH
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movq	QWORD PTR [ecx+8], xmm0

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movss	xmm0, xmm1

; 107  : 		m_Position = position;

	mov	DWORD PTR [ecx+16], eax
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T38[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1496 : 	mpLights[miNumLights]->SetBrightness( 40.0f );

	mov	eax, DWORD PTR [esi+932]
	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\light.h

; 71   : 	void SetBrightness(float brightness) { mBrightness = brightness; }

	mov	DWORD PTR [eax+24], 1109393408		; 42200000H

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1497 : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	ecx, DWORD PTR [eax]
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 1498 : 	miNumLights++;

	inc	DWORD PTR [esi+932]

; 1500 : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T25[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	test	edx, edx
	je	SHORT $LN14@SceneItems
	movq	xmm1, QWORD PTR $T3[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T46[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1500 : 	temp = new CModel;

	mov	eax, DWORD PTR $T46[ebp+8]
	movss	xmm0, xmm1
	unpcklps xmm0, xmm1
	mov	DWORD PTR [esp+12], 1065353216		; 3f800000H
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	unpcklps xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T17[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1500 : 	temp = new CModel;

	mov	eax, DWORD PTR $T17[ebp+8]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	edi, eax
	jmp	SHORT $LN15@SceneItems
$LN14@SceneItems:
	xor	edi, edi
$LN15@SceneItems:

; 1501 : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	test	eax, eax
	je	SHORT $LN16@SceneItems
	mov	ecx, eax
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	ecx, eax
	jmp	SHORT $LN17@SceneItems
$LN16@SceneItems:
	xor	ecx, ecx
$LN17@SceneItems:
	mov	eax, DWORD PTR [esi+932]

; 1502 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+812], ecx
	lea	ecx, DWORD PTR $T30[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	0
	push	DWORD PTR [esi+2616]
	lea	eax, DWORD PTR $T30[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	push	eax
	mov	ecx, edi
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	test	al, al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	sete	bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T30[ebp+20], 16		; 00000010H
	jb	SHORT $LN262@SceneItems
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T30[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN262@SceneItems:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T30[ebp+20], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T30[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T30[ebp], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1502 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	test	bl, bl
	jne	$LN345@SceneItems

; 1503 : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR [esi+932]

; 1504 : 	mpLights[miNumLights]->SetColour(1.0f, 1.0f, 1.0f);

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	DWORD PTR [esp+8], 1065353216		; 3f800000H
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\simon\documents\github\post-processing\light.h

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	mov	DWORD PTR [eax], edi
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1504 : 	mpLights[miNumLights]->SetColour(1.0f, 1.0f, 1.0f);

	mov	ecx, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR [esi+ecx*4+812]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movss	xmm0, DWORD PTR $T11[ebp]
	movss	xmm1, DWORD PTR __real@42aa0000
	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T45[ebp+8], 1101004800	; 41a00000H
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	mov	eax, DWORD PTR $T45[ebp+8]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T37[ebp+8], 1045220557	; 3e4ccccdH
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movq	QWORD PTR [ecx+8], xmm0

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm0, QWORD PTR $T10[ebp]

; 107  : 		m_Position = position;

	mov	DWORD PTR [ecx+16], eax
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T37[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1507 : 	mpLights[miNumLights]->SetBrightness( 40.0f );

	mov	eax, DWORD PTR [esi+932]
	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\light.h

; 71   : 	void SetBrightness(float brightness) { mBrightness = brightness; }

	mov	DWORD PTR [eax+24], 1109393408		; 42200000H

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1508 : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	ecx, DWORD PTR [eax]
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 1509 : 	miNumLights++;

	inc	DWORD PTR [esi+932]

; 1511 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, 25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TripleOutline], mTechniquesMirror[TripleOutline], mpMaps[9], NULL, true, true, false ); 

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T23[ebp], edx
	movss	xmm1, DWORD PTR __real@3f4ccccd
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	movq	QWORD PTR $T9[ebp], xmm1
	test	edx, edx
	je	SHORT $LN18@SceneItems
	push	0
	push	1
	push	1
	push	0
	push	DWORD PTR [esi+972]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T44[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1511 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, 25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TripleOutline], mTechniquesMirror[TripleOutline], mpMaps[9], NULL, true, true, false ); 

	push	DWORD PTR [esi+2800]
	mov	eax, DWORD PTR $T44[ebp+8]
	push	DWORD PTR [esi+2680]
	unpcklps xmm0, xmm1
	movss	xmm1, DWORD PTR __real@40a00000
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T16[ebp+8], 1117126656	; 42960000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1511 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, 25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TripleOutline], mTechniquesMirror[TripleOutline], mpMaps[9], NULL, true, true, false ); 

	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR $T11[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T16[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN19@SceneItems
$LN18@SceneItems:
	xor	ecx, ecx
$LN19@SceneItems:
	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm1, QWORD PTR $T6[ebp]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T36[ebp+8], 1092616192	; 41200000H
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1511 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, 25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TripleOutline], mTechniquesMirror[TripleOutline], mpMaps[9], NULL, true, true, false ); 

	mov	DWORD PTR [esi+eax*4+8], ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1515 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, -25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TextureMorph], mTechniquesMirror[TextureMorph], mpMaps[10], mpMaps[11], true, false, false ); 

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+8]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T36[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1513 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1515 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, -25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TextureMorph], mTechniquesMirror[TextureMorph], mpMaps[10], mpMaps[11], true, false, false ); 

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T22[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	edx, edx
	je	SHORT $LN20@SceneItems
	movq	xmm1, QWORD PTR $T9[ebp]
	push	0
	push	0
	push	1
	push	DWORD PTR [esi+980]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T43[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1515 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, -25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TextureMorph], mTechniquesMirror[TextureMorph], mpMaps[10], mpMaps[11], true, false, false ); 

	push	DWORD PTR [esi+976]
	mov	eax, DWORD PTR $T43[ebp+8]
	push	DWORD PTR [esi+2804]
	unpcklps xmm0, xmm1
	push	DWORD PTR [esi+2684]
	movss	xmm1, DWORD PTR __real@40a00000
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T15[ebp+8], 1103626240	; 41c80000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1515 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, -25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TextureMorph], mTechniquesMirror[TextureMorph], mpMaps[10], mpMaps[11], true, false, false ); 

	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR $T11[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T15[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN21@SceneItems
$LN20@SceneItems:
	xor	ecx, ecx
$LN21@SceneItems:
	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm1, QWORD PTR $T6[ebp]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T35[ebp+8], 1092616192	; 41200000H
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1515 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x", D3DXVECTOR3(xOff, yOff, -25.0f+zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[TextureMorph], mTechniquesMirror[TextureMorph], mpMaps[10], mpMaps[11], true, false, false ); 

	mov	DWORD PTR [esi+eax*4+8], ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\model.h

; 111  : 		m_Rotation = rotation;

	movq	xmm1, QWORD PTR $T3[ebp]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1521 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3( xOff, yOff+5.0f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[6], mpMaps[7], true, false, true);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+8]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T35[ebp+8]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T42[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	QWORD PTR [ecx+32], xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 322  :     y = fy;

	movss	xmm0, DWORD PTR __real@40490fdb
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\model.h

; 111  : 		m_Rotation = rotation;

	unpcklps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+8]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 111  : 		m_Rotation = rotation;

	mov	eax, DWORD PTR $T42[ebp+8]
	movq	QWORD PTR [ecx+20], xmm1
	mov	DWORD PTR [ecx+28], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1518 : 	mpObjects[miNumObjects]->SetWiggle( 2.0f );

	mov	eax, DWORD PTR [esi+808]
	mov	eax, DWORD PTR [esi+eax*4+8]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 99   : 	void SetWiggle( float rate ) { mWiggle = true; mWiggleRate = rate; }

	mov	BYTE PTR [eax+56], 1
	mov	DWORD PTR [eax+60], 1073741824		; 40000000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1519 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1521 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3( xOff, yOff+5.0f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[6], mpMaps[7], true, false, true);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T21[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	edx, edx
	je	SHORT $LN22@SceneItems
	movq	xmm1, QWORD PTR $T2[ebp]
	push	1
	push	0
	push	1
	push	DWORD PTR [esi+964]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T41[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1521 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3( xOff, yOff+5.0f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[6], mpMaps[7], true, false, true);

	push	DWORD PTR [esi+960]
	mov	eax, DWORD PTR $T41[ebp+8]
	push	DWORD PTR [esi+2764]
	unpcklps xmm0, xmm1
	push	DWORD PTR [esi+2644]
	movq	xmm1, QWORD PTR $T6[ebp]
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T14[ebp+8], 1112014848	; 42480000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1521 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3( xOff, yOff+5.0f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[6], mpMaps[7], true, false, true);

	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR $T11[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T14[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN23@SceneItems
$LN22@SceneItems:
	xor	ecx, ecx
$LN23@SceneItems:
	mov	eax, DWORD PTR [esi+808]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm0, DWORD PTR __real@3fc00000
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T34[ebp+8], 1069547520	; 3fc00000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1521 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3( xOff, yOff+5.0f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[6], mpMaps[7], true, false, true);

	mov	DWORD PTR [esi+eax*4+8], ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1525 : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x", D3DXVECTOR3( xOff, yOff+12.5f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[13], mpMaps[14], true, false, true);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+8]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T34[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1523 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1525 : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x", D3DXVECTOR3( xOff, yOff+12.5f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[13], mpMaps[14], true, false, true);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T20[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	edx, edx
	je	SHORT $LN24@SceneItems
	movq	xmm0, QWORD PTR $T2[ebp]
	push	1
	push	0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 322  :     y = fy;

	movss	xmm1, DWORD PTR __real@418c0000
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1525 : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x", D3DXVECTOR3( xOff, yOff+12.5f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[13], mpMaps[14], true, false, true);

	push	1
	push	DWORD PTR [esi+992]
	unpcklps xmm0, xmm0
	push	DWORD PTR [esi+988]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T40[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1525 : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x", D3DXVECTOR3( xOff, yOff+12.5f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[13], mpMaps[14], true, false, true);

	push	DWORD PTR [esi+2764]
	mov	eax, DWORD PTR $T40[ebp+8]
	push	DWORD PTR [esi+2644]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T13[ebp+8], 1112014848	; 42480000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1525 : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x", D3DXVECTOR3( xOff, yOff+12.5f, zOff), D3DXVECTOR3( 1.0f, 1.0f, 1.0f ), mTechniques[ParallaxMapped], mTechniquesMirror[ParallaxMapped], mpMaps[13], mpMaps[14], true, false, true);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR $T11[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T13[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_08KCKKFACH@Teapot?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN25@SceneItems
$LN24@SceneItems:
	xor	ecx, ecx
$LN25@SceneItems:
	mov	eax, DWORD PTR [esi+808]

; 1529 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3(xOff, yOff+15.0f, zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[LitGlass], mTechniquesMirror[LitGlass], mpMaps[8], NULL, true, true, false ); 

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	inc	DWORD PTR [esi+808]
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T19[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	edx, edx
	je	SHORT $LN26@SceneItems
	movq	xmm0, QWORD PTR $T9[ebp]
	push	0
	push	1
	movss	xmm1, DWORD PTR __real@41a00000
	push	1
	push	0
	push	DWORD PTR [esi+968]
	unpcklps xmm0, xmm0
	push	DWORD PTR [esi+2792]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T39[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1529 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3(xOff, yOff+15.0f, zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[LitGlass], mTechniquesMirror[LitGlass], mpMaps[8], NULL, true, true, false ); 

	push	DWORD PTR [esi+2672]
	mov	eax, DWORD PTR $T39[ebp+8]
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T12[ebp+8], 1112014848	; 42480000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1529 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3(xOff, yOff+15.0f, zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[LitGlass], mTechniquesMirror[LitGlass], mpMaps[8], NULL, true, true, false ); 

	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR $T11[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T12[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN27@SceneItems
$LN26@SceneItems:
	xor	ecx, ecx
$LN27@SceneItems:
	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm0, QWORD PTR $T6[ebp]
	unpcklps xmm0, xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T33[ebp+8], 1092616192	; 41200000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1529 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x", D3DXVECTOR3(xOff, yOff+15.0f, zOff), D3DXVECTOR3( 0.8f, 0.8f, 0.0f ), mTechniques[LitGlass], mTechniquesMirror[LitGlass], mpMaps[8], NULL, true, true, false ); 

	mov	DWORD PTR [esi+eax*4+8], ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+808]
	mov	eax, DWORD PTR [esi+eax*4+8]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR $T33[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1534 : 	return true;

	mov	al, 1
	inc	DWORD PTR [esi+808]
$LN4@SceneItems:

; 1535 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$0:
	mov	eax, DWORD PTR $T29[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$1:
	mov	eax, DWORD PTR $T28[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$2:
	lea	ecx, DWORD PTR $T32[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$3:
	mov	eax, DWORD PTR $T27[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$4:
	mov	eax, DWORD PTR $T26[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$5:
	lea	ecx, DWORD PTR $T31[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$6:
	mov	eax, DWORD PTR $T25[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$7:
	mov	eax, DWORD PTR $T24[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$8:
	lea	ecx, DWORD PTR $T30[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$9:
	mov	eax, DWORD PTR $T23[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$10:
	mov	eax, DWORD PTR $T22[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$11:
	mov	eax, DWORD PTR $T21[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$12:
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SceneItems@CScene@@AAE_NXZ$13:
	mov	eax, DWORD PTR $T19[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SceneItems@CScene@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SceneItems@CScene@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SceneItems@CScene@@AAE_NXZ ENDP			; CScene::SceneItems
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\users\simon\documents\github\post-processing\scene.cpp
;	COMDAT ?BasicItems@CScene@@AAE_NXZ
_TEXT	SEGMENT
$T2 = -136						; size = 12
$T3 = -136						; size = 12
$T4 = -132						; size = 8
$T5 = -124						; size = 12
$T6 = -124						; size = 12
$T7 = -124						; size = 12
$T8 = -124						; size = 12
$T9 = -120						; size = 8
$T10 = -112						; size = 8
$T11 = -112						; size = 8
$T12 = -104						; size = 8
$T13 = -96						; size = 8
$T14 = -88						; size = 12
$T15 = -88						; size = 12
$T16 = -88						; size = 12
$T17 = -88						; size = 12
$T18 = -88						; size = 12
$T19 = -88						; size = 12
$T20 = -88						; size = 12
$T21 = -88						; size = 12
$T22 = -84						; size = 8
$T23 = -76						; size = 8
$T24 = -76						; size = 8
$T25 = -68						; size = 4
$T26 = -68						; size = 4
$T27 = -68						; size = 4
$T28 = -68						; size = 4
$T29 = -68						; size = 4
$T30 = -68						; size = 4
$T31 = -68						; size = 4
$T32 = -68						; size = 4
$T33 = -68						; size = 4
$T34 = -68						; size = 4
$T35 = -68						; size = 4
$T36 = -68						; size = 4
$T37 = -68						; size = 4
$T38 = -68						; size = 4
$T39 = -68						; size = 4
$T40 = -68						; size = 4
$T41 = -68						; size = 4
$T42 = -68						; size = 4
$T43 = -68						; size = 4
$T44 = -68						; size = 4
$T45 = -68						; size = 4
$T46 = -64						; size = 24
$T47 = -52						; size = 12
$T48 = -52						; size = 12
$T49 = -52						; size = 12
$T50 = -52						; size = 12
$T51 = -52						; size = 12
$T52 = -52						; size = 12
$T53 = -52						; size = 12
$T54 = -52						; size = 12
$T55 = -52						; size = 12
$T56 = -52						; size = 12
$T57 = -52						; size = 12
$T58 = -52						; size = 12
$T59 = -40						; size = 24
$T60 = -40						; size = 24
$T61 = -28						; size = 12
$T62 = -28						; size = 12
$T63 = -28						; size = 12
$T64 = -28						; size = 12
$T65 = -28						; size = 12
$T66 = -28						; size = 12
$T67 = -28						; size = 12
$T68 = -28						; size = 12
$T69 = -28						; size = 12
$T70 = -28						; size = 12
$T71 = -28						; size = 12
$T72 = -28						; size = 12
$T73 = -28						; size = 12
$T74 = -28						; size = 12
$T75 = -28						; size = 12
$T76 = -28						; size = 12
$T77 = -28						; size = 12
$T78 = -28						; size = 12
$T79 = -28						; size = 12
$T80 = -28						; size = 12
$T81 = -28						; size = 12
$T82 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?BasicItems@CScene@@AAE_NXZ PROC			; CScene::BasicItems, COMDAT
; _this$ = ecx

; 1301 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BasicItems@CScene@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1304 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(0, 10, 0),			D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[7], mTechniquesMirror[7], mpMaps[3], mpMaps[4], true, false, true);

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T45[ebp], edx
	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	movq	QWORD PTR $T13[ebp], xmm2
	movq	QWORD PTR $T12[ebp], xmm1
	test	edx, edx
	je	SHORT $LN6@BasicItems
	push	1
	push	0
	push	1
	push	DWORD PTR [esi+952]
	movss	xmm0, xmm2
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T21[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1304 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(0, 10, 0),			D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[7], mTechniquesMirror[7], mpMaps[3], mpMaps[4], true, false, true);

	push	DWORD PTR [esi+948]
	mov	eax, DWORD PTR $T21[ebp+8]
	push	DWORD PTR [esi+2764]
	unpcklps xmm0, xmm2
	push	DWORD PTR [esi+2644]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T8[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1304 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(0, 10, 0),			D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[7], mTechniquesMirror[7], mpMaps[3], mpMaps[4], true, false, true);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@41200000
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T8[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN7@BasicItems
$LN6@BasicItems:
	xor	ecx, ecx
$LN7@BasicItems:
	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 92   : 	void SetSpinY( float rate ) { mSpinY = true; mSpinYRate = rate; }

	movss	xmm0, DWORD PTR __real@3f000000
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1309 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(0, 10, 40),			D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[7], mTechniquesMirror[7], mpMaps[6], mpMaps[7], true, false, true);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 92   : 	void SetSpinY( float rate ) { mSpinY = true; mSpinYRate = rate; }

	movq	QWORD PTR $T11[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1305 : 	mpObjects[miNumObjects]->SetSpinY(0.5f);

	mov	eax, DWORD PTR [esi+eax*4+8]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 92   : 	void SetSpinY( float rate ) { mSpinY = true; mSpinYRate = rate; }

	mov	BYTE PTR [eax+42], 1
	mov	DWORD PTR [eax+48], 1056964608		; 3f000000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1306 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1309 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(0, 10, 40),			D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[7], mTechniquesMirror[7], mpMaps[6], mpMaps[7], true, false, true);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T44[ebp], edx
	movss	xmm0, DWORD PTR __real@42200000
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	movq	QWORD PTR $T24[ebp], xmm0
	test	edx, edx
	je	SHORT $LN8@BasicItems
	movq	xmm1, QWORD PTR $T13[ebp]
	push	1
	push	0
	push	1
	push	DWORD PTR [esi+964]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T20[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1309 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(0, 10, 40),			D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[7], mTechniquesMirror[7], mpMaps[6], mpMaps[7], true, false, true);

	push	DWORD PTR [esi+960]
	mov	eax, DWORD PTR $T20[ebp+8]
	push	DWORD PTR [esi+2764]
	unpcklps xmm0, xmm1
	push	DWORD PTR [esi+2644]
	movss	xmm1, DWORD PTR __real@41200000
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T7[ebp+8], 1109393408	; 42200000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1309 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(0, 10, 40),			D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[7], mTechniquesMirror[7], mpMaps[6], mpMaps[7], true, false, true);

	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR $T12[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T7[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN9@BasicItems
$LN8@BasicItems:
	xor	ecx, ecx
$LN9@BasicItems:
	mov	eax, DWORD PTR [esi+808]

; 1315 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(40, 10, 40),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[8], mTechniquesMirror[8], mpMaps[6], NULL, true, true);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	mov	eax, DWORD PTR [esi+808]
	mov	eax, DWORD PTR [esi+eax*4+8]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 92   : 	void SetSpinY( float rate ) { mSpinY = true; mSpinYRate = rate; }

	mov	BYTE PTR [eax+42], 1
	mov	DWORD PTR [eax+48], 1056964608		; 3f000000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1311 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1315 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(40, 10, 40),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[8], mTechniquesMirror[8], mpMaps[6], NULL, true, true);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T43[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	edx, edx
	je	SHORT $LN10@BasicItems
	movq	xmm1, QWORD PTR $T13[ebp]
	push	0
	push	1
	push	1
	push	0
	push	DWORD PTR [esi+960]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T19[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1315 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(40, 10, 40),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[8], mTechniquesMirror[8], mpMaps[6], NULL, true, true);

	push	DWORD PTR [esi+2768]
	mov	eax, DWORD PTR $T19[ebp+8]
	push	DWORD PTR [esi+2648]
	unpcklps xmm0, xmm1
	movss	xmm1, DWORD PTR __real@41200000
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T6[ebp+8], 1109393408	; 42200000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1315 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(40, 10, 40),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[8], mTechniquesMirror[8], mpMaps[6], NULL, true, true);

	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR $T24[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T6[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN11@BasicItems
$LN10@BasicItems:
	xor	ecx, ecx
$LN11@BasicItems:
	mov	eax, DWORD PTR [esi+808]

; 1320 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 20, 10, 0 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[1], mTechniquesMirror[1], mpMaps[0], NULL, false, false);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	mov	eax, DWORD PTR [esi+808]
	mov	eax, DWORD PTR [esi+eax*4+8]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 99   : 	void SetWiggle( float rate ) { mWiggle = true; mWiggleRate = rate; }

	mov	BYTE PTR [eax+56], 1
	mov	DWORD PTR [eax+60], 1073741824		; 40000000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1317 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1320 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 20, 10, 0 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[1], mTechniquesMirror[1], mpMaps[0], NULL, false, false);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T42[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	edx, edx
	je	SHORT $LN12@BasicItems
	movq	xmm1, QWORD PTR $T13[ebp]
	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR [esi+936]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T18[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1320 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 20, 10, 0 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[1], mTechniquesMirror[1], mpMaps[0], NULL, false, false);

	push	DWORD PTR [esi+2740]
	mov	eax, DWORD PTR $T18[ebp+8]
	push	DWORD PTR [esi+2620]
	unpcklps xmm0, xmm1
	movss	xmm1, DWORD PTR __real@41200000
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T5[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1320 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 20, 10, 0 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[1], mTechniquesMirror[1], mpMaps[0], NULL, false, false);

	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __real@41a00000
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T5[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN13@BasicItems
$LN12@BasicItems:
	xor	ecx, ecx
$LN13@BasicItems:
	mov	eax, DWORD PTR [esi+808]

; 1325 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(-20, 10, 0),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[0], NULL, true, false);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	inc	DWORD PTR [esi+808]
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T41[ebp], edx
	movss	xmm2, DWORD PTR __real@c1a00000
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	movq	QWORD PTR $T9[ebp], xmm2
	test	edx, edx
	je	SHORT $LN14@BasicItems
	movq	xmm1, QWORD PTR $T13[ebp]
	push	0
	push	0
	push	1
	push	0
	push	DWORD PTR [esi+936]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T17[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1325 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(-20, 10, 0),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[0], NULL, true, false);

	push	DWORD PTR [esi+2760]
	mov	eax, DWORD PTR $T17[ebp+8]
	push	DWORD PTR [esi+2640]
	unpcklps xmm0, xmm1
	movss	xmm1, DWORD PTR __real@41200000
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T3[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1325 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3(-20, 10, 0),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[0], NULL, true, false);

	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm2
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T3[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN15@BasicItems
$LN14@BasicItems:
	xor	ecx, ecx
$LN15@BasicItems:
	mov	eax, DWORD PTR [esi+808]

; 1329 : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x",	D3DXVECTOR3( 15, 5, 15 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[5], mTechniquesMirror[5], mpMaps[2], NULL, true, false);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	inc	DWORD PTR [esi+808]
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T40[ebp], edx
	movss	xmm3, DWORD PTR __real@40a00000
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	movq	QWORD PTR $T23[ebp], xmm3
	test	edx, edx
	je	SHORT $LN16@BasicItems
	movq	xmm2, QWORD PTR $T13[ebp]
	push	0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm1, DWORD PTR __real@41700000
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1329 : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x",	D3DXVECTOR3( 15, 5, 15 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[5], mTechniquesMirror[5], mpMaps[2], NULL, true, false);

	movss	xmm0, xmm2
	push	0
	push	1
	push	0
	push	DWORD PTR [esi+944]
	unpcklps xmm0, xmm2
	push	DWORD PTR [esi+2756]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T16[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1329 : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x",	D3DXVECTOR3( 15, 5, 15 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[5], mTechniquesMirror[5], mpMaps[2], NULL, true, false);

	push	DWORD PTR [esi+2636]
	mov	eax, DWORD PTR $T16[ebp+8]
	sub	esp, 12					; 0000000cH
	unpcklps xmm1, xmm3
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T2[ebp+8], 1097859072	; 41700000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1329 : 	mpObjects[miNumObjects] = new CRenderObject("Teapot.x",	D3DXVECTOR3( 15, 5, 15 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[5], mTechniquesMirror[5], mpMaps[2], NULL, true, false);

	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T2[ebp+8]
	push	OFFSET ??_C@_08KCKKFACH@Teapot?4x?$AA@
	movq	QWORD PTR [ecx], xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN17@BasicItems
$LN16@BasicItems:
	xor	ecx, ecx
$LN17@BasicItems:
	mov	eax, DWORD PTR [esi+808]

; 1336 : 	mpObjects[miNumObjects] = new CRenderObject("Sphere.x",	D3DXVECTOR3(50, 30, 10),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[2], mTechniquesMirror[2], mpMaps[0], NULL, false, true);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	mov	eax, DWORD PTR [esi+808]
	mov	eax, DWORD PTR [esi+eax*4+8]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 91   : 	void SetSpinX( float rate ) { mSpinX = true; mSpinXRate = rate; }

	mov	BYTE PTR [eax+41], 1
	mov	DWORD PTR [eax+44], 1084227584		; 40a00000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1331 : 	mpObjects[miNumObjects]->SetSpinZ(2.5f);

	mov	eax, DWORD PTR [esi+808]
	mov	eax, DWORD PTR [esi+eax*4+8]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 93   : 	void SetSpinZ( float rate ) { mSpinZ = true; mSpinZRate = rate; }

	mov	BYTE PTR [eax+43], 1
	mov	DWORD PTR [eax+52], 1075838976		; 40200000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1332 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1336 : 	mpObjects[miNumObjects] = new CRenderObject("Sphere.x",	D3DXVECTOR3(50, 30, 10),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[2], mTechniquesMirror[2], mpMaps[0], NULL, false, true);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T39[ebp], edx
	movss	xmm2, DWORD PTR __real@42480000
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	movq	QWORD PTR $T4[ebp], xmm2
	test	edx, edx
	je	SHORT $LN18@BasicItems
	movq	xmm1, QWORD PTR $T13[ebp]
	push	0
	push	1
	push	0
	push	0
	push	DWORD PTR [esi+936]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T15[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1336 : 	mpObjects[miNumObjects] = new CRenderObject("Sphere.x",	D3DXVECTOR3(50, 30, 10),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[2], mTechniquesMirror[2], mpMaps[0], NULL, false, true);

	push	DWORD PTR [esi+2744]
	mov	eax, DWORD PTR $T15[ebp+8]
	push	DWORD PTR [esi+2624]
	unpcklps xmm0, xmm1
	movss	xmm1, DWORD PTR __real@41f00000
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T58[ebp+8], 1092616192	; 41200000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1336 : 	mpObjects[miNumObjects] = new CRenderObject("Sphere.x",	D3DXVECTOR3(50, 30, 10),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[2], mTechniquesMirror[2], mpMaps[0], NULL, false, true);

	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm2
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T58[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN19@BasicItems
$LN18@BasicItems:
	xor	ecx, ecx
$LN19@BasicItems:
	mov	eax, DWORD PTR [esi+808]

; 1341 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 180, 5, 152 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[4], mTechniquesMirror[4], mpMaps[0], NULL, true, false);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	mov	eax, DWORD PTR [esi+808]
	mov	eax, DWORD PTR [esi+eax*4+8]
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 88   : 	void SetColourCycle() { mColourCycle = true; }

	mov	BYTE PTR [eax+40], 1
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1338 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1341 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 180, 5, 152 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[4], mTechniquesMirror[4], mpMaps[0], NULL, true, false);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T38[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	test	edx, edx
	je	SHORT $LN20@BasicItems
	movq	xmm2, QWORD PTR $T13[ebp]
	push	0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm1, DWORD PTR __real@43340000
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1341 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 180, 5, 152 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[4], mTechniquesMirror[4], mpMaps[0], NULL, true, false);

	movss	xmm0, xmm2
	push	0
	push	1
	push	0
	push	DWORD PTR [esi+936]
	unpcklps xmm0, xmm2
	push	DWORD PTR [esi+2752]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T57[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1341 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 180, 5, 152 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[4], mTechniquesMirror[4], mpMaps[0], NULL, true, false);

	push	DWORD PTR [esi+2632]
	mov	eax, DWORD PTR $T57[ebp+8]
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T14[ebp+8], 1125646336	; 43180000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1341 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 180, 5, 152 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[4], mTechniquesMirror[4], mpMaps[0], NULL, true, false);

	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR $T23[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T14[ebp+8]
	unpcklps xmm1, xmm0
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	movq	QWORD PTR [ecx], xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN21@BasicItems
$LN20@BasicItems:
	xor	ecx, ecx
$LN21@BasicItems:
	mov	eax, DWORD PTR [esi+808]

; 1345 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 200, 5, 200 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[0], NULL, true, false);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	inc	DWORD PTR [esi+808]
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T37[ebp], edx
	movss	xmm2, DWORD PTR __real@43480000
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	movq	QWORD PTR $T22[ebp], xmm2
	test	edx, edx
	je	SHORT $LN22@BasicItems
	movq	xmm1, QWORD PTR $T13[ebp]
	push	0
	push	0
	push	1
	push	0
	push	DWORD PTR [esi+936]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T56[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1345 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 200, 5, 200 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[0], NULL, true, false);

	push	DWORD PTR [esi+2760]
	mov	eax, DWORD PTR $T56[ebp+8]
	push	DWORD PTR [esi+2640]
	unpcklps xmm0, xmm1
	movq	xmm1, QWORD PTR $T23[ebp]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T82[ebp+8], 1128792064	; 43480000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1345 : 	mpObjects[miNumObjects] = new CRenderObject("Cube.x",	D3DXVECTOR3( 200, 5, 200 ),		D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[0], NULL, true, false);

	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm2
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T82[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_06HGKAGIBP@Cube?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN23@BasicItems
$LN22@BasicItems:
	xor	ecx, ecx
$LN23@BasicItems:
	mov	eax, DWORD PTR [esi+808]

; 1349 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -10 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[9], mTechniquesMirror[9], mpMaps[5], NULL, true, false);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	inc	DWORD PTR [esi+808]
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T36[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	test	edx, edx
	je	SHORT $LN24@BasicItems
	movq	xmm1, QWORD PTR $T12[ebp]
	push	0
	push	0
	push	1
	push	0
	push	DWORD PTR [esi+956]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T81[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1349 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -10 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[9], mTechniquesMirror[9], mpMaps[5], NULL, true, false);

	push	DWORD PTR [esi+2772]
	mov	eax, DWORD PTR $T81[ebp+8]
	push	DWORD PTR [esi+2652]
	unpcklps xmm0, xmm1
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T55[ebp+8], -1054867456	; c1200000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1349 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -10 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[9], mTechniquesMirror[9], mpMaps[5], NULL, true, false);

	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T55[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN25@BasicItems
$LN24@BasicItems:
	xor	ecx, ecx
$LN25@BasicItems:
	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm1, QWORD PTR $T23[ebp]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T68[ebp+8], 1084227584	; 40a00000H
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1349 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -10 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[9], mTechniquesMirror[9], mpMaps[5], NULL, true, false);

	mov	DWORD PTR [esi+eax*4+8], ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1354 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -30 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[10], mTechniquesMirror[10], mpMaps[5], NULL, true, false);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+8]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T68[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1351 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1354 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -30 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[10], mTechniquesMirror[10], mpMaps[5], NULL, true, false);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T35[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	edx, edx
	je	SHORT $LN26@BasicItems
	movq	xmm1, QWORD PTR $T12[ebp]
	push	0
	push	0
	push	1
	push	0
	push	DWORD PTR [esi+956]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T80[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1354 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -30 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[10], mTechniquesMirror[10], mpMaps[5], NULL, true, false);

	push	DWORD PTR [esi+2776]
	mov	eax, DWORD PTR $T80[ebp+8]
	push	DWORD PTR [esi+2656]
	unpcklps xmm0, xmm1
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T54[ebp+8], -1041235968	; c1f00000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1354 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -30 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[10], mTechniquesMirror[10], mpMaps[5], NULL, true, false);

	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T54[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN27@BasicItems
$LN26@BasicItems:
	xor	ecx, ecx
$LN27@BasicItems:
	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm1, QWORD PTR $T23[ebp]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T67[ebp+8], 1084227584	; 40a00000H
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1354 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 0, 0, -30 ),		D3DXVECTOR3( 0.0f, 0.0f, 0.0f), mTechniques[10], mTechniquesMirror[10], mpMaps[5], NULL, true, false);

	mov	DWORD PTR [esi+eax*4+8], ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1360 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 20, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[11], mTechniquesMirror[11], mpMaps[3], mpMaps[4], true, true, true);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+8]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T67[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1356 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1360 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 20, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[11], mTechniquesMirror[11], mpMaps[3], mpMaps[4], true, true, true);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T34[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	edx, edx
	je	SHORT $LN28@BasicItems
	movq	xmm1, QWORD PTR $T11[ebp]
	push	1
	push	1
	push	1
	push	DWORD PTR [esi+952]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T79[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1360 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 20, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[11], mTechniquesMirror[11], mpMaps[3], mpMaps[4], true, true, true);

	push	DWORD PTR [esi+948]
	mov	eax, DWORD PTR $T79[ebp+8]
	push	DWORD PTR [esi+2780]
	unpcklps xmm0, xmm1
	push	DWORD PTR [esi+2660]
	movq	xmm1, QWORD PTR $T23[ebp]
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T53[ebp+8], -1054867456	; c1200000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1360 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 20, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[11], mTechniquesMirror[11], mpMaps[3], mpMaps[4], true, true, true);

	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __real@41a00000
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T53[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN29@BasicItems
$LN28@BasicItems:
	xor	ecx, ecx
$LN29@BasicItems:
	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm1, QWORD PTR $T23[ebp]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T66[ebp+8], 1084227584	; 40a00000H
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1360 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 20, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[11], mTechniquesMirror[11], mpMaps[3], mpMaps[4], true, true, true);

	mov	DWORD PTR [esi+eax*4+8], ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1366 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 50, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[12], mTechniquesMirror[12], mpMaps[6], mpMaps[7], true, true, true);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+8]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T66[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1362 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1366 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 50, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[12], mTechniquesMirror[12], mpMaps[6], mpMaps[7], true, true, true);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T33[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	edx, edx
	je	SHORT $LN30@BasicItems
	movq	xmm1, QWORD PTR $T11[ebp]
	push	1
	push	1
	push	1
	push	DWORD PTR [esi+964]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T78[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1366 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 50, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[12], mTechniquesMirror[12], mpMaps[6], mpMaps[7], true, true, true);

	push	DWORD PTR [esi+960]
	mov	eax, DWORD PTR $T78[ebp+8]
	push	DWORD PTR [esi+2784]
	unpcklps xmm0, xmm1
	push	DWORD PTR [esi+2664]
	movq	xmm1, QWORD PTR $T4[ebp]
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T52[ebp+8], -1054867456	; c1200000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1366 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 50, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[12], mTechniquesMirror[12], mpMaps[6], mpMaps[7], true, true, true);

	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR $T23[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T52[ebp+8]
	unpcklps xmm1, xmm0
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	movq	QWORD PTR [ecx], xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN31@BasicItems
$LN30@BasicItems:
	xor	ecx, ecx
$LN31@BasicItems:
	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm1, QWORD PTR $T23[ebp]
	movss	xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T65[ebp+8], 1084227584	; 40a00000H
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1366 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 50, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[12], mTechniquesMirror[12], mpMaps[6], mpMaps[7], true, true, true);

	mov	DWORD PTR [esi+eax*4+8], ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1371 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 80, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[13], mTechniquesMirror[13], mpMaps[6], mpMaps[7], true, true, true);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+8]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T65[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1368 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1371 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 80, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[13], mTechniquesMirror[13], mpMaps[6], mpMaps[7], true, true, true);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T32[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	edx, edx
	je	SHORT $LN32@BasicItems
	movq	xmm1, QWORD PTR $T11[ebp]
	push	1
	push	1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm0, DWORD PTR __real@42a00000
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1371 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 80, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[13], mTechniquesMirror[13], mpMaps[6], mpMaps[7], true, true, true);

	push	1
	push	DWORD PTR [esi+964]
	unpcklps xmm1, xmm1
	push	DWORD PTR [esi+960]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T77[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1371 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 80, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[13], mTechniquesMirror[13], mpMaps[6], mpMaps[7], true, true, true);

	push	DWORD PTR [esi+2788]
	mov	eax, DWORD PTR $T77[ebp+8]
	push	DWORD PTR [esi+2668]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T51[ebp+8], -1054867456	; c1200000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1371 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 80, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[13], mTechniquesMirror[13], mpMaps[6], mpMaps[7], true, true, true);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm1
	movq	xmm1, QWORD PTR $T23[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T51[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_07DBODOLME@Troll?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN33@BasicItems
$LN32@BasicItems:
	xor	ecx, ecx
$LN33@BasicItems:
	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm0, QWORD PTR $T23[ebp]
	unpcklps xmm0, xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T64[ebp+8], 1084227584	; 40a00000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1371 : 	mpObjects[miNumObjects] = new CRenderObject("Troll.x",	D3DXVECTOR3( 80, 5, -10 ),		D3DXVECTOR3( 0.5f, 0.5f, 0.0f), mTechniques[13], mTechniquesMirror[13], mpMaps[6], mpMaps[7], true, true, true);

	mov	DWORD PTR [esi+eax*4+8], ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+808]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1377 : 	mpObjects[miNumObjects] = new CRenderObject("Floor.x",	D3DXVECTOR3(0,0,0),				D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[1], NULL, true, false);

	push	72					; 00000048H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+8]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T64[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1373 : 	miNumObjects++;

	inc	DWORD PTR [esi+808]

; 1377 : 	mpObjects[miNumObjects] = new CRenderObject("Floor.x",	D3DXVECTOR3(0,0,0),				D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[1], NULL, true, false);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T31[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	test	edx, edx
	je	SHORT $LN34@BasicItems
	movq	xmm0, QWORD PTR $T13[ebp]
	push	0
	movq	xmm1, QWORD PTR $T12[ebp]
	push	0
	push	1
	push	0
	push	DWORD PTR [esi+940]
	unpcklps xmm0, xmm0
	push	DWORD PTR [esi+2760]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T76[ebp+8], 1065353216	; 3f800000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1377 : 	mpObjects[miNumObjects] = new CRenderObject("Floor.x",	D3DXVECTOR3(0,0,0),				D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[1], NULL, true, false);

	push	DWORD PTR [esi+2640]
	mov	eax, DWORD PTR $T76[ebp+8]
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T50[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1377 : 	mpObjects[miNumObjects] = new CRenderObject("Floor.x",	D3DXVECTOR3(0,0,0),				D3DXVECTOR3(1.0f, 1.0f, 1.0f), mTechniques[6], mTechniquesMirror[6], mpMaps[1], NULL, true, false);

	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR $T50[ebp+8]
	unpcklps xmm0, xmm1
	push	OFFSET ??_C@_07MPPKGAHN@Floor?4x?$AA@
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CRenderObject@@QAE@QADUD3DXVECTOR3@@1PAUID3D10EffectTechnique@@2PAUID3D10ShaderResourceView@@3_N44@Z ; CRenderObject::CRenderObject
	mov	ecx, eax
	jmp	SHORT $LN35@BasicItems
$LN34@BasicItems:
	xor	ecx, ecx
$LN35@BasicItems:
	mov	eax, DWORD PTR [esi+808]

; 1384 : 	temp = new CModel;

	push	1936					; 00000790H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+8], ecx
	inc	DWORD PTR [esi+808]
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T30[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	test	edx, edx
	je	SHORT $LN36@BasicItems
	movq	xmm1, QWORD PTR $T12[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T75[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1384 : 	temp = new CModel;

	mov	eax, DWORD PTR $T75[ebp+8]
	movss	xmm0, xmm1
	unpcklps xmm0, xmm1
	mov	DWORD PTR [esp+12], 1065353216		; 3f800000H
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	unpcklps xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T49[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1384 : 	temp = new CModel;

	mov	eax, DWORD PTR $T49[ebp+8]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	edi, eax
	jmp	SHORT $LN37@BasicItems
$LN36@BasicItems:
	xor	edi, edi
$LN37@BasicItems:

; 1385 : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T29[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
	test	eax, eax
	je	SHORT $LN38@BasicItems
	mov	ecx, eax
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	ecx, eax
	jmp	SHORT $LN39@BasicItems
$LN38@BasicItems:
	xor	ecx, ecx
$LN39@BasicItems:
	mov	eax, DWORD PTR [esi+932]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	8
	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1385 : 	mpLights[miNumLights] = new CLight();

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+812], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	ecx, DWORD PTR $T60[ebp]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T60[ebp+20], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T60[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T60[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1386 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	0
	push	DWORD PTR [esi+2616]
	lea	eax, DWORD PTR $T60[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
	push	eax
	mov	ecx, edi
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	test	al, al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	sete	bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T60[ebp+20], 16		; 00000010H
	jb	SHORT $LN242@BasicItems
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T60[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN242@BasicItems:
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1386 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	test	bl, bl
	je	SHORT $LN3@BasicItems
$LN427@BasicItems:
	xor	al, al
	jmp	$LN4@BasicItems
$LN3@BasicItems:

; 1387 : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR [esi+932]

; 1388 : 	mpLights[miNumLights]->SetColour(1.0f, 0.0f, 0.7f);

	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	DWORD PTR [esp+8], 1060320051		; 3f333333H
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\simon\documents\github\post-processing\light.h

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	mov	DWORD PTR [eax], edi
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1388 : 	mpLights[miNumLights]->SetColour(1.0f, 0.0f, 0.7f);

	mov	ecx, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR [esi+ecx*4+812]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1392 : 	mpLights[miNumLights]->SetOrbit(  D3DXVECTOR3(0, 20, 0), 25.0f, 0.1f );

	sub	esp, 20					; 00000014H
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movss	xmm0, DWORD PTR __real@41f00000
	movss	xmm1, DWORD PTR __real@41200000
	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1392 : 	mpLights[miNumLights]->SetOrbit(  D3DXVECTOR3(0, 20, 0), 25.0f, 0.1f );

	movss	xmm1, DWORD PTR __real@41a00000
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T74[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1392 : 	mpLights[miNumLights]->SetOrbit(  D3DXVECTOR3(0, 20, 0), 25.0f, 0.1f );

	mov	DWORD PTR [esp+16], 1036831949		; 3dcccccdH
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	mov	eax, DWORD PTR $T74[ebp+8]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T63[ebp+8], 1036831949	; 3dcccccdH
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1392 : 	mpLights[miNumLights]->SetOrbit(  D3DXVECTOR3(0, 20, 0), 25.0f, 0.1f );

	mov	DWORD PTR [esp+12], 1103626240		; 41c80000H
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movq	QWORD PTR [ecx+8], xmm0
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm0, DWORD PTR __real@3dcccccd
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	mov	DWORD PTR [ecx+16], eax
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T63[ebp+8]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T73[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	QWORD PTR [ecx+32], xmm0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1392 : 	mpLights[miNumLights]->SetOrbit(  D3DXVECTOR3(0, 20, 0), 25.0f, 0.1f );

	movss	xmm0, DWORD PTR $T12[ebp]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1392 : 	mpLights[miNumLights]->SetOrbit(  D3DXVECTOR3(0, 20, 0), 25.0f, 0.1f );

	mov	ecx, esp
	mov	eax, DWORD PTR [esi+932]
	unpcklps xmm0, xmm1
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\light.h

; 71   : 	void SetBrightness(float brightness) { mBrightness = brightness; }

	mov	DWORD PTR [eax+24], 1092616192		; 41200000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1392 : 	mpLights[miNumLights]->SetOrbit(  D3DXVECTOR3(0, 20, 0), 25.0f, 0.1f );

	mov	eax, DWORD PTR $T73[ebp+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR [esi+ecx*4+812]
	call	?SetOrbit@CLight@@QAEXUD3DXVECTOR3@@MM@Z ; CLight::SetOrbit

; 1393 : 	mpLights[miNumLights]->SetColourCycle( 17.0f );

	push	ecx
	mov	ecx, DWORD PTR [esi+932]
	mov	DWORD PTR [esp], 1099431936		; 41880000H
	mov	ecx, DWORD PTR [esi+ecx*4+812]
	call	?SetColourCycle@CLight@@QAEXM@Z		; CLight::SetColourCycle

; 1394 : 
; 1395 : 	miNumLights++;

	inc	DWORD PTR [esi+932]

; 1398 : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T28[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	test	edx, edx
	je	SHORT $LN40@BasicItems
	movq	xmm1, QWORD PTR $T12[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T72[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1398 : 	temp = new CModel;

	mov	eax, DWORD PTR $T72[ebp+8]
	movss	xmm0, xmm1
	unpcklps xmm0, xmm1
	mov	DWORD PTR [esp+12], 1065353216		; 3f800000H
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movss	xmm0, xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	unpcklps xmm0, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T48[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1398 : 	temp = new CModel;

	mov	eax, DWORD PTR $T48[ebp+8]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	edi, eax
	jmp	SHORT $LN41@BasicItems
$LN40@BasicItems:
	xor	edi, edi
$LN41@BasicItems:

; 1399 : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T27[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
	test	eax, eax
	je	SHORT $LN42@BasicItems
	mov	ecx, eax
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	ecx, eax
	jmp	SHORT $LN43@BasicItems
$LN42@BasicItems:
	xor	ecx, ecx
$LN43@BasicItems:
	mov	eax, DWORD PTR [esi+932]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	8
	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1399 : 	mpLights[miNumLights] = new CLight();

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+812], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	ecx, DWORD PTR $T59[ebp]

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T59[ebp+20], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T59[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T59[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1400 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	0
	push	DWORD PTR [esi+2616]
	lea	eax, DWORD PTR $T59[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 20		; 00000014H
	push	eax
	mov	ecx, edi
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	test	al, al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	sete	bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T59[ebp+20], 16		; 00000010H
	jb	SHORT $LN340@BasicItems
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T59[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN340@BasicItems:
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1400 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	test	bl, bl
	jne	$LN427@BasicItems

; 1401 : 	mpLights[miNumLights]->SetModel(temp);

	mov	eax, DWORD PTR [esi+932]

; 1402 : 	mpLights[miNumLights]->SetColour(1.0f, 0.8f, 0.2f);

	sub	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR __real@3e4ccccd
	movq	QWORD PTR $T10[ebp], xmm0
	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	DWORD PTR [esp+8], 1045220557		; 3e4ccccdH
	mov	DWORD PTR [esp+4], 1061997773		; 3f4ccccdH
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\simon\documents\github\post-processing\light.h

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	mov	DWORD PTR [eax], edi
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1402 : 	mpLights[miNumLights]->SetColour(1.0f, 0.8f, 0.2f);

	mov	ecx, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR [esi+ecx*4+812]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movss	xmm1, DWORD PTR __real@41f00000
	movq	xmm0, QWORD PTR $T9[ebp]
	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm1, QWORD PTR $T10[ebp]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T71[ebp+8], 1112014848	; 42480000H
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	mov	eax, DWORD PTR $T71[ebp+8]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T62[ebp+8], 1045220557	; 3e4ccccdH
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movq	QWORD PTR [ecx+8], xmm0

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movss	xmm0, xmm1

; 107  : 		m_Position = position;

	mov	DWORD PTR [ecx+16], eax
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	ecx, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T62[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1405 : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	ecx, DWORD PTR [eax]
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix

; 1406 : 	mpLights[miNumLights]->SetBrightness( 5.0f );

	mov	eax, DWORD PTR [esi+932]

; 1407 : 	mpLights[miNumLights]->SetFade( 2.0f );

	push	ecx
	mov	DWORD PTR [esp], 1073741824		; 40000000H
	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\light.h

; 71   : 	void SetBrightness(float brightness) { mBrightness = brightness; }

	mov	DWORD PTR [eax+24], 1084227584		; 40a00000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1407 : 	mpLights[miNumLights]->SetFade( 2.0f );

	mov	ecx, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR [esi+ecx*4+812]
	call	?SetFade@CLight@@QAEXM@Z		; CLight::SetFade

; 1408 : 
; 1409 : 	miNumLights++;

	inc	DWORD PTR [esi+932]

; 1413 : 	temp = new CModel;

	push	1936					; 00000790H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T26[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 21		; 00000015H
	test	edx, edx
	je	SHORT $LN44@BasicItems
	movq	xmm1, QWORD PTR $T12[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T70[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1413 : 	temp = new CModel;

	mov	eax, DWORD PTR $T70[ebp+8]
	movss	xmm0, xmm1
	unpcklps xmm0, xmm1
	mov	DWORD PTR [esp+12], 1065353216		; 3f800000H
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	unpcklps xmm1, xmm1
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T47[ebp+8], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1413 : 	temp = new CModel;

	mov	eax, DWORD PTR $T47[ebp+8]
	movq	QWORD PTR [ecx], xmm1
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edx
	call	??0CModel@@QAE@UD3DXVECTOR3@@0M@Z	; CModel::CModel
	mov	edi, eax
	jmp	SHORT $LN45@BasicItems
$LN44@BasicItems:
	xor	edi, edi
$LN45@BasicItems:

; 1414 : 	mpLights[miNumLights] = new CLight();

	push	92					; 0000005cH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T25[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 22		; 00000016H
	test	eax, eax
	je	SHORT $LN46@BasicItems
	mov	ecx, eax
	call	??0CLight@@QAE@XZ			; CLight::CLight
	mov	ecx, eax
	jmp	SHORT $LN47@BasicItems
$LN46@BasicItems:
	xor	ecx, ecx
$LN47@BasicItems:
	mov	eax, DWORD PTR [esi+932]

; 1415 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	push	OFFSET ??_C@_08EEMGLHJD@Sphere?4x?$AA@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+eax*4+812], ecx
	lea	ecx, DWORD PTR $T46[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	0
	push	DWORD PTR [esi+2616]
	lea	eax, DWORD PTR $T46[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 23		; 00000017H
	push	eax
	mov	ecx, edi
	call	?Load@CModel@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUID3D10EffectTechnique@@_N@Z ; CModel::Load
	test	al, al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	sete	bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T46[ebp+20], 16		; 00000010H
	jb	SHORT $LN394@BasicItems
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T46[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN394@BasicItems:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T46[ebp+20], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T46[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T46[ebp], 0
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1415 : 	if (!temp->	Load( "Sphere.x", mTechniques[0] )) return false;

	test	bl, bl
	jne	$LN427@BasicItems
; File c:\users\simon\documents\github\post-processing\light.h

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1417 : 	mpLights[miNumLights]->SetColour(1.0f, 0.8f, 0.2f);

	sub	esp, 12					; 0000000cH
; File c:\users\simon\documents\github\post-processing\light.h

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1417 : 	mpLights[miNumLights]->SetColour(1.0f, 0.8f, 0.2f);

	mov	DWORD PTR [esp+8], 1045220557		; 3e4ccccdH
	mov	DWORD PTR [esp+4], 1061997773		; 3f4ccccdH
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\simon\documents\github\post-processing\light.h

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	mov	DWORD PTR [eax], edi
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1417 : 	mpLights[miNumLights]->SetColour(1.0f, 0.8f, 0.2f);

	mov	ecx, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR [esi+ecx*4+812]
	call	?SetColour@CLight@@QAEXMMM@Z		; CLight::SetColour
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movq	xmm0, QWORD PTR $T22[ebp]
	movss	xmm1, DWORD PTR __real@41c80000
	unpcklps xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T69[ebp+8], 1128792064	; 43480000H
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR $T69[ebp+8]
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 323  :     z = fz;

	mov	DWORD PTR $T61[ebp+8], 1045220557	; 3e4ccccdH
; File c:\users\simon\documents\github\post-processing\model.h

; 107  : 		m_Position = position;

	movq	QWORD PTR [ecx+8], xmm0

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	movq	xmm0, QWORD PTR $T10[ebp]

; 107  : 		m_Position = position;

	mov	DWORD PTR [ecx+16], eax
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	unpcklps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR $T61[ebp+8]
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax
; File c:\users\simon\documents\github\post-processing\light.h

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [esi+932]
	mov	ecx, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1420 : 	mpLights[miNumLights]->GetModel()->UpdateMatrix();

	mov	ecx, DWORD PTR [ecx]
	call	?UpdateMatrix@CModel@@QAEXXZ		; CModel::UpdateMatrix
; File c:\users\simon\documents\github\post-processing\light.h

; 71   : 	void SetBrightness(float brightness) { mBrightness = brightness; }

	mov	eax, DWORD PTR [esi+932]
	mov	eax, DWORD PTR [esi+eax*4+812]
	mov	DWORD PTR [eax+24], 1084227584		; 40a00000H
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1422 : 	mpLights[miNumLights]->SetDisco();

	mov	eax, DWORD PTR [esi+932]
	mov	eax, DWORD PTR [esi+eax*4+812]
; File c:\users\simon\documents\github\post-processing\light.h

; 86   : 	void SetDisco() { mDisco = true; mPulse = false; mCycleColour = false;}

	mov	BYTE PTR [eax+88], 1
	mov	BYTE PTR [eax+68], bl
	mov	BYTE PTR [eax+60], bl
; File c:\users\simon\documents\github\post-processing\scene.cpp

; 1443 : 	return true;

	mov	al, 1
	inc	DWORD PTR [esi+932]
$LN4@BasicItems:

; 1444 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$0:
	mov	eax, DWORD PTR $T45[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$1:
	mov	eax, DWORD PTR $T44[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$2:
	mov	eax, DWORD PTR $T43[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$3:
	mov	eax, DWORD PTR $T42[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$4:
	mov	eax, DWORD PTR $T41[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$5:
	mov	eax, DWORD PTR $T40[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$6:
	mov	eax, DWORD PTR $T39[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$7:
	mov	eax, DWORD PTR $T38[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$8:
	mov	eax, DWORD PTR $T37[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$9:
	mov	eax, DWORD PTR $T36[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$10:
	mov	eax, DWORD PTR $T35[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$11:
	mov	eax, DWORD PTR $T34[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$12:
	mov	eax, DWORD PTR $T33[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$13:
	mov	eax, DWORD PTR $T32[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$14:
	mov	eax, DWORD PTR $T31[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$15:
	mov	eax, DWORD PTR $T30[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$16:
	mov	eax, DWORD PTR $T29[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$17:
	lea	ecx, DWORD PTR $T60[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$18:
	mov	eax, DWORD PTR $T28[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$19:
	mov	eax, DWORD PTR $T27[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$20:
	lea	ecx, DWORD PTR $T59[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$21:
	mov	eax, DWORD PTR $T26[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$22:
	mov	eax, DWORD PTR $T25[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?BasicItems@CScene@@AAE_NXZ$23:
	lea	ecx, DWORD PTR $T46[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?BasicItems@CScene@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?BasicItems@CScene@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?BasicItems@CScene@@AAE_NXZ ENDP			; CScene::BasicItems
; Function compile flags: /Ogtp
;	COMDAT ??_GCRenderObject@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCRenderObject@@QAEPAXI@Z PROC			; CRenderObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1CRenderObject@@QAE@XZ		; CRenderObject::~CRenderObject
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GCRenderObject@@QAEPAXI@Z ENDP			; CRenderObject::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?GetOutlineThickness@CRenderObject@@QAEMXZ
_TEXT	SEGMENT
?GetOutlineThickness@CRenderObject@@QAEMXZ PROC		; CRenderObject::GetOutlineThickness, COMDAT
; _this$ = ecx

; 103  : 	float GetOutlineThickness() { return mOutlineThickness; }

	fld	DWORD PTR [ecx+68]
	ret	0
?GetOutlineThickness@CRenderObject@@QAEMXZ ENDP		; CRenderObject::GetOutlineThickness
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?GetWiggle@CRenderObject@@QAEMXZ
_TEXT	SEGMENT
?GetWiggle@CRenderObject@@QAEMXZ PROC			; CRenderObject::GetWiggle, COMDAT
; _this$ = ecx

; 101  : 	float GetWiggle() { return mWiggleValue; }

	fld	DWORD PTR [ecx+64]
	ret	0
?GetWiggle@CRenderObject@@QAEMXZ ENDP			; CRenderObject::GetWiggle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?SetWiggle@CRenderObject@@QAEXM@Z
_TEXT	SEGMENT
_rate$ = 8						; size = 4
?SetWiggle@CRenderObject@@QAEXM@Z PROC			; CRenderObject::SetWiggle, COMDAT
; _this$ = ecx

; 99   : 	void SetWiggle( float rate ) { mWiggle = true; mWiggleRate = rate; }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _rate$[ebp]
	mov	BYTE PTR [ecx+56], 1
	movss	DWORD PTR [ecx+60], xmm0
	pop	ebp
	ret	4
?SetWiggle@CRenderObject@@QAEXM@Z ENDP			; CRenderObject::SetWiggle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?SetSpinZ@CRenderObject@@QAEXM@Z
_TEXT	SEGMENT
_rate$ = 8						; size = 4
?SetSpinZ@CRenderObject@@QAEXM@Z PROC			; CRenderObject::SetSpinZ, COMDAT
; _this$ = ecx

; 93   : 	void SetSpinZ( float rate ) { mSpinZ = true; mSpinZRate = rate; }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _rate$[ebp]
	mov	BYTE PTR [ecx+43], 1
	movss	DWORD PTR [ecx+52], xmm0
	pop	ebp
	ret	4
?SetSpinZ@CRenderObject@@QAEXM@Z ENDP			; CRenderObject::SetSpinZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?SetSpinY@CRenderObject@@QAEXM@Z
_TEXT	SEGMENT
_rate$ = 8						; size = 4
?SetSpinY@CRenderObject@@QAEXM@Z PROC			; CRenderObject::SetSpinY, COMDAT
; _this$ = ecx

; 92   : 	void SetSpinY( float rate ) { mSpinY = true; mSpinYRate = rate; }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _rate$[ebp]
	mov	BYTE PTR [ecx+42], 1
	movss	DWORD PTR [ecx+48], xmm0
	pop	ebp
	ret	4
?SetSpinY@CRenderObject@@QAEXM@Z ENDP			; CRenderObject::SetSpinY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?SetSpinX@CRenderObject@@QAEXM@Z
_TEXT	SEGMENT
_rate$ = 8						; size = 4
?SetSpinX@CRenderObject@@QAEXM@Z PROC			; CRenderObject::SetSpinX, COMDAT
; _this$ = ecx

; 91   : 	void SetSpinX( float rate ) { mSpinX = true; mSpinXRate = rate; }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _rate$[ebp]
	mov	BYTE PTR [ecx+41], 1
	movss	DWORD PTR [ecx+44], xmm0
	pop	ebp
	ret	4
?SetSpinX@CRenderObject@@QAEXM@Z ENDP			; CRenderObject::SetSpinX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?SetColourCycle@CRenderObject@@QAEXXZ
_TEXT	SEGMENT
?SetColourCycle@CRenderObject@@QAEXXZ PROC		; CRenderObject::SetColourCycle, COMDAT
; _this$ = ecx

; 88   : 	void SetColourCycle() { mColourCycle = true; }

	mov	BYTE PTR [ecx+40], 1
	ret	0
?SetColourCycle@CRenderObject@@QAEXXZ ENDP		; CRenderObject::SetColourCycle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?RenderMirror@CRenderObject@@QAEXXZ
_TEXT	SEGMENT
?RenderMirror@CRenderObject@@QAEXXZ PROC		; CRenderObject::RenderMirror, COMDAT
; _this$ = ecx

; 86   : 	void RenderMirror() { mModel->Render( mMirrorTechnique ); }

	push	DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx]
	call	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z ; CModel::Render
	ret	0
?RenderMirror@CRenderObject@@QAEXXZ ENDP		; CRenderObject::RenderMirror
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?Render@CRenderObject@@QAEXXZ
_TEXT	SEGMENT
?Render@CRenderObject@@QAEXXZ PROC			; CRenderObject::Render, COMDAT
; _this$ = ecx

; 85   : 	void Render() { mModel->Render( mTechnique ); }

	push	DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [ecx]
	call	?Render@CModel@@QAEXPAUID3D10EffectTechnique@@@Z ; CModel::Render
	ret	0
?Render@CRenderObject@@QAEXXZ ENDP			; CRenderObject::Render
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?IsTransparent@CRenderObject@@QAE_NXZ
_TEXT	SEGMENT
?IsTransparent@CRenderObject@@QAE_NXZ PROC		; CRenderObject::IsTransparent, COMDAT
; _this$ = ecx

; 80   : 	bool IsTransparent() { return mIsTransparent; }

	mov	al, BYTE PTR [ecx+33]
	ret	0
?IsTransparent@CRenderObject@@QAE_NXZ ENDP		; CRenderObject::IsTransparent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?IsLit@CRenderObject@@QAE_NXZ
_TEXT	SEGMENT
?IsLit@CRenderObject@@QAE_NXZ PROC			; CRenderObject::IsLit, COMDAT
; _this$ = ecx

; 75   : 	bool IsLit() { return mIsLit; }

	mov	al, BYTE PTR [ecx+32]
	ret	0
?IsLit@CRenderObject@@QAE_NXZ ENDP			; CRenderObject::IsLit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?GetNormalMap@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ
_TEXT	SEGMENT
?GetNormalMap@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ PROC ; CRenderObject::GetNormalMap, COMDAT
; _this$ = ecx

; 72   : 	ID3D10ShaderResourceView* GetNormalMap() { return mNormMap; }

	mov	eax, DWORD PTR [ecx+28]
	ret	0
?GetNormalMap@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ENDP ; CRenderObject::GetNormalMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?GetTexture@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ
_TEXT	SEGMENT
?GetTexture@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ PROC ; CRenderObject::GetTexture, COMDAT
; _this$ = ecx

; 69   : 	ID3D10ShaderResourceView* GetTexture() { return mTexture; }

	mov	eax, DWORD PTR [ecx+24]
	ret	0
?GetTexture@CRenderObject@@QAEPAUID3D10ShaderResourceView@@XZ ENDP ; CRenderObject::GetTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?GetColourV@CRenderObject@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetColourV@CRenderObject@@QAE?AUD3DXVECTOR3@@XZ PROC	; CRenderObject::GetColourV, COMDAT
; _this$ = ecx

; 59   : 	D3DXVECTOR3 GetColourV(){ return D3DXVECTOR3( mr, mg, mb ); }

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 322  :     y = fy;

	mov	edx, DWORD PTR [ecx+8]

; 323  :     z = fz;

	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
; File c:\users\simon\documents\github\post-processing\renderobject.h

; 59   : 	D3DXVECTOR3 GetColourV(){ return D3DXVECTOR3( mr, mg, mb ); }

	pop	ebp
	ret	4
?GetColourV@CRenderObject@@QAE?AUD3DXVECTOR3@@XZ ENDP	; CRenderObject::GetColourV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\renderobject.h
;	COMDAT ?GetModel@CRenderObject@@QAEPAVCModel@@XZ
_TEXT	SEGMENT
?GetModel@CRenderObject@@QAEPAVCModel@@XZ PROC		; CRenderObject::GetModel, COMDAT
; _this$ = ecx

; 54   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetModel@CRenderObject@@QAEPAVCModel@@XZ ENDP		; CRenderObject::GetModel
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCLight@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCLight@@QAEPAXI@Z PROC				; CLight::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1CLight@@QAE@XZ			; CLight::~CLight
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GCLight@@QAEPAXI@Z ENDP				; CLight::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\light.h
;	COMDAT ?SetDisco@CLight@@QAEXXZ
_TEXT	SEGMENT
?SetDisco@CLight@@QAEXXZ PROC				; CLight::SetDisco, COMDAT
; _this$ = ecx

; 86   : 	void SetDisco() { mDisco = true; mPulse = false; mCycleColour = false;}

	mov	BYTE PTR [ecx+88], 1
	mov	BYTE PTR [ecx+68], 0
	mov	BYTE PTR [ecx+60], 0
	ret	0
?SetDisco@CLight@@QAEXXZ ENDP				; CLight::SetDisco
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\light.h
;	COMDAT ?SetBrightness@CLight@@QAEXM@Z
_TEXT	SEGMENT
_brightness$ = 8					; size = 4
?SetBrightness@CLight@@QAEXM@Z PROC			; CLight::SetBrightness, COMDAT
; _this$ = ecx

; 71   : 	void SetBrightness(float brightness) { mBrightness = brightness; }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _brightness$[ebp]
	movss	DWORD PTR [ecx+24], xmm0
	pop	ebp
	ret	4
?SetBrightness@CLight@@QAEXM@Z ENDP			; CLight::SetBrightness
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\light.h
;	COMDAT ?GetBrightness@CLight@@QAEMXZ
_TEXT	SEGMENT
?GetBrightness@CLight@@QAEMXZ PROC			; CLight::GetBrightness, COMDAT
; _this$ = ecx

; 70   : 	float GetBrightness() { return mBrightness; }

	fld	DWORD PTR [ecx+24]
	ret	0
?GetBrightness@CLight@@QAEMXZ ENDP			; CLight::GetBrightness
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\light.h
;	COMDAT ?SetModel@CLight@@QAEXPAVCModel@@@Z
_TEXT	SEGMENT
_model$ = 8						; size = 4
?SetModel@CLight@@QAEXPAVCModel@@@Z PROC		; CLight::SetModel, COMDAT
; _this$ = ecx

; 68   : 	void SetModel( CModel* model ) { mModel = model; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _model$[ebp]
	mov	DWORD PTR [ecx], eax
	pop	ebp
	ret	4
?SetModel@CLight@@QAEXPAVCModel@@@Z ENDP		; CLight::SetModel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\light.h
;	COMDAT ?GetModel@CLight@@QAEPAVCModel@@XZ
_TEXT	SEGMENT
?GetModel@CLight@@QAEPAVCModel@@XZ PROC			; CLight::GetModel, COMDAT
; _this$ = ecx

; 67   : 	CModel* GetModel() { return mModel; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetModel@CLight@@QAEPAVCModel@@XZ ENDP			; CLight::GetModel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\light.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\light.h
;	COMDAT ?GetColourV@CLight@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetColourV@CLight@@QAE?AUD3DXVECTOR3@@XZ PROC		; CLight::GetColourV, COMDAT
; _this$ = ecx

; 56   : 	D3DXVECTOR3 GetColourV(){ return D3DXVECTOR3( mr, mg, mb ); }

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 322  :     y = fy;

	mov	edx, DWORD PTR [ecx+8]

; 323  :     z = fz;

	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
; File c:\users\simon\documents\github\post-processing\light.h

; 56   : 	D3DXVECTOR3 GetColourV(){ return D3DXVECTOR3( mr, mg, mb ); }

	pop	ebp
	ret	4
?GetColourV@CLight@@QAE?AUD3DXVECTOR3@@XZ ENDP		; CLight::GetColourV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\camera.h
;	COMDAT ?SetNearClip@CCamera@@QAEXM@Z
_TEXT	SEGMENT
_nearClip$ = 8						; size = 4
?SetNearClip@CCamera@@QAEXM@Z PROC			; CCamera::SetNearClip, COMDAT
; _this$ = ecx

; 111  : 	{

	push	ebp
	mov	ebp, esp

; 112  : 		m_NearClip = nearClip;

	movss	xmm0, DWORD PTR _nearClip$[ebp]
	movss	DWORD PTR [ecx+36], xmm0

; 113  : 	}

	pop	ebp
	ret	4
?SetNearClip@CCamera@@QAEXM@Z ENDP			; CCamera::SetNearClip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\camera.h
;	COMDAT ?SetRotation@CCamera@@QAEXUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_rotation$ = 8						; size = 12
?SetRotation@CCamera@@QAEXUD3DXVECTOR3@@@Z PROC		; CCamera::SetRotation, COMDAT
; _this$ = ecx

; 103  : 	{

	push	ebp
	mov	ebp, esp

; 104  : 		m_Rotation = rotation;

	movq	xmm0, QWORD PTR _rotation$[ebp]
	mov	eax, DWORD PTR _rotation$[ebp+8]
	movq	QWORD PTR [ecx+20], xmm0
	mov	DWORD PTR [ecx+28], eax

; 105  : 	}

	pop	ebp
	ret	12					; 0000000cH
?SetRotation@CCamera@@QAEXUD3DXVECTOR3@@@Z ENDP		; CCamera::SetRotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\camera.h
;	COMDAT ?SetPosition@CCamera@@QAEXUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_position$ = 8						; size = 12
?SetPosition@CCamera@@QAEXUD3DXVECTOR3@@@Z PROC		; CCamera::SetPosition, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp

; 100  : 		m_Position = position;

	movq	xmm0, QWORD PTR _position$[ebp]
	mov	eax, DWORD PTR _position$[ebp+8]
	movq	QWORD PTR [ecx+8], xmm0
	mov	DWORD PTR [ecx+16], eax

; 101  : 	}

	pop	ebp
	ret	12					; 0000000cH
?SetPosition@CCamera@@QAEXUD3DXVECTOR3@@@Z ENDP		; CCamera::SetPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\camera.h
;	COMDAT ?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ PROC ; CCamera::GetProjectionMatrix, COMDAT
; _this$ = ecx

; 75   : 	{

	push	ebp
	mov	ebp, esp

; 76   : 		return m_ProjMatrix;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movdqu	xmm0, XMMWORD PTR [ecx+176]
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR [ecx+192]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movdqu	xmm0, XMMWORD PTR [ecx+208]
	movdqu	XMMWORD PTR [eax+32], xmm0
	movdqu	xmm0, XMMWORD PTR [ecx+224]
	movdqu	XMMWORD PTR [eax+48], xmm0

; 77   : 	}

	pop	ebp
	ret	4
?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ ENDP ; CCamera::GetProjectionMatrix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\camera.h
;	COMDAT ?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ PROC	; CCamera::GetViewMatrix, COMDAT
; _this$ = ecx

; 71   : 	{

	push	ebp
	mov	ebp, esp

; 72   : 		return m_ViewMatrix;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movdqu	xmm0, XMMWORD PTR [ecx+112]
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR [ecx+128]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movdqu	xmm0, XMMWORD PTR [ecx+144]
	movdqu	XMMWORD PTR [eax+32], xmm0
	movdqu	xmm0, XMMWORD PTR [ecx+160]
	movdqu	XMMWORD PTR [eax+48], xmm0

; 73   : 	}

	pop	ebp
	ret	4
?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@XZ ENDP	; CCamera::GetViewMatrix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\camera.h
;	COMDAT ?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@XZ PROC	; CCamera::GetPosition, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp

; 63   : 		return m_Position;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movq	xmm0, QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+16]
	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], ecx

; 64   : 	}

	pop	ebp
	ret	4
?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@XZ ENDP	; CCamera::GetPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\camera.h
;	COMDAT ?SetViewport@CCamera@@SAXHH@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?SetViewport@CCamera@@SAXHH@Z PROC			; CCamera::SetViewport, COMDAT

; 48   : 	static void SetViewport( int width, int height ) { mViewportWidth = width; mViewportHeight = height; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR ?mViewportWidth@CCamera@@0HA, eax ; CCamera::mViewportWidth
	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR ?mViewportHeight@CCamera@@0HA, eax ; CCamera::mViewportHeight
	pop	ebp
	ret	0
?SetViewport@CCamera@@SAXHH@Z ENDP			; CCamera::SetViewport
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\model.h
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
; File c:\users\simon\documents\github\post-processing\model.h
;	COMDAT ?SetScale@CModel@@QAEXM@Z
_TEXT	SEGMENT
$T1 = -12						; size = 12
_scale$ = 8						; size = 4
?SetScale@CModel@@QAEXM@Z PROC				; CModel::SetScale, COMDAT
; _this$ = ecx

; 118  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl

; 321  :     x = fx;

	movss	xmm0, DWORD PTR _scale$[ebp]

; 322  :     y = fy;
; 323  :     z = fz;

	movss	DWORD PTR $T1[ebp+8], xmm0
; File c:\users\simon\documents\github\post-processing\model.h

; 119  : 		m_Scale = D3DXVECTOR3( scale, scale, scale );

	mov	eax, DWORD PTR $T1[ebp+8]
	unpcklps xmm0, xmm0
	movq	QWORD PTR [ecx+32], xmm0
	mov	DWORD PTR [ecx+40], eax

; 120  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale@CModel@@QAEXM@Z ENDP				; CModel::SetScale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\model.h
;	COMDAT ?SetRotation@CModel@@QAEXUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_rotation$ = 8						; size = 12
?SetRotation@CModel@@QAEXUD3DXVECTOR3@@@Z PROC		; CModel::SetRotation, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp

; 111  : 		m_Rotation = rotation;

	movq	xmm0, QWORD PTR _rotation$[ebp]
	mov	eax, DWORD PTR _rotation$[ebp+8]
	movq	QWORD PTR [ecx+20], xmm0
	mov	DWORD PTR [ecx+28], eax

; 112  : 	}

	pop	ebp
	ret	12					; 0000000cH
?SetRotation@CModel@@QAEXUD3DXVECTOR3@@@Z ENDP		; CModel::SetRotation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\model.h
;	COMDAT ?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_position$ = 8						; size = 12
?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z PROC		; CModel::SetPosition, COMDAT
; _this$ = ecx

; 106  : 	{

	push	ebp
	mov	ebp, esp

; 107  : 		m_Position = position;

	movq	xmm0, QWORD PTR _position$[ebp]
	mov	eax, DWORD PTR _position$[ebp+8]
	movq	QWORD PTR [ecx+8], xmm0
	mov	DWORD PTR [ecx+16], eax

; 108  : 	}

	pop	ebp
	ret	12					; 0000000cH
?SetPosition@CModel@@QAEXUD3DXVECTOR3@@@Z ENDP		; CModel::SetPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\model.h
;	COMDAT ?GetWorldMatrix@CModel@@QAE?AU_D3DXMATRIXA16@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetWorldMatrix@CModel@@QAE?AU_D3DXMATRIXA16@@XZ PROC	; CModel::GetWorldMatrix, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp

; 100  : 		return m_WorldMatrix;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movdqu	xmm0, XMMWORD PTR [ecx+48]
	movdqu	XMMWORD PTR [eax], xmm0
	movdqu	xmm0, XMMWORD PTR [ecx+64]
	movdqu	XMMWORD PTR [eax+16], xmm0
	movdqu	xmm0, XMMWORD PTR [ecx+80]
	movdqu	XMMWORD PTR [eax+32], xmm0
	movdqu	xmm0, XMMWORD PTR [ecx+96]
	movdqu	XMMWORD PTR [eax+48], xmm0

; 101  : 	}

	pop	ebp
	ret	4
?GetWorldMatrix@CModel@@QAE?AU_D3DXMATRIXA16@@XZ ENDP	; CModel::GetWorldMatrix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\model.h
;	COMDAT ?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ PROC		; CModel::GetPosition, COMDAT
; _this$ = ecx

; 86   : 	{

	push	ebp
	mov	ebp, esp

; 87   : 		return m_Position;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movq	xmm0, QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+16]
	movq	QWORD PTR [eax], xmm0
	mov	DWORD PTR [eax+8], ecx

; 88   : 	}

	pop	ebp
	ret	4
?GetPosition@CModel@@QAE?AUD3DXVECTOR3@@XZ ENDP		; CModel::GetPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\model.h
;	COMDAT ?SetDevice@CModel@@SAXPAUID3D10Device@@@Z
_TEXT	SEGMENT
_newDevice$ = 8						; size = 4
?SetDevice@CModel@@SAXPAUID3D10Device@@@Z PROC		; CModel::SetDevice, COMDAT

; 66   : 	static void SetDevice(ID3D10Device* newDevice) { mpd3dDev = newDevice; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _newDevice$[ebp]
	mov	DWORD PTR ?mpd3dDev@CModel@@0PAUID3D10Device@@A, eax ; CModel::mpd3dDev
	pop	ebp
	ret	0
?SetDevice@CModel@@SAXPAUID3D10Device@@@Z ENDP		; CModel::SetDevice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\defines.h
;	COMDAT ?square@@YAMM@Z
_TEXT	SEGMENT
tv66 = 8						; size = 4
_x$ = 8							; size = 4
?square@@YAMM@Z PROC					; square, COMDAT

; 25   : inline float square (float x) { return x * x; }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _x$[ebp]
	mulss	xmm0, xmm0
	movss	DWORD PTR tv66[ebp], xmm0
	fld	DWORD PTR tv66[ebp]
	pop	ebp
	ret	0
?square@@YAMM@Z ENDP					; square
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\defines.h
;	COMDAT ?ToRadians@@YAMM@Z
_TEXT	SEGMENT
tv66 = 8						; size = 4
_deg$ = 8						; size = 4
?ToRadians@@YAMM@Z PROC					; ToRadians, COMDAT

; 23   : inline float ToRadians( float deg ) { return deg * (float)D3DX_PI / 180.0f; }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _deg$[ebp]
	mulss	xmm0, DWORD PTR __real@40490fdb
	divss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR tv66[ebp], xmm0
	fld	DWORD PTR tv66[ebp]
	pop	ebp
	ret	0
?ToRadians@@YAMM@Z ENDP					; ToRadians
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 614  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	esi

; 615  : 		if (_Syserror_map(_Errval))

	mov	esi, DWORD PTR __Errval$[ebp]
	push	esi
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax

; 299  : 		{	// construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi

; 615  : 		if (_Syserror_map(_Errval))

	je	SHORT $LN2@default_er

; 299  : 		{	// construct from error code and category

	mov	DWORD PTR [eax+4], OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	pop	esi

; 616  : 			return (error_condition(_Errval, generic_category()));
; 617  : 		else
; 618  : 			return (error_condition(_Errval, system_category()));
; 619  : 		}

	pop	ebp
	ret	8
$LN2@default_er:

; 299  : 		{	// construct from error code and category

	mov	DWORD PTR [eax+4], OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	pop	esi

; 616  : 			return (error_condition(_Errval, generic_category()));
; 617  : 		else
; 618  : 			return (error_condition(_Errval, system_category()));
; 619  : 		}

	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 607  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	push	DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	add	esp, 4

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	test	eax, eax
	mov	edx, OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
	cmovne	edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN47@message
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 610  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN47@message:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL49@message:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL49@message
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 610  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 603  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 604  : 		}

	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 597  : 	_System_error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7_System_error_category@std@@6B@

; 598  : 		{	// default constructor
; 599  : 		}

	mov	eax, ecx
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 584  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	push	ecx

; 585  : 		if (_Errcode == (int)io_errc::stream)

	mov	eax, DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 585  : 		if (_Errcode == (int)io_errc::stream)

	cmp	eax, 1
	jne	SHORT $LN2@message
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	21					; 00000015H

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 588  : 			return (_Generic_error_category::message(_Errcode));

	mov	eax, esi
	pop	esi

; 589  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@message:

; 588  : 			return (_Generic_error_category::message(_Errcode));

	push	eax
	push	esi
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, esi
	pop	esi

; 589  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 580  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 581  : 		}

	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 574  : 	_Iostream_error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@

; 575  : 		{	// default constructor
; 576  : 		}

	mov	eax, ecx
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN8@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 563  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	push	DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	add	esp, 4

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	test	eax, eax
	mov	edx, OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
	cmovne	edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN47@message
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 566  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN47@message:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL49@message:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL49@message
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 566  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 559  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 560  : 		}

	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 553  : 	_Generic_error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7_Generic_error_category@std@@6B@

; 554  : 		{	// default constructor
; 555  : 		}

	mov	eax, ecx
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 352  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp

; 177  : 		return (this == &_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	mov	al, 1

; 355  : 		}

	pop	ebp
	ret	4
$LN3@operator:

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	xor	al, al

; 355  : 		}

	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 338  : 		return (*_Mycat);

	mov	eax, DWORD PTR [ecx+4]

; 339  : 		}

	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 333  : 		return (_Myval);

	mov	eax, DWORD PTR [ecx]

; 334  : 		}

	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 299  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 300  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR [ecx+4]

; 248  : 		}

	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 242  : 		return (_Myval);

	mov	eax, DWORD PTR [ecx]

; 243  : 		}

	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 176  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp

; 177  : 		return (this == &_Right);

	xor	eax, eax
	cmp	ecx, DWORD PTR __Right$[ebp]
	sete	al

; 178  : 		}

	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 391  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp

; 177  : 		return (this == &_Right);

	mov	eax, DWORD PTR __Code$[ebp]
	cmp	ecx, DWORD PTR [eax+4]

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	jne	SHORT $LN3@equivalent
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	al, 1

; 393  : 	}

	pop	ebp
	ret	8
$LN3@equivalent:

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	xor	al, al

; 393  : 	}

	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 384  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T1[ebp]
	sub	esp, 8
	push	DWORD PTR __Errval$[ebp]
	push	edx
	call	DWORD PTR [eax+12]

; 177  : 		return (this == &_Right);

	mov	edx, DWORD PTR __Cond$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edx+4]

; 178  : 		}
; 179  : 
; 180  : 	bool operator!=(const error_category& _Right) const _NOEXCEPT
; 181  : 		{	// compare categories for inequality
; 182  : 		return (!(*this == _Right));
; 183  : 		}
; 184  : 
; 185  : 	bool operator<(const error_category& _Right) const _NOEXCEPT
; 186  : 		{	// compare categories for order
; 187  : 		return (this < &_Right);
; 188  : 		}
; 189  : 
; 190  : 	error_category(const error_category&) = delete;
; 191  : 	error_category& operator=(const error_category&) = delete;
; 192  : 	};
; 193  : 
; 194  : 		// CLASS error_code
; 195  : class error_code
; 196  : 	{	// store an implementation-specific error code and category
; 197  : public:
; 198  : 	typedef error_code _Myt;
; 199  : 
; 200  : 	error_code()
; 201  : 		: _Myval(0),
; 202  : 			_Mycat(&system_category())
; 203  : 		{	// construct non-error
; 204  : 		}
; 205  : 
; 206  : 	error_code(int _Val, const error_category& _Cat)
; 207  : 		: _Myval(_Val), _Mycat(&_Cat)
; 208  : 		{	// construct from error code and category
; 209  : 		}
; 210  : 
; 211  : 	template<class _Enum,
; 212  : 		class = typename enable_if<is_error_code_enum<_Enum>::value,
; 213  : 			void>::type>
; 214  : 		error_code(_Enum _Errcode)
; 215  : 		: _Myval(0), _Mycat(0)
; 216  : 		{	// construct from enumerated error code
; 217  : 		*this = make_error_code(_Errcode);	// using ADL
; 218  : 		}
; 219  : 
; 220  : 	void assign(int _Val, const error_category& _Cat)
; 221  : 		{	// assign error code and category
; 222  : 		_Myval = _Val;
; 223  : 		_Mycat = &_Cat;
; 224  : 		}
; 225  : 
; 226  : 	template<class _Enum>
; 227  : 		typename enable_if<is_error_code_enum<_Enum>::value,
; 228  : 			error_code>::type& operator=(_Enum _Errcode)
; 229  : 		{	// assign enumerated error code
; 230  : 		*this = make_error_code(_Errcode);	// using ADL
; 231  : 		return (*this);
; 232  : 		}
; 233  : 
; 234  : 	void clear() _NOEXCEPT
; 235  : 		{	// assign non-error
; 236  : 		_Myval = 0;
; 237  : 		_Mycat = &system_category();
; 238  : 		}
; 239  : 
; 240  : 	int value() const
; 241  : 		{	// get error code
; 242  : 		return (_Myval);
; 243  : 		}
; 244  : 
; 245  : 	const error_category& category() const
; 246  : 		{	// get category
; 247  : 		return (*_Mycat);
; 248  : 		}
; 249  : 
; 250  : 	error_condition default_error_condition() const;
; 251  : 
; 252  : 	string message() const
; 253  : 		{	// get name of error code
; 254  : 		return (category().message(value()));
; 255  : 		}
; 256  : 
; 257  : 	explicit operator bool() const _NOEXCEPT
; 258  : 		{	// test for actual error
; 259  : 		return (value() != 0);
; 260  : 		}
; 261  : 
; 262  : 	bool operator==(const error_code& _Right) const _NOEXCEPT
; 263  : 		{	// test if *this == _Right
; 264  : 		return (category() == _Right.category()
; 265  : 			&& value() == _Right.value());
; 266  : 		}
; 267  : 
; 268  : 	bool operator!=(const error_code& _Right) const _NOEXCEPT
; 269  : 		{	// test if *this != _Right
; 270  : 		return (!(*this == _Right));
; 271  : 		}
; 272  : 
; 273  : 	bool operator<(const error_code& _Right) const _NOEXCEPT
; 274  : 		{	// test if *this == _Right
; 275  : 		return (category() < _Right.category()
; 276  : 			|| (category() == _Right.category()
; 277  : 				&& value() < _Right.value()));
; 278  : 		}
; 279  : 
; 280  : private:
; 281  : 	int _Myval;	// the stored error number
; 282  : 	const error_category *_Mycat;	// pointer to error category
; 283  : 	};
; 284  : 
; 285  : 		// CLASS error_condition
; 286  : class error_condition
; 287  : 	{	// store an abstract error code and category
; 288  : public:
; 289  : 	typedef error_condition _Myt;
; 290  : 
; 291  : 	error_condition() _NOEXCEPT
; 292  : 		: _Myval(0),
; 293  : 			_Mycat(&generic_category())
; 294  : 		{	// construct non-error
; 295  : 		}
; 296  : 
; 297  : 	error_condition(int _Val, const error_category& _Cat) _NOEXCEPT
; 298  : 		: _Myval(_Val), _Mycat(&_Cat)
; 299  : 		{	// construct from error code and category
; 300  : 		}
; 301  : 
; 302  : 	template<class _Enum,
; 303  : 		class = typename enable_if<is_error_condition_enum<_Enum>::value,
; 304  : 			void>::type>
; 305  : 		error_condition(_Enum _Errcode) _NOEXCEPT
; 306  : 		: _Myval(0), _Mycat(0)
; 307  : 		{	// construct from enumerated error code
; 308  : 		*this = make_error_condition(_Errcode);	// using ADL
; 309  : 		}
; 310  : 
; 311  : 	void assign(int _Val, const error_category& _Cat) _NOEXCEPT
; 312  : 		{	// assign error code and category
; 313  : 		_Myval = _Val;
; 314  : 		_Mycat = &_Cat;
; 315  : 		}
; 316  : 
; 317  : 	template<class _Enum>
; 318  : 		typename enable_if<is_error_condition_enum<_Enum>::value,
; 319  : 			error_condition>::type& operator=(_Enum _Errcode) _NOEXCEPT
; 320  : 		{	// assign enumerated error code
; 321  : 		*this = make_error_condition(_Errcode);	// using ADL
; 322  : 		return (*this);
; 323  : 		}
; 324  : 
; 325  : 	void clear() _NOEXCEPT
; 326  : 		{	// assign non-error
; 327  : 		_Myval = 0;
; 328  : 		_Mycat = &generic_category();
; 329  : 		}
; 330  : 
; 331  : 	int value() const _NOEXCEPT
; 332  : 		{	// get error code
; 333  : 		return (_Myval);
; 334  : 		}
; 335  : 
; 336  : 	const error_category& category() const _NOEXCEPT
; 337  : 		{	// get category
; 338  : 		return (*_Mycat);
; 339  : 		}
; 340  : 
; 341  : 	string message() const
; 342  : 		{	// get name of error code
; 343  : 		return (category().message(value()));
; 344  : 		}
; 345  : 
; 346  : 	explicit operator bool() const _NOEXCEPT
; 347  : 		{	// test for actual error
; 348  : 		return (value() != 0);
; 349  : 		}
; 350  : 
; 351  : 	bool operator==(const error_condition& _Right) const _NOEXCEPT
; 352  : 		{	// test if *this == _Right
; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	jne	SHORT $LN5@equivalent
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN5@equivalent

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	al, 1

; 386  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN5@equivalent:

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	xor	al, al

; 386  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 377  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp

; 299  : 		{	// construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Errval$[ebp]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 378  : 	return (error_condition(_Errval, *this));
; 379  : 	}

	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 160  : 		}

	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 154  : 	error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 155  : 		{	// default constructor
; 156  : 		}

	mov	eax, ecx
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 653  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 654  : 	}

	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 643  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 644  : 	}

	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 75   : 			}

	mov	eax, ecx
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 2273 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	je	SHORT $LN19@Tidy

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN19@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN14@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Tidy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebx
$LN19@Tidy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2286 : 		}

	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	esi
	test	edx, edx
	je	SHORT $LN2@Inside

; 513  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN8@Inside
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	esi, ecx
$LN9@Inside:

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	edx, esi
	jb	SHORT $LN2@Inside

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN14@Inside
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN15@Inside
$LN14@Inside:
	mov	esi, ecx
$LN15@Inside:

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	eax, DWORD PTR [ecx+16]
	add	eax, esi
	cmp	eax, edx
	jbe	SHORT $LN2@Inside

; 2260 : 		else
; 2261 : 			return (true);

	mov	al, 1
	pop	esi

; 2262 : 		}

	pop	ebp
	ret	4
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2262 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ptr$1$ = 12						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2243 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	cmp	edi, -2					; fffffffeH
	ja	$LN67@Grow

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	DWORD PTR [esi+16]
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, edi
	pop	edi
	sbb	eax, eax
	neg	eax
	pop	esi

; 2253 : 		}

	pop	ebp
	ret	8
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	cmp	BYTE PTR __Trim$[ebp], 0
	je	SHORT $LN3@Grow
	cmp	edi, 16					; 00000010H
	jae	SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	push	ebx
	mov	ebx, DWORD PTR [esi+16]
	cmp	edi, ebx
	cmovb	ebx, edi

; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN44@Grow

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __Ptr$1$[ebp], eax

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)

	test	ebx, ebx
	je	SHORT $LN39@Grow
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	eax
	push	esi
	call	_memcpy
	mov	eax, DWORD PTR __Ptr$1$[ebp]
	add	esp, 12					; 0000000cH
$LN39@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN44@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);
; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	eax, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ebx+esi], 0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	sbb	eax, eax
	pop	edi
	neg	eax
	pop	esi

; 2253 : 		}

	pop	ebp
	ret	8
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN64@Grow

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);
; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN60@Grow
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, DWORD PTR [esi]
$LN60@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
$LN64@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, edi
	pop	edi
	sbb	eax, eax
	neg	eax
	pop	esi

; 2253 : 		}

	pop	ebp
	ret	8
$LN67@Grow:

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN69@Grow:
$LN66@Grow:
	int	3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN5@Eos
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2238 : 		}

	pop	ebp
	ret	4
$LN5@Eos:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2238 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$1$ = -20						; size = 4
__Newres$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
$T2 = 11						; size = 1
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, eax
	or	edi, 15					; 0000000fH

; 2203 : 		if (max_size() < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax
	jmp	SHORT $LN47@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	ebx, DWORD PTR [esi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN47@Copy

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, -2					; fffffffeH

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN47@Copy

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);
; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	edi, -2					; fffffffeH
$LN47@Copy:

; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

	xor	eax, eax
	mov	DWORD PTR __Ptr$1$[ebp], eax

; 24   : 
; 25   : 	if (_Count == 0)

	test	ecx, ecx
	je	SHORT $LN19@Copy

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	ecx, -1
	ja	SHORT $LN62@Copy
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN19@Copy
$LN62@Copy:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN174@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END

	mov	eax, $LN171@Copy
	ret	0
$LN171@Copy:

; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	edi, DWORD PTR __Newres$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], eax
$LN19@Copy:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	je	SHORT $LN112@Copy

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN105@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN106@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN91@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN91@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2222 : 			_RERAISE;

	push	0

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 2222 : 			_RERAISE;

	push	0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2222 : 			_RERAISE;

	call	__CxxThrowException@8
$LN175@Copy:
$LN105@Copy:

; 513  : 			: this->_Bx._Buf);

	mov	ecx, esi
$LN106@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	ebx, ebx
	je	SHORT $LN112@Copy
	push	ebx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN112@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN131@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN131@Copy:

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2231 : 		this->_Myres = _Newres;

	mov	DWORD PTR [esi+20], edi

; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 513  : 			: this->_Bx._Buf);

	cmp	edi, 16					; 00000010H
	jb	SHORT $LN166@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, eax
$LN166@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2233 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN173@Copy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1761 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR [ecx+16]

; 1755 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1343 : 		if (this->_Mysize < _Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	edi, ecx
	jb	SHORT $LN41@erase

; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, ecx
	cmp	eax, edx
	ja	SHORT $LN3@erase

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN14@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1354 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1355 : 		}

	pop	ebp
	ret	8
$LN14@erase:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1355 : 		}

	pop	ebp
	ret	8
$LN3@erase:

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)

	test	edx, edx
	je	SHORT $LN38@erase

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN22@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN23@erase
$LN22@erase:
	mov	eax, esi
$LN23@erase:

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

	sub	edi, edx
	push	ebx
	lea	ebx, DWORD PTR [eax+ecx]

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN29@erase
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ebx+edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH
$LN29@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi
	pop	ebx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN34@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1354 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1355 : 		}

	pop	ebp
	ret	8
$LN34@erase:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN38@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1354 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1355 : 		}

	pop	ebp
	ret	8
$LN41@erase:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN43@erase:
$LN40@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp

; 1335 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN18@erase

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN11@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1338 : 		return (*this);

	mov	eax, ecx

; 1339 : 		}

	pop	ebp
	ret	4
$LN11@erase:

; 513  : 			: this->_Bx._Buf);

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1338 : 		return (*this);

	mov	eax, ecx

; 1339 : 		}

	pop	ebp
	ret	4
$LN18@erase:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN20@erase:
$LN17@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@assign
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1170 : 		}

	pop	ebp
	ret	4
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@assign:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@assign
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1170 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@assign

; 513  : 			: this->_Bx._Buf);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN13@assign
$LN12@assign:
	mov	eax, esi
$LN13@assign:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@assign

; 513  : 			: this->_Bx._Buf);

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN18@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN19@assign
$LN18@assign:
	mov	edx, esi
$LN19@assign:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@assign

; 513  : 			: this->_Bx._Buf);

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN24@assign

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN24@assign:

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	edi

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Count$[ebp]
	cmp	edi, -2					; fffffffeH
	ja	SHORT $LN118@assign

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN32@assign

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1157 : 
; 1158 : 		if (_Grow(_Count))

	je	SHORT $LN112@assign
$LN117@assign:

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN96@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN97@assign
$LN32@assign:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN117@assign

; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN87@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1163 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN87@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1164 : 		}

	pop	ebp
	ret	8
$LN96@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
$LN97@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	edi, edi
	je	SHORT $LN103@assign
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN103@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN108@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1163 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN108@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN112@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1163 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN118@assign:

; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN120@assign:
$LN115@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 1130 : 		if (_Right.size() < _Roff)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Roff$[ebp]
	mov	edi, DWORD PTR [ebx+16]
	cmp	edi, ecx
	jb	$LN125@assign

; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;

	sub	edi, ecx

; 1133 : 		if (_Count < _Num)

	cmp	DWORD PTR __Count$[ebp], edi
	cmovb	edi, DWORD PTR __Count$[ebp]

; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	lea	eax, DWORD PTR [edi+ecx]

; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)

	cmp	DWORD PTR [esi+16], eax
	jb	$LN127@assign

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN25@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN25@assign:

; 513  : 			: this->_Bx._Buf);

	mov	edx, esi

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN3@assign:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	$LN128@assign

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN35@assign

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Roff$[ebp]

; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1138 : 		else if (_Grow(_Num))

	je	SHORT $LN120@assign
$LN124@assign:

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN98@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ebx, DWORD PTR [ebx]
$LN98@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN104@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN105@assign
$LN35@assign:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN124@assign

; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN90@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN90@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN104@assign:

; 513  : 			: this->_Bx._Buf);

	mov	edx, esi
$LN105@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	edi, edi
	je	SHORT $LN111@assign
	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1141 : 				_Right._Myptr() + _Roff, _Num);

	lea	eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN111@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN116@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1144 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN116@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN120@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN125@assign:

; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN129@assign:
$LN127@assign:
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN130@assign:
$LN128@assign:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN131@assign:
$LN122@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 990  : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN21@basic_stri
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@basic_stri:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 992  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN43@basic_stri
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
$LN43@basic_stri:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edx, ecx
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL45@basic_stri:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL45@basic_stri
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp

; 684  : 		return (_Alty());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 494  : 		_Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

	mov	eax, ecx

; 495  : 		_Myres = 0;

	mov	DWORD PTR [ecx+20], 0

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 521  : 		}

	ret	0
$LN3@Myptr:

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	mov	eax, ecx

; 521  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 514  : 		}

	ret	0
$LN3@Myptr:

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	mov	eax, ecx

; 514  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 495  : 		_Myres = 0;
; 496  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 25   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN14@allocate
	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 848  : 		}

	pop	ebp
	ret	4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
	int	3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 802  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

	or	eax, -1

; 736  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 613  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 25   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN11@allocate
	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, ecx

; 579  : 		}

	pop	ebp
	ret	4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]

; 554  : 		}

	pop	ebp
	ret	0
$LN3@move:

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	mov	DWORD PTR __Count$[ebp], eax

; 554  : 		}

	pop	ebp

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	jmp	_memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]

; 531  : 		}

	pop	ebp
	ret	0
$LN3@copy:

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	mov	DWORD PTR __Count$[ebp], eax

; 531  : 		}

	pop	ebp

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 524  : 		}

	pop	ebp
	ret	0
$LN3@length:

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	lea	edx, DWORD PTR [eax+1]
$LL5@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@length
	sub	eax, edx

; 524  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 2806 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h

; 210  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
	test	eax, eax
	je	SHORT $LN25@dynamic

; 211  : 		{
; 212  : 			for(int i = 0; i < m_nSize; i++)
; 213  : 				m_aT[i].~T();
; 214  : 			free(m_aT);

	push	eax
	call	_free
	add	esp, 4

; 215  : 			m_aT = NULL;

	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN25@dynamic:

; 216  : 		}
; 217  : 		m_nSize = 0;
; 218  : 		m_nAllocSize = 0;

	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0
	ret	0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2821 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	mov	ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET ??__F_AtlWinModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlWinModule''
	call	_atexit
	pop	ecx
	ret	0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2806 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	ecx
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2807 : 	}

	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2800 : 	{

	push	esi

; 2803 : 
; 2804 : 	void Term()
; 2805 : 	{
; 2806 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4

; 2800 : 	{

	mov	esi, ecx

; 2803 : 
; 2804 : 	void Term()
; 2805 : 	{
; 2806 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	esi
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h

; 210  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN24@CAtlWinMod

; 211  : 		{
; 212  : 			for(int i = 0; i < m_nSize; i++)
; 213  : 				m_aT[i].~T();
; 214  : 			free(m_aT);

	push	eax
	call	_free
	add	esp, 4

; 215  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN24@CAtlWinMod:

; 216  : 		}
; 217  : 		m_nSize = 0;
; 218  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 2802 : 	}

	ret	0
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2786 : 	CAtlWinModule()

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movdqu	XMMWORD PTR [esi+4], xmm0
	lea	eax, DWORD PTR [esi+4]
	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h

; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h

; 120  : 	{

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h

; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 2788 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	DWORD PTR [esi], 44			; 0000002cH

; 2798 : 
; 2799 : 	~CAtlWinModule()
; 2800 : 	{
; 2801 : 		Term();
; 2802 : 	}
; 2803 : 
; 2804 : 	void Term()
; 2805 : 	{
; 2806 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());
; 2807 : 	}
; 2808 : 
; 2809 : 	void AddCreateWndData(_Inout_ _AtlCreateWndData* pData, _In_ void* pObject)
; 2810 : 	{
; 2811 : 		AtlWinModuleAddCreateWndData(this, pData, pObject);
; 2812 : 	}
; 2813 : 
; 2814 : 	void* ExtractCreateWndData()
; 2815 : 	{
; 2816 : 		return AtlWinModuleExtractCreateWndData(this);
; 2817 : 	}
; 2818 : };
; 2819 : 
; 2820 : #ifndef _ATL_STATIC_LIB_IMPL
; 2821 : __declspec(selectany) CAtlWinModule _AtlWinModule;
; 2822 : #endif
; 2823 : 
; 2824 : #endif // _ATL_NO_WIN_SUPPORT
; 2825 : 
; 2826 : #ifndef _ATL_STATIC_LIB_IMPL
; 2827 : class CAtlModule;
; 2828 : __declspec(selectany) CAtlModule* _pAtlModule = NULL;
; 2829 : #endif //  _ATL_STATIC_LIB_IMPL
; 2830 : 
; 2831 : template<bool isDllModule, typename T>
; 2832 : struct CAtlValidateModuleConfiguration
; 2833 : {
; 2834 : #if !defined(_WINDLL) && !defined(_USRDLL)
; 2835 : 	static_assert(!isDllModule, "'CAtlDllModuleT<T>' must be used with either _WINDLL or _USRDLL defined");
; 2836 : #else
; 2837 : 	static_assert(isDllModule, "'CAtlExeModuleT<T>' must be used with neither _WINDLL nor _USRDLL defined");
; 2838 : #endif
; 2839 : };
; 2840 : 
; 2841 : #if defined(_M_CEE) && !defined(_ATL_MIXED)
; 2842 : 
; 2843 : // This small class takes care of releasing the class factories at managed
; 2844 : // shutdown when we are compiling /clr. We can't wait to call _AtlComModule.Term()
; 2845 : // in _AtlComModule destructor, since _AtlComModule is a native global object, and it
; 2846 : // will be destructed after the managed runtime has been shutdown.
; 2847 : 
; 2848 : // Notice that if the user defines _ATL_MIXED, he/she will need to take care
; 2849 : // of releasing the eventual managed class factories at the right time.
; 2850 : 
; 2851 : class CAtlReleaseManagedClassFactories
; 2852 : {
; 2853 : public:
; 2854 : 	CAtlReleaseManagedClassFactories() { }
; 2855 : 	~CAtlReleaseManagedClassFactories()
; 2856 : 	{
; 2857 : 		_AtlComModule.Term();
; 2858 : 	}
; 2859 : };
; 2860 : 
; 2861 : __declspec (selectany) CAtlReleaseManagedClassFactories _AtlReleaseManagedClassFactories;
; 2862 : 
; 2863 : extern "C"
; 2864 : {
; 2865 : __declspec (selectany) void *_pAtlReleaseManagedClassFactories = &_AtlReleaseManagedClassFactories;
; 2866 : }
; 2867 : #if defined(_M_IX86)
; 2868 : 	#pragma comment(linker, "/include:__pAtlReleaseManagedClassFactories")
; 2869 : #else
; 2870 : 	#pragma comment(linker, "/include:_pAtlReleaseManagedClassFactories")
; 2871 : #endif
; 2872 : 
; 2873 : #endif
; 2874 : 
; 2875 : #ifndef _ATL_STATIC_LIB_IMPL
; 2876 : 
; 2877 : class ATL_NO_VTABLE CAtlModule : 
; 2878 : 	public _ATL_MODULE
; 2879 : {
; 2880 : public :
; 2881 : 	static GUID m_libid;
; 2882 : 	IGlobalInterfaceTable* m_pGIT;
; 2883 : 
; 2884 : 	CAtlModule() throw()
; 2885 : 	{
; 2886 : 		// Should have only one instance of a class
; 2887 : 		// derived from CAtlModule in a project.
; 2888 : 		ATLASSERT(_pAtlModule == NULL);
; 2889 : 		cbSize = 0;
; 2890 : 		m_pTermFuncs = NULL;
; 2891 : 
; 2892 : 		m_nLockCnt = 0;
; 2893 : 		_pAtlModule = this;
; 2894 : 		m_pGIT = NULL;
; 2895 : 
; 2896 : 		if (FAILED(m_csStaticDataInitAndTypeInfo.Init()))
; 2897 : 		{
; 2898 : 			ATLTRACE(atlTraceGeneral, 0, _T("ERROR : Unable to initialize critical section in CAtlModule\n"));
; 2899 : 			ATLASSERT(0);
; 2900 : 			CAtlBaseModule::m_bInitFailed = true;
; 2901 : 			return;
; 2902 : 		}
; 2903 : 
; 2904 : 		// Set cbSize on success.
; 2905 : 		cbSize = sizeof(_ATL_MODULE);
; 2906 : 	}
; 2907 : 
; 2908 : 	void Term() throw()
; 2909 : 	{
; 2910 : 		// cbSize == 0 indicates that Term has already been called
; 2911 : 		if (cbSize == 0)
; 2912 : 			return;
; 2913 : 
; 2914 : 		// Call term functions
; 2915 : 		if (m_pTermFuncs != NULL)
; 2916 : 		{
; 2917 : 			AtlCallTermFunc(this);
; 2918 : 			m_pTermFuncs = NULL;
; 2919 : 		}
; 2920 : 
; 2921 : 		if (m_pGIT != NULL)
; 2922 : 			m_pGIT->Release();
; 2923 : 
; 2924 : 		m_csStaticDataInitAndTypeInfo.Term();
; 2925 : 
; 2926 : 		cbSize = 0;
; 2927 : 	}
; 2928 : 
; 2929 : 	virtual ~CAtlModule() throw()
; 2930 : 	{
; 2931 : 		Term();
; 2932 : 	}
; 2933 : 
; 2934 : 	virtual LONG Lock() throw()
; 2935 : 	{
; 2936 : 		return CComGlobalsThreadModel::Increment(&m_nLockCnt);
; 2937 : 	}
; 2938 : 
; 2939 : 	virtual LONG Unlock() throw()
; 2940 : 	{
; 2941 : 		return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
; 2942 : 	}
; 2943 : 
; 2944 : 	virtual LONG GetLockCount() throw()
; 2945 : 	{
; 2946 : 		return m_nLockCnt;
; 2947 : 	}
; 2948 : 
; 2949 : 	HRESULT AddTermFunc(
; 2950 : 		_In_ _ATL_TERMFUNC* pFunc, 
; 2951 : 		_In_ DWORD_PTR dw) throw()
; 2952 : 	{
; 2953 : 		return AtlModuleAddTermFunc(this, pFunc, dw);
; 2954 : 	}
; 2955 : 
; 2956 : 	virtual HRESULT GetGITPtr(_Outptr_ IGlobalInterfaceTable** ppGIT) throw()
; 2957 : 	{
; 2958 : 		ATLASSERT(ppGIT != NULL);
; 2959 : 
; 2960 : 		if (ppGIT == NULL)
; 2961 : 			return E_POINTER;
; 2962 : 
; 2963 : 		HRESULT hr = S_OK;
; 2964 : 		if (m_pGIT == NULL)
; 2965 : 		{
; 2966 : 			hr = ::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,
; 2967 : 				__uuidof(IGlobalInterfaceTable), (void**)&m_pGIT);
; 2968 : 		}
; 2969 : 
; 2970 : 		if (SUCCEEDED(hr))
; 2971 : 		{
; 2972 : 			ATLASSUME(m_pGIT != NULL);
; 2973 : 			*ppGIT = m_pGIT;
; 2974 : 			m_pGIT->AddRef();
; 2975 : 		}
; 2976 : 		return hr;
; 2977 : 	}
; 2978 : 
; 2979 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 2980 : 	virtual HRESULT AddCommonRGSReplacements(_Inout_ IRegistrarBase* /*pRegistrar*/) throw() = 0;
; 2981 : 
; 2982 : 	// Resource-based Registration
; 2983 : 	// Statically linking to Registry Ponent
; 2984 : 	HRESULT WINAPI UpdateRegistryFromResource(
; 2985 : 		_In_z_ LPCTSTR lpszRes,
; 2986 : 		_In_ BOOL bRegister,
; 2987 : 		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw();
; 2988 : 	HRESULT WINAPI UpdateRegistryFromResource(
; 2989 : 		_In_ UINT nResID,
; 2990 : 		_In_ BOOL bRegister,
; 2991 : 		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw();
; 2992 : 
; 2993 : 	static void EscapeSingleQuote(
; 2994 : 		_Out_writes_z_(destSizeInChars) LPOLESTR lpDest,
; 2995 : 		_In_ size_t destSizeInChars,
; 2996 : 		_In_z_ LPCOLESTR lp) throw()
; 2997 : 	{
; 2998 : 		if (destSizeInChars == 0)
; 2999 : 		{
; 3000 : 			return;
; 3001 : 		}
; 3002 : 		UINT i = 0;
; 3003 : 		// copy charecters to the destination buffer but leave the last char to be NULL.
; 3004 : 		for (i=0; i < destSizeInChars-1 && *lp; i++)
; 3005 : 		{
; 3006 : 			*lpDest++ = *lp;
; 3007 : 			// make sure we won't promote lpDest behind the buffer limit.
; 3008 : 			if (*lp == '\'' && ++i < destSizeInChars-1)
; 3009 : 				*lpDest++ = *lp;
; 3010 : 			lp++;
; 3011 : 		}
; 3012 : 		*lpDest = '\0';
; 3013 : 	}
; 3014 : 
; 3015 : 	ATL_DEPRECATED("CAtlModule::EscapeSingleQuote(dest, src) is unsafe. Instead, use CAtlModule::EscapeSingleQuote(dest, size, src)")
; 3016 : 	static void EscapeSingleQuote(
; 3017 : 		_Out_ _Post_z_ LPOLESTR lpDest,
; 3018 : 		_In_z_ LPCOLESTR lp) throw()
; 3019 : 	{
; 3020 : ATLPREFAST_SUPPRESS(6386)
; 3021 : 		EscapeSingleQuote(lpDest, SIZE_MAX/sizeof(OLECHAR), lp);
; 3022 : ATLPREFAST_UNSUPPRESS()
; 3023 : 	}
; 3024 : 
; 3025 : 	// search for an occurence of string p2 in string p1
; 3026 : 	static LPCTSTR FindOneOf(
; 3027 : 		_In_z_ LPCTSTR p1,
; 3028 : 		_In_z_ LPCTSTR p2) throw()
; 3029 : 	{
; 3030 : 		while (p1 != NULL && *p1 != _T('\0'))
; 3031 : 		{
; 3032 : 			LPCTSTR p = p2;
; 3033 : 			while (p != NULL && *p != _T('\0'))
; 3034 : 			{
; 3035 : 				if (*p1 == *p)
; 3036 : 					return CharNext(p1);
; 3037 : 				p = CharNext(p);
; 3038 : 			}
; 3039 : 			p1 = CharNext(p1);
; 3040 : 		}
; 3041 : 		return NULL;
; 3042 : 	}
; 3043 : #pragma warning(push)  // disable 4302
; 3044 : #pragma warning(disable : 4302)	// 'type cast' : truncation from 'LPSTR' to 'TCHAR'
; 3045 : 
; 3046 : 	static int WordCmpI(
; 3047 : 		_In_z_ LPCTSTR psz1,
; 3048 : 		_In_z_ LPCTSTR psz2) throw()
; 3049 : 	{
; 3050 : 		TCHAR c1 = (TCHAR)CharUpper((LPTSTR)*psz1);
; 3051 : 		TCHAR c2 = (TCHAR)CharUpper((LPTSTR)*psz2);
; 3052 : 		while (c1 != _T('\0') && c1 == c2 && c1 != ' ' && c1 != '\t')
; 3053 : 		{
; 3054 : 			psz1 = CharNext(psz1);
; 3055 : 			psz2 = CharNext(psz2);
; 3056 : 			c1 = (TCHAR)CharUpper((LPTSTR)*psz1);
; 3057 : 			c2 = (TCHAR)CharUpper((LPTSTR)*psz2);
; 3058 : 		}
; 3059 : 		if ((c1 == _T('\0') || c1 == ' ' || c1 == '\t') && (c2 == _T('\0') || c2 == ' ' || c2 == '\t'))
; 3060 : 			return 0;
; 3061 : 
; 3062 : 		return (c1 < c2) ? -1 : 1;
; 3063 : 	}
; 3064 : #pragma warning (pop)  // disable 4302
; 3065 : 
; 3066 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 3067 : };
; 3068 : 
; 3069 : __declspec(selectany) GUID CAtlModule::m_libid = {0x0, 0x0, 0x0, {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0} };
; 3070 : 
; 3071 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 3072 : 
; 3073 : #define DECLARE_LIBID(libid) \
; 3074 : 	static void InitLibId() throw() \
; 3075 : 	{ \
; 3076 : 		ATL::CAtlModule::m_libid = libid; \
; 3077 : 	}
; 3078 : 
; 3079 : #define DECLARE_REGISTRY_APPID_RESOURCEID(resid, appid) \
; 3080 : 	static LPCOLESTR GetAppId() throw() \
; 3081 : 	{ \
; 3082 : 		return OLESTR(appid); \
; 3083 : 	} \
; 3084 : 	static TCHAR* GetAppIdT() throw() \
; 3085 : 	{ \
; 3086 : 		return _T(appid); \
; 3087 : 	} \
; 3088 : 	static HRESULT WINAPI UpdateRegistryAppId(_In_ BOOL bRegister) throw() \
; 3089 : 	{ \
; 3090 : 		ATL::_ATL_REGMAP_ENTRY aMapEntries [] = \
; 3091 : 		{ \
; 3092 : 			{ OLESTR("APPID"), GetAppId() }, \
; 3093 : 			{ NULL, NULL } \
; 3094 : 		}; \
; 3095 : 		return ATL::_pAtlModule->UpdateRegistryFromResource(resid, bRegister, aMapEntries); \
; 3096 : 	}
; 3097 : 
; 3098 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 3099 : 
; 3100 : inline HRESULT AtlGetGITPtr(_Outptr_ IGlobalInterfaceTable** ppGIT) throw()
; 3101 : {
; 3102 : 	if (ppGIT == NULL)
; 3103 : 		return E_POINTER;
; 3104 : 
; 3105 : 	if (_pAtlModule == NULL)
; 3106 : 	{
; 3107 : 		return CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,
; 3108 : 			__uuidof(IGlobalInterfaceTable), (void**)ppGIT);
; 3109 : 	}
; 3110 : 	else
; 3111 : 	{
; 3112 : 		return _pAtlModule->GetGITPtr(ppGIT);
; 3113 : 	}
; 3114 : }
; 3115 : 
; 3116 : template <class T>
; 3117 : class ATL_NO_VTABLE CAtlModuleT : 
; 3118 : 	public CAtlModule
; 3119 : {
; 3120 : public :
; 3121 : 	CAtlModuleT() throw()
; 3122 : 	{
; 3123 : 		T::InitLibId();
; 3124 : 	}
; 3125 : 
; 3126 : 	static void InitLibId() throw()
; 3127 : 	{
; 3128 : 	}
; 3129 : 
; 3130 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 3131 : 
; 3132 : 	HRESULT RegisterServer(
; 3133 : 		_In_ BOOL bRegTypeLib = FALSE,
; 3134 : 		_In_opt_ const CLSID* pCLSID = NULL) throw()
; 3135 : 	{
; 3136 : 		(pCLSID);
; 3137 : 		(bRegTypeLib);
; 3138 : 
; 3139 : 		HRESULT hr = S_OK;
; 3140 : 
; 3141 : #ifndef _ATL_NO_COM_SUPPORT
; 3142 : 
; 3143 : 		hr = _AtlComModule.RegisterServer(bRegTypeLib, pCLSID);
; 3144 : 
; 3145 : #endif	// _ATL_NO_COM_SUPPORT
; 3146 : 
; 3147 : 
; 3148 : #ifndef _ATL_NO_PERF_SUPPORT
; 3149 : 
; 3150 : 		if (SUCCEEDED(hr) && _pPerfRegFunc != NULL)
; 3151 : 			hr = (*_pPerfRegFunc)(_AtlBaseModule.m_hInst);
; 3152 : 
; 3153 : #endif
; 3154 : 
; 3155 : 		return hr;
; 3156 : 	}
; 3157 : 
; 3158 : 	HRESULT UnregisterServer(
; 3159 : 		_In_ BOOL bUnRegTypeLib,
; 3160 : 		_In_opt_ const CLSID* pCLSID = NULL) throw()
; 3161 : 	{
; 3162 : 		(bUnRegTypeLib);
; 3163 : 		(pCLSID);
; 3164 : 
; 3165 : 		HRESULT hr = S_OK;
; 3166 : 
; 3167 : #ifndef _ATL_NO_PERF_SUPPORT
; 3168 : 
; 3169 : 		if (_pPerfUnRegFunc != NULL)
; 3170 : 			hr = (*_pPerfUnRegFunc)();
; 3171 : 
; 3172 : #endif
; 3173 : 
; 3174 : #ifndef _ATL_NO_COM_SUPPORT
; 3175 : 
; 3176 : 		if (SUCCEEDED(hr))
; 3177 : 			hr = _AtlComModule.UnregisterServer(bUnRegTypeLib, pCLSID);
; 3178 : 
; 3179 : #endif	// _ATL_NO_COM_SUPPORT
; 3180 : 
; 3181 : 		return hr;
; 3182 : 
; 3183 : 	}
; 3184 : 
; 3185 : 	static HRESULT WINAPI UpdateRegistryAppId(_In_ BOOL /*bRegister*/) throw()
; 3186 : 	{
; 3187 : 		return S_OK;
; 3188 : 	}
; 3189 : 	HRESULT RegisterAppId() throw()
; 3190 : 	{
; 3191 : 		return T::UpdateRegistryAppId(TRUE);
; 3192 : 	}
; 3193 : 
; 3194 : 	HRESULT UnregisterAppId() throw()
; 3195 : 	{
; 3196 : 		return T::UpdateRegistryAppId(FALSE);
; 3197 : 	}
; 3198 : 
; 3199 : 	virtual HRESULT AddCommonRGSReplacements(_Inout_ IRegistrarBase* pRegistrar) throw()
; 3200 : 	{
; 3201 : 		return pRegistrar->AddReplacement(L"APPID", T::GetAppId());
; 3202 : 	}
; 3203 : 
; 3204 : 	static LPCOLESTR GetAppId() throw()
; 3205 : 	{
; 3206 : 		return OLESTR("");
; 3207 : 	}
; 3208 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 3209 : };
; 3210 : 
; 3211 : #endif // _ATL_STATIC_LIB_IMPL
; 3212 : 
; 3213 : #if !defined(_ATL_NATIVE_INITIALIZATION)
; 3214 : #pragma warning(push)  // disable 4483
; 3215 : #pragma warning(disable:4483)
; 3216 : namespace __identifier("<AtlImplementationDetails>")
; 3217 : #pragma warning(pop)  // disable 4483
; 3218 : {
; 3219 : 	__declspec(selectany) bool DllModuleInitialized = false;
; 3220 : }
; 3221 : 
; 3222 : #endif
; 3223 : 
; 3224 : #ifndef _ATL_STATIC_LIB_IMPL
; 3225 : 
; 3226 : template <class T>
; 3227 : class ATL_NO_VTABLE CAtlDllModuleT : 
; 3228 : 	public CAtlModuleT<T>,
; 3229 : 	private CAtlValidateModuleConfiguration<true, T>
; 3230 : {
; 3231 : public :
; 3232 : 	CAtlDllModuleT() throw()
; 3233 : 	{
; 3234 : 		_AtlComModule.ExecuteObjectMain(true);
; 3235 : #if !defined(_ATL_NATIVE_INITIALIZATION)
; 3236 : #pragma warning(push)  // disable 4483
; 3237 : #pragma warning(disable:4483)
; 3238 : 		using namespace __identifier("<AtlImplementationDetails>");
; 3239 : #pragma warning(pop)  // disable 4483
; 3240 : 		ATLASSERT(DllModuleInitialized == false);
; 3241 : 		DllModuleInitialized = true;
; 3242 : 		_DllMain(DLL_PROCESS_ATTACH, NULL);
; 3243 : #endif
; 3244 : 	}
; 3245 : 
; 3246 : 	~CAtlDllModuleT() throw()
; 3247 : 	{
; 3248 : #if !defined(_ATL_NATIVE_INITIALIZATION)
; 3249 : #pragma warning(push)  // disable 4483
; 3250 : #pragma warning(disable:4483)
; 3251 : 		using namespace __identifier("<AtlImplementationDetails>");
; 3252 : #pragma warning(pop)  // disable 4483
; 3253 : 		ATLASSERT(DllModuleInitialized == true);
; 3254 : 		_DllMain(DLL_PROCESS_DETACH, NULL);
; 3255 : #endif
; 3256 : 		_AtlComModule.ExecuteObjectMain(false);
; 3257 : 	}
; 3258 : 
; 3259 : 	BOOL WINAPI DllMain(
; 3260 : 		_In_ DWORD dwReason,
; 3261 : 		_In_opt_ LPVOID lpReserved) throw();
; 3262 : 
; 3263 : 	BOOL WINAPI _DllMain(
; 3264 : 		_In_ DWORD dwReason,
; 3265 : 		_In_opt_ LPVOID /* lpReserved */) throw()
; 3266 : 	{
; 3267 : 		if (dwReason == DLL_PROCESS_ATTACH)
; 3268 : 		{
; 3269 : 			if (CAtlBaseModule::m_bInitFailed)
; 3270 : 			{
; 3271 : 				ATLASSERT(0);
; 3272 : 				return FALSE;
; 3273 : 			}
; 3274 : 		}
; 3275 : #if defined(_DEBUG) && !defined(_ATL_NO_WIN_SUPPORT)
; 3276 : 		else if (dwReason == DLL_PROCESS_DETACH)
; 3277 : 		{
; 3278 : 			// Prevent false memory leak reporting. ~CAtlWinModule may be too late.
; 3279 : 			_AtlWinModule.Term();
; 3280 : 		}
; 3281 : #endif	// _DEBUG
; 3282 : 		return TRUE;    // ok
; 3283 : 	}
; 3284 : 
; 3285 : 	HRESULT DllCanUnloadNow() throw()
; 3286 : 	{
; 3287 : 		T* pT = static_cast<T*>(this);
; 3288 : 		return (pT->GetLockCount()==0) ? S_OK : S_FALSE;
; 3289 : 	}
; 3290 : 
; 3291 : 	HRESULT DllGetClassObject(
; 3292 : 		_In_ REFCLSID rclsid,
; 3293 : 		_In_ REFIID riid,
; 3294 : 		_COM_Outptr_ LPVOID* ppv) throw()
; 3295 : 	{
; 3296 : 		T* pT = static_cast<T*>(this);
; 3297 : 		return pT->GetClassObject(rclsid, riid, ppv);
; 3298 : 	}
; 3299 : 
; 3300 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 3301 : 
; 3302 : 	HRESULT DllRegisterServer(
; 3303 : 		_In_ BOOL bRegTypeLib = TRUE) throw()
; 3304 : 	{
; 3305 : 		LCID lcid = GetThreadLocale();
; 3306 : 		SetThreadLocale(LOCALE_SYSTEM_DEFAULT);
; 3307 : 		// registers object, typelib and all interfaces in typelib
; 3308 : 		T* pT = static_cast<T*>(this);
; 3309 : 		HRESULT hr = pT->RegisterAppId();
; 3310 : 		if (SUCCEEDED(hr))
; 3311 : 			hr = pT->RegisterServer(bRegTypeLib);
; 3312 : 		SetThreadLocale(lcid);
; 3313 : 		return hr;
; 3314 : 	}
; 3315 : 
; 3316 : 	HRESULT DllUnregisterServer(
; 3317 : 		_In_ BOOL bUnRegTypeLib = TRUE) throw()
; 3318 : 	{
; 3319 : 		LCID lcid = GetThreadLocale();
; 3320 : 		SetThreadLocale(LOCALE_SYSTEM_DEFAULT);
; 3321 : 		T* pT = static_cast<T*>(this);
; 3322 : 		HRESULT hr = pT->UnregisterServer(bUnRegTypeLib);
; 3323 : 		if (SUCCEEDED(hr))
; 3324 : 			hr = pT->UnregisterAppId();
; 3325 : 		SetThreadLocale(lcid);
; 3326 : 		return hr;
; 3327 : 	}
; 3328 : 
; 3329 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 3330 : 
; 3331 : 	// Obtain a Class Factory
; 3332 : 	HRESULT GetClassObject(
; 3333 : 		_In_ REFCLSID rclsid,
; 3334 : 		_In_ REFIID riid,
; 3335 : 		_COM_Outptr_ LPVOID* ppv) throw()
; 3336 : 	{
; 3337 : 		return AtlComModuleGetClassObject(&_AtlComModule, rclsid, riid, ppv);
; 3338 : 	}
; 3339 : };
; 3340 : 
; 3341 : #endif // _ATL_STATIC_LIB_IMPL
; 3342 : 
; 3343 : #pragma managed(push, off)
; 3344 : 
; 3345 : #ifndef _ATL_STATIC_LIB_IMPL
; 3346 : 
; 3347 : template <class T>
; 3348 : inline BOOL WINAPI CAtlDllModuleT<T>::DllMain(
; 3349 : 	_In_ DWORD dwReason,
; 3350 : 	_In_opt_ LPVOID lpReserved) throw()
; 3351 : {
; 3352 : #if !defined(_ATL_NATIVE_INITIALIZATION)
; 3353 : 	UNREFERENCED_PARAMETER(dwReason); UNREFERENCED_PARAMETER(lpReserved);
; 3354 : #pragma warning(push)  // disable 4483
; 3355 : #pragma warning(disable:4483)
; 3356 : 	using namespace __identifier("<AtlImplementationDetails>");
; 3357 : #pragma warning(pop)  // disable 4483
; 3358 : 	if (dwReason == DLL_PROCESS_ATTACH)
; 3359 : 	{
; 3360 : 		ATLASSERT(DllModuleInitialized == false);
; 3361 : 	}
; 3362 : 	return TRUE;
; 3363 : #else
; 3364 : 	return _DllMain(dwReason, lpReserved);
; 3365 : #endif
; 3366 : }
; 3367 : 
; 3368 : #endif // _ATL_STATIC_LIB_IMPL
; 3369 : 
; 3370 : #pragma managed(pop)
; 3371 : 
; 3372 : #ifndef _AFX
; 3373 : 
; 3374 : #ifndef _ATL_STATIC_LIB_IMPL
; 3375 : 
; 3376 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 3377 : template <class T>
; 3378 : class ATL_NO_VTABLE CAtlExeModuleT : 
; 3379 : 	public CAtlModuleT<T>,
; 3380 : 	private CAtlValidateModuleConfiguration<false, T>
; 3381 : {
; 3382 : public :
; 3383 : #ifndef _ATL_NO_COM_SUPPORT
; 3384 : 
; 3385 : 	DWORD m_dwMainThreadID;
; 3386 : 	HANDLE m_hEventShutdown;
; 3387 : 	DWORD m_dwTimeOut;
; 3388 : 	DWORD m_dwPause;
; 3389 : 	bool m_bDelayShutdown;
; 3390 : 	bool m_bActivity;
; 3391 : 	bool m_bComInitialized;    // Flag that indicates if ATL initialized COM
; 3392 : 
; 3393 : #endif // _ATL_NO_COM_SUPPORT
; 3394 : 
; 3395 : 	CAtlExeModuleT() throw()
; 3396 : 
; 3397 : #ifndef _ATL_NO_COM_SUPPORT
; 3398 : 
; 3399 : 		: m_dwMainThreadID(::GetCurrentThreadId()),
; 3400 : 		m_dwTimeOut(5000),
; 3401 : 		m_dwPause(1000),
; 3402 : 		m_hEventShutdown(NULL),
; 3403 : 		m_bDelayShutdown(true),
; 3404 : 		m_bComInitialized(false)
; 3405 : 
; 3406 : #endif // _ATL_NO_COM_SUPPORT
; 3407 : 
; 3408 : 	{
; 3409 : #if !defined(_ATL_NO_COM_SUPPORT)
; 3410 : 
; 3411 : 		_AtlComModule.ExecuteObjectMain(true);
; 3412 : 
; 3413 : #endif	//  !defined(_ATL_NO_COM_SUPPORT)
; 3414 : 
; 3415 : 	}
; 3416 : 
; 3417 : 	~CAtlExeModuleT() throw()
; 3418 : 	{
; 3419 : #ifndef _ATL_NO_COM_SUPPORT
; 3420 : 
; 3421 : 		_AtlComModule.ExecuteObjectMain(false);
; 3422 : 
; 3423 : #endif
; 3424 : 
; 3425 : 		// Call term functions before COM is uninitialized
; 3426 : 		Term();
; 3427 : 
; 3428 : #ifndef _ATL_NO_COM_SUPPORT
; 3429 : 
; 3430 : 		// Clean up AtlComModule before COM is uninitialized
; 3431 : 		_AtlComModule.Term();
; 3432 : 
; 3433 : #endif // _ATL_NO_COM_SUPPORT
; 3434 : 	}
; 3435 : 
; 3436 : 	static HRESULT InitializeCom() throw()
; 3437 : 	{
; 3438 : #if defined(_ATL_FREE_THREADED)
; 3439 : 		return CoInitializeEx(NULL, COINIT_MULTITHREADED);
; 3440 : #else
; 3441 : 		return CoInitialize(NULL);
; 3442 : #endif
; 3443 : 	}
; 3444 : 
; 3445 : 	static void UninitializeCom() throw()
; 3446 : 	{
; 3447 : 		CoUninitialize();
; 3448 : 	}
; 3449 : 
; 3450 : 	LONG Lock() throw()
; 3451 : 	{
; 3452 : 		return CoAddRefServerProcess();
; 3453 : 	}
; 3454 : 
; 3455 : 	LONG Unlock() throw()
; 3456 : 	{
; 3457 : 		LONG lRet = CoReleaseServerProcess();
; 3458 : 
; 3459 : #ifndef _ATL_NO_COM_SUPPORT
; 3460 : 
; 3461 : 		if (lRet == 0)
; 3462 : 		{
; 3463 : 			if (m_bDelayShutdown)
; 3464 : 			{
; 3465 : 				m_bActivity = true;
; 3466 : 				::SetEvent(m_hEventShutdown); // tell monitor that we transitioned to zero
; 3467 : 			}
; 3468 : 			else
; 3469 : 			{
; 3470 : 				::PostThreadMessage(m_dwMainThreadID, WM_QUIT, 0, 0);
; 3471 : 			}
; 3472 : 		}
; 3473 : 
; 3474 : #endif	// _ATL_NO_COM_SUPPORT
; 3475 : 
; 3476 : 		return lRet;
; 3477 : 	}
; 3478 : #ifndef _ATL_NO_COM_SUPPORT
; 3479 : 
; 3480 : 	void MonitorShutdown() throw()
; 3481 : 	{
; 3482 : 		::WaitForSingleObject(m_hEventShutdown, INFINITE);
; 3483 : 		::CloseHandle(m_hEventShutdown);
; 3484 : 		m_hEventShutdown = NULL;
; 3485 : 		::PostThreadMessage(m_dwMainThreadID, WM_QUIT, 0, 0);
; 3486 : 	}
; 3487 : 
; 3488 : 	HANDLE StartMonitor() throw()
; 3489 : 	{
; 3490 : 		m_hEventShutdown = ::CreateEvent(NULL, false, false, NULL);
; 3491 : 		if (m_hEventShutdown == NULL)
; 3492 : 		{
; 3493 : 			return NULL;
; 3494 : 		}
; 3495 : 		DWORD dwThreadID;
; 3496 : 		HANDLE hThread = ::CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
; 3497 : 		if(hThread==NULL)
; 3498 : 		{
; 3499 : 			::CloseHandle(m_hEventShutdown);
; 3500 : 			m_hEventShutdown = NULL;
; 3501 : 		}
; 3502 : 		return hThread;
; 3503 : 	}
; 3504 : 
; 3505 : 	static DWORD WINAPI MonitorProc(_In_ void* pv) throw()
; 3506 : 	{
; 3507 : 		CAtlExeModuleT<T>* p = static_cast<CAtlExeModuleT<T>*>(pv);
; 3508 : 		p->MonitorShutdown();
; 3509 : 		return 0;
; 3510 : 	}
; 3511 : #endif	// _ATL_NO_COM_SUPPORT
; 3512 : 
; 3513 : 	int WinMain(_In_ int nShowCmd) throw()
; 3514 : 	{
; 3515 : 		if (CAtlBaseModule::m_bInitFailed)
; 3516 : 		{
; 3517 : 			ATLASSERT(0);
; 3518 : 			return -1;
; 3519 : 		}
; 3520 : 		T* pT = static_cast<T*>(this);
; 3521 : 		HRESULT hr = S_OK;
; 3522 : 
; 3523 : #if !defined(_ATL_NO_COM_SUPPORT)
; 3524 : 		hr = T::InitializeCom();
; 3525 : 		if (FAILED(hr))
; 3526 : 		{
; 3527 : 			// Ignore RPC_E_CHANGED_MODE if CLR is loaded. Error is due to CLR initializing
; 3528 : 			// COM and InitializeCOM trying to initialize COM with different flags.
; 3529 : 			if (hr != RPC_E_CHANGED_MODE || GetModuleHandle(_T("Mscoree.dll")) == NULL)
; 3530 : 			{
; 3531 : 				ATLASSERT(0);
; 3532 : 				return hr;
; 3533 : 			}
; 3534 : 		}
; 3535 : 		else
; 3536 : 		{
; 3537 : 			m_bComInitialized = true;
; 3538 : 		}
; 3539 : #endif	//  !defined(_ATL_NO_COM_SUPPORT)
; 3540 : 
; 3541 : 		LPTSTR lpCmdLine = GetCommandLine();
; 3542 : 		if (pT->ParseCommandLine(lpCmdLine, &hr) == true)
; 3543 : 			hr = pT->Run(nShowCmd);
; 3544 : 
; 3545 : #if defined(_DEBUG) && !defined(_ATL_NO_WIN_SUPPORT)
; 3546 : 		// Prevent false memory leak reporting. ~CAtlWinModule may be too late.
; 3547 : 		_AtlWinModule.Term();
; 3548 : #endif	// _DEBUG
; 3549 : 
; 3550 : #ifndef _ATL_NO_COM_SUPPORT
; 3551 : 		if (m_bComInitialized)
; 3552 : 			T::UninitializeCom();
; 3553 : #endif // _ATL_NO_COM_SUPPORT
; 3554 : 
; 3555 : 		return hr;
; 3556 : 	}
; 3557 : 
; 3558 : 	// Scan command line and perform registration
; 3559 : 	// Return value specifies if server should run
; 3560 : 
; 3561 : 	// Parses the command line and registers/unregisters the rgs file if necessary
; 3562 : 	bool ParseCommandLine(
; 3563 : 		_In_z_ LPCTSTR lpCmdLine,
; 3564 : 		_Out_ HRESULT* pnRetCode) throw()
; 3565 : 	{
; 3566 : 		*pnRetCode = S_OK;
; 3567 : 
; 3568 : 		TCHAR szTokens[] = _T("-/");
; 3569 : 
; 3570 : 		T* pT = static_cast<T*>(this);
; 3571 : 		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
; 3572 : 		while (lpszToken != NULL)
; 3573 : 		{
; 3574 : 			if (WordCmpI(lpszToken, _T("UnregServer"))==0)
; 3575 : 			{
; 3576 : 				*pnRetCode = pT->UnregisterServer(TRUE);
; 3577 : 				if (SUCCEEDED(*pnRetCode))
; 3578 : 					*pnRetCode = pT->UnregisterAppId();
; 3579 : 				return false;
; 3580 : 			}
; 3581 : 
; 3582 : 			if (WordCmpI(lpszToken, _T("RegServer"))==0)
; 3583 : 			{
; 3584 : 				*pnRetCode = pT->RegisterAppId();
; 3585 : 				if (SUCCEEDED(*pnRetCode))
; 3586 : 					*pnRetCode = pT->RegisterServer(TRUE);
; 3587 : 				return false;
; 3588 : 			}
; 3589 : 
; 3590 : 			if (WordCmpI(lpszToken, _T("UnregServerPerUser"))==0)
; 3591 : 			{
; 3592 : 				*pnRetCode = AtlSetPerUserRegistration(true);
; 3593 : 				if (FAILED(*pnRetCode))
; 3594 : 				{
; 3595 : 					return false;
; 3596 : 				}
; 3597 : 
; 3598 : 				*pnRetCode = pT->UnregisterServer(TRUE);
; 3599 : 				if (SUCCEEDED(*pnRetCode))
; 3600 : 					*pnRetCode = pT->UnregisterAppId();
; 3601 : 				return false;
; 3602 : 			}
; 3603 : 
; 3604 : 			if (WordCmpI(lpszToken, _T("RegServerPerUser"))==0)
; 3605 : 			{
; 3606 : 				*pnRetCode = AtlSetPerUserRegistration(true);
; 3607 : 				if (FAILED(*pnRetCode))
; 3608 : 				{
; 3609 : 					return false;
; 3610 : 				}
; 3611 : 
; 3612 : 				*pnRetCode = pT->RegisterAppId();
; 3613 : 				if (SUCCEEDED(*pnRetCode))
; 3614 : 					*pnRetCode = pT->RegisterServer(TRUE);
; 3615 : 				return false;
; 3616 : 			}
; 3617 : 
; 3618 : 			lpszToken = FindOneOf(lpszToken, szTokens);
; 3619 : 		}
; 3620 : 
; 3621 : 		return true;
; 3622 : 	}
; 3623 : 
; 3624 : 	HRESULT PreMessageLoop(_In_ int /*nShowCmd*/) throw()
; 3625 : 	{
; 3626 : 		HRESULT hr = S_OK;
; 3627 : 		T* pT = static_cast<T*>(this);
; 3628 : 		pT;
; 3629 : 
; 3630 : #ifndef _ATL_NO_COM_SUPPORT
; 3631 : 
; 3632 : 		// NOTE: much of this code is duplicated in CAtlServiceModuleT::PreMessageLoop below, so
; 3633 : 		// if you make changes to either method make sure to change both methods (if necessary).
; 3634 : 
; 3635 : 		hr = pT->RegisterClassObjects(CLSCTX_LOCAL_SERVER,
; 3636 : 			REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
; 3637 : 
; 3638 : 		if (FAILED(hr))
; 3639 : 			return hr;
; 3640 : 
; 3641 : 		if (hr == S_OK)
; 3642 : 		{
; 3643 : 			if (m_bDelayShutdown)
; 3644 : 			{
; 3645 : 				CHandle h(pT->StartMonitor());
; 3646 : 				if (h.m_h == NULL)
; 3647 : 				{
; 3648 : 					hr = E_FAIL;
; 3649 : 				}
; 3650 : 				else
; 3651 : 				{
; 3652 : 					hr = CoResumeClassObjects();
; 3653 : 					ATLASSERT(SUCCEEDED(hr));
; 3654 : 					if (FAILED(hr))
; 3655 : 					{
; 3656 : 						::SetEvent(m_hEventShutdown); // tell monitor to shutdown
; 3657 : 						::WaitForSingleObject(h, m_dwTimeOut * 2);
; 3658 : 					}
; 3659 : 				}
; 3660 : 			}
; 3661 : 			else
; 3662 : 			{
; 3663 : 				hr = CoResumeClassObjects();
; 3664 : 				ATLASSERT(SUCCEEDED(hr));
; 3665 : 			}
; 3666 : 
; 3667 : 			if (FAILED(hr))
; 3668 : 				pT->RevokeClassObjects();
; 3669 : 		}
; 3670 : 		else
; 3671 : 		{
; 3672 : 			m_bDelayShutdown = false;
; 3673 : 		}
; 3674 : 
; 3675 : #endif	// _ATL_NO_COM_SUPPORT
; 3676 : 
; 3677 : 		ATLASSERT(SUCCEEDED(hr));
; 3678 : 		return hr;
; 3679 : 	}
; 3680 : 
; 3681 : 	HRESULT PostMessageLoop() throw()
; 3682 : 	{
; 3683 : 		HRESULT hr = S_OK;
; 3684 : 
; 3685 : #ifndef _ATL_NO_COM_SUPPORT
; 3686 : 
; 3687 : 		T* pT = static_cast<T*>(this);
; 3688 : 		hr = pT->RevokeClassObjects();
; 3689 : 		if (m_bDelayShutdown)
; 3690 : 			Sleep(m_dwPause); //wait for any threads to finish
; 3691 : 
; 3692 : #endif	// _ATL_NO_COM_SUPPORT
; 3693 : 
; 3694 : 		return hr;
; 3695 : 	}
; 3696 : 
; 3697 : 	void RunMessageLoop() throw()
; 3698 : 	{
; 3699 : 		MSG msg;
; 3700 : 		while (GetMessage(&msg, 0, 0, 0) > 0)
; 3701 : 		{
; 3702 : 			TranslateMessage(&msg);
; 3703 : 			DispatchMessage(&msg);
; 3704 : 		}
; 3705 : 	}
; 3706 : 
; 3707 : 	HRESULT Run(_In_ int nShowCmd = SW_HIDE) throw()
; 3708 : 	{
; 3709 : 		HRESULT hr = S_OK;
; 3710 : 
; 3711 : 		T* pT = static_cast<T*>(this);
; 3712 : 		hr = pT->PreMessageLoop(nShowCmd);
; 3713 : 
; 3714 : 		// Call RunMessageLoop only if PreMessageLoop returns S_OK.
; 3715 : 		if (hr == S_OK)
; 3716 : 		{
; 3717 : 			pT->RunMessageLoop();
; 3718 : 		}
; 3719 : 
; 3720 : 		// Call PostMessageLoop if PreMessageLoop returns success.
; 3721 : 		if (SUCCEEDED(hr))
; 3722 : 		{
; 3723 : 			hr = pT->PostMessageLoop();
; 3724 : 		}
; 3725 : 
; 3726 : 		ATLASSERT(SUCCEEDED(hr));
; 3727 : 		return hr;
; 3728 : 	}
; 3729 : 
; 3730 : 	// Register/Revoke All Class Factories with the OS (EXE only)
; 3731 : 	HRESULT RegisterClassObjects(
; 3732 : 		_In_ DWORD dwClsContext,
; 3733 : 		_In_ DWORD dwFlags) throw()
; 3734 : 	{
; 3735 : 		return AtlComModuleRegisterClassObjects(&_AtlComModule, dwClsContext, dwFlags);
; 3736 : 	}
; 3737 : 	HRESULT RevokeClassObjects() throw()
; 3738 : 	{
; 3739 : 		return AtlComModuleRevokeClassObjects(&_AtlComModule);
; 3740 : 	}
; 3741 : };
; 3742 : 
; 3743 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 3744 : 
; 3745 : #ifndef _ATL_NO_SERVICE
; 3746 : template <class T, UINT nServiceNameID>
; 3747 : class ATL_NO_VTABLE CAtlServiceModuleT : 
; 3748 : 	public CAtlExeModuleT<T>
; 3749 : {
; 3750 : public :
; 3751 : 
; 3752 : 	CAtlServiceModuleT() throw()
; 3753 : 	{
; 3754 : 		m_bService = TRUE;
; 3755 : 		LoadString(_AtlBaseModule.GetModuleInstance(), nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));
; 3756 : 
; 3757 : 		// set up the initial service status
; 3758 : 		m_hServiceStatus = NULL;
; 3759 : 		m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
; 3760 : 		m_status.dwCurrentState = SERVICE_STOPPED;
; 3761 : 		m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
; 3762 : 		m_status.dwWin32ExitCode = 0;
; 3763 : 		m_status.dwServiceSpecificExitCode = 0;
; 3764 : 		m_status.dwCheckPoint = 0;
; 3765 : 		m_status.dwWaitHint = 0;
; 3766 : 	}
; 3767 : 
; 3768 : 	int WinMain(_In_ int nShowCmd) throw()
; 3769 : 	{
; 3770 : 		if (CAtlBaseModule::m_bInitFailed)
; 3771 : 		{
; 3772 : 			ATLASSERT(0);
; 3773 : 			return -1;
; 3774 : 		}
; 3775 : 
; 3776 : 		T* pT = static_cast<T*>(this);
; 3777 : 		HRESULT hr = S_OK;
; 3778 : 
; 3779 : 		LPTSTR lpCmdLine = GetCommandLine();
; 3780 : 		if (pT->ParseCommandLine(lpCmdLine, &hr) == true)
; 3781 : 			hr = pT->Start(nShowCmd);
; 3782 : 
; 3783 : #if defined(_DEBUG) && !defined(_ATL_NO_WIN_SUPPORT)
; 3784 : 		// Prevent false memory leak reporting. ~CAtlWinModule may be too late.
; 3785 : 		_AtlWinModule.Term();
; 3786 : #endif	// _DEBUG
; 3787 : 
; 3788 : #ifndef _ATL_NO_COM_SUPPORT
; 3789 : 		// COM must be uninitialized after Term method was called in local service scenario
; 3790 : 		if (!m_bService && m_bComInitialized)
; 3791 : 		{
; 3792 : 			T::UninitializeCom();
; 3793 : 		}
; 3794 : #endif // _ATL_NO_COM_SUPPORT
; 3795 : 
; 3796 : 		return hr;
; 3797 : 	}
; 3798 : 
; 3799 : 	HRESULT Start(_In_ int nShowCmd) throw()
; 3800 : 	{
; 3801 : 		T* pT = static_cast<T*>(this);
; 3802 : 		// Are we Service or Local Server
; 3803 : 		CRegKey keyAppID;
; 3804 : 		LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
; 3805 : 		if (lRes != ERROR_SUCCESS)
; 3806 : 		{
; 3807 : 			m_status.dwWin32ExitCode = lRes;
; 3808 : 			return m_status.dwWin32ExitCode;
; 3809 : 		}
; 3810 : 
; 3811 : 		CRegKey key;
; 3812 : 		lRes = key.Open(keyAppID, pT->GetAppIdT(), KEY_READ);
; 3813 : 		if (lRes != ERROR_SUCCESS)
; 3814 : 		{
; 3815 : 			m_status.dwWin32ExitCode = lRes;
; 3816 : 			return m_status.dwWin32ExitCode;
; 3817 : 		}
; 3818 : 
; 3819 : 		TCHAR szValue[MAX_PATH];
; 3820 : 		DWORD dwLen = MAX_PATH;
; 3821 : 		lRes = key.QueryStringValue(_T("LocalService"), szValue, &dwLen);
; 3822 : 
; 3823 : 		m_bService = FALSE;
; 3824 : 		if (lRes == ERROR_SUCCESS)
; 3825 : 			m_bService = TRUE;
; 3826 : 
; 3827 : 		if (m_bService)
; 3828 : 		{
; 3829 : 			SERVICE_TABLE_ENTRY st[] =
; 3830 : 			{
; 3831 : 				{ m_szServiceName, _ServiceMain },
; 3832 : 				{ NULL, NULL }
; 3833 : 			};
; 3834 : 			if (::StartServiceCtrlDispatcher(st) == 0)
; 3835 : 				m_status.dwWin32ExitCode = GetLastError();
; 3836 : 			return m_status.dwWin32ExitCode;
; 3837 : 		}
; 3838 : 		// local server - call Run() directly, rather than
; 3839 : 		// from ServiceMain()		
; 3840 : #ifndef _ATL_NO_COM_SUPPORT
; 3841 : 		HRESULT hr = T::InitializeCom();
; 3842 : 		if (FAILED(hr))
; 3843 : 		{
; 3844 : 			// Ignore RPC_E_CHANGED_MODE if CLR is loaded. Error is due to CLR initializing
; 3845 : 			// COM and InitializeCOM trying to initialize COM with different flags.
; 3846 : 			if (hr != RPC_E_CHANGED_MODE || GetModuleHandle(_T("Mscoree.dll")) == NULL)
; 3847 : 			{
; 3848 : 				return hr;
; 3849 : 			}
; 3850 : 		}
; 3851 : 		else
; 3852 : 		{
; 3853 : 			m_bComInitialized = true;
; 3854 : 		}
; 3855 : #endif //_ATL_NO_COM_SUPPORT
; 3856 : 
; 3857 : 		m_status.dwWin32ExitCode = pT->Run(nShowCmd);
; 3858 : 		return m_status.dwWin32ExitCode;
; 3859 : 	}
; 3860 : 
; 3861 : 	inline HRESULT RegisterAppId(_In_ bool bService = false) throw()
; 3862 : 	{
; 3863 : 		if (!Uninstall())
; 3864 : 			return E_FAIL;
; 3865 : 
; 3866 : 		HRESULT hr = T::UpdateRegistryAppId(TRUE);
; 3867 : 		if (FAILED(hr))
; 3868 : 			return hr;
; 3869 : 
; 3870 : 		CRegKey keyAppID;
; 3871 : 		LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
; 3872 : 		if (lRes != ERROR_SUCCESS)
; 3873 : 			return AtlHresultFromWin32(lRes);
; 3874 : 
; 3875 : 		CRegKey key;
; 3876 : 
; 3877 : 		lRes = key.Create(keyAppID, T::GetAppIdT());
; 3878 : 		if (lRes != ERROR_SUCCESS)
; 3879 : 			return AtlHresultFromWin32(lRes);
; 3880 : 
; 3881 : 		key.DeleteValue(_T("LocalService"));
; 3882 : 
; 3883 : 		if (!bService)
; 3884 : 			return S_OK;
; 3885 : 
; 3886 : 		key.SetStringValue(_T("LocalService"), m_szServiceName);
; 3887 : 
; 3888 : 		// Create service
; 3889 : 		if (!Install())
; 3890 : 			return E_FAIL;
; 3891 : 		return S_OK;
; 3892 : 	}
; 3893 : 
; 3894 : 	HRESULT UnregisterAppId() throw()
; 3895 : 	{
; 3896 : 		if (!Uninstall())
; 3897 : 			return E_FAIL;
; 3898 : 		// First remove entries not in the RGS file.
; 3899 : 		CRegKey keyAppID;
; 3900 : 		LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
; 3901 : 		if (lRes != ERROR_SUCCESS)
; 3902 : 			return AtlHresultFromWin32(lRes);
; 3903 : 
; 3904 : 		CRegKey key;
; 3905 : 		lRes = key.Open(keyAppID, T::GetAppIdT(), KEY_WRITE);
; 3906 : 		if (lRes != ERROR_SUCCESS)
; 3907 : 			return AtlHresultFromWin32(lRes);
; 3908 : 		key.DeleteValue(_T("LocalService"));
; 3909 : 
; 3910 : 		return T::UpdateRegistryAppId(FALSE);
; 3911 : 	}
; 3912 : 
; 3913 : 	// Parses the command line and registers/unregisters the rgs file if necessary
; 3914 : 	bool ParseCommandLine(
; 3915 : 		_In_z_ LPCTSTR lpCmdLine,
; 3916 : 		_Out_ HRESULT* pnRetCode) throw()
; 3917 : 	{
; 3918 : 		if (!CAtlExeModuleT<T>::ParseCommandLine(lpCmdLine, pnRetCode))
; 3919 : 			return false;
; 3920 : 
; 3921 : 		TCHAR szTokens[] = _T("-/");
; 3922 : 		*pnRetCode = S_OK;
; 3923 : 
; 3924 : 		T* pT = static_cast<T*>(this);
; 3925 : 		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
; 3926 : 		while (lpszToken != NULL)
; 3927 : 		{
; 3928 : 			if (WordCmpI(lpszToken, _T("Service"))==0)
; 3929 : 			{
; 3930 : 				*pnRetCode = pT->RegisterAppId(true);
; 3931 : 				if (SUCCEEDED(*pnRetCode))
; 3932 : 					*pnRetCode = pT->RegisterServer(TRUE);
; 3933 : 				return false;
; 3934 : 			}
; 3935 : 			lpszToken = FindOneOf(lpszToken, szTokens);
; 3936 : 		}
; 3937 : 		return true;
; 3938 : 	}
; 3939 : 
; 3940 : 	void ServiceMain(
; 3941 : 		_In_ DWORD dwArgc,
; 3942 : 		_In_reads_(dwArgc) _Deref_pre_z_ LPTSTR* lpszArgv) throw()
; 3943 : 	{
; 3944 : 		lpszArgv;
; 3945 : 		dwArgc;
; 3946 : 		// Register the control request handler
; 3947 : 		m_status.dwCurrentState = SERVICE_START_PENDING;
; 3948 : 		m_dwThreadID = GetCurrentThreadId();
; 3949 : 		m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
; 3950 : 		if (m_hServiceStatus == NULL)
; 3951 : 		{
; 3952 : 			LogEvent(_T("Handler not installed"));
; 3953 : 			return;
; 3954 : 		}
; 3955 : 		SetServiceStatus(SERVICE_START_PENDING);
; 3956 : 
; 3957 : 		m_status.dwWin32ExitCode = S_OK;
; 3958 : 		m_status.dwCheckPoint = 0;
; 3959 : 		m_status.dwWaitHint = 0;
; 3960 : 
; 3961 : 		T* pT = static_cast<T*>(this);
; 3962 : #ifndef _ATL_NO_COM_SUPPORT
; 3963 : 
; 3964 : 		HRESULT hr = E_FAIL;
; 3965 : 		hr = T::InitializeCom();
; 3966 : 		if (FAILED(hr))
; 3967 : 		{
; 3968 : 			// Ignore RPC_E_CHANGED_MODE if CLR is loaded. Error is due to CLR initializing
; 3969 : 			// COM and InitializeCOM trying to initialize COM with different flags.
; 3970 : 			if (hr != RPC_E_CHANGED_MODE || GetModuleHandle(_T("Mscoree.dll")) == NULL)
; 3971 : 			{
; 3972 : 				return;
; 3973 : 			}
; 3974 : 		}
; 3975 : 		else
; 3976 : 		{
; 3977 : 			m_bComInitialized = true;
; 3978 : 		}
; 3979 : 
; 3980 : 		m_bDelayShutdown = false;
; 3981 : #endif //_ATL_NO_COM_SUPPORT
; 3982 : 		// When the Run function returns, the service has stopped.
; 3983 : 		m_status.dwWin32ExitCode = pT->Run(SW_HIDE);
; 3984 : 
; 3985 : #ifndef _ATL_NO_COM_SUPPORT
; 3986 : 		if (m_bService && m_bComInitialized)
; 3987 : 			T::UninitializeCom();
; 3988 : #endif
; 3989 : 
; 3990 : 		SetServiceStatus(SERVICE_STOPPED);
; 3991 : 		LogEvent(_T("Service stopped"));
; 3992 : 	}
; 3993 : 
; 3994 : 	HRESULT Run(_In_ int nShowCmd = SW_HIDE) throw()
; 3995 : 	{
; 3996 : 		HRESULT hr = S_OK;
; 3997 : 		T* pT = static_cast<T*>(this);
; 3998 : 
; 3999 : 		hr = pT->PreMessageLoop(nShowCmd);
; 4000 : 
; 4001 : 		if (hr == S_OK)
; 4002 : 		{
; 4003 : 			pT->RunMessageLoop();
; 4004 : 		}
; 4005 : 
; 4006 : 		if (SUCCEEDED(hr))
; 4007 : 		{
; 4008 : 			hr = pT->PostMessageLoop();
; 4009 : 		}
; 4010 : 
; 4011 : 		return hr;
; 4012 : 	}
; 4013 : 
; 4014 : 	HRESULT PreMessageLoop(_In_ int nShowCmd) throw()
; 4015 : 	{
; 4016 : 		HRESULT hr = S_OK;
; 4017 : 		T* pT = static_cast<T*>(this);
; 4018 : 
; 4019 : 		if (m_bService)
; 4020 : 		{
; 4021 : #ifndef _ATL_NO_COM_SUPPORT
; 4022 : 			hr = pT->InitializeSecurity();
; 4023 : 
; 4024 : 			if (FAILED(hr))
; 4025 : 			{
; 4026 : 				return hr;
; 4027 : 			}
; 4028 : #endif	// _ATL_NO_COM_SUPPORT
; 4029 : 		}
; 4030 : 
; 4031 : #ifndef _ATL_NO_COM_SUPPORT
; 4032 : 
; 4033 : 		// NOTE: much of this code is duplicated in CAtlExeModuleT::PreMessageLoop above, so if
; 4034 : 		// you make changes to either method make sure to change both methods (if necessary).
; 4035 : 
; 4036 : 		hr = pT->RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
; 4037 : 		if (FAILED(hr))
; 4038 : 		{
; 4039 : 			return hr;
; 4040 : 		}
; 4041 : 
; 4042 : 		if (hr == S_OK)
; 4043 : 		{
; 4044 : 			if (m_bDelayShutdown)
; 4045 : 			{
; 4046 : 				CHandle h(pT->StartMonitor());
; 4047 : 				if (h.m_h == NULL)
; 4048 : 				{
; 4049 : 					hr = E_FAIL;
; 4050 : 				}
; 4051 : 				else
; 4052 : 				{
; 4053 : 					if (m_bService)
; 4054 : 					{
; 4055 : 						// Make sure that service was not stoped during initialization
; 4056 : 						if (::InterlockedCompareExchange(&m_status.dwCurrentState, SERVICE_RUNNING, SERVICE_START_PENDING) == SERVICE_START_PENDING)
; 4057 : 						{
; 4058 : 							LogEvent(_T("Service started/resumed"));
; 4059 : 							::SetServiceStatus(m_hServiceStatus, &m_status);
; 4060 : 						}
; 4061 : 					}
; 4062 : 
; 4063 : 					hr = CoResumeClassObjects();
; 4064 : 					ATLASSERT(SUCCEEDED(hr));
; 4065 : 					if (FAILED(hr))
; 4066 : 					{
; 4067 : 						::SetEvent(m_hEventShutdown); // tell monitor to shutdown
; 4068 : 						::WaitForSingleObject(h, m_dwTimeOut * 2);
; 4069 : 					}
; 4070 : 				}
; 4071 : 			}
; 4072 : 			else
; 4073 : 			{
; 4074 : 				if (m_bService)
; 4075 : 				{
; 4076 : 					// Make sure that service was not stoped during initialization
; 4077 : 					if (::InterlockedCompareExchange(&m_status.dwCurrentState, SERVICE_RUNNING, SERVICE_START_PENDING) == SERVICE_START_PENDING)
; 4078 : 					{
; 4079 : 						LogEvent(_T("Service started/resumed"));
; 4080 : 						::SetServiceStatus(m_hServiceStatus, &m_status);
; 4081 : 					}
; 4082 : 				}
; 4083 : 
; 4084 : 				hr = CoResumeClassObjects();
; 4085 : 				ATLASSERT(SUCCEEDED(hr));
; 4086 : 			}
; 4087 : 
; 4088 : 			if (FAILED(hr))
; 4089 : 				pT->RevokeClassObjects();
; 4090 : 		}
; 4091 : 		else
; 4092 : 		{
; 4093 : 			m_bDelayShutdown = false;
; 4094 : 		}
; 4095 : 
; 4096 : #else	// _ATL_NO_COM_SUPPORT
; 4097 : 
; 4098 : 		if (m_bService)
; 4099 : 		{
; 4100 : 			// Make sure that service was not stoped during initialization
; 4101 : 			if (::InterlockedCompareExchange(&m_status.dwCurrentState, SERVICE_RUNNING, SERVICE_START_PENDING) == SERVICE_START_PENDING)
; 4102 : 			{
; 4103 : 				LogEvent(_T("Service started/resumed"));
; 4104 : 				::SetServiceStatus(m_hServiceStatus, &m_status);
; 4105 : 			}
; 4106 : 		}
; 4107 : 
; 4108 : #endif	// _ATL_NO_COM_SUPPORT
; 4109 : 
; 4110 : 		ATLASSERT(SUCCEEDED(hr));
; 4111 : 		return hr;
; 4112 : 	}
; 4113 : 
; 4114 : 	void OnStop() throw()
; 4115 : 	{
; 4116 : 		SetServiceStatus(SERVICE_STOP_PENDING);
; 4117 : 		::PostThreadMessage(m_dwThreadID, WM_QUIT, 0, 0);
; 4118 : 	}
; 4119 : 
; 4120 : 	void OnPause() throw()
; 4121 : 	{
; 4122 : 	}
; 4123 : 
; 4124 : 	void OnContinue() throw()
; 4125 : 	{
; 4126 : 	}
; 4127 : 
; 4128 : 	void OnInterrogate() throw()
; 4129 : 	{
; 4130 : 	}
; 4131 : 
; 4132 : 	void OnShutdown() throw()
; 4133 : 	{
; 4134 : 	}
; 4135 : 
; 4136 : 	void OnUnknownRequest(_In_ DWORD /*dwOpcode*/) throw()
; 4137 : 	{
; 4138 : 		LogEvent(_T("Bad service request"));
; 4139 : 	}
; 4140 : 
; 4141 : 	void Handler(_In_ DWORD dwOpcode) throw()
; 4142 : 	{
; 4143 : 		T* pT = static_cast<T*>(this);
; 4144 : 
; 4145 : 		switch (dwOpcode)
; 4146 : 		{
; 4147 : 		case SERVICE_CONTROL_STOP:
; 4148 : 			pT->OnStop();
; 4149 : 			break;
; 4150 : 		case SERVICE_CONTROL_PAUSE:
; 4151 : 			pT->OnPause();
; 4152 : 			break;
; 4153 : 		case SERVICE_CONTROL_CONTINUE:
; 4154 : 			pT->OnContinue();
; 4155 : 			break;
; 4156 : 		case SERVICE_CONTROL_INTERROGATE:
; 4157 : 			pT->OnInterrogate();
; 4158 : 			break;
; 4159 : 		case SERVICE_CONTROL_SHUTDOWN:
; 4160 : 			pT->OnShutdown();
; 4161 : 			break;
; 4162 : 		default:
; 4163 : 			pT->OnUnknownRequest(dwOpcode);
; 4164 : 		}
; 4165 : 	}
; 4166 : 
; 4167 : 	BOOL IsInstalled() throw()
; 4168 : 	{
; 4169 : 		BOOL bResult = FALSE;
; 4170 : 
; 4171 : 		SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
; 4172 : 
; 4173 : 		if (hSCM != NULL)
; 4174 : 		{
; 4175 : 			SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
; 4176 : 			if (hService != NULL)
; 4177 : 			{
; 4178 : 				bResult = TRUE;
; 4179 : 				::CloseServiceHandle(hService);
; 4180 : 			}
; 4181 : 			::CloseServiceHandle(hSCM);
; 4182 : 		}
; 4183 : 		return bResult;
; 4184 : 	}
; 4185 : 	BOOL Install() throw()
; 4186 : 	{
; 4187 : 		if (IsInstalled())
; 4188 : 			return TRUE;
; 4189 : 
; 4190 : 		// Get the executable file path
; 4191 : 		TCHAR szFilePath[MAX_PATH + _ATL_QUOTES_SPACE];
; 4192 : 		DWORD dwFLen = ::GetModuleFileName(NULL, szFilePath + 1, MAX_PATH);
; 4193 : 		if( dwFLen == 0 || dwFLen == MAX_PATH )
; 4194 : 			return FALSE;
; 4195 : 
; 4196 : 		// Quote the FilePath before calling CreateService
; 4197 : 		szFilePath[0] = _T('\"');
; 4198 : 		szFilePath[dwFLen + 1] = _T('\"');
; 4199 : 		szFilePath[dwFLen + 2] = 0;
; 4200 : 
; 4201 : 		SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
; 4202 : 		if (hSCM == NULL)
; 4203 : 		{
; 4204 : 			TCHAR szBuf[1024];
; 4205 : 			if (AtlLoadString(ATL_SERVICE_MANAGER_OPEN_ERROR, szBuf, 1024) == 0)
; 4206 : #ifdef UNICODE
; 4207 : 				Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not open Service Manager"));
; 4208 : #else
; 4209 : 				Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not open Service Manager"));
; 4210 : #endif
; 4211 : 			MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
; 4212 : 			return FALSE;
; 4213 : 		}
; 4214 : 
; 4215 : 		SC_HANDLE hService = ::CreateService(
; 4216 : 			hSCM, m_szServiceName, m_szServiceName,
; 4217 : 			SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
; 4218 : 			SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
; 4219 : 			szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);
; 4220 : 
; 4221 : 		if (hService == NULL)
; 4222 : 		{
; 4223 : 			::CloseServiceHandle(hSCM);
; 4224 : 			TCHAR szBuf[1024];
; 4225 : 			if (AtlLoadString(ATL_SERVICE_START_ERROR, szBuf, 1024) == 0)
; 4226 : #ifdef UNICODE
; 4227 : 				Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not start service"));
; 4228 : #else
; 4229 : 				Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not start service"));
; 4230 : #endif
; 4231 : 			MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
; 4232 : 			return FALSE;
; 4233 : 		}
; 4234 : 
; 4235 : 		::CloseServiceHandle(hService);
; 4236 : 		::CloseServiceHandle(hSCM);
; 4237 : 		return TRUE;
; 4238 : 	}
; 4239 : 
; 4240 : 	BOOL Uninstall() throw()
; 4241 : 	{
; 4242 : 		if (!IsInstalled())
; 4243 : 			return TRUE;
; 4244 : 
; 4245 : 		SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
; 4246 : 
; 4247 : 		if (hSCM == NULL)
; 4248 : 		{
; 4249 : 			TCHAR szBuf[1024];
; 4250 : 			if (AtlLoadString(ATL_SERVICE_MANAGER_OPEN_ERROR, szBuf, 1024) == 0)
; 4251 : #ifdef UNICODE
; 4252 : 				Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not open Service Manager"));
; 4253 : #else
; 4254 : 				Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not open Service Manager"));
; 4255 : #endif
; 4256 : 			MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
; 4257 : 			return FALSE;
; 4258 : 		}
; 4259 : 
; 4260 : 		SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);
; 4261 : 
; 4262 : 		if (hService == NULL)
; 4263 : 		{
; 4264 : 			::CloseServiceHandle(hSCM);
; 4265 : 			TCHAR szBuf[1024];
; 4266 : 			if (AtlLoadString(ATL_SERVICE_OPEN_ERROR, szBuf, 1024) == 0)
; 4267 : #ifdef UNICODE
; 4268 : 				Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not open service"));
; 4269 : #else
; 4270 : 				Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not open service"));
; 4271 : #endif
; 4272 : 			MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
; 4273 : 			return FALSE;
; 4274 : 		}
; 4275 : 		SERVICE_STATUS status;
; 4276 : 		BOOL bRet = ::ControlService(hService, SERVICE_CONTROL_STOP, &status);
; 4277 : 		if (!bRet)
; 4278 : 		{
; 4279 : 			DWORD dwError = GetLastError();
; 4280 : 			if (!((dwError == ERROR_SERVICE_NOT_ACTIVE) ||  (dwError == ERROR_SERVICE_CANNOT_ACCEPT_CTRL && status.dwCurrentState == SERVICE_STOP_PENDING)))
; 4281 : 			{
; 4282 : 				TCHAR szBuf[1024];
; 4283 : 				if (AtlLoadString(ATL_SERVICE_STOP_ERROR, szBuf, 1024) == 0)
; 4284 : #ifdef UNICODE
; 4285 : 					Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not stop service"));
; 4286 : #else
; 4287 : 					Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not stop service"));
; 4288 : #endif
; 4289 : 				MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
; 4290 : 			}
; 4291 : 		}
; 4292 : 
; 4293 : 		BOOL bDelete = ::DeleteService(hService);
; 4294 : 		::CloseServiceHandle(hService);
; 4295 : 		::CloseServiceHandle(hSCM);
; 4296 : 
; 4297 : 		if (bDelete)
; 4298 : 			return TRUE;
; 4299 : 
; 4300 : 		TCHAR szBuf[1024];
; 4301 : 		if (AtlLoadString(ATL_SERVICE_DELETE_ERROR, szBuf, 1024) == 0)
; 4302 : #ifdef UNICODE
; 4303 : 			Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not delete service"));
; 4304 : #else
; 4305 : 			Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not delete service"));
; 4306 : #endif
; 4307 : 		MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
; 4308 : 		return FALSE;
; 4309 : 	}
; 4310 : 
; 4311 : 	LONG Unlock() throw()
; 4312 : 	{
; 4313 : 		LONG lRet;
; 4314 : 		if (m_bService)
; 4315 : 		{
; 4316 : 			// We are running as a service, therefore transition to zero does not
; 4317 : 			// unload the process
; 4318 : 			lRet = CAtlModuleT<T>::Unlock();
; 4319 : 		}
; 4320 : 		else
; 4321 : 		{
; 4322 : 			// We are running as EXE, use MonitorShutdown logic provided by CExeModule
; 4323 : 			lRet = CAtlExeModuleT<T>::Unlock();
; 4324 : 		}
; 4325 : 		return lRet;
; 4326 : 	}
; 4327 : 
; 4328 : 	void LogEventEx(
; 4329 : 		_In_ int id,
; 4330 : 		_In_opt_z_ LPCTSTR pszMessage=NULL,
; 4331 : 		_In_ WORD type = EVENTLOG_INFORMATION_TYPE) throw()
; 4332 : 	{
; 4333 : 		/* Get a handle to use with ReportEvent(). */
; 4334 : 		HANDLE hEventSource = RegisterEventSource(NULL, m_szServiceName);
; 4335 : 		if (hEventSource != NULL)
; 4336 : 		{
; 4337 : 			/* Write to event log. */
; 4338 : 			ReportEvent(hEventSource,
; 4339 : 						type,
; 4340 : 						(WORD)0,
; 4341 : 						id,
; 4342 : 						NULL,
; 4343 : 						(WORD)(pszMessage != NULL ? 1 : 0),
; 4344 : 						0,
; 4345 : 						pszMessage != NULL ? &pszMessage : NULL,
; 4346 : 						NULL);
; 4347 : 			DeregisterEventSource(hEventSource);
; 4348 : 		}
; 4349 : 	}
; 4350 : 
; 4351 : #pragma warning(push)  // disable 4793
; 4352 : #pragma warning(disable : 4793)
; 4353 : 	void __cdecl LogEvent(
; 4354 : 		_In_z_ _Printf_format_string_ LPCTSTR pszFormat, ...) throw()
; 4355 : 	{
; 4356 : 		const int LOG_EVENT_MSG_SIZE = 256;
; 4357 : 
; 4358 : 		TCHAR chMsg[LOG_EVENT_MSG_SIZE];
; 4359 : 		HANDLE hEventSource;
; 4360 : 		LPTSTR lpszStrings[1];
; 4361 : 		va_list pArg;
; 4362 : 
; 4363 : 		va_start(pArg, pszFormat);
; 4364 : 		_vsntprintf_s(chMsg, LOG_EVENT_MSG_SIZE, LOG_EVENT_MSG_SIZE-1, pszFormat, pArg);
; 4365 : 		va_end(pArg);
; 4366 : 
; 4367 : 		chMsg[LOG_EVENT_MSG_SIZE - 1] = 0;
; 4368 : 
; 4369 : 		lpszStrings[0] = chMsg;
; 4370 : 
; 4371 : 		if (!m_bService)
; 4372 : 		{
; 4373 : 			// Not running as a service, so print out the error message
; 4374 : 			// to the console if possible
; 4375 : 			_putts(chMsg);
; 4376 : 		}
; 4377 : 
; 4378 : 		/* Get a handle to use with ReportEvent(). */
; 4379 : 		hEventSource = RegisterEventSource(NULL, m_szServiceName);
; 4380 : 		if (hEventSource != NULL)
; 4381 : 		{
; 4382 : 			/* Write to event log. */
; 4383 : 			ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
; 4384 : 			DeregisterEventSource(hEventSource);
; 4385 : 		}
; 4386 : 	}
; 4387 : #pragma warning(pop)  // disable 4793
; 4388 : 
; 4389 : 	void SetServiceStatus(_In_ DWORD dwState) throw()
; 4390 : 	{
; 4391 : 		::InterlockedExchange(&m_status.dwCurrentState, dwState);
; 4392 : 		::SetServiceStatus(m_hServiceStatus, &m_status);
; 4393 : 	}
; 4394 : 
; 4395 : //Implementation
; 4396 : protected:
; 4397 : 	static void WINAPI _ServiceMain(
; 4398 : 		_In_ DWORD dwArgc,
; 4399 : 		_In_reads_(dwArgc) _Deref_pre_z_ LPTSTR* lpszArgv) throw()
; 4400 : 	{
; 4401 : 		((T*)_pAtlModule)->ServiceMain(dwArgc, lpszArgv);
; 4402 : 	}
; 4403 : 	static void WINAPI _Handler(_In_ DWORD dwOpcode) throw()
; 4404 : 	{
; 4405 : 		((T*)_pAtlModule)->Handler(dwOpcode);
; 4406 : 	}
; 4407 : 
; 4408 : // data members
; 4409 : public:
; 4410 : 	TCHAR m_szServiceName[256];
; 4411 : 	SERVICE_STATUS_HANDLE m_hServiceStatus;
; 4412 : 	SERVICE_STATUS m_status;
; 4413 : 	BOOL m_bService;
; 4414 : 	DWORD m_dwThreadID;
; 4415 : };
; 4416 : 
; 4417 : #endif //	_ATL_NO_SERVICE
; 4418 : 
; 4419 : #endif // _ATL_STATIC_LIB_IMPL
; 4420 : 
; 4421 : #endif	// !_AFX
; 4422 : 
; 4423 : #ifdef _AFX
; 4424 : 
; 4425 : class CAtlMfcModule : 
; 4426 : 	public ATL::CAtlModuleT<CAtlMfcModule>
; 4427 : {
; 4428 : public :
; 4429 : 	virtual LONG Lock() throw()
; 4430 : 	{
; 4431 : #ifdef _USRDLL
; 4432 : 		AFX_MANAGE_STATE(AfxGetStaticModuleState());
; 4433 : #endif
; 4434 : 		AfxOleLockApp();
; 4435 : 		return AfxGetModuleState()->m_nObjectCount;
; 4436 : 	}
; 4437 : 
; 4438 : 	virtual LONG Unlock() throw()
; 4439 : 	{
; 4440 : #ifdef _USRDLL
; 4441 : 		AFX_MANAGE_STATE(AfxGetStaticModuleState());
; 4442 : #endif
; 4443 : 		AfxOleUnlockApp();
; 4444 : 		return AfxGetModuleState()->m_nObjectCount;
; 4445 : 	}
; 4446 : 
; 4447 : 	virtual LONG GetLockCount() throw()
; 4448 : 	{
; 4449 : #ifdef _USRDLL
; 4450 : 		AFX_MANAGE_STATE(AfxGetStaticModuleState());
; 4451 : #endif
; 4452 : 		return AfxGetModuleState()->m_nObjectCount;
; 4453 : 	}
; 4454 : 
; 4455 : 	// Obtain a Class Factory (DLL only)
; 4456 : 	HRESULT GetClassObject(
; 4457 : 		_In_ REFCLSID rclsid,
; 4458 : 		_In_ REFIID riid,
; 4459 : 		_COM_Outptr_ LPVOID* ppv)
; 4460 : 	{
; 4461 : 		return ATL::AtlComModuleGetClassObject(&ATL::_AtlComModule, rclsid, riid, ppv);
; 4462 : 	}
; 4463 : 
; 4464 : 	// Register/Revoke All Class Factories with the OS (EXE only)
; 4465 : 	HRESULT RegisterClassObjects(
; 4466 : 		_In_ DWORD dwClsContext,
; 4467 : 		_In_ DWORD dwFlags)
; 4468 : 	{
; 4469 : 		return ATL::AtlComModuleRegisterClassObjects(&ATL::_AtlComModule, dwClsContext, dwFlags);
; 4470 : 	}
; 4471 : 
; 4472 : 	HRESULT RevokeClassObjects()
; 4473 : 	{
; 4474 : 		return ATL::AtlComModuleRevokeClassObjects(&ATL::_AtlComModule);
; 4475 : 	}
; 4476 : };
; 4477 : 
; 4478 : #endif //	_AFX
; 4479 : 
; 4480 : /////////////////////////////////////////////////////////////////////////////
; 4481 : // CComModule - Uses the functionality provided by other modules
; 4482 : 
; 4483 : #define THREADFLAGS_APARTMENT 0x1
; 4484 : #define THREADFLAGS_BOTH 0x2
; 4485 : #define AUTPRXFLAG 0x4
; 4486 : 
; 4487 : #ifndef _ATL_NO_COMMODULE
; 4488 : 
; 4489 : class CComModule;
; 4490 : 
; 4491 : #if !defined(_ATL_NATIVE_INITIALIZATION)
; 4492 : 
; 4493 : #pragma managed(push, off)
; 4494 : 
; 4495 : #pragma warning(push)  // disable 4483
; 4496 : #pragma warning(disable:4483)
; 4497 : namespace __identifier("<AtlImplementationDetails>")
; 4498 : #pragma warning(pop)  // disable 4483
; 4499 : {
; 4500 : 	struct CComModuleHelper
; 4501 : 	{
; 4502 : 		CComModule* Module;
; 4503 : 		HINSTANCE Instance;
; 4504 : 		_ATL_OBJMAP_ENTRY* ObjectMap;		
; 4505 : 		const GUID* LibraryId;
; 4506 : 
; 4507 : 		// Must NOT have any constructors
; 4508 : 		// We initialize the object in DllMain *before*
; 4509 : 		// the constructors would run.
; 4510 : 
; 4511 : 		void Initialize(
; 4512 : 			_In_ CComModule* pModule,
; 4513 : 			_In_ HINSTANCE hInstance,
; 4514 : 			_In_ _ATL_OBJMAP_ENTRY* pObjMap,
; 4515 : 			_In_ const GUID* pLibID)
; 4516 : 		{
; 4517 : 			Module = pModule;
; 4518 : 			Instance = hInstance;
; 4519 : 			ObjectMap = pObjMap;
; 4520 : 			LibraryId = pLibID;
; 4521 : 		}
; 4522 : 	};
; 4523 : 
; 4524 : 	__declspec(selectany) CComModuleHelper ComModuleHelper;
; 4525 : 	__declspec(selectany) bool ComModuleInitialized = false;
; 4526 : }
; 4527 : 
; 4528 : #pragma managed(pop)
; 4529 : 
; 4530 : #endif
; 4531 : 
; 4532 : 
; 4533 : __declspec(selectany) CComModule* _pModule = NULL;
; 4534 : class CComModule : 
; 4535 : 	public CAtlModuleT<CComModule>
; 4536 : {
; 4537 : public :
; 4538 : 
; 4539 : 	CComModule()
; 4540 : 	{
; 4541 : 		// Should have only one instance of a class
; 4542 : 		// derived from CComModule in a project.
; 4543 : 		ATLASSERT(_pModule == NULL);
; 4544 : 		_pModule = this;
; 4545 : #if !defined(_ATL_NATIVE_INITIALIZATION)
; 4546 : #pragma warning(push)  // disable 4483
; 4547 : #pragma warning(disable:4483)
; 4548 : 		using namespace __identifier("<AtlImplementationDetails>");
; 4549 : #pragma warning(pop)  // disable 4483
; 4550 : 		ATLASSERT(ComModuleInitialized == false);
; 4551 : 		// If ComModuleHelper.Module == NULL it mean that DllMain has not been called, so we assume CComModule lives in
; 4552 : 		// an exe and not in a dll
; 4553 : 		if (ComModuleHelper.Module != NULL)
; 4554 : 		{
; 4555 : 			ATLASSERT(ComModuleHelper.Module == this);
; 4556 : 			_DllMain(ComModuleHelper.Instance, DLL_PROCESS_ATTACH, NULL, ComModuleHelper.ObjectMap, ComModuleHelper.LibraryId);
; 4557 : 		}
; 4558 : 		ComModuleInitialized = true;
; 4559 : #endif
; 4560 : 	}
; 4561 : 
; 4562 : 	~CComModule()
; 4563 : 	{
; 4564 : #if !defined(_ATL_NATIVE_INITIALIZATION)
; 4565 : #pragma warning(push)  // disable 4483
; 4566 : #pragma warning(disable:4483)
; 4567 : 		using namespace __identifier("<AtlImplementationDetails>");
; 4568 : #pragma warning(pop)  // disable 4483
; 4569 : 		ATLASSERT(ComModuleInitialized == true);
; 4570 : 		// If ComModuleHelper.Module == NULL it mean that DllMain has not been called, so we assume CComModule lives in
; 4571 : 		// an exe and not in a dll
; 4572 : 		if (ComModuleHelper.Module != NULL)
; 4573 : 		{
; 4574 : 			ATLASSERT(ComModuleHelper.Module == this);
; 4575 : 			_DllMain(ComModuleHelper.Instance, DLL_PROCESS_DETACH, NULL, ComModuleHelper.ObjectMap, ComModuleHelper.LibraryId);
; 4576 : 		}
; 4577 : #endif
; 4578 : 	}
; 4579 : 
; 4580 : 	__declspec(property(get = get_m_hInst)) HINSTANCE m_hInst;
; 4581 : 	HINSTANCE& get_m_hInst() const throw()
; 4582 : 	{
; 4583 : 		return _AtlBaseModule.m_hInst;
; 4584 : 	}
; 4585 : 
; 4586 : 	__declspec(property(get = get_m_hInstResource, put = put_m_hInstResource)) HINSTANCE m_hInstResource;
; 4587 : 	HINSTANCE& get_m_hInstResource() const throw()
; 4588 : 	{
; 4589 : 		return _AtlBaseModule.m_hInstResource;
; 4590 : 	}
; 4591 : 	void put_m_hInstResource(_In_ HINSTANCE h) throw()
; 4592 : 	{
; 4593 : 		_AtlBaseModule.SetResourceInstance(h);
; 4594 : 	}
; 4595 : 	HINSTANCE SetResourceInstance(_In_ HINSTANCE h) throw()
; 4596 : 	{
; 4597 : 		return _AtlBaseModule.SetResourceInstance(h);
; 4598 : 	}
; 4599 : 
; 4600 : 	HINSTANCE GetModuleInstance() throw()
; 4601 : 	{
; 4602 : 		return _AtlBaseModule.m_hInst;
; 4603 : 	}
; 4604 : 	HINSTANCE GetResourceInstance() throw()
; 4605 : 	{
; 4606 : 		return _AtlBaseModule.m_hInstResource;
; 4607 : 	}
; 4608 : 
; 4609 : 	__declspec(property(get = get_m_hInstTypeLib, put = put_m_hInstTypeLib)) HINSTANCE m_hInstTypeLib;
; 4610 : 	HINSTANCE& get_m_hInstTypeLib() const throw()
; 4611 : 	{
; 4612 : 		return _AtlComModule.m_hInstTypeLib;
; 4613 : 	}
; 4614 : 	void put_m_hInstTypeLib(_In_ HINSTANCE h) throw()
; 4615 : 	{
; 4616 : 		_AtlComModule.m_hInstTypeLib = h;
; 4617 : 	}
; 4618 : 
; 4619 : 	HINSTANCE GetTypeLibInstance() const throw()
; 4620 : 	{
; 4621 : 		return _AtlComModule.m_hInstTypeLib;
; 4622 : 	}
; 4623 : 
; 4624 : 	// For Backward compatibility
; 4625 : 	_ATL_OBJMAP_ENTRY* m_pObjMap;
; 4626 : 
; 4627 : #ifndef _ATL_NO_WIN_SUPPORT
; 4628 : 	__declspec(property(get  = get_m_csWindowCreate)) CRITICAL_SECTION m_csWindowCreate;
; 4629 : 	CRITICAL_SECTION& get_m_csWindowCreate() throw();
; 4630 : 
; 4631 : 		__declspec(property(get  = get_m_pCreateWndList, put = put_m_pCreateWndList)) _AtlCreateWndData* m_pCreateWndList;
; 4632 : 	_AtlCreateWndData*& get_m_pCreateWndList() throw();
; 4633 : 	void put_m_pCreateWndList(_In_ _AtlCreateWndData* p) throw();
; 4634 : #endif // _ATL_NO_WIN_SUPPORT
; 4635 : 
; 4636 : 	__declspec(property(get  = get_m_csObjMap)) CRITICAL_SECTION m_csObjMap;
; 4637 : 	CRITICAL_SECTION& get_m_csObjMap() throw();
; 4638 : 
; 4639 : 	__declspec(property(get  = get_m_csStaticDataInit)) CRITICAL_SECTION m_csTypeInfoHolder;
; 4640 : 	__declspec(property(get  = get_m_csStaticDataInit)) CRITICAL_SECTION m_csStaticDataInit;
; 4641 : 	CRITICAL_SECTION& get_m_csStaticDataInit() throw();
; 4642 : 	void EnterStaticDataCriticalSection() throw()
; 4643 : 	{
; 4644 : 		EnterCriticalSection(&m_csStaticDataInit);
; 4645 : 	}
; 4646 : 
; 4647 : 	void LeaveStaticDataCriticalSection() throw()
; 4648 : 	{
; 4649 : 		LeaveCriticalSection(&m_csStaticDataInit);
; 4650 : 	}
; 4651 : 
; 4652 : 	__declspec(property(get  = get_dwAtlBuildVer)) DWORD dwAtlBuildVer;
; 4653 : 	DWORD& get_dwAtlBuildVer() throw()
; 4654 : 	{
; 4655 : 		return _AtlBaseModule.dwAtlBuildVer;
; 4656 : 	}
; 4657 : 
; 4658 : 	__declspec(property(get  = get_pguidVer)) const GUID* pguidVer;
; 4659 : 	const GUID*& get_pguidVer() throw()
; 4660 : 	{
; 4661 : 		return _AtlBaseModule.pguidVer;
; 4662 : 	}
; 4663 : 
; 4664 : #ifdef _ATL_DEBUG_INTERFACES
; 4665 : 
; 4666 : 	__declspec(property(get  = get_m_nIndexQI, put = put_m_nIndexQI)) UINT m_nIndexQI;
; 4667 : 	UINT& get_m_nIndexQI() throw();
; 4668 : 	void put_m_nIndexQI(_In_ UINT nIndex) throw();
; 4669 : 
; 4670 : 	__declspec(property(get  = get_m_nIndexBreakAt, put = put_m_nIndexBreakAt)) UINT m_nIndexBreakAt;
; 4671 : 	UINT& get_m_nIndexBreakAt() throw();
; 4672 : 	void put_m_nIndexBreakAt(_In_ UINT nIndex) throw();
; 4673 : 
; 4674 : 	__declspec(property(get  = get_m_paThunks)) CSimpleArray<_QIThunk*>* m_paThunks;
; 4675 : 	CSimpleArray<_QIThunk*>* get_m_paThunks() throw();
; 4676 : 	HRESULT AddThunk(
; 4677 : 		_Inout_ _Deref_pre_valid_ _Deref_post_valid_ IUnknown** pp,
; 4678 : 		_In_z_ LPCTSTR lpsz,
; 4679 : 		_In_ REFIID iid) throw();
; 4680 : 
; 4681 : 	HRESULT AddNonAddRefThunk(
; 4682 : 		_Inout_ IUnknown* p,
; 4683 : 		_In_z_ LPCTSTR lpsz,
; 4684 : 		_Outptr_ IUnknown** ppThunkRet) throw();
; 4685 : 
; 4686 : 	void DeleteNonAddRefThunk(_In_ IUnknown* pUnk) throw();
; 4687 : 	void DeleteThunk(_In_ _QIThunk* p) throw();
; 4688 : 	bool DumpLeakedThunks() throw();
; 4689 : #endif // _ATL_DEBUG_INTERFACES
; 4690 : 
; 4691 : 	HRESULT Init(
; 4692 : 		_In_ _ATL_OBJMAP_ENTRY* p,
; 4693 : 		_In_ HINSTANCE h,
; 4694 : 		_In_opt_ const GUID* plibid = NULL) throw();
; 4695 : 
; 4696 : 	void Term() throw();
; 4697 : 
; 4698 : 	HRESULT GetClassObject(
; 4699 : 		_In_ REFCLSID rclsid,
; 4700 : 		_In_ REFIID riid,
; 4701 : 		_COM_Outptr_ LPVOID* ppv) throw();
; 4702 : 
; 4703 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 4704 : 	// Register/Revoke All Class Factories with the OS (EXE only)
; 4705 : 	HRESULT RegisterClassObjects(_In_ DWORD dwClsContext, _In_ DWORD dwFlags) throw();
; 4706 : 	HRESULT RevokeClassObjects() throw();	
; 4707 : 
; 4708 : 	// Registry support (helpers)
; 4709 : 	HRESULT RegisterTypeLib() throw();
; 4710 : 	HRESULT RegisterTypeLib(_In_z_ LPCTSTR lpszIndex) throw();	
; 4711 : 	HRESULT UnRegisterTypeLib() throw();
; 4712 : 	HRESULT UnRegisterTypeLib(_In_z_ LPCTSTR lpszIndex) throw();
; 4713 : 
; 4714 : 	HRESULT RegisterServer(
; 4715 : 		_In_ BOOL bRegTypeLib = FALSE,
; 4716 : 		_In_opt_ const CLSID* pCLSID = NULL) throw();
; 4717 : 	HRESULT UnregisterServer(
; 4718 : 		_In_ BOOL bUnRegTypeLib,
; 4719 : 		_In_opt_ const CLSID* pCLSID = NULL) throw();
; 4720 : 	HRESULT UnregisterServer(_In_opt_ const CLSID* pCLSID = NULL) throw();
; 4721 : 
; 4722 : 	HRESULT RegisterAppId(_In_z_ LPCTSTR pAppId);
; 4723 : 	HRESULT UnregisterAppId(_In_z_ LPCTSTR pAppId);
; 4724 : 
; 4725 : 	// Resource-based Registration
; 4726 : 	virtual HRESULT WINAPI UpdateRegistryFromResourceD(
; 4727 : 		_In_opt_z_ LPCTSTR lpszRes,
; 4728 : 		_In_ BOOL bRegister,
; 4729 : 		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
; 4730 : 	{
; 4731 : 		(lpszRes);
; 4732 : 		(bRegister);
; 4733 : 		(pMapEntries);
; 4734 : 		return E_FAIL;
; 4735 : 	}
; 4736 : 	
; 4737 : 	virtual HRESULT WINAPI UpdateRegistryFromResourceD(
; 4738 : 		_In_ UINT nResID,
; 4739 : 		_In_ BOOL bRegister,
; 4740 : 		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
; 4741 : 	{
; 4742 : 		(nResID);
; 4743 : 		(bRegister);
; 4744 : 		(pMapEntries);
; 4745 : 		return E_FAIL;
; 4746 : 	}
; 4747 : 
; 4748 : 	virtual HRESULT WINAPI UpdateRegistryFromResource(
; 4749 : 		_In_z_ LPCTSTR lpszRes,
; 4750 : 		_In_ BOOL bRegister,
; 4751 : 		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
; 4752 : 	{
; 4753 : 		return CAtlModuleT<CComModule>::UpdateRegistryFromResource(lpszRes, bRegister, pMapEntries);
; 4754 : 	}
; 4755 : 	virtual HRESULT WINAPI UpdateRegistryFromResource(
; 4756 : 		_In_ UINT nResID,
; 4757 : 		_In_ BOOL bRegister,
; 4758 : 		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
; 4759 : 	{
; 4760 : 		return CAtlModuleT<CComModule>::UpdateRegistryFromResource(nResID, bRegister, pMapEntries);
; 4761 : 	}
; 4762 : 
; 4763 : 	HRESULT DllRegisterServer(_In_ BOOL bRegTypeLib = TRUE)  throw()
; 4764 : 	{
; 4765 : 		// registers object, typelib and all interfaces in typelib
; 4766 : 		return RegisterServer(bRegTypeLib);
; 4767 : 	}
; 4768 : 
; 4769 : 	HRESULT DllUnregisterServer(_In_ BOOL bUnRegTypeLib = TRUE)  throw()
; 4770 : 	{
; 4771 : 		return UnregisterServer(bUnRegTypeLib);
; 4772 : 	}
; 4773 : 
; 4774 : 	// Use RGS file for registration
; 4775 : 
; 4776 : 	ATL_DEPRECATED("CComModule::RegisterProgID is no longer recommended. Instead, use an RGS file for registration.")
; 4777 : 	static HRESULT RegisterProgID(
; 4778 : 		_In_z_ LPCTSTR lpszCLSID,
; 4779 : 		_In_z_ LPCTSTR lpszProgID,
; 4780 : 		_In_z_ LPCTSTR lpszUserDesc);
; 4781 : 
; 4782 : 	ATL_DEPRECATED("CComModule::RegisterVersionIndependentProgID is no longer recommended. Instead, use an RGS file for registration.")
; 4783 : 	static HRESULT RegisterVersionIndependentProgID(
; 4784 : 		_In_z_ LPCTSTR lpszCLSID,
; 4785 : 		_In_z_ LPCTSTR lpszVerIndProgID,
; 4786 : 		_In_z_ LPCTSTR lpszCurVerProgID,
; 4787 : 		_In_z_ LPCTSTR lpszUserDesc);
; 4788 : 
; 4789 : 	// Standard Registration
; 4790 : 	ATL_DEPRECATED("CComModule::UpdateRegistryClass is no longer recommended. Instead, use an RGS file for registration.")
; 4791 : 	HRESULT WINAPI UpdateRegistryClass(
; 4792 : 		_In_ const CLSID& clsid,
; 4793 : 		_In_opt_z_ LPCTSTR lpszProgID,
; 4794 : 		_In_opt_z_ LPCTSTR lpszVerIndProgID,
; 4795 : 		_In_ UINT nDescID,
; 4796 : 		_In_ DWORD dwFlags,
; 4797 : 		_In_ BOOL bRegister);
; 4798 : 
; 4799 : 	ATL_DEPRECATED("CComModule::UpdateRegistryClass is no longer recommended. Instead, use an RGS file for registration.")
; 4800 : 	HRESULT WINAPI UpdateRegistryClass(
; 4801 : 		_In_ const CLSID& clsid,
; 4802 : 		_In_opt_z_ LPCTSTR lpszProgID,
; 4803 : 		_In_opt_z_ LPCTSTR lpszVerIndProgID,
; 4804 : 		_In_z_ LPCTSTR szDesc,
; 4805 : 		_In_ DWORD dwFlags,
; 4806 : 		_In_ BOOL bRegister);
; 4807 : 
; 4808 : 	ATL_DEPRECATED("CComModule::RegisterClassHelper is no longer recommended. Instead, use an RGS file for registration.")
; 4809 : 	HRESULT WINAPI RegisterClassHelper(
; 4810 : 		_In_ const CLSID& clsid,
; 4811 : 		_In_opt_z_ LPCTSTR lpszProgID,
; 4812 : 		_In_opt_z_ LPCTSTR lpszVerIndProgID,
; 4813 : 		_In_z_ LPCTSTR szDesc,
; 4814 : 		_In_ DWORD dwFlags);
; 4815 : 
; 4816 : 	ATL_DEPRECATED("CComModule::UnregisterClassHelper is no longer recommended. Instead, use an RGS file for registration.")
; 4817 : 	HRESULT WINAPI UnregisterClassHelper(
; 4818 : 		_In_ const CLSID& clsid,
; 4819 : 		_In_opt_z_ LPCTSTR lpszProgID,
; 4820 : 		_In_opt_z_ LPCTSTR lpszVerIndProgID);
; 4821 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 4822 : 
; 4823 : #ifndef _ATL_NO_WIN_SUPPORT
; 4824 : 	void AddCreateWndData(
; 4825 : 		_In_ _AtlCreateWndData* pData,
; 4826 : 		_In_ void* pObject) throw()
; 4827 : 	{
; 4828 : 		_AtlWinModule.AddCreateWndData(pData, pObject);
; 4829 : 	}
; 4830 : 
; 4831 : 	void* ExtractCreateWndData() throw()
; 4832 : 	{
; 4833 : 		return _AtlWinModule.ExtractCreateWndData();
; 4834 : 	}
; 4835 : #endif // _ATL_NO_WIN_SUPPORT
; 4836 : 
; 4837 : 	// Only used in CComAutoThreadModule
; 4838 : 	HRESULT CreateInstance(
; 4839 : 		_In_opt_ void* /*pfnCreateInstance*/,
; 4840 : 		_In_ REFIID /*riid*/,
; 4841 : 		_COM_Outptr_ void** /*ppvObj*/) throw()
; 4842 : 	{
; 4843 : 		ATLASSERT(0);
; 4844 : 		_Analysis_assume_(FALSE);
; 4845 : 		ATLTRACENOTIMPL(_T("CComModule::CreateInstance"));
; 4846 : 	}
; 4847 : 
; 4848 : 	BOOL WINAPI DllMain(
; 4849 : 		_In_ HINSTANCE hInstance,
; 4850 : 		_In_ DWORD dwReason,
; 4851 : 		_In_opt_ LPVOID /* lpReserved */,
; 4852 : 		_In_ _ATL_OBJMAP_ENTRY* pObjMap,
; 4853 : 		_In_ const GUID* pLibID);
; 4854 : 
; 4855 : 	BOOL WINAPI _DllMain(
; 4856 : 		_In_ HINSTANCE hInstance,
; 4857 : 		_In_ DWORD dwReason,
; 4858 : 		_In_opt_ LPVOID /* lpReserved */,
; 4859 : 		_In_ _ATL_OBJMAP_ENTRY* pObjMap,
; 4860 : 		_In_ const GUID* pLibID)
; 4861 : 	{
; 4862 : 		if (dwReason == DLL_PROCESS_ATTACH)
; 4863 : 		{
; 4864 : 			if (CAtlBaseModule::m_bInitFailed)
; 4865 : 			{
; 4866 : 				ATLASSERT(0);
; 4867 : 				return FALSE;
; 4868 : 			}
; 4869 : 
; 4870 : 			if (FAILED(Init(pObjMap, hInstance, pLibID)))
; 4871 : 			{
; 4872 : 				Term();
; 4873 : 				return FALSE;
; 4874 : 			}
; 4875 : 		}
; 4876 : 		else if (dwReason == DLL_PROCESS_DETACH)
; 4877 : 			Term();
; 4878 : 		return TRUE;    // ok
; 4879 : 	}
; 4880 : 
; 4881 : 	HRESULT DllCanUnloadNow()  throw()
; 4882 : 	{
; 4883 : 		return (GetLockCount()==0) ? S_OK : S_FALSE;
; 4884 : 	}
; 4885 : 	HRESULT DllGetClassObject(
; 4886 : 		_In_ REFCLSID rclsid,
; 4887 : 		_In_ REFIID riid,
; 4888 : 		_COM_Outptr_ LPVOID* ppv)  throw()
; 4889 : 	{
; 4890 : 		return GetClassObject(rclsid, riid, ppv);
; 4891 : 	}
; 4892 : 	
; 4893 : private:
; 4894 : 	static HRESULT RegisterProgIDHelper(
; 4895 : 		_In_z_ LPCTSTR lpszCLSID,
; 4896 : 		_In_z_ LPCTSTR lpszProgID,
; 4897 : 		_In_opt_z_ LPCTSTR lpszCurVerProgID,
; 4898 : 		_In_z_ LPCTSTR lpszUserDesc,
; 4899 : 		_In_ BOOL bIsVerIndProgID);
; 4900 : };
; 4901 : 
; 4902 : #pragma managed(push, off)
; 4903 : inline BOOL WINAPI CComModule::DllMain(
; 4904 : 	_In_ HINSTANCE hInstance,
; 4905 : 	_In_ DWORD dwReason,
; 4906 : 	_In_opt_ LPVOID lpReserved,
; 4907 : 	_In_ _ATL_OBJMAP_ENTRY* pObjMap,
; 4908 : 	_In_ const GUID* pLibID)
; 4909 : {
; 4910 : #if !defined(_ATL_NATIVE_INITIALIZATION)
; 4911 : #pragma warning(push)  // disable 4483
; 4912 : #pragma warning(disable:4483)
; 4913 : 	using namespace __identifier("<AtlImplementationDetails>");
; 4914 : #pragma warning(pop)  // disable 4483
; 4915 : 	UNREFERENCED_PARAMETER(lpReserved);
; 4916 : 	if (dwReason == DLL_PROCESS_ATTACH)
; 4917 : 	{
; 4918 : 		ATLASSERT(ComModuleInitialized == false);
; 4919 : 		ComModuleHelper.Initialize(this, hInstance, pObjMap, pLibID);
; 4920 : 	}
; 4921 : 	return TRUE;
; 4922 : #else
; 4923 : 	return _DllMain(hInstance, dwReason, lpReserved, pObjMap, pLibID);
; 4924 : #endif
; 4925 : }
; 4926 : #pragma managed(pop)
; 4927 : 
; 4928 : #endif	// !_ATL_NO_COMMODULE
; 4929 : 
; 4930 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 4931 : 
; 4932 : /////////////////////////////////////////////////////////////////////////////
; 4933 : // Thread creation helpers
; 4934 : 
; 4935 : // CRTThreadTraits
; 4936 : // This class is for use with CThreadPool or CWorkerThread
; 4937 : // It should be used if the worker class will use CRT
; 4938 : // functions.
; 4939 : class CRTThreadTraits
; 4940 : {
; 4941 : public:
; 4942 : 	static HANDLE CreateThread(
; 4943 : 		_In_opt_ LPSECURITY_ATTRIBUTES lpsa,
; 4944 : 		_In_ DWORD dwStackSize,
; 4945 : 		_In_ LPTHREAD_START_ROUTINE pfnThreadProc,
; 4946 : 		_In_opt_ void *pvParam,
; 4947 : 		_In_ DWORD dwCreationFlags,
; 4948 : 		_Out_opt_ DWORD *pdwThreadId) throw()
; 4949 : 	{
; 4950 : 		ATLASSERT(sizeof(DWORD) == sizeof(unsigned int)); // sanity check for pdwThreadId
; 4951 : 
; 4952 : 		// _beginthreadex calls CreateThread which will set the last error value before it returns.
; 4953 : 		return (HANDLE) _beginthreadex(lpsa, dwStackSize, (unsigned int (__stdcall *)(void *)) pfnThreadProc, pvParam, dwCreationFlags, (unsigned int *) pdwThreadId);
; 4954 : 	}
; 4955 : };
; 4956 : 
; 4957 : // Win32ThreadTraits
; 4958 : // This class is for use with CThreadPool or CWorkerThread
; 4959 : // It should be used if the worker class will not use CRT
; 4960 : // functions.
; 4961 : class Win32ThreadTraits
; 4962 : {
; 4963 : public:
; 4964 : 	static HANDLE CreateThread(
; 4965 : 		_In_opt_ LPSECURITY_ATTRIBUTES lpsa,
; 4966 : 		_In_ DWORD dwStackSize,
; 4967 : 		_In_ LPTHREAD_START_ROUTINE pfnThreadProc,
; 4968 : 		_In_opt_ void *pvParam,
; 4969 : 		_In_ DWORD dwCreationFlags,
; 4970 : 		_Out_opt_ DWORD *pdwThreadId) throw()
; 4971 : 	{
; 4972 : 		return ::CreateThread(lpsa, dwStackSize, pfnThreadProc, pvParam, dwCreationFlags, pdwThreadId);
; 4973 : 	}
; 4974 : };
; 4975 : 
; 4976 : typedef CRTThreadTraits DefaultThreadTraits;
; 4977 : 
; 4978 : template <typename T>
; 4979 : HANDLE CreateThreadT(
; 4980 : 	_In_opt_ LPSECURITY_ATTRIBUTES lpsa,
; 4981 : 	_In_ DWORD dwStackSize,
; 4982 : 	_In_ DWORD (WINAPI * pfn)(_In_ T *pparam),
; 4983 : 	_In_opt_ T *pparam,
; 4984 : 	_In_ DWORD dwCreationFlags,
; 4985 : 	_Out_opt_ LPDWORD pdw)
; 4986 : {
; 4987 : 	return DefaultThreadTraits::CreateThread(lpsa,
; 4988 : 		dwStackSize,
; 4989 : 		(LPTHREAD_START_ROUTINE)pfn,
; 4990 : 		pparam,
; 4991 : 		dwCreationFlags,
; 4992 : 		pdw);
; 4993 : }
; 4994 : 
; 4995 : template <typename T>
; 4996 : HANDLE AtlCreateThread(_In_ DWORD (WINAPI* pfn)(_In_ T *pparam), _In_ T *pparam)
; 4997 : {
; 4998 : 	return CreateThreadT(0, 0, pfn, pparam, 0, 0);
; 4999 : }
; 5000 : 
; 5001 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 5002 : 
; 5003 : /////////////////////////////////////////////////////////////////////////////////////////////
; 5004 : // Thread Pooling classes
; 5005 : 
; 5006 : class _AtlAptCreateObjData
; 5007 : {
; 5008 : public:
; 5009 : 	_ATL_CREATORFUNC* pfnCreateInstance;
; 5010 : 	const IID* piid;
; 5011 : 	HANDLE hEvent;
; 5012 : 	LPSTREAM pStream;
; 5013 : 	HRESULT hRes;
; 5014 : };
; 5015 : 
; 5016 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 5017 : 
; 5018 : class CComApartment
; 5019 : {
; 5020 : public:
; 5021 : 	CComApartment()
; 5022 : 	{
; 5023 : 		m_nLockCnt = 0;
; 5024 : 		m_hThread = NULL;
; 5025 : 	}
; 5026 : 	static UINT ATL_CREATE_OBJECT;
; 5027 : 	static DWORD WINAPI _Apartment(_In_ void* pv)
; 5028 : 	{
; 5029 : 		ATLENSURE(pv != NULL);
; 5030 : 		return ((CComApartment*)pv)->Apartment();
; 5031 : 	}
; 5032 : 	DWORD Apartment()
; 5033 : 	{
; 5034 : ATLPREFAST_SUPPRESS(6031)
; 5035 : 		CoInitialize(NULL);
; 5036 : ATLPREFAST_UNSUPPRESS()
; 5037 : 		MSG msg;
; 5038 : 		while(GetMessage(&msg, 0, 0, 0) > 0)
; 5039 : 		{
; 5040 : 			if (msg.message == ATL_CREATE_OBJECT)
; 5041 : 			{
; 5042 : 				_AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
; 5043 : 				CComPtr<IUnknown> pUnk;
; 5044 : 				pdata->hRes = pdata->pfnCreateInstance(NULL, __uuidof(IUnknown), (void**)&pUnk);
; 5045 : 				if (SUCCEEDED(pdata->hRes))
; 5046 : 					pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
; 5047 : 				if (SUCCEEDED(pdata->hRes))
; 5048 : 				{
; 5049 : 					ATLTRACE(atlTraceCOM, 2, _T("Object created on thread = %d\n"), GetCurrentThreadId());
; 5050 : 				}
; 5051 : #ifdef _DEBUG
; 5052 : 				else
; 5053 : 				{
; 5054 : 					ATLTRACE(atlTraceCOM, 2, _T("Failed to create Object on thread = %d\n"), GetCurrentThreadId());
; 5055 : 				}
; 5056 : #endif
; 5057 : 				SetEvent(pdata->hEvent);
; 5058 : 			}
; 5059 : 			DispatchMessage(&msg);
; 5060 : 		}
; 5061 : 		CoUninitialize();
; 5062 : 
; 5063 : 		return 0;
; 5064 : 	}
; 5065 : 	LONG Lock()
; 5066 : 	{
; 5067 : 		return CComGlobalsThreadModel::Increment(&m_nLockCnt);
; 5068 : 	}
; 5069 : 	LONG Unlock()
; 5070 : 	{
; 5071 : 		return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
; 5072 : 	}
; 5073 : 	LONG GetLockCount() const
; 5074 : 	{
; 5075 : 		return m_nLockCnt;
; 5076 : 	}
; 5077 : 
; 5078 : 	DWORD m_dwThreadID;
; 5079 : 	HANDLE m_hThread;
; 5080 : 	LONG m_nLockCnt;
; 5081 : };
; 5082 : 
; 5083 : __declspec(selectany) UINT CComApartment::ATL_CREATE_OBJECT = 0;
; 5084 : 
; 5085 : class CComSimpleThreadAllocator
; 5086 : {
; 5087 : public:
; 5088 : 	CComSimpleThreadAllocator()
; 5089 : 	{
; 5090 : 		m_nThread = 0;
; 5091 : 	}
; 5092 : 	int GetThread(_In_opt_ CComApartment* /*pApt*/, _In_ int nThreads)
; 5093 : 	{
; 5094 : 		if (++m_nThread == nThreads)
; 5095 : 			m_nThread = 0;
; 5096 : 		return m_nThread;
; 5097 : 	}
; 5098 : 	int m_nThread;
; 5099 : };
; 5100 : 
; 5101 : __interface IAtlAutoThreadModule
; 5102 : {
; 5103 : 	virtual HRESULT CreateInstance(
; 5104 : 		_In_ void* pfnCreateInstance,
; 5105 : 		_In_ REFIID riid,
; 5106 : 		_COM_Outptr_ void** ppvObj);
; 5107 : };
; 5108 : 
; 5109 : __declspec(selectany) IAtlAutoThreadModule* _pAtlAutoThreadModule;
; 5110 : 
; 5111 : template <class T, class ThreadAllocator = CComSimpleThreadAllocator, DWORD dwWait = INFINITE>
; 5112 : class ATL_NO_VTABLE CAtlAutoThreadModuleT : 
; 5113 : 	public IAtlAutoThreadModule
; 5114 : {
; 5115 : // This class is not for use in a DLL.
; 5116 : // If this class were used in a DLL,  there will be a deadlock when the DLL is unloaded.
; 5117 : // because of dwWait's default value of INFINITE
; 5118 : public:
; 5119 : 	CAtlAutoThreadModuleT(_In_ int nThreads = T::GetDefaultThreads())
; 5120 : 	{
; 5121 : 		ATLASSERT(_pAtlAutoThreadModule == NULL);
; 5122 : 		_pAtlAutoThreadModule = this;
; 5123 : 		m_nThreads= 0;
; 5124 : 
; 5125 : 		m_pApartments = _ATL_NEW CComApartment[nThreads];
; 5126 : 		ATLASSERT(m_pApartments != NULL);
; 5127 : 		if(m_pApartments == NULL)
; 5128 : 		{
; 5129 : 			CAtlBaseModule::m_bInitFailed = true;
; 5130 : 			ATLENSURE(0);
; 5131 : 		}
; 5132 : 
; 5133 : 		memset(m_pApartments, 0, sizeof(CComApartment) * nThreads);
; 5134 : 
; 5135 : 		m_nThreads = nThreads;
; 5136 : 		for (int i = 0; i < nThreads; i++)
; 5137 : 		{
; 5138 : 			typedef unsigned ( __stdcall *pfnThread )( void * );
; 5139 : 			errno_t save_errno = Checked::get_errno();
; 5140 : 			Checked::set_errno(0);
; 5141 : 			m_pApartments[i].m_hThread = (HANDLE)_beginthreadex(NULL, 0, (pfnThread)CComApartment::_Apartment, &m_pApartments[i], 0, (UINT*)&m_pApartments[i].m_dwThreadID);
; 5142 : 			if (m_pApartments[i].m_hThread == NULL)
; 5143 : 			{
; 5144 : 				HRESULT hr = E_FAIL;
; 5145 : 				// _beginthreadex sets errno when it fails
; 5146 : 				switch (Checked::get_errno())
; 5147 : 				{
; 5148 : 				case EAGAIN:
; 5149 : 					hr = HRESULT_FROM_WIN32(ERROR_TOO_MANY_TCBS);
; 5150 : 					break;
; 5151 : 				case EINVAL:
; 5152 : 					hr = E_INVALIDARG;
; 5153 : 					break;
; 5154 : 				}
; 5155 : 				ATLASSERT(0);
; 5156 : 				CAtlBaseModule::m_bInitFailed = true;
; 5157 : 				break;
; 5158 : 			}
; 5159 : 			Checked::set_errno(save_errno);
; 5160 : 		}
; 5161 : 		if (!CAtlBaseModule::m_bInitFailed)
; 5162 : 			CComApartment::ATL_CREATE_OBJECT = RegisterWindowMessage(_T("ATL_CREATE_OBJECT"));
; 5163 : 	}
; 5164 : 
; 5165 : 	virtual ~CAtlAutoThreadModuleT()
; 5166 : 	{
; 5167 : 		if (m_pApartments == NULL)
; 5168 : 			return;
; 5169 : 
; 5170 : 		DWORD dwCurrentThreadId = GetCurrentThreadId();
; 5171 : 		int nCurrentThread = -1;
; 5172 : 		for (int i=0; i < m_nThreads; i++)
; 5173 : 		{
; 5174 : 			if (m_pApartments[i].m_hThread == NULL)
; 5175 : 				continue;
; 5176 : 			if (m_pApartments[i].m_dwThreadID == dwCurrentThreadId)
; 5177 : 			{
; 5178 : 				nCurrentThread = i;
; 5179 : 				continue;
; 5180 : 			}
; 5181 : 			while (::PostThreadMessage(m_pApartments[i].m_dwThreadID, WM_QUIT, 0, 0) == 0)
; 5182 : 			{
; 5183 : 				/* Unfortunately, we can not use GetLastError() here to determine
; 5184 : 				 * what went wrong here.  It could be the thread ID is invalid (in this case
; 5185 : 				 * we want to break from this loop) or it could be the message loop for this
; 5186 : 				 * thread has not been created yet (in this case, we should sleep and try again).
; 5187 : 				 * However, GetLastError() will return ERROR_INVALID_THREAD_ID for both cases.
; 5188 : 				 */
; 5189 : 				::Sleep(100);
; 5190 : 			}
; 5191 : 			::WaitForSingleObject(m_pApartments[i].m_hThread, dwWait);
; 5192 : 			CloseHandle(m_pApartments[i].m_hThread);
; 5193 : 		}
; 5194 : 		if (nCurrentThread != -1)
; 5195 : 			CloseHandle(m_pApartments[nCurrentThread].m_hThread);
; 5196 : 
; 5197 : 		delete [] m_pApartments;
; 5198 : 		m_pApartments = NULL;
; 5199 : 	}
; 5200 : 
; 5201 : 	HRESULT CreateInstance(
; 5202 : 		_In_opt_ void* pfnCreateInstance,
; 5203 : 		_In_ REFIID riid,
; 5204 : 		_COM_Outptr_ void** ppvObj)
; 5205 : 	{
; 5206 : 		ATLASSERT(ppvObj != NULL);
; 5207 : 		if (ppvObj == NULL)
; 5208 : 			return E_POINTER;
; 5209 : 		*ppvObj = NULL;
; 5210 : 
; 5211 : 		_ATL_CREATORFUNC* pFunc = (_ATL_CREATORFUNC*) pfnCreateInstance;
; 5212 : 		_AtlAptCreateObjData data;
; 5213 : 		data.pfnCreateInstance = pFunc;
; 5214 : 		data.piid = &riid;
; 5215 : 		data.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
; 5216 : 		ATLENSURE(data.hEvent != NULL);
; 5217 : 		data.hRes = S_OK;
; 5218 : 		int nThread = m_Allocator.GetThread(m_pApartments, m_nThreads);
; 5219 : 		int nIterations = 0;
; 5220 : 		while(::PostThreadMessage(m_pApartments[nThread].m_dwThreadID, CComApartment::ATL_CREATE_OBJECT, 0, (LPARAM)&data) == 0 && ++nIterations < 100)
; 5221 : 		{
; 5222 : 			Sleep(100);
; 5223 : 		}
; 5224 : 		if (nIterations < 100)
; 5225 : 		{
; 5226 : 			AtlWaitWithMessageLoop(data.hEvent);
; 5227 : 		}
; 5228 : 		else
; 5229 : 		{
; 5230 : 			data.hRes = AtlHresultFromLastError();
; 5231 : 		}
; 5232 : 		if (data.hEvent)
; 5233 : 			CloseHandle(data.hEvent);
; 5234 : 		if (SUCCEEDED(data.hRes))
; 5235 : 			data.hRes = CoGetInterfaceAndReleaseStream(data.pStream, riid, ppvObj);
; 5236 : 		return data.hRes;
; 5237 : 	}
; 5238 : 	DWORD dwThreadID;
; 5239 : 	int m_nThreads;
; 5240 : 	CComApartment* m_pApartments;
; 5241 : 	ThreadAllocator m_Allocator;
; 5242 : 	static int GetDefaultThreads()
; 5243 : 	{
; 5244 : 		SYSTEM_INFO si;
; 5245 : 		GetSystemInfo(&si);
; 5246 : 		return si.dwNumberOfProcessors * 4;
; 5247 : 	}
; 5248 : };
; 5249 : 
; 5250 : class CAtlAutoThreadModule : 
; 5251 : 	public CAtlAutoThreadModuleT<CAtlAutoThreadModule>
; 5252 : {
; 5253 : public :
; 5254 : };
; 5255 : 
; 5256 : 
; 5257 : #ifndef _ATL_NO_COMMODULE
; 5258 : 
; 5259 : template <class ThreadAllocator = CComSimpleThreadAllocator, DWORD dwWait = INFINITE>
; 5260 : class CComAutoThreadModule :
; 5261 : 	public CComModule,
; 5262 : 	public CAtlAutoThreadModuleT<CComAutoThreadModule<ThreadAllocator,dwWait>, ThreadAllocator, dwWait>
; 5263 : {
; 5264 : public:
; 5265 : 	CComAutoThreadModule(_In_ int nThreads = GetDefaultThreads()) :
; 5266 : 		CAtlAutoThreadModuleT<CComAutoThreadModule<ThreadAllocator,dwWait>, ThreadAllocator, dwWait>(nThreads)
; 5267 : 	{
; 5268 : 	}
; 5269 : 	HRESULT Init(
; 5270 : 		_In_ _ATL_OBJMAP_ENTRY* p,
; 5271 : 		_In_ HINSTANCE h,
; 5272 : 		_In_opt_ const GUID* plibid = NULL,
; 5273 : 		_In_ int nThreads = GetDefaultThreads())
; 5274 : 	{
; 5275 : 		nThreads;
; 5276 : 		ATLASSERT(nThreads == GetDefaultThreads() && _T("Set number of threads through the constructor"));
; 5277 : 		return CComModule::Init(p, h, plibid);
; 5278 : 	}
; 5279 : };
; 5280 : 
; 5281 : #endif	// !_ATL_NO_COMMODULE
; 5282 : 
; 5283 : // Used in CThreadPool
; 5284 : class Win32WaitTraits
; 5285 : {
; 5286 : public:
; 5287 : 	static DWORD WaitForSingleObject(
; 5288 : 		_In_ HANDLE hHandle,
; 5289 : 		_In_ DWORD dwTimeout)
; 5290 : 	{
; 5291 : 		return ::WaitForSingleObject(hHandle, dwTimeout);
; 5292 : 	}
; 5293 : };
; 5294 : 
; 5295 : typedef Win32WaitTraits DefaultWaitTraits;
; 5296 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 5297 : 
; 5298 : /////////////////////////////////////////////////////////////////////////////
; 5299 : // GIT Pointer
; 5300 : 
; 5301 : template <class T>
; 5302 : class CComGITPtr
; 5303 : {
; 5304 : public:
; 5305 : 	CComGITPtr() throw()
; 5306 : 	{
; 5307 : 		m_dwCookie = 0;
; 5308 : 	}
; 5309 : 	CComGITPtr(_In_ T* p)
; 5310 : 	{
; 5311 : 		m_dwCookie = 0;
; 5312 : 		HRESULT hr = Attach(p);
; 5313 : 
; 5314 : 		if (FAILED(hr))
; 5315 : 			AtlThrow(hr);
; 5316 : 	}
; 5317 : 	CComGITPtr(_In_ const CComGITPtr& git)
; 5318 : 	{
; 5319 : 		m_dwCookie = 0;
; 5320 : 
; 5321 : 		if (git.m_dwCookie != 0)
; 5322 : 		{
; 5323 : 			CComPtr<T> spT;
; 5324 : 
; 5325 : 			HRESULT hr = git.CopyTo(&spT);
; 5326 : 			if (SUCCEEDED(hr))
; 5327 : 				hr = Attach(spT);
; 5328 : 
; 5329 : 			if (FAILED(hr))
; 5330 : 				AtlThrow(hr);
; 5331 : 		}
; 5332 : 	}
; 5333 : 	explicit CComGITPtr(_In_ DWORD dwCookie) throw()
; 5334 : 	{
; 5335 : 		ATLASSUME(dwCookie != NULL);
; 5336 : 		m_dwCookie = dwCookie;
; 5337 : 
; 5338 : #ifdef _DEBUG
; 5339 : 		CComPtr<T> spT;
; 5340 : 		HRESULT hr = CopyTo(&spT);
; 5341 : 		ATLASSERT(SUCCEEDED(hr));
; 5342 : #endif
; 5343 : 	}
; 5344 : 
; 5345 : 	CComGITPtr(CComGITPtr&& rv)
; 5346 : 	{
; 5347 : 		m_dwCookie = rv.m_dwCookie;
; 5348 : 		rv.m_dwCookie = 0;
; 5349 : 	}
; 5350 : 
; 5351 : 	CComGITPtr& operator=(CComGITPtr&& rv)
; 5352 : 	{
; 5353 : 		if (this != &rv)
; 5354 : 		{
; 5355 : 			ATLVERIFY(SUCCEEDED(Revoke()));
; 5356 : 
; 5357 : 			m_dwCookie = rv.m_dwCookie;
; 5358 : 			rv.m_dwCookie = 0;
; 5359 : 		}
; 5360 : 
; 5361 : 		return *this;
; 5362 : 	}
; 5363 : 
; 5364 : 	~CComGITPtr() throw()
; 5365 : 	{
; 5366 : 		Revoke();
; 5367 : 	}
; 5368 : 	CComGITPtr& operator=(_In_ const CComGITPtr& git)
; 5369 : 	{
; 5370 : 		if (this != &git)
; 5371 : 		{
; 5372 : 			if (git.m_dwCookie == 0)
; 5373 : 			{
; 5374 : 				ATLVERIFY(SUCCEEDED(Revoke()));
; 5375 : 			}
; 5376 : 			else
; 5377 : 			{
; 5378 : 				CComPtr<T> spT;
; 5379 : 
; 5380 : 				HRESULT hr = git.CopyTo(&spT);
; 5381 : 				if (SUCCEEDED(hr))
; 5382 : 				{
; 5383 : 					hr = Attach(spT);
; 5384 : 				}
; 5385 : 
; 5386 : 				if (FAILED(hr))
; 5387 : 				{
; 5388 : 					AtlThrow(hr);
; 5389 : 				}
; 5390 : 			}
; 5391 : 		}
; 5392 : 		return *this;
; 5393 : 	}
; 5394 : 	CComGITPtr& operator=(_In_ T* p)
; 5395 : 	{
; 5396 : 		HRESULT hr = Attach(p);
; 5397 : 		if (FAILED(hr))
; 5398 : 			AtlThrow(hr);
; 5399 : 		return *this;
; 5400 : 	}
; 5401 : 	CComGITPtr& operator=(_In_ DWORD dwCookie)
; 5402 : 	{
; 5403 : 		if(*this!=dwCookie)
; 5404 : 		{
; 5405 : 			HRESULT hr = Attach(dwCookie);
; 5406 : 			if (FAILED(hr))
; 5407 : 			{
; 5408 : 				AtlThrow(hr);
; 5409 : 			}
; 5410 : 
; 5411 : 			m_dwCookie = dwCookie;
; 5412 : 
; 5413 : #ifdef _DEBUG
; 5414 : 			CComPtr<T> spT;
; 5415 : 			hr = CopyTo(&spT);
; 5416 : 			ATLASSERT(SUCCEEDED(hr));
; 5417 : #endif
; 5418 : 		}
; 5419 : 		return *this;
; 5420 : 	}
; 5421 : 
; 5422 : 	// basic comparison operators
; 5423 : 	bool operator!=(_In_ const CComGITPtr& git) const
; 5424 : 	{
; 5425 : 		return !operator==(git);
; 5426 : 	}
; 5427 : 
; 5428 : 	bool operator!=(_In_ DWORD dwCookie) const
; 5429 : 	{
; 5430 : 		return !operator==(dwCookie);
; 5431 : 	}
; 5432 : 
; 5433 : 	bool operator==(_In_ const CComGITPtr& git) const
; 5434 : 	{
; 5435 : 		return m_dwCookie==git.GetCookie();
; 5436 : 	}
; 5437 : 
; 5438 : 	bool operator==(_In_ DWORD dwCookie) const
; 5439 : 	{
; 5440 : 		return m_dwCookie==dwCookie;
; 5441 : 	}
; 5442 : 
; 5443 : 	// Get the cookie from the class
; 5444 : 	operator DWORD() const
; 5445 : 	{
; 5446 : 		return m_dwCookie;
; 5447 : 	}
; 5448 : 	// Get the cookie from the class
; 5449 : 	DWORD GetCookie() const
; 5450 : 	{
; 5451 : 		return m_dwCookie;
; 5452 : 	}
; 5453 : 	// Register the passed interface pointer in the GIT
; 5454 : 	HRESULT Attach(_In_ T* p) throw()
; 5455 : 	{
; 5456 : 		if (p)
; 5457 : 		{
; 5458 : 			CComPtr<IGlobalInterfaceTable> spGIT;
; 5459 : 			HRESULT hr = E_FAIL;
; 5460 : 			hr = AtlGetGITPtr(&spGIT);
; 5461 : 			ATLASSERT(spGIT != NULL);
; 5462 : 			ATLASSERT(SUCCEEDED(hr));
; 5463 : 			if (FAILED(hr))
; 5464 : 				return hr;
; 5465 : 
; 5466 : 			if (m_dwCookie != 0)
; 5467 : 				hr = spGIT->RevokeInterfaceFromGlobal(m_dwCookie);
; 5468 : 			if (FAILED(hr))
; 5469 : 				return hr;
; 5470 : 
; 5471 : 			return spGIT->RegisterInterfaceInGlobal(p, __uuidof(T), &m_dwCookie);
; 5472 : 		}
; 5473 : 		else
; 5474 : 		{
; 5475 : 			return Revoke();
; 5476 : 		}
; 5477 : 	}
; 5478 : 
; 5479 : 	HRESULT Attach(_In_ DWORD dwCookie) throw()
; 5480 : 	{
; 5481 : 		ATLASSERT(dwCookie != NULL);
; 5482 : 		HRESULT hr = Revoke();
; 5483 : 		if (FAILED(hr))
; 5484 : 			return hr;
; 5485 : 		m_dwCookie = dwCookie;
; 5486 : 		return S_OK;
; 5487 : 	}
; 5488 : 
; 5489 : 	// Detach
; 5490 : 	DWORD Detach() throw()
; 5491 : 	{
; 5492 : 		DWORD dwCookie = m_dwCookie;
; 5493 : 		m_dwCookie = NULL;
; 5494 : 		return dwCookie;
; 5495 : 	}
; 5496 : 
; 5497 : 	// Remove the interface from the GIT
; 5498 : 	HRESULT Revoke() throw()
; 5499 : 	{
; 5500 : 		HRESULT hr = S_OK;
; 5501 : 		if (m_dwCookie != 0)
; 5502 : 		{
; 5503 : 			CComPtr<IGlobalInterfaceTable> spGIT;
; 5504 : 			hr = AtlGetGITPtr(&spGIT);
; 5505 : 
; 5506 : 			ATLASSERT(spGIT != NULL);
; 5507 : 			ATLASSERT(SUCCEEDED(hr));
; 5508 : 			if (FAILED(hr))
; 5509 : 				return hr;
; 5510 : 
; 5511 : 			hr = spGIT->RevokeInterfaceFromGlobal(m_dwCookie);
; 5512 : 			if (SUCCEEDED(hr))
; 5513 : 				m_dwCookie = 0;
; 5514 : 		}
; 5515 : 		return hr;
; 5516 : 	}
; 5517 : 	// Get's the interface from the GIT and copies it to the passed pointer. The pointer
; 5518 : 	// must be released by the caller when finished.
; 5519 : 	HRESULT CopyTo(_Outptr_ T** pp) const throw()
; 5520 : 	{
; 5521 : 		CComPtr<IGlobalInterfaceTable> spGIT;
; 5522 : 		HRESULT hr = E_FAIL;
; 5523 : 		hr = AtlGetGITPtr(&spGIT);
; 5524 : 
; 5525 : 		ATLASSERT(spGIT != NULL);
; 5526 : 		ATLASSERT(SUCCEEDED(hr));
; 5527 : 		if (FAILED(hr))
; 5528 : 			return hr;
; 5529 : 
; 5530 : 		ATLASSUME(m_dwCookie!=NULL);
; 5531 : 		return spGIT->GetInterfaceFromGlobal(m_dwCookie, __uuidof(T), (void**)pp);
; 5532 : 	}
; 5533 : 	DWORD m_dwCookie;
; 5534 : };
; 5535 : 
; 5536 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 5537 : 
; 5538 : /////////////////////////////////////////////////////////////////////////////
; 5539 : // CRegKey
; 5540 : 
; 5541 : class CRegKey
; 5542 : {
; 5543 : public:
; 5544 : 	/// <summary>
; 5545 : 	/// CRegKey constructor</summary>
; 5546 : 	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
; 5547 : 	CRegKey(_In_opt_ CAtlTransactionManager* pTM = NULL) throw();
; 5548 : 	CRegKey(_Inout_ CRegKey& key) throw();
; 5549 : 	explicit CRegKey(_In_ HKEY hKey) throw();
; 5550 : 	~CRegKey() throw();
; 5551 : 
; 5552 : 	CRegKey& operator=(_Inout_ CRegKey& key) throw();
; 5553 : 
; 5554 : // Attributes
; 5555 : public:
; 5556 : 	operator HKEY() const throw();
; 5557 : 	HKEY m_hKey;
; 5558 : 	REGSAM m_samWOW64;
; 5559 : 
; 5560 : 	/// <summary>
; 5561 : 	/// Pointer to CAtlTransactionManager object</summary>
; 5562 : 	CAtlTransactionManager* m_pTM;
; 5563 : 
; 5564 : // Operations
; 5565 : public:
; 5566 : 	ATL_DEPRECATED("CRegKey::SetValue(DWORD, TCHAR *valueName) has been superseded by CRegKey::SetDWORDValue")
; 5567 : 	LSTATUS SetValue(
; 5568 : 		_In_ DWORD dwValue,
; 5569 : 		_In_opt_z_ LPCTSTR lpszValueName);
; 5570 : 
; 5571 : 	ATL_DEPRECATED("CRegKey::SetValue(TCHAR *value, TCHAR *valueName) has been superseded by CRegKey::SetStringValue and CRegKey::SetMultiStringValue")
; 5572 : 	LSTATUS SetValue(
; 5573 : 		_In_z_ LPCTSTR lpszValue,
; 5574 : 		_In_opt_z_ LPCTSTR lpszValueName = NULL,
; 5575 : 		_In_ bool bMulti = false,
; 5576 : 		_In_ int nValueLen = -1);
; 5577 : 	LSTATUS SetValue(
; 5578 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5579 : 		_In_ DWORD dwType,
; 5580 : 		_In_opt_ const void* pValue,
; 5581 : 		_In_ ULONG nBytes) throw();
; 5582 : 	LSTATUS SetGUIDValue(
; 5583 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5584 : 		_In_ REFGUID guidValue) throw();
; 5585 : 	LSTATUS SetBinaryValue(
; 5586 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5587 : 		_In_opt_ const void* pValue,
; 5588 : 		_In_ ULONG nBytes) throw();
; 5589 : 	LSTATUS SetDWORDValue(
; 5590 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5591 : 		_In_ DWORD dwValue) throw();
; 5592 : 	LSTATUS SetQWORDValue(
; 5593 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5594 : 		_In_ ULONGLONG qwValue) throw();
; 5595 : 	LSTATUS SetStringValue(
; 5596 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5597 : 		_In_opt_z_ LPCTSTR pszValue,
; 5598 : 		_In_ DWORD dwType = REG_SZ) throw();
; 5599 : 	LSTATUS SetMultiStringValue(
; 5600 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5601 : 		_In_z_ LPCTSTR pszValue) throw();
; 5602 : 
; 5603 : 	ATL_DEPRECATED("CRegKey::QueryValue(DWORD, TCHAR *valueName) has been superseded by CRegKey::QueryDWORDValue")
; 5604 : 	LSTATUS QueryValue(
; 5605 : 		_Out_ DWORD& dwValue,
; 5606 : 		_In_opt_z_ LPCTSTR lpszValueName);
; 5607 : 
; 5608 : 	ATL_DEPRECATED("CRegKey::QueryValue(TCHAR *value, TCHAR *valueName) has been superseded by CRegKey::QueryStringValue and CRegKey::QueryMultiStringValue")
; 5609 : 	LSTATUS QueryValue(
; 5610 : 		_Out_writes_to_opt_(*pdwCount, *pdwCount) LPTSTR szValue,
; 5611 : 		_In_opt_z_ LPCTSTR lpszValueName,
; 5612 : 		_Inout_ DWORD* pdwCount);
; 5613 : 	LSTATUS QueryValue(
; 5614 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5615 : 		_Out_opt_ DWORD* pdwType,
; 5616 : 		_Out_opt_ void* pData,
; 5617 : 		_Inout_ ULONG* pnBytes) throw();
; 5618 : 	LSTATUS QueryGUIDValue(
; 5619 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5620 : 		_Out_ GUID& guidValue) throw();
; 5621 : 	LSTATUS QueryBinaryValue(
; 5622 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5623 : 		_Out_opt_ void* pValue,
; 5624 : 		_Inout_opt_ ULONG* pnBytes) throw();
; 5625 : 	LSTATUS QueryDWORDValue(
; 5626 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5627 : 		_Out_ DWORD& dwValue) throw();
; 5628 : 	LSTATUS QueryQWORDValue(
; 5629 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5630 : 		_Out_ ULONGLONG& qwValue) throw();
; 5631 : 	LSTATUS QueryStringValue(
; 5632 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5633 : 		_Out_writes_to_opt_(*pnChars, *pnChars) LPTSTR pszValue,
; 5634 : 		_Inout_ ULONG* pnChars) throw();
; 5635 : 	LSTATUS QueryMultiStringValue(
; 5636 : 		_In_opt_z_ LPCTSTR pszValueName,
; 5637 : 		_Out_writes_to_opt_(*pnChars, *pnChars) LPTSTR pszValue,
; 5638 : 		_Inout_ ULONG* pnChars) throw();
; 5639 : 
; 5640 : 	// Get the key's security attributes.
; 5641 : 	LSTATUS GetKeySecurity(
; 5642 : 		_In_ SECURITY_INFORMATION si,
; 5643 : 		_Out_opt_ PSECURITY_DESCRIPTOR psd,
; 5644 : 		_Inout_ LPDWORD pnBytes) throw();
; 5645 : 	// Set the key's security attributes.
; 5646 : 	LSTATUS SetKeySecurity(
; 5647 : 		_In_ SECURITY_INFORMATION si,
; 5648 : 		_In_ PSECURITY_DESCRIPTOR psd) throw();
; 5649 : 
; 5650 : 	LSTATUS SetKeyValue(
; 5651 : 		_In_z_ LPCTSTR lpszKeyName,
; 5652 : 		_In_opt_z_ LPCTSTR lpszValue,
; 5653 : 		_In_opt_z_ LPCTSTR lpszValueName = NULL) throw();
; 5654 : 	static LSTATUS WINAPI SetValue(
; 5655 : 		_In_ HKEY hKeyParent,
; 5656 : 		_In_z_ LPCTSTR lpszKeyName,
; 5657 : 		_In_opt_z_ LPCTSTR lpszValue,
; 5658 : 		_In_opt_z_ LPCTSTR lpszValueName = NULL);
; 5659 : 
; 5660 : 	// Create a new registry key (or open an existing one).
; 5661 : 	LSTATUS Create(
; 5662 : 		_In_ HKEY hKeyParent,
; 5663 : 		_In_z_ LPCTSTR lpszKeyName,
; 5664 : 		_In_opt_z_ LPTSTR lpszClass = REG_NONE,
; 5665 : 		_In_ DWORD dwOptions = REG_OPTION_NON_VOLATILE,
; 5666 : 		_In_ REGSAM samDesired = KEY_READ | KEY_WRITE,
; 5667 : 		_In_opt_ LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
; 5668 : 		_Out_opt_ LPDWORD lpdwDisposition = NULL) throw();
; 5669 : 	// Open an existing registry key.
; 5670 : 	LSTATUS Open(
; 5671 : 		_In_ HKEY hKeyParent,
; 5672 : 		_In_opt_z_ LPCTSTR lpszKeyName,
; 5673 : 		_In_ REGSAM samDesired = KEY_READ | KEY_WRITE) throw();
; 5674 : 	// Close the registry key.
; 5675 : 	LSTATUS Close() throw();
; 5676 : 	// Flush the key's data to disk.
; 5677 : 	LSTATUS Flush() throw();
; 5678 : 
; 5679 : 	// Detach the CRegKey object from its HKEY.  Releases ownership.
; 5680 : 	HKEY Detach() throw();
; 5681 : 	// Attach the CRegKey object to an existing HKEY.  Takes ownership.
; 5682 : 	void Attach(_In_ HKEY hKey) throw();
; 5683 : 
; 5684 : 	// Enumerate the subkeys of the key.   
; 5685 : 	LSTATUS EnumKey(
; 5686 : 		_In_ DWORD iIndex,
; 5687 : 		_Out_writes_to_(*pnNameLength, *pnNameLength) _Post_z_ LPTSTR pszName,
; 5688 : 		_Inout_ LPDWORD pnNameLength,
; 5689 : 		_Out_opt_ FILETIME* pftLastWriteTime = NULL) throw();
; 5690 : 	LSTATUS NotifyChangeKeyValue(
; 5691 : 		_In_ BOOL bWatchSubtree,
; 5692 : 		_In_ DWORD dwNotifyFilter,
; 5693 : 		_In_ HANDLE hEvent,
; 5694 : 		_In_ BOOL bAsync = TRUE) throw();
; 5695 : 
; 5696 : 	LSTATUS DeleteSubKey(_In_z_ LPCTSTR lpszSubKey) throw();
; 5697 : 	LSTATUS RecurseDeleteKey(_In_z_ LPCTSTR lpszKey) throw();
; 5698 : 	LSTATUS DeleteValue(_In_z_ LPCTSTR lpszValue) throw();
; 5699 : };
; 5700 : 
; 5701 : inline CRegKey::CRegKey(_In_opt_ CAtlTransactionManager* pTM) throw() :
; 5702 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)
; 5703 : {
; 5704 : }
; 5705 : 
; 5706 : inline CRegKey::CRegKey(_Inout_ CRegKey& key) throw() :
; 5707 : 	m_hKey( NULL )
; 5708 : {
; 5709 : 	REGSAM samWOW64 = key.m_samWOW64;
; 5710 : 	CAtlTransactionManager* pTM = key.m_pTM;
; 5711 : 	Attach( key.Detach() );
; 5712 : 	m_samWOW64 = samWOW64;
; 5713 : 	m_pTM = pTM;
; 5714 : }
; 5715 : 
; 5716 : inline CRegKey::CRegKey(_In_ HKEY hKey) throw() :
; 5717 : 	m_hKey(hKey), m_samWOW64(0), m_pTM(NULL)
; 5718 : {
; 5719 : }
; 5720 : 
; 5721 : inline CRegKey::~CRegKey() throw()
; 5722 : {Close();}
; 5723 : 
; 5724 : inline CRegKey& CRegKey::operator=(_Inout_ CRegKey& key) throw()
; 5725 : {
; 5726 : 	if(m_hKey!=key.m_hKey)
; 5727 : 	{
; 5728 : 		Close();
; 5729 : 		REGSAM samWOW64 = key.m_samWOW64;
; 5730 : 		CAtlTransactionManager* pTM = key.m_pTM;
; 5731 : 		Attach( key.Detach() );
; 5732 : 		m_samWOW64 = samWOW64;
; 5733 : 		m_pTM = pTM;
; 5734 : 	}
; 5735 : 	return( *this );
; 5736 : }
; 5737 : 
; 5738 : inline CRegKey::operator HKEY() const throw()
; 5739 : {
; 5740 : 	return m_hKey;
; 5741 : }
; 5742 : 
; 5743 : inline HKEY CRegKey::Detach() throw()
; 5744 : {
; 5745 : 	HKEY hKey = m_hKey;
; 5746 : 	m_hKey = NULL;
; 5747 : 	m_samWOW64 = 0;
; 5748 : 	m_pTM = NULL;
; 5749 : 	return hKey;
; 5750 : }
; 5751 : 
; 5752 : inline void CRegKey::Attach(_In_ HKEY hKey) throw()
; 5753 : {
; 5754 : 	ATLASSUME(m_hKey == NULL);
; 5755 : 	m_hKey = hKey;
; 5756 : 	m_samWOW64 = 0;
; 5757 : 	m_pTM = NULL;
; 5758 : }
; 5759 : 
; 5760 : inline LSTATUS CRegKey::DeleteSubKey(_In_z_ LPCTSTR lpszSubKey) throw()
; 5761 : {
; 5762 : 	ATLASSUME(m_hKey != NULL);
; 5763 : 
; 5764 : 	if (m_pTM != NULL)
; 5765 : 	{
; 5766 : 		return m_pTM->RegDeleteKey(m_hKey, lpszSubKey);
; 5767 : 	}
; 5768 : 
; 5769 : #if WINVER >= 0x0501
; 5770 : #ifdef _UNICODE
; 5771 : 	static decltype(RegDeleteKeyExW) *pfnRegDeleteKeyEx = NULL;
; 5772 : #else
; 5773 : 	static decltype(RegDeleteKeyExA) *pfnRegDeleteKeyEx = NULL;
; 5774 : #endif	// _UNICODE
; 5775 : 	static bool bInitialized = false;
; 5776 : 
; 5777 : 	if (!bInitialized)
; 5778 : 	{
; 5779 : 		HMODULE hAdvapi32 = GetModuleHandle(_T("Advapi32.dll"));
; 5780 : 		if (hAdvapi32 != NULL)
; 5781 : 		{
; 5782 : #ifdef _UNICODE
; 5783 : 			pfnRegDeleteKeyEx = (decltype(RegDeleteKeyExW) *)GetProcAddress(hAdvapi32, "RegDeleteKeyExW");
; 5784 : #else
; 5785 : 			pfnRegDeleteKeyEx = (decltype(RegDeleteKeyExA) *)GetProcAddress(hAdvapi32, "RegDeleteKeyExA");
; 5786 : #endif	// _UNICODE
; 5787 : 		}
; 5788 : 		bInitialized = true;
; 5789 : 	}
; 5790 : 
; 5791 : 	if (pfnRegDeleteKeyEx != NULL)
; 5792 : 	{
; 5793 : 		return pfnRegDeleteKeyEx(m_hKey, lpszSubKey, m_samWOW64, 0);
; 5794 : 	}
; 5795 : 
; 5796 : #endif	// WINVER
; 5797 : 
; 5798 : 	return RegDeleteKey(m_hKey, lpszSubKey);
; 5799 : }
; 5800 : 
; 5801 : inline LSTATUS CRegKey::DeleteValue(_In_z_ LPCTSTR lpszValue) throw()
; 5802 : {
; 5803 : 	ATLASSUME(m_hKey != NULL);
; 5804 : 	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
; 5805 : }
; 5806 : 
; 5807 : inline LSTATUS CRegKey::Close() throw()
; 5808 : {
; 5809 : 	LONG lRes = ERROR_SUCCESS;
; 5810 : 	if (m_hKey != NULL)
; 5811 : 	{
; 5812 : 		lRes = RegCloseKey(m_hKey);
; 5813 : 		m_hKey = NULL;
; 5814 : 	}
; 5815 : 	m_samWOW64 = 0;
; 5816 : 	return lRes;
; 5817 : }
; 5818 : 
; 5819 : inline LSTATUS CRegKey::Flush() throw()
; 5820 : {
; 5821 : 	ATLASSUME(m_hKey != NULL);
; 5822 : 
; 5823 : 	return ::RegFlushKey(m_hKey);
; 5824 : }
; 5825 : 
; 5826 : inline LSTATUS CRegKey::EnumKey(
; 5827 : 	_In_ DWORD iIndex,
; 5828 : 	_Out_writes_to_(*pnNameLength, *pnNameLength) _Post_z_ LPTSTR pszName,
; 5829 : 	_Inout_ LPDWORD pnNameLength,
; 5830 : 	_Out_opt_ FILETIME* pftLastWriteTime) throw()
; 5831 : {
; 5832 : 	FILETIME ftLastWriteTime;
; 5833 : 
; 5834 : 	ATLASSUME(m_hKey != NULL);
; 5835 : 	if (pftLastWriteTime == NULL)
; 5836 : 	{
; 5837 : 		pftLastWriteTime = &ftLastWriteTime;
; 5838 : 	}
; 5839 : 
; 5840 : 	return ::RegEnumKeyEx(m_hKey, iIndex, pszName, pnNameLength, NULL, NULL, NULL, pftLastWriteTime);
; 5841 : }
; 5842 : 
; 5843 : inline LSTATUS CRegKey::NotifyChangeKeyValue(
; 5844 : 	_In_ BOOL bWatchSubtree,
; 5845 : 	_In_ DWORD dwNotifyFilter,
; 5846 : 	_In_ HANDLE hEvent,
; 5847 : 	_In_ BOOL bAsync) throw()
; 5848 : {
; 5849 : 	ATLASSUME(m_hKey != NULL);
; 5850 : 	ATLASSERT((hEvent != NULL) || !bAsync);
; 5851 : 
; 5852 : 	return ::RegNotifyChangeKeyValue(m_hKey, bWatchSubtree, dwNotifyFilter, hEvent, bAsync);
; 5853 : }
; 5854 : 
; 5855 : inline LSTATUS CRegKey::Create(
; 5856 : 	_In_ HKEY hKeyParent,
; 5857 : 	_In_z_ LPCTSTR lpszKeyName,
; 5858 : 	_In_opt_z_ LPTSTR lpszClass,
; 5859 : 	_In_ DWORD dwOptions,
; 5860 : 	_In_ REGSAM samDesired,
; 5861 : 	_In_opt_ LPSECURITY_ATTRIBUTES lpSecAttr,
; 5862 : 	_Out_opt_ LPDWORD lpdwDisposition) throw()
; 5863 : {
; 5864 : 	ATLASSERT(hKeyParent != NULL);
; 5865 : 	DWORD dw;
; 5866 : 	HKEY hKey = NULL;
; 5867 : 	LONG lRes = m_pTM != NULL ?
; 5868 : 		m_pTM->RegCreateKeyEx(hKeyParent, lpszKeyName, 0, lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw) :
; 5869 : 		RegCreateKeyEx(hKeyParent, lpszKeyName, 0, lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
; 5870 : 	if (lRes == ERROR_SUCCESS)
; 5871 : 	{
; 5872 :     	if (lpdwDisposition != NULL)
; 5873 : 		    *lpdwDisposition = dw;
; 5874 : 
; 5875 :         lRes = Close();
; 5876 : 		m_hKey = hKey;
; 5877 : #if WINVER >= 0x0501
; 5878 : 		m_samWOW64 = samDesired & (KEY_WOW64_32KEY | KEY_WOW64_64KEY);
; 5879 : #endif
; 5880 : 	}
; 5881 : 	return lRes;
; 5882 : }
; 5883 : 
; 5884 : inline LSTATUS CRegKey::Open(
; 5885 : 	_In_ HKEY hKeyParent,
; 5886 : 	_In_opt_z_ LPCTSTR lpszKeyName,
; 5887 : 	_In_ REGSAM samDesired) throw()
; 5888 : {
; 5889 : 	ATLASSUME(hKeyParent != NULL);
; 5890 : 	HKEY hKey = NULL;
; 5891 : 	LONG lRes = m_pTM != NULL ?
; 5892 : 		m_pTM->RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey) :
; 5893 : 		RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
; 5894 : 	if (lRes == ERROR_SUCCESS)
; 5895 : 	{
; 5896 : 		lRes = Close();
; 5897 : 		ATLASSERT(lRes == ERROR_SUCCESS);
; 5898 : 		m_hKey = hKey;
; 5899 : #if WINVER >= 0x0501
; 5900 : 		m_samWOW64 = samDesired & (KEY_WOW64_32KEY | KEY_WOW64_64KEY);
; 5901 : #endif
; 5902 : 	}
; 5903 : 	return lRes;
; 5904 : }
; 5905 : 
; 5906 : #pragma warning(push)  // disable 4996
; 5907 : #pragma warning(disable: 4996)
; 5908 : inline LSTATUS CRegKey::QueryValue(
; 5909 : 	_Out_ DWORD& dwValue,
; 5910 : 	_In_opt_z_ LPCTSTR lpszValueName)
; 5911 : {
; 5912 : 	DWORD dwType = 0;
; 5913 : 	DWORD dwCount = sizeof(DWORD);
; 5914 :     LONG lRes = RegQueryValueEx(m_hKey, lpszValueName, NULL, &dwType,
; 5915 : 		(LPBYTE)&dwValue, &dwCount);
; 5916 :     _Analysis_assume_((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
; 5917 : 	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
; 5918 : 	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
; 5919 : 	if (lRes == ERROR_SUCCESS && dwType != REG_DWORD)
; 5920 : 		return ERROR_INVALID_DATA;
; 5921 : 	return lRes;
; 5922 : }
; 5923 : 
; 5924 : ATLPREFAST_SUPPRESS(6053 6103 6385 6386)
; 5925 : inline LSTATUS CRegKey::QueryValue(
; 5926 : 	_Out_writes_to_opt_(*pdwCount, *pdwCount) LPTSTR pszValue,
; 5927 : 	_In_opt_z_ LPCTSTR lpszValueName,
; 5928 : 	_Inout_ DWORD* pdwCount)
; 5929 : {
; 5930 : 	ATLENSURE(pdwCount != NULL);
; 5931 : 	DWORD dwType = 0;
; 5932 : 	LONG lRes = RegQueryValueEx(m_hKey, lpszValueName, NULL, &dwType, (LPBYTE)pszValue, pdwCount);
; 5933 : 	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
; 5934 : 			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
; 5935 : 	if (lRes == ERROR_SUCCESS && pszValue != NULL)
; 5936 : 	{
; 5937 : 		if(*pdwCount>0)
; 5938 : 		{
; 5939 : 			switch(dwType)
; 5940 : 			{
; 5941 : 				case REG_SZ:
; 5942 : 				case REG_EXPAND_SZ:
; 5943 : 					if ((*pdwCount) % sizeof(TCHAR) != 0 || pszValue[(*pdwCount) / sizeof(TCHAR) - 1] != 0)
; 5944 : 					{
; 5945 : 						pszValue[0]=_T('\0');
; 5946 : 		 				return ERROR_INVALID_DATA;
; 5947 : 					}
; 5948 : 					break;
; 5949 : 				case REG_MULTI_SZ:
; 5950 : 					if ((*pdwCount) % sizeof(TCHAR) != 0 || (*pdwCount) / sizeof(TCHAR) < 1 || pszValue[(*pdwCount) / sizeof(TCHAR) -1] != 0 || (((*pdwCount) / sizeof(TCHAR))>1 && pszValue[(*pdwCount) / sizeof(TCHAR) - 2] != 0) )
; 5951 : 					{
; 5952 : 						pszValue[0]=_T('\0');
; 5953 : 						return ERROR_INVALID_DATA;
; 5954 : 					}
; 5955 : 					break;
; 5956 : 				default:
; 5957 : 					// Ensure termination
; 5958 : 					pszValue[0]=_T('\0');
; 5959 : 					return ERROR_INVALID_DATA;
; 5960 : 			}
; 5961 : 		}
; 5962 : 		else
; 5963 : 		{
; 5964 : 			// this is a blank one with no data yet
; 5965 : 			// Ensure termination
; 5966 : 			pszValue[0]=_T('\0');
; 5967 : 		}
; 5968 : 	}
; 5969 : 	return lRes;
; 5970 : }
; 5971 : ATLPREFAST_UNSUPPRESS()
; 5972 : #pragma warning(pop)  // disable 4996
; 5973 : 
; 5974 : inline LSTATUS CRegKey::QueryValue(
; 5975 : 	_In_opt_z_ LPCTSTR pszValueName,
; 5976 : 	_Out_opt_ DWORD* pdwType,
; 5977 : 	_Out_opt_ void* pData,
; 5978 : 	_Inout_ ULONG* pnBytes) throw()
; 5979 : {
; 5980 : 	ATLASSUME(m_hKey != NULL);
; 5981 : 
; 5982 : 	return( ::RegQueryValueEx(m_hKey, pszValueName, NULL, pdwType, static_cast< LPBYTE >( pData ), pnBytes) );
; 5983 : }
; 5984 : 
; 5985 : inline LSTATUS CRegKey::QueryDWORDValue(
; 5986 : 	_In_opt_z_ LPCTSTR pszValueName,
; 5987 : 	_Out_ DWORD& dwValue) throw()
; 5988 : {
; 5989 : 	LONG lRes;
; 5990 : 	ULONG nBytes;
; 5991 : 	DWORD dwType;
; 5992 : 
; 5993 : 	ATLASSUME(m_hKey != NULL);
; 5994 : 
; 5995 : 	nBytes = sizeof(DWORD);
; 5996 : 	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(&dwValue),
; 5997 : 		&nBytes);
; 5998 : 	if (lRes != ERROR_SUCCESS)
; 5999 : 		return lRes;
; 6000 : 	if (dwType != REG_DWORD)
; 6001 : 		return ERROR_INVALID_DATA;
; 6002 : 
; 6003 : 	return ERROR_SUCCESS;
; 6004 : }
; 6005 : inline LSTATUS CRegKey::QueryQWORDValue(
; 6006 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6007 : 	_Out_ ULONGLONG& qwValue) throw()
; 6008 : {
; 6009 : 	LONG lRes;
; 6010 : 	ULONG nBytes;
; 6011 : 	DWORD dwType;
; 6012 : 
; 6013 : 	ATLASSUME(m_hKey != NULL);
; 6014 : 
; 6015 : 	nBytes = sizeof(ULONGLONG);
; 6016 : 	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(&qwValue),
; 6017 : 		&nBytes);
; 6018 : 	if (lRes != ERROR_SUCCESS)
; 6019 : 		return lRes;
; 6020 : 	if (dwType != REG_QWORD)
; 6021 : 		return ERROR_INVALID_DATA;
; 6022 : 
; 6023 : 	return ERROR_SUCCESS;
; 6024 : }
; 6025 : 
; 6026 : inline LONG CRegKey::QueryBinaryValue(
; 6027 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6028 : 	_Out_opt_ void* pValue,
; 6029 : 	_Inout_opt_ ULONG* pnBytes) throw()
; 6030 : {
; 6031 : 	LONG lRes;
; 6032 : 	DWORD dwType;
; 6033 : 
; 6034 : 	ATLASSERT(pnBytes != NULL);
; 6035 : 	ATLASSUME(m_hKey != NULL);
; 6036 : 
; 6037 : 	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(pValue),
; 6038 : 		pnBytes);
; 6039 : 	if (lRes != ERROR_SUCCESS)
; 6040 : 		return lRes;
; 6041 : 	if (dwType != REG_BINARY)
; 6042 : 		return ERROR_INVALID_DATA;
; 6043 : 
; 6044 : 	return ERROR_SUCCESS;
; 6045 : }
; 6046 : 
; 6047 : ATLPREFAST_SUPPRESS(6053)
; 6048 : /* prefast noise VSW 496818 */
; 6049 : inline LSTATUS CRegKey::QueryStringValue(
; 6050 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6051 : 	_Out_writes_to_opt_(*pnChars, *pnChars) LPTSTR pszValue,
; 6052 : 	_Inout_ ULONG* pnChars) throw()
; 6053 : {
; 6054 : 	LONG lRes;
; 6055 : 	DWORD dwType;
; 6056 : 	ULONG nBytes;
; 6057 : 
; 6058 : 	ATLASSUME(m_hKey != NULL);
; 6059 : 	ATLASSERT(pnChars != NULL);
; 6060 : 
; 6061 : 	nBytes = (*pnChars)*sizeof(TCHAR);
; 6062 : 	*pnChars = 0;
; 6063 : 	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(pszValue),
; 6064 : 		&nBytes);
; 6065 : 
; 6066 : 	if (lRes != ERROR_SUCCESS)
; 6067 : 	{
; 6068 : 		return lRes;
; 6069 : 	}
; 6070 : 
; 6071 : 	if(dwType != REG_SZ && dwType != REG_EXPAND_SZ)
; 6072 : 	{
; 6073 : 		return ERROR_INVALID_DATA;
; 6074 : 	}
; 6075 : 
; 6076 : 	if (pszValue != NULL)
; 6077 : 	{
; 6078 : 		if(nBytes!=0)
; 6079 : 		{
; 6080 : ATLPREFAST_SUPPRESS(6385) // suppress noisy code analysis warning due to annotation on RegQueryValueEx
; 6081 : 			if ((nBytes % sizeof(TCHAR) != 0) || (pszValue[nBytes / sizeof(TCHAR) -1] != 0))
; 6082 : 			{
; 6083 : 				return ERROR_INVALID_DATA;
; 6084 : 			}
; 6085 : ATLPREFAST_UNSUPPRESS()
; 6086 : 		}
; 6087 : 		else
; 6088 : 		{
; 6089 : 			pszValue[0]=_T('\0');
; 6090 : 		}
; 6091 : 	}
; 6092 : 
; 6093 : 	*pnChars = nBytes/sizeof(TCHAR);
; 6094 : 
; 6095 : 	return ERROR_SUCCESS;
; 6096 : }
; 6097 : ATLPREFAST_UNSUPPRESS()
; 6098 : 
; 6099 : ATLPREFAST_SUPPRESS(6053 6054 6386)
; 6100 : /* prefast noise VSW 496818 */
; 6101 : inline LSTATUS CRegKey::QueryMultiStringValue(
; 6102 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6103 : 	_Out_writes_to_opt_(*pnChars, *pnChars) LPTSTR pszValue,
; 6104 : 	_Inout_ ULONG* pnChars) throw()
; 6105 : {
; 6106 : 	LONG lRes;
; 6107 : 	DWORD dwType;
; 6108 : 	ULONG nBytes;
; 6109 : 
; 6110 : 	ATLASSUME(m_hKey != NULL);
; 6111 : 	ATLASSERT(pnChars != NULL);
; 6112 : 
; 6113 : 	if (pszValue != NULL && *pnChars < 2)
; 6114 : 		return ERROR_INSUFFICIENT_BUFFER;
; 6115 : 
; 6116 : 	nBytes = (*pnChars)*sizeof(TCHAR);
; 6117 : 	*pnChars = 0;
; 6118 : 
; 6119 : 	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(pszValue),
; 6120 : 		&nBytes);
; 6121 : 	if (lRes != ERROR_SUCCESS)
; 6122 : 		return lRes;
; 6123 : 	if (dwType != REG_MULTI_SZ)
; 6124 : 		return ERROR_INVALID_DATA;
; 6125 : 	if (pszValue != NULL && (nBytes % sizeof(TCHAR) != 0 || nBytes / sizeof(TCHAR) < 1 || pszValue[nBytes / sizeof(TCHAR) -1] != 0 || ((nBytes/sizeof(TCHAR))>1 && pszValue[nBytes / sizeof(TCHAR) - 2] != 0)))
; 6126 : 		return ERROR_INVALID_DATA;
; 6127 : 
; 6128 : 	*pnChars = nBytes/sizeof(TCHAR);
; 6129 : 
; 6130 : 	return ERROR_SUCCESS;
; 6131 : }
; 6132 : ATLPREFAST_UNSUPPRESS()
; 6133 : 
; 6134 : inline LSTATUS CRegKey::QueryGUIDValue(
; 6135 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6136 : 	_Out_ GUID& guidValue) throw()
; 6137 : {
; 6138 : 	TCHAR szGUID[64];
; 6139 : 	LONG lRes;
; 6140 : 	ULONG nCount;
; 6141 : 	HRESULT hr;
; 6142 : 
; 6143 : 	ATLASSUME(m_hKey != NULL);
; 6144 : 
; 6145 : 	guidValue = GUID_NULL;
; 6146 : 
; 6147 : 	nCount = 64;
; 6148 : 	lRes = QueryStringValue(pszValueName, szGUID, &nCount);
; 6149 : 
; 6150 : 	if (lRes != ERROR_SUCCESS)
; 6151 : 		return lRes;
; 6152 : 
; 6153 : 	if(szGUID[0] != _T('{'))
; 6154 : 		return ERROR_INVALID_DATA;
; 6155 : 
; 6156 : 	USES_CONVERSION_EX;
; 6157 : 	LPOLESTR lpstr = T2OLE_EX(szGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 6158 : #ifndef _UNICODE
; 6159 : 	if(lpstr == NULL)
; 6160 : 		return E_OUTOFMEMORY;
; 6161 : #endif
; 6162 : 
; 6163 : 	hr = ::CLSIDFromString(lpstr, &guidValue);
; 6164 : 	if (FAILED(hr))
; 6165 : 		return ERROR_INVALID_DATA;
; 6166 : 
; 6167 : 	return ERROR_SUCCESS;
; 6168 : }
; 6169 : 
; 6170 : inline LSTATUS WINAPI CRegKey::SetValue(
; 6171 : 	_In_ HKEY hKeyParent,
; 6172 : 	_In_z_ LPCTSTR lpszKeyName,
; 6173 : 	_In_opt_z_ LPCTSTR lpszValue,
; 6174 : 	_In_opt_z_ LPCTSTR lpszValueName)
; 6175 : {
; 6176 : 	ATLASSERT(lpszValue != NULL);
; 6177 : 	CRegKey key;
; 6178 : 	LONG lRes = key.Create(hKeyParent, lpszKeyName);
; 6179 : 	if (lRes == ERROR_SUCCESS)
; 6180 : 		lRes = key.SetStringValue(lpszValueName, lpszValue);
; 6181 : 	return lRes;
; 6182 : }
; 6183 : 
; 6184 : inline LSTATUS CRegKey::SetKeyValue(
; 6185 : 	_In_z_ LPCTSTR lpszKeyName,
; 6186 : 	_In_opt_z_ LPCTSTR lpszValue,
; 6187 : 	_In_opt_z_ LPCTSTR lpszValueName) throw()
; 6188 : {
; 6189 : 	ATLASSERT(lpszValue != NULL);
; 6190 : 	CRegKey key;
; 6191 : 	LONG lRes = key.Create(m_hKey, lpszKeyName, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE | m_samWOW64);
; 6192 : 	if (lRes == ERROR_SUCCESS)
; 6193 : 		lRes = key.SetStringValue(lpszValueName, lpszValue);
; 6194 : 	return lRes;
; 6195 : }
; 6196 : 
; 6197 : #pragma warning(push)  // disable 4996
; 6198 : #pragma warning(disable: 4996)
; 6199 : inline LSTATUS CRegKey::SetValue(
; 6200 : 	_In_ DWORD dwValue,
; 6201 : 	_In_opt_z_ LPCTSTR pszValueName)
; 6202 : {
; 6203 : 	ATLASSUME(m_hKey != NULL);
; 6204 : 	return SetDWORDValue(pszValueName, dwValue);
; 6205 : }
; 6206 : 
; 6207 : inline LSTATUS CRegKey::SetValue(
; 6208 : 	_In_z_ LPCTSTR lpszValue,
; 6209 : 	_In_opt_z_ LPCTSTR lpszValueName,
; 6210 : 	_In_ bool bMulti,
; 6211 : 	_In_ int nValueLen)
; 6212 : {
; 6213 : 	ATLENSURE(lpszValue != NULL);
; 6214 : 	ATLASSUME(m_hKey != NULL);
; 6215 : 
; 6216 : 	if (bMulti && nValueLen == -1)
; 6217 : 		return ERROR_INVALID_PARAMETER;
; 6218 : 
; 6219 : 	if (nValueLen == -1)
; 6220 : 		nValueLen = static_cast<int>(_tcslen(lpszValue) + 1);
; 6221 : 
; 6222 : 	DWORD dwType = bMulti ? REG_MULTI_SZ : REG_SZ;
; 6223 : 
; 6224 : 	return ::RegSetValueEx(m_hKey, lpszValueName, 0, dwType,
; 6225 : 		reinterpret_cast<const BYTE*>(lpszValue), nValueLen*sizeof(TCHAR));
; 6226 : }
; 6227 : #pragma warning(pop)  // disable 4996
; 6228 : 
; 6229 : inline LSTATUS CRegKey::SetValue(
; 6230 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6231 : 	_In_ DWORD dwType,
; 6232 : 	_In_opt_ const void* pValue,
; 6233 : 	_In_ ULONG nBytes) throw()
; 6234 : {
; 6235 : 	ATLASSUME(m_hKey != NULL);
; 6236 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, dwType, static_cast<const BYTE*>(pValue), nBytes);
; 6237 : }
; 6238 : 
; 6239 : inline LSTATUS CRegKey::SetBinaryValue(
; 6240 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6241 : 	_In_opt_ const void* pData,
; 6242 : 	_In_ ULONG nBytes) throw()
; 6243 : {
; 6244 : 	ATLASSUME(m_hKey != NULL);
; 6245 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_BINARY, reinterpret_cast<const BYTE*>(pData), nBytes);
; 6246 : }
; 6247 : 
; 6248 : inline LSTATUS CRegKey::SetDWORDValue(
; 6249 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6250 : 	_In_ DWORD dwValue) throw()
; 6251 : {
; 6252 : 	ATLASSUME(m_hKey != NULL);
; 6253 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_DWORD, reinterpret_cast<const BYTE*>(&dwValue), sizeof(DWORD));
; 6254 : }
; 6255 : 
; 6256 : inline LSTATUS CRegKey::SetQWORDValue(
; 6257 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6258 : 	_In_ ULONGLONG qwValue) throw()
; 6259 : {
; 6260 : 	ATLASSUME(m_hKey != NULL);
; 6261 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_QWORD, reinterpret_cast<const BYTE*>(&qwValue), sizeof(ULONGLONG));
; 6262 : }
; 6263 : 
; 6264 : inline LSTATUS CRegKey::SetStringValue(
; 6265 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6266 : 	_In_opt_z_ LPCTSTR pszValue,
; 6267 : 	_In_ DWORD dwType) throw()
; 6268 : {
; 6269 : 	ATLASSUME(m_hKey != NULL);
; 6270 : 	ATLENSURE_RETURN_VAL(pszValue != NULL, ERROR_INVALID_DATA);
; 6271 : 	ATLASSERT((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ));
; 6272 : 
; 6273 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, dwType, reinterpret_cast<const BYTE*>(pszValue), (static_cast<DWORD>(_tcslen(pszValue))+1)*sizeof(TCHAR));
; 6274 : }
; 6275 : 
; 6276 : inline LSTATUS CRegKey::SetMultiStringValue(
; 6277 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6278 : 	_In_z_ LPCTSTR pszValue) throw()
; 6279 : {
; 6280 : 	LPCTSTR pszTemp;
; 6281 : 	ULONG nBytes;
; 6282 : 	ULONG nLength;
; 6283 : 
; 6284 : 	ATLASSUME(m_hKey != NULL);
; 6285 : 	ATLENSURE_RETURN_VAL(pszValue != NULL, ERROR_INVALID_DATA);
; 6286 : 
; 6287 : 	// Find the total length (in bytes) of all of the strings, including the
; 6288 : 	// terminating '\0' of each string, and the second '\0' that terminates
; 6289 : 	// the list.
; 6290 : 	nBytes = 0;
; 6291 : 	pszTemp = pszValue;
; 6292 : 	do
; 6293 : 	{
; 6294 : 		nLength = static_cast<ULONG>(_tcslen(pszTemp))+1;
; 6295 : 		pszTemp += nLength;
; 6296 : 		nBytes += nLength*sizeof(TCHAR);
; 6297 : 	} while (nLength != 1);
; 6298 : 
; 6299 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_MULTI_SZ, reinterpret_cast<const BYTE*>(pszValue),
; 6300 : 		nBytes);
; 6301 : }
; 6302 : 
; 6303 : inline LSTATUS CRegKey::SetGUIDValue(
; 6304 : 	_In_opt_z_ LPCTSTR pszValueName,
; 6305 : 	_In_ REFGUID guidValue) throw()
; 6306 : {
; 6307 : 	OLECHAR szGUID[64];
; 6308 : 
; 6309 : 	ATLASSUME(m_hKey != NULL);
; 6310 : 
; 6311 : ATLPREFAST_SUPPRESS(6031)
; 6312 : 	::StringFromGUID2(guidValue, szGUID, 64);
; 6313 : ATLPREFAST_UNSUPPRESS()
; 6314 : 
; 6315 : 	USES_CONVERSION_EX;
; 6316 : 	LPCTSTR lpstr = OLE2CT_EX(szGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 6317 : #ifndef _UNICODE
; 6318 : 	if(lpstr == NULL)
; 6319 : 		return E_OUTOFMEMORY;
; 6320 : #endif
; 6321 : 	return SetStringValue(pszValueName, lpstr);
; 6322 : }
; 6323 : 
; 6324 : inline LSTATUS CRegKey::GetKeySecurity(
; 6325 : 	_In_ SECURITY_INFORMATION si,
; 6326 : 	_Out_opt_ PSECURITY_DESCRIPTOR psd,
; 6327 : 	_Inout_ LPDWORD pnBytes) throw()
; 6328 : {
; 6329 : 	ATLASSUME(m_hKey != NULL);
; 6330 : 	ATLASSUME(pnBytes != NULL);
; 6331 : 
; 6332 : 	return ::RegGetKeySecurity(m_hKey, si, psd, pnBytes);
; 6333 : }
; 6334 : 
; 6335 : inline LSTATUS CRegKey::SetKeySecurity(
; 6336 : 	_In_ SECURITY_INFORMATION si,
; 6337 : 	_In_ PSECURITY_DESCRIPTOR psd) throw()
; 6338 : {
; 6339 : 	ATLASSUME(m_hKey != NULL);
; 6340 : 	ATLASSUME(psd != NULL);
; 6341 : 
; 6342 : 	return ::RegSetKeySecurity(m_hKey, si, psd);
; 6343 : }
; 6344 : 
; 6345 : inline LSTATUS CRegKey::RecurseDeleteKey(_In_z_ LPCTSTR lpszKey) throw()
; 6346 : {
; 6347 : 	CRegKey key;
; 6348 : 	LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE | m_samWOW64);
; 6349 : 	if (lRes != ERROR_SUCCESS)
; 6350 : 	{
; 6351 : 		if (lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
; 6352 : 		{
; 6353 : 			ATLTRACE(atlTraceCOM, 0, _T("CRegKey::RecurseDeleteKey : Failed to Open Key %s(Error = %d)\n"), lpszKey, lRes);
; 6354 : 		}
; 6355 : 		return lRes;
; 6356 : 	}
; 6357 : 	FILETIME time;
; 6358 : 	DWORD dwSize = 256;
; 6359 : 	TCHAR szBuffer[256];
; 6360 : 	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
; 6361 : 		&time)==ERROR_SUCCESS)
; 6362 : 	{
; 6363 : 		lRes = key.RecurseDeleteKey(szBuffer);
; 6364 : 		if (lRes != ERROR_SUCCESS)
; 6365 : 			return lRes;
; 6366 : 		dwSize = 256;
; 6367 : 	}
; 6368 : 	key.Close();
; 6369 : 	return DeleteSubKey(lpszKey);
; 6370 : }
; 6371 : 
; 6372 : #ifndef _ATL_NO_COMMODULE
; 6373 : 
; 6374 : inline HRESULT CComModule::RegisterProgIDHelper(
; 6375 : 	_In_z_ LPCTSTR lpszCLSID,
; 6376 : 	_In_z_ LPCTSTR lpszProgID,
; 6377 : 	_In_opt_z_ LPCTSTR lpszCurVerProgID,
; 6378 : 	_In_z_ LPCTSTR lpszUserDesc,
; 6379 : 	_In_ BOOL bIsVerIndProgID)
; 6380 : {
; 6381 : 	CRegKey keyProgID;
; 6382 : 	LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE);
; 6383 : 	if (lRes == ERROR_SUCCESS)
; 6384 : 	{
; 6385 : 		lRes = keyProgID.SetStringValue(NULL, lpszUserDesc);
; 6386 : 		if (lRes == ERROR_SUCCESS)
; 6387 : 		{
; 6388 : 			lRes = keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
; 6389 : 			if (lRes == ERROR_SUCCESS)
; 6390 : 			{
; 6391 : 				lRes = bIsVerIndProgID ? keyProgID.SetKeyValue(_T("CurVer"), lpszCurVerProgID) : ERROR_SUCCESS;
; 6392 : 				if (lRes == ERROR_SUCCESS)
; 6393 : 					return S_OK;
; 6394 : 			}
; 6395 : 		}
; 6396 : 	}
; 6397 : 	return AtlHresultFromWin32(lRes);
; 6398 : }
; 6399 : 
; 6400 : inline HRESULT CComModule::RegisterProgID(
; 6401 : 	_In_z_ LPCTSTR lpszCLSID,
; 6402 : 	_In_z_ LPCTSTR lpszProgID,
; 6403 : 	_In_z_ LPCTSTR lpszUserDesc)
; 6404 : {
; 6405 : 	return RegisterProgIDHelper(lpszCLSID, lpszProgID, NULL, lpszUserDesc, FALSE);
; 6406 : }
; 6407 : 
; 6408 : inline HRESULT CComModule::RegisterVersionIndependentProgID(
; 6409 : 	_In_z_ LPCTSTR lpszCLSID,
; 6410 : 	_In_z_ LPCTSTR lpszVerIndProgID,
; 6411 : 	_In_z_ LPCTSTR lpszCurVerProgID,
; 6412 : 	_In_z_ LPCTSTR lpszUserDesc)
; 6413 : {
; 6414 : 	return RegisterProgIDHelper(lpszCLSID, lpszVerIndProgID, lpszCurVerProgID, lpszUserDesc, TRUE);
; 6415 : }
; 6416 : 
; 6417 : inline HRESULT CComModule::RegisterAppId(_In_z_ LPCTSTR pAppId)
; 6418 : {
; 6419 : 	CRegKey keyAppID;
; 6420 : 	HRESULT hr = S_OK;
; 6421 : 	LONG lRet;
; 6422 : 
; 6423 : 	if ( (lRet = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE)) == ERROR_SUCCESS)
; 6424 : 	{
; 6425 : 		TCHAR szModule1[MAX_PATH];
; 6426 : 		TCHAR szModule2[MAX_PATH];
; 6427 : 		TCHAR* pszFileName;
; 6428 : 
; 6429 : 		DWORD dwFLen = ::GetModuleFileName(GetModuleInstance(), szModule1, MAX_PATH);
; 6430 : 		if ( dwFLen != 0 && dwFLen != MAX_PATH )
; 6431 : 		{
; 6432 :             DWORD dwRet = ::GetFullPathName(szModule1, MAX_PATH, szModule2, &pszFileName);
; 6433 : 			if (dwRet != 0 && dwRet < MAX_PATH)
; 6434 : 			{
; 6435 : 				CRegKey keyAppIDEXE;
; 6436 : 				if ( (lRet = keyAppIDEXE.Create(keyAppID, pszFileName, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE)) == ERROR_SUCCESS)
; 6437 : 				{
; 6438 : 					lRet = keyAppIDEXE.SetStringValue(_T("AppID"), pAppId);
; 6439 : 					if (lRet != ERROR_SUCCESS)
; 6440 : 					{
; 6441 : 						ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to set app id string value\n"));
; 6442 : 						hr = AtlHresultFromWin32(lRet);
; 6443 : 						return hr;
; 6444 : 					}
; 6445 : 				}
; 6446 : 				else
; 6447 : 				{
; 6448 : 					ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to create file name key\n"));
; 6449 : 					hr = AtlHresultFromWin32(lRet);
; 6450 : 					return hr;
; 6451 : 				}
; 6452 : 				if ( (lRet = keyAppIDEXE.Create(keyAppID, pAppId, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE)) == ERROR_SUCCESS)
; 6453 : 				{
; 6454 : 					lRet = keyAppIDEXE.SetStringValue(NULL, pszFileName);
; 6455 : 					if (lRet != ERROR_SUCCESS)
; 6456 : 					{
; 6457 : 						ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to set file name string value\n"));
; 6458 : 						hr = AtlHresultFromWin32(lRet);
; 6459 : 						return hr;
; 6460 : 					}
; 6461 : 				}
; 6462 : 				else
; 6463 : 				{
; 6464 : 					ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to create app id key\n"));
; 6465 : 					hr = AtlHresultFromWin32(lRet);
; 6466 : 					return hr;
; 6467 : 				}
; 6468 : 			}
; 6469 : 			else
; 6470 : 			{
; 6471 : 				ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to get full path name for file %s\n"), szModule1);
; 6472 : 				hr = AtlHresultFromLastError();
; 6473 : 			}
; 6474 : 		}
; 6475 : 		else
; 6476 : 		{
; 6477 : 			ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to get module name\n"));
; 6478 : 			if( dwFLen == 0 )
; 6479 : 				hr = AtlHresultFromLastError();
; 6480 : 			else if( dwFLen == MAX_PATH )
; 6481 : 				hr =  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
; 6482 : 		}
; 6483 : 	}
; 6484 : 	else
; 6485 : 	{
; 6486 : 		ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to open registry key\n"));
; 6487 : 		hr = AtlHresultFromWin32(lRet);
; 6488 : 	}
; 6489 : 	return hr;
; 6490 : }
; 6491 : 
; 6492 : inline HRESULT CComModule::UnregisterAppId(_In_z_ LPCTSTR pAppId)
; 6493 : {
; 6494 : 	CRegKey keyAppID;
; 6495 : 	HRESULT hr = S_OK;
; 6496 : 	LONG lRet = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ | KEY_WRITE);
; 6497 : 
; 6498 : 	if (lRet == ERROR_SUCCESS)
; 6499 : 	{
; 6500 : 		TCHAR szModule1[MAX_PATH];
; 6501 : 		TCHAR szModule2[MAX_PATH];
; 6502 : 		TCHAR* pszFileName;
; 6503 : 
; 6504 : 		DWORD dwFLen = ::GetModuleFileName(GetModuleInstance(), szModule1, MAX_PATH);
; 6505 : 		if ( dwFLen != 0 && dwFLen != MAX_PATH )
; 6506 : 		{
; 6507 :             DWORD dwRet = ::GetFullPathName(szModule1, MAX_PATH, szModule2, &pszFileName);
; 6508 : 			if (dwRet != 0 && dwRet < MAX_PATH)
; 6509 : 			{
; 6510 : 				if ((lRet = keyAppID.RecurseDeleteKey(pAppId)) != ERROR_SUCCESS)
; 6511 : 				{
; 6512 : 					if (lRet != ERROR_FILE_NOT_FOUND)
; 6513 : 						hr = AtlHresultFromWin32(lRet);
; 6514 : 				}
; 6515 : 				if ((lRet = keyAppID.RecurseDeleteKey(pszFileName)) != ERROR_SUCCESS)
; 6516 : 				{
; 6517 : 					if (lRet != ERROR_FILE_NOT_FOUND)
; 6518 : 						hr = AtlHresultFromWin32(lRet);
; 6519 : 				}
; 6520 : 			}
; 6521 : 			else
; 6522 : 			{
; 6523 : 				ATLTRACE(atlTraceCOM, 0, _T("CComModule::UnregisterAppId : Failed to get full path name for file %s\n"), szModule1);
; 6524 : 				hr = AtlHresultFromLastError();
; 6525 : 			}
; 6526 : 		}
; 6527 : 		else
; 6528 : 		{
; 6529 : 			ATLTRACE(atlTraceCOM, 0, _T("CComModule::UnregisterAppId : Failed to get module name\n"));
; 6530 : 			if( dwFLen == 0 )
; 6531 : 				hr = AtlHresultFromLastError();
; 6532 : 			else if( dwFLen == MAX_PATH )
; 6533 : 				hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
; 6534 : 		}
; 6535 : 	}
; 6536 : 	else
; 6537 : 	{
; 6538 : 		if (lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
; 6539 : 		{
; 6540 : 			ATLTRACE(atlTraceCOM, 0, _T("CComModule::UnregisterAppId : Failed to open registry key\n"));
; 6541 : 			hr = AtlHresultFromWin32(lRet);
; 6542 : 		}
; 6543 : 	}
; 6544 : 	return hr;
; 6545 : }
; 6546 : #endif	// !_ATL_NO_COMMODULE
; 6547 : 
; 6548 : }	// namespace ATL
; 6549 : 
; 6550 : 
; 6551 : #include <statreg.h>
; 6552 : 
; 6553 : 
; 6554 : namespace ATL
; 6555 : {
; 6556 : #ifndef _ATL_STATIC_LIB_IMPL
; 6557 : 
; 6558 : #pragma warning(suppress: 6262) // Stack size of '2460' bytes is OK
; 6559 : inline HRESULT WINAPI CAtlModule::UpdateRegistryFromResource(
; 6560 : 	_In_z_ LPCTSTR lpszRes,
; 6561 : 	_In_ BOOL bRegister,
; 6562 : 	_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries /*= NULL*/) throw()
; 6563 : {
; 6564 : 	CRegObject ro;
; 6565 : 	HRESULT hr = ro.FinalConstruct();
; 6566 : 	if (FAILED(hr))
; 6567 : 	{
; 6568 : 		return hr;
; 6569 : 	}
; 6570 : 
; 6571 : 	if (pMapEntries != NULL)
; 6572 : 	{
; 6573 : 		while (pMapEntries->szKey != NULL)
; 6574 : 		{
; 6575 : 			ATLASSUME(NULL != pMapEntries->szData);
; 6576 : 			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
; 6577 : 			pMapEntries++;
; 6578 : 		}
; 6579 : 	}
; 6580 : 
; 6581 : 	hr = AddCommonRGSReplacements(&ro);
; 6582 : 	if (FAILED(hr))
; 6583 : 		return hr;
; 6584 : 
; 6585 : 	USES_CONVERSION_EX;
; 6586 : 	TCHAR szModule[MAX_PATH];
; 6587 : 	HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();
; 6588 : 	DWORD dwFLen = GetModuleFileName(hInst, szModule, MAX_PATH);
; 6589 : 	if( dwFLen == 0 )
; 6590 : 		return AtlHresultFromLastError();
; 6591 : 	else if( dwFLen == MAX_PATH )
; 6592 : 		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
; 6593 : 
; 6594 : 	LPOLESTR pszModule = NULL;
; 6595 : 	pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 6596 : #ifndef _UNICODE
; 6597 : 	if(pszModule == NULL)
; 6598 : 		return E_OUTOFMEMORY;
; 6599 : #endif
; 6600 : 
; 6601 : 	OLECHAR pszModuleUnquoted[_MAX_PATH * 2];
; 6602 : 	EscapeSingleQuote(pszModuleUnquoted, _countof(pszModuleUnquoted), pszModule);
; 6603 : 
; 6604 : 	HRESULT hRes;
; 6605 : 	if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE
; 6606 : 	{
; 6607 : 		// If Registering as an EXE, then we quote the resultant path.
; 6608 : 		// We don't do it for a DLL, because LoadLibrary fails if the path is
; 6609 : 		// quoted
; 6610 : 		OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2];
; 6611 : 		pszModuleQuote[0] = OLESTR('\"');
; 6612 : 		if(!ocscpy_s(pszModuleQuote + 1, (_MAX_PATH + _ATL_QUOTES_SPACE)*2 - 1, pszModuleUnquoted))
; 6613 : 		{
; 6614 : 			return E_FAIL;
; 6615 : 		}
; 6616 : 		size_t nLen = ocslen(pszModuleQuote);
; 6617 : 		pszModuleQuote[nLen] = OLESTR('\"');
; 6618 : 		pszModuleQuote[nLen + 1] = 0;
; 6619 : 
; 6620 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
; 6621 : 	}
; 6622 : 	else
; 6623 : 	{
; 6624 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleUnquoted);
; 6625 : 	}
; 6626 : 
; 6627 : 	if(FAILED(hRes))
; 6628 : 		return hRes;
; 6629 : 
; 6630 : 	hRes = ro.AddReplacement(OLESTR("Module_Raw"), pszModuleUnquoted);
; 6631 : 	if(FAILED(hRes))
; 6632 : 		return hRes;
; 6633 : 
; 6634 : 	LPCOLESTR szType = OLESTR("REGISTRY");
; 6635 : 	LPCOLESTR pszRes = T2COLE_EX(lpszRes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 6636 : #ifndef _UNICODE
; 6637 : 	if(pszRes == NULL)
; 6638 : 		return E_OUTOFMEMORY;
; 6639 : #endif
; 6640 : 	hr = (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
; 6641 : 		ro.ResourceUnregisterSz(pszModule, pszRes, szType);
; 6642 : 	return hr;
; 6643 : }
; 6644 : #pragma warning(suppress: 6262) // Stack size of '2456' bytes is OK
; 6645 : inline HRESULT WINAPI CAtlModule::UpdateRegistryFromResource(
; 6646 : 	_In_ UINT nResID,
; 6647 : 	_In_ BOOL bRegister,
; 6648 : 	_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries /*= NULL*/) throw()
; 6649 : {
; 6650 : 	CRegObject ro;
; 6651 : 	HRESULT hr = ro.FinalConstruct();
; 6652 : 	if (FAILED(hr))
; 6653 : 	{
; 6654 : 		return hr;
; 6655 : 	}
; 6656 : 
; 6657 : 	if (pMapEntries != NULL)
; 6658 : 	{
; 6659 : 		while (pMapEntries->szKey != NULL)
; 6660 : 		{
; 6661 : 			ATLASSUME(NULL != pMapEntries->szData);
; 6662 : 			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
; 6663 : 			pMapEntries++;
; 6664 : 		}
; 6665 : 	}
; 6666 : 
; 6667 : 	hr = AddCommonRGSReplacements(&ro);
; 6668 : 	if (FAILED(hr))
; 6669 : 		return hr;
; 6670 : 
; 6671 : 	USES_CONVERSION_EX;
; 6672 : 	TCHAR szModule[MAX_PATH];
; 6673 : 	HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();
; 6674 : 	DWORD dwFLen = GetModuleFileName(hInst, szModule, MAX_PATH);
; 6675 : 	if( dwFLen == 0 )
; 6676 : 		return AtlHresultFromLastError();
; 6677 : 	else if( dwFLen == MAX_PATH )
; 6678 : 		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
; 6679 : 
; 6680 : 	LPOLESTR pszModule = NULL;
; 6681 : 	pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 6682 : #ifndef _UNICODE
; 6683 : 	if(pszModule == NULL)
; 6684 : 		return E_OUTOFMEMORY;
; 6685 : #endif
; 6686 : 
; 6687 : 	OLECHAR pszModuleUnquoted[_MAX_PATH * 2];
; 6688 : 	EscapeSingleQuote(pszModuleUnquoted, _countof(pszModuleUnquoted), pszModule);
; 6689 : 
; 6690 : 	HRESULT hRes;
; 6691 : 	if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE
; 6692 : 	{
; 6693 : 		// If Registering as an EXE, then we quote the resultant path.
; 6694 : 		// We don't do it for a DLL, because LoadLibrary fails if the path is
; 6695 : 		// quoted
; 6696 : 		OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2];
; 6697 : 		pszModuleQuote[0] = OLESTR('\"');
; 6698 : 		if(!ocscpy_s(pszModuleQuote + 1, (_MAX_PATH + _ATL_QUOTES_SPACE)*2 - 1, pszModuleUnquoted))
; 6699 : 		{
; 6700 : 			return E_FAIL;
; 6701 : 		}
; 6702 : 		size_t nLen = ocslen(pszModuleQuote);
; 6703 : 		pszModuleQuote[nLen] = OLESTR('\"');
; 6704 : 		pszModuleQuote[nLen + 1] = 0;
; 6705 : 
; 6706 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
; 6707 : 	}
; 6708 : 	else
; 6709 : 	{
; 6710 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleUnquoted);
; 6711 : 	}
; 6712 : 
; 6713 : 	if(FAILED(hRes))
; 6714 : 		return hRes;
; 6715 : 
; 6716 : 	hRes = ro.AddReplacement(OLESTR("Module_Raw"), pszModuleUnquoted);
; 6717 : 	if(FAILED(hRes))
; 6718 : 		return hRes;
; 6719 : 
; 6720 : 	LPCOLESTR szType = OLESTR("REGISTRY");
; 6721 : 	hr = (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
; 6722 : 		ro.ResourceUnregister(pszModule, nResID, szType);
; 6723 : 	return hr;
; 6724 : }
; 6725 : #endif // _ATL_STATIC_LIB_IMPL
; 6726 : 
; 6727 : #ifndef _ATL_NO_COMMODULE
; 6728 : 
; 6729 : #pragma warning( push )  // disable 4996
; 6730 : #pragma warning( disable: 4996 )  // Disable "deprecated symbol" warning
; 6731 : 
; 6732 : inline HRESULT WINAPI CComModule::UpdateRegistryClass(
; 6733 : 	_In_ const CLSID& clsid,
; 6734 : 	_In_opt_z_ LPCTSTR lpszProgID,
; 6735 : 	_In_opt_z_ LPCTSTR lpszVerIndProgID,
; 6736 : 	_In_ UINT nDescID,
; 6737 : 	_In_ DWORD dwFlags,
; 6738 : 	_In_ BOOL bRegister)
; 6739 : {
; 6740 : 	if (bRegister)
; 6741 : 	{
; 6742 : 		TCHAR szDesc[256];
; 6743 : 		LoadString(m_hInst, nDescID, szDesc, 256);
; 6744 : 		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, szDesc, dwFlags);
; 6745 : 	}
; 6746 : 	return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
; 6747 : }
; 6748 : 
; 6749 : inline HRESULT WINAPI CComModule::UpdateRegistryClass(
; 6750 : 	_In_ const CLSID& clsid,
; 6751 : 	_In_opt_z_ LPCTSTR lpszProgID,
; 6752 : 	_In_opt_z_ LPCTSTR lpszVerIndProgID,
; 6753 : 	_In_z_ LPCTSTR szDesc,
; 6754 : 	_In_ DWORD dwFlags,
; 6755 : 	_In_ BOOL bRegister)
; 6756 : {
; 6757 : 	if (bRegister)
; 6758 : 		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, szDesc, dwFlags);
; 6759 : 	return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
; 6760 : }
; 6761 : 
; 6762 : ATLPREFAST_SUPPRESS(6102 6386)
; 6763 : inline HRESULT WINAPI CComModule::RegisterClassHelper(
; 6764 : 	_In_ const CLSID& clsid,
; 6765 : 	_In_opt_z_ LPCTSTR lpszProgID,
; 6766 : 	_In_opt_z_ LPCTSTR lpszVerIndProgID,
; 6767 : 	_In_z_ LPCTSTR szDesc,
; 6768 : 	_In_ DWORD dwFlags)
; 6769 : {
; 6770 : 	static const TCHAR szProgID[] = _T("ProgID");
; 6771 : 	static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
; 6772 : 	static const TCHAR szLS32[] = _T("LocalServer32");
; 6773 : 	static const TCHAR szIPS32[] = _T("InprocServer32");
; 6774 : 	static const TCHAR szThreadingModel[] = _T("ThreadingModel");
; 6775 : 	static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
; 6776 : 	static const TCHAR szApartment[] = _T("Apartment");
; 6777 : 	static const TCHAR szBoth[] = _T("both");
; 6778 : 	USES_CONVERSION_EX;
; 6779 : 	TCHAR szModule[_MAX_PATH + _ATL_QUOTES_SPACE];
; 6780 : 
; 6781 : 	ATLENSURE(lpszProgID && lpszVerIndProgID || !lpszProgID && !lpszVerIndProgID);
; 6782 : 
; 6783 : 	if (!szDesc)
; 6784 : 	{
; 6785 : 		szDesc = _T("");
; 6786 : 	}
; 6787 : 
; 6788 : 	// If the ModuleFileName's length is equal or greater than the 3rd parameter
; 6789 : 	// (length of the buffer passed),GetModuleFileName fills the buffer (truncates
; 6790 : 	// if neccessary), but doesn't null terminate it. It returns the same value as
; 6791 : 	// the 3rd parameter passed. So if the return value is the same as the 3rd param
; 6792 : 	// then you have a non null terminated buffer (which may or may not be truncated)
; 6793 : 	// We pass (szModule + 1) because in case it's an EXE we need to quote the PATH
; 6794 : 	// The quote is done later in this method before the SetKeyValue is called
; 6795 : 	DWORD dwLen = GetModuleFileName(m_hInst, szModule + 1, MAX_PATH);
; 6796 : 	if (dwLen == 0)
; 6797 : 	{
; 6798 : 		return AtlHresultFromLastError();
; 6799 : 	}
; 6800 : 	else if( dwLen == MAX_PATH )
; 6801 : 	{
; 6802 : 		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
; 6803 : 	}
; 6804 : 
; 6805 : 	LPOLESTR lpOleStr;
; 6806 : 	HRESULT hRes = StringFromCLSID(clsid, &lpOleStr);
; 6807 : 	if (FAILED(hRes))
; 6808 : 		return hRes;
; 6809 : 
; 6810 : 	LPTSTR lpszCLSID = OLE2T_EX(lpOleStr, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 6811 : #ifndef _UNICODE
; 6812 : 	if(lpszCLSID == NULL)
; 6813 : 	{
; 6814 : 		CoTaskMemFree(lpOleStr);
; 6815 : 		return E_OUTOFMEMORY;
; 6816 : 	}
; 6817 : #endif
; 6818 : 
; 6819 : 	hRes = lpszProgID ? RegisterProgID(lpszCLSID, lpszProgID, szDesc) : S_OK;
; 6820 : 	if (hRes == S_OK)
; 6821 : 	{
; 6822 : 		// use lpszProgID as the CurVer ProgID
; 6823 : 		hRes = lpszVerIndProgID ? RegisterVersionIndependentProgID(lpszCLSID, lpszVerIndProgID, lpszProgID, szDesc) : S_OK;
; 6824 : 	}
; 6825 : 	LONG lRes = ERROR_SUCCESS;
; 6826 : 	if (hRes == S_OK)
; 6827 : 	{
; 6828 : 		CRegKey key;
; 6829 : 		lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ | KEY_WRITE);
; 6830 : 		if (lRes == ERROR_SUCCESS)
; 6831 : 		{
; 6832 : 			lRes = key.Create(key, lpszCLSID, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);
; 6833 : 			if (lRes == ERROR_SUCCESS)
; 6834 : 			{
; 6835 : 				lRes = key.SetStringValue(NULL, szDesc);
; 6836 : 				if (lRes == ERROR_SUCCESS)
; 6837 : 				{
; 6838 : 					lRes = lpszProgID ? key.SetKeyValue(szProgID, lpszProgID) : ERROR_SUCCESS;
; 6839 : 					if (lRes == ERROR_SUCCESS)
; 6840 : 					{
; 6841 : 						lRes = lpszVerIndProgID ? key.SetKeyValue(szVIProgID, lpszVerIndProgID) : ERROR_SUCCESS;
; 6842 : 						if (lRes == ERROR_SUCCESS)
; 6843 : 						{
; 6844 : 							if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
; 6845 : 							{
; 6846 : 								// If Registering as an EXE, then we quote the resultant path.
; 6847 : 								// We don't do it for a DLL, because LoadLibrary fails if the path is
; 6848 : 								// quoted
; 6849 : 								szModule[0] = _T('\"');
; 6850 : 								szModule[dwLen + 1] = _T('\"');
; 6851 : 								szModule[dwLen + 2] = 0;
; 6852 : 
; 6853 : 								lRes = key.SetKeyValue(szLS32, szModule);
; 6854 : 							}
; 6855 : 							else
; 6856 : 							{
; 6857 : 								lRes = key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule + 1);
; 6858 : 								if (lRes == ERROR_SUCCESS)
; 6859 : 								{
; 6860 : 									LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
; 6861 : 										(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
; 6862 : 									if (lpszModel != NULL)
; 6863 : 										lRes = key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
; 6864 : 								}
; 6865 : 							}
; 6866 : 						}
; 6867 : 					}
; 6868 : 				}
; 6869 : 			}
; 6870 : 		}
; 6871 : 	}
; 6872 : 	CoTaskMemFree(lpOleStr);
; 6873 : 	if (lRes != ERROR_SUCCESS)
; 6874 : 		hRes = AtlHresultFromWin32(lRes);
; 6875 : 	return hRes;
; 6876 : }
; 6877 : ATLPREFAST_UNSUPPRESS()
; 6878 : 
; 6879 : inline HRESULT WINAPI CComModule::UnregisterClassHelper(
; 6880 : 	_In_ const CLSID& clsid,
; 6881 : 	_In_opt_z_ LPCTSTR lpszProgID,
; 6882 : 	_In_opt_z_ LPCTSTR lpszVerIndProgID)
; 6883 : {
; 6884 : 	USES_CONVERSION_EX;
; 6885 : 	CRegKey key;
; 6886 : 	LONG lRet;
; 6887 : 
; 6888 : 	key.Attach(HKEY_CLASSES_ROOT);
; 6889 : 	if (lpszProgID != NULL && lpszProgID[0]!=_T('\0'))
; 6890 : 	{
; 6891 : 		lRet = key.RecurseDeleteKey(lpszProgID);
; 6892 : 		if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
; 6893 : 		{
; 6894 : 			ATLTRACE(atlTraceCOM, 0, _T("Failed to Unregister ProgID : %s\n"), lpszProgID);
; 6895 : 			key.Detach();
; 6896 : 			return AtlHresultFromWin32(lRet);
; 6897 : 		}
; 6898 : 	}
; 6899 : 	if (lpszVerIndProgID != NULL && lpszVerIndProgID[0]!=_T('\0'))
; 6900 : 	{
; 6901 : 		lRet = key.RecurseDeleteKey(lpszVerIndProgID);
; 6902 : 		if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
; 6903 : 		{
; 6904 : 			ATLTRACE(atlTraceCOM, 0, _T("Failed to Unregister Version Independent ProgID : %s\n"), lpszVerIndProgID);
; 6905 : 			key.Detach();
; 6906 : 			return AtlHresultFromWin32(lRet);
; 6907 : 		}
; 6908 : 	}
; 6909 : 	LPOLESTR lpOleStr;
; 6910 : 	HRESULT hr = StringFromCLSID(clsid, &lpOleStr);
; 6911 : 	if (SUCCEEDED(hr))
; 6912 : 	{
; 6913 : 		LPTSTR lpsz = OLE2T_EX(lpOleStr, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 6914 : #ifndef _UNICODE
; 6915 : 		if(lpsz == NULL)
; 6916 : 		{
; 6917 : 			CoTaskMemFree(lpOleStr);
; 6918 : 			return E_OUTOFMEMORY;
; 6919 : 		}
; 6920 : #endif
; 6921 : 
; 6922 : 		lRet = key.Open(key, _T("CLSID"), KEY_READ | KEY_WRITE);
; 6923 : 		if (lRet == ERROR_SUCCESS)
; 6924 : 			lRet = key.RecurseDeleteKey(lpsz);
; 6925 : 		if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
; 6926 : 		{
; 6927 : 			ATLTRACE(atlTraceCOM, 0, _T("Failed to delete CLSID : %s\n"), lpsz);
; 6928 : 			hr = AtlHresultFromWin32(lRet);
; 6929 : 		}
; 6930 : 		CoTaskMemFree(lpOleStr);
; 6931 : 	}
; 6932 : 	else
; 6933 : 	{
; 6934 : 		ATLTRACE(atlTraceCOM, 0, _T("Failed to delete CLSID : {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
; 6935 : 			clsid.Data1,
; 6936 : 			clsid.Data2,
; 6937 : 			clsid.Data3,
; 6938 : 			clsid.Data4[0],
; 6939 : 			clsid.Data4[1],
; 6940 : 			clsid.Data4[2],
; 6941 : 			clsid.Data4[3],
; 6942 : 			clsid.Data4[4],
; 6943 : 			clsid.Data4[5],
; 6944 : 			clsid.Data4[6],
; 6945 : 			clsid.Data4[7]
; 6946 : 			);
; 6947 : 	}
; 6948 : 	key.Detach();
; 6949 : 	return hr;
; 6950 : }
; 6951 : 
; 6952 : #pragma warning( pop )  // disable 4996
; 6953 : 
; 6954 : #endif	// !_ATL_NO_COMMODULE
; 6955 : 
; 6956 : #ifdef _ATL_DEBUG_INTERFACES
; 6957 : 
; 6958 : inline void _QIThunk::Dump() throw()
; 6959 : {
; 6960 : 	TCHAR buf[512+1];
; 6961 : 	if (m_dwRef != 0)
; 6962 : 	{
; 6963 : 		_stprintf_s(buf, _countof(buf), _T("ATL: QIThunk - %-10d\tLEAK    :\tObject = 0x%p\tRefcount = %d\tMaxRefCount = %d\t"),
; 6964 : 			m_nIndex, m_pUnk, m_dwRef, m_dwMaxRef);
; 6965 : 		buf[_countof(buf)-1] = 0;
; 6966 : 		OutputDebugString(buf);
; 6967 : 		AtlDumpIID(m_iid, m_lpszClassName, S_OK);
; 6968 : 	}
; 6969 : 	else
; 6970 : 	{
; 6971 : 		_stprintf_s(buf, _countof(buf), _T("ATL: QIThunk - %-10d\tNonAddRef LEAK :\tObject = 0x%p\t"), m_nIndex, m_pUnk);
; 6972 : 		buf[_countof(buf)-1] = 0;
; 6973 : 		OutputDebugString(buf);
; 6974 : 		AtlDumpIID(m_iid, m_lpszClassName, S_OK);
; 6975 : 	}
; 6976 : }
; 6977 : 
; 6978 : #endif	// _ATL_DEBUG_INTERFACES
; 6979 : 
; 6980 : #if defined(_ATL_DEBUG_INTERFACES) || defined(_ATL_DEBUG_QI)
; 6981 : __forceinline HRESULT WINAPI AtlDumpIID(
; 6982 : 	_In_ REFIID iid,
; 6983 : 	_In_z_ LPCTSTR pszClassName,
; 6984 : 	_In_ HRESULT hr) throw()
; 6985 : {
; 6986 : 	USES_CONVERSION_EX;
; 6987 : 	CRegKey key;
; 6988 : 	TCHAR szName[100];
; 6989 : 	DWORD dwType;
; 6990 : 	DWORD dw = sizeof(szName);
; 6991 : 
; 6992 : 	LPOLESTR pszGUID = NULL;
; 6993 : 	if (FAILED(StringFromCLSID(iid, &pszGUID)))
; 6994 : 		return hr;
; 6995 : 
; 6996 : 	OutputDebugString(pszClassName);
; 6997 : 	OutputDebugString(_T(" - "));
; 6998 : 
; 6999 : 	LPTSTR lpszGUID = OLE2T_EX(pszGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 7000 : #ifndef _UNICODE
; 7001 : 	if(lpszGUID == NULL)
; 7002 : 	{
; 7003 : 		CoTaskMemFree(pszGUID);
; 7004 : 		return hr;
; 7005 : 	}
; 7006 : #endif
; 7007 : 	// Attempt to find it in the interfaces section
; 7008 : 	BOOL fClsNameFound = FALSE;
; 7009 : 	if (key.Open(HKEY_CLASSES_ROOT, _T("Interface"), KEY_READ) == ERROR_SUCCESS)
; 7010 : 	{
; 7011 : 		if (key.Open(key, lpszGUID, KEY_READ) == ERROR_SUCCESS)
; 7012 : 		{
; 7013 : 			*szName = 0;
; 7014 : 			if (RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw) == ERROR_SUCCESS)
; 7015 : 			{
; 7016 : 				OutputDebugString(szName);
; 7017 : 				fClsNameFound = TRUE;
; 7018 : 			}
; 7019 : 		}
; 7020 : 	}
; 7021 : 	// Attempt to find it in the clsid section
; 7022 : 	if ( !fClsNameFound && key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ) == ERROR_SUCCESS)
; 7023 : 	{
; 7024 : 		if (key.Open(key, lpszGUID, KEY_READ) == ERROR_SUCCESS)
; 7025 : 		{
; 7026 : 			*szName = 0;
; 7027 : 			if (RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw) == ERROR_SUCCESS)
; 7028 : 			{
; 7029 : 				OutputDebugString(_T("(CLSID\?\?\?) "));
; 7030 : 				OutputDebugString(szName);
; 7031 : 				fClsNameFound = TRUE;
; 7032 : 			}
; 7033 : 		}
; 7034 : 	}
; 7035 : 	/*Dump out the GUID only if no class name found*/
; 7036 : 	if( !fClsNameFound )
; 7037 : 		OutputDebugString(lpszGUID);
; 7038 : 
; 7039 : 	if (hr != S_OK)
; 7040 : 		OutputDebugString(_T(" - failed"));
; 7041 : 	OutputDebugString(_T("\n"));
; 7042 : 	CoTaskMemFree(pszGUID);
; 7043 : 
; 7044 : 	return hr;
; 7045 : }
; 7046 : #endif	// _ATL_DEBUG_INTERFACES || _ATL_DEBUG_QI
; 7047 : 
; 7048 : 
; 7049 : // WM_FORWARDMSG - used to forward a message to another window for processing
; 7050 : // WPARAM - DWORD dwUserData - defined by user
; 7051 : // LPARAM - LPMSG pMsg - a pointer to the MSG structure
; 7052 : // return value - 0 if the message was not processed, nonzero if it was
; 7053 : #define WM_FORWARDMSG       0x037F
; 7054 : 
; 7055 : }; //namespace ATL
; 7056 : 
; 7057 : #ifndef _ATL_NO_AUTOMATIC_NAMESPACE
; 7058 : using namespace ATL;
; 7059 : #endif //!_ATL_NO_AUTOMATIC_NAMESPACE
; 7060 : 
; 7061 : #ifdef _ATL_ATTRIBUTES
; 7062 : #include <atlplus.h>
; 7063 : #endif
; 7064 : 
; 7065 : namespace ATL
; 7066 : {
; 7067 : 
; 7068 : /////////////////////////////////////////////////////////////////////////////
; 7069 : // statics
; 7070 : 
; 7071 : 	static inline LPTSTR AtlFindExtension(_In_z_ LPCTSTR psz)
; 7072 : 	{
; 7073 : 		if (psz == NULL)
; 7074 : 			return NULL;
; 7075 : 		LPCTSTR pszRemember = NULL;
; 7076 : 		while (*psz != _T('\0'))
; 7077 : 		{
; 7078 : 			switch (*psz)
; 7079 : 			{
; 7080 : 			case _T('\\'):
; 7081 : 				pszRemember = NULL;
; 7082 : 				break;
; 7083 : 			case _T('.'):
; 7084 : 				pszRemember = psz;
; 7085 : 				break;
; 7086 : 			default:
; 7087 : 				break;
; 7088 : 			}
; 7089 : 			psz = CharNext(psz);
; 7090 : 		}
; 7091 : 		return (LPTSTR) ((pszRemember == NULL) ? psz : pszRemember);
; 7092 : 	}
; 7093 : 
; 7094 : /////////////////////////////////////////////////////////////////////////////
; 7095 : // Per User Registration
; 7096 : 
; 7097 : ATLINLINE ATLAPI AtlSetPerUserRegistration(_In_ bool bEnable)
; 7098 : {
; 7099 : 	_AtlRegisterPerUser = bEnable;
; 7100 : 	return S_OK;
; 7101 : }
; 7102 : 
; 7103 : ATLINLINE ATLAPI AtlGetPerUserRegistration(_Out_ bool* pbEnabled)
; 7104 : {
; 7105 : 	if (pbEnabled == NULL)
; 7106 : 		return E_POINTER;
; 7107 : 
; 7108 : 	*pbEnabled = _AtlRegisterPerUser;
; 7109 : 	return S_OK;
; 7110 : }
; 7111 : 
; 7112 : /////////////////////////////////////////////////////////////////////////////
; 7113 : // TypeLib registration
; 7114 : 
; 7115 : #define _ATL_MAX_PATH_PLUS_INDEX (_MAX_PATH + _ATL_TYPELIB_INDEX_LENGTH)
; 7116 : 
; 7117 : ATLINLINE ATLAPI AtlLoadTypeLib(
; 7118 : 	_In_ HINSTANCE hInstTypeLib,
; 7119 : 	_In_opt_z_ LPCOLESTR lpszIndex,
; 7120 : 	_Outptr_result_z_ BSTR* pbstrPath,
; 7121 : 	_Outptr_ ITypeLib** ppTypeLib)
; 7122 : {
; 7123 : 	ATLASSERT(pbstrPath != NULL && ppTypeLib != NULL);
; 7124 : 	if (pbstrPath == NULL || ppTypeLib == NULL)
; 7125 : 		return E_POINTER;
; 7126 : 
; 7127 : 	*pbstrPath = NULL;
; 7128 : 	*ppTypeLib = NULL;
; 7129 : 
; 7130 : 	USES_CONVERSION_EX;
; 7131 : 	ATLASSERT(hInstTypeLib != NULL);
; 7132 : 	TCHAR szModule[_ATL_MAX_PATH_PLUS_INDEX];
; 7133 : 
; 7134 : 	DWORD dwFLen = GetModuleFileName(hInstTypeLib, szModule, MAX_PATH);
; 7135 : 	if( dwFLen == 0 )
; 7136 : 	{
; 7137 : 		HRESULT hRes = AtlHresultFromLastError();
; 7138 : 		_Analysis_assume_(FAILED(hRes));
; 7139 : 		return hRes;
; 7140 : 	}
; 7141 : 	else if( dwFLen == MAX_PATH )
; 7142 : 		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
; 7143 : 
; 7144 : 	// get the extension pointer in case of fail
; 7145 : 	LPTSTR lpszExt = NULL;
; 7146 : 
; 7147 : 	lpszExt = AtlFindExtension(szModule);
; 7148 : 
; 7149 : 	if (lpszIndex != NULL)
; 7150 : 	{
; 7151 : 		LPCTSTR lpcszIndex = OLE2CT_EX(lpszIndex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 7152 : 		if(lpcszIndex == NULL)
; 7153 : 		{
; 7154 : 			return E_OUTOFMEMORY;
; 7155 : 		}
; 7156 : 		DWORD nIndexLen = static_cast<DWORD>(_tcslen(lpcszIndex));
; 7157 : 
; 7158 : 		DWORD newLen = dwFLen + nIndexLen;
; 7159 : 		if ((newLen < dwFLen) || (newLen < nIndexLen) || (newLen >= _ATL_MAX_PATH_PLUS_INDEX))
; 7160 : 			return E_FAIL;
; 7161 : #ifdef UNICODE
; 7162 : 		Checked::wcscpy_s(szModule + dwFLen, _countof(szModule) - dwFLen, lpcszIndex);
; 7163 : #else
; 7164 : 		Checked::strcpy_s(szModule + dwFLen, _countof(szModule) - dwFLen, lpcszIndex);
; 7165 : #endif
; 7166 : 	}
; 7167 : 	LPOLESTR lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 7168 : #ifndef _UNICODE
; 7169 : 	if(lpszModule == NULL)
; 7170 : 		return E_OUTOFMEMORY;
; 7171 : #endif
; 7172 : 	HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);
; 7173 : 	if (FAILED(hr))
; 7174 : 	{
; 7175 : 		// typelib not in module, try <module>.tlb instead
; 7176 : 		TCHAR szExt[] = _T(".tlb");
; 7177 : 		if ((lpszExt - szModule + sizeof(szExt)/sizeof(TCHAR)) > _MAX_PATH)
; 7178 : 			return E_FAIL;
; 7179 : 
; 7180 : #ifdef UNICODE
; 7181 : 		Checked::wcscpy_s(lpszExt, _countof(szModule) - (lpszExt - szModule), szExt);
; 7182 : #else
; 7183 : 		Checked::strcpy_s(lpszExt, _countof(szModule) - (lpszExt - szModule), szExt);
; 7184 : #endif
; 7185 : 		lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 7186 : #ifndef _UNICODE
; 7187 : 		if(lpszModule == NULL)
; 7188 : 			return E_OUTOFMEMORY;
; 7189 : #endif
; 7190 : 		hr = LoadTypeLib(lpszModule, ppTypeLib);
; 7191 : 	}
; 7192 : 	if (SUCCEEDED(hr))
; 7193 : 	{
; 7194 : 		*pbstrPath = ::SysAllocString(lpszModule);
; 7195 : 		if (*pbstrPath == NULL)
; 7196 : 		{
; 7197 : 			hr = E_OUTOFMEMORY;
; 7198 : 			(*ppTypeLib)->Release();
; 7199 : 			*ppTypeLib = NULL;
; 7200 : 		}
; 7201 : 	}
; 7202 : 	return hr;
; 7203 : }
; 7204 : 
; 7205 : ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper(
; 7206 : 	_In_ REFCLSID clsid,
; 7207 :     _In_opt_ const struct _ATL_CATMAP_ENTRY* pCatMap,
; 7208 : 	_In_ BOOL bRegister)
; 7209 : {
; 7210 :    CComPtr< ICatRegister > pCatRegister;
; 7211 :    HRESULT hResult;
; 7212 :    const struct _ATL_CATMAP_ENTRY* pEntry;
; 7213 :    CATID catid;
; 7214 : 
; 7215 :    if( pCatMap == NULL )
; 7216 :    {
; 7217 : 	  return( S_OK );
; 7218 :    }
; 7219 : 
; 7220 :    if (InlineIsEqualGUID(clsid, GUID_NULL))
; 7221 :    {
; 7222 : 	  ATLASSERT(0 && _T("Use OBJECT_ENTRY_NON_CREATEABLE_EX macro if you want to register class categories for non creatable objects."));
; 7223 : 	  return S_OK;
; 7224 :    }
; 7225 : 
; 7226 :    hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,
; 7227 : 	  CLSCTX_INPROC_SERVER, __uuidof(ICatRegister), (void**)&pCatRegister );
; 7228 :    if( FAILED( hResult ) )
; 7229 :    {
; 7230 : 	  // Since not all systems have the category manager installed, we'll allow
; 7231 : 	  // the registration to succeed even though we didn't register our
; 7232 : 	  // categories.  If you really want to register categories on a system
; 7233 : 	  // without the category manager, you can either manually add the
; 7234 : 	  // appropriate entries to your registry script (.rgs), or you can
; 7235 : 	  // redistribute comcat.dll.
; 7236 : 	  return( S_OK );
; 7237 :    }
; 7238 : 
; 7239 :    hResult = S_OK;
; 7240 :    pEntry = pCatMap;
; 7241 :    while( pEntry->iType != _ATL_CATMAP_ENTRY_END )
; 7242 :    {
; 7243 : 	  catid = *pEntry->pcatid;
; 7244 : 	  if( bRegister )
; 7245 : 	  {
; 7246 : 		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
; 7247 : 		 {
; 7248 : 			hResult = pCatRegister->RegisterClassImplCategories( clsid, 1,
; 7249 : 			   &catid );
; 7250 : 		 }
; 7251 : 		 else
; 7252 : 		 {
; 7253 : 			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
; 7254 : 			hResult = pCatRegister->RegisterClassReqCategories( clsid, 1,
; 7255 : 			   &catid );
; 7256 : 		 }
; 7257 : 		 if( FAILED( hResult ) )
; 7258 : 		 {
; 7259 : 			return( hResult );
; 7260 : 		 }
; 7261 : 	  }
; 7262 : 	  else
; 7263 : 	  {
; 7264 : 		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
; 7265 : 		 {
; 7266 : 			pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );
; 7267 : 		 }
; 7268 : 		 else
; 7269 : 		 {
; 7270 : 			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
; 7271 : 			pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );
; 7272 : 		 }
; 7273 : 	  }
; 7274 : 	  pEntry++;
; 7275 :    }
; 7276 : 
; 7277 :    // When unregistering remove "Implemented Categories" and "Required Categories" subkeys if they are empty.
; 7278 :    if (!bRegister)
; 7279 :    {
; 7280 : 		OLECHAR szGUID[64];
; 7281 : ATLPREFAST_SUPPRESS(6031)
; 7282 : 		::StringFromGUID2(clsid, szGUID, 64);
; 7283 : ATLPREFAST_UNSUPPRESS()
; 7284 : 		USES_CONVERSION_EX;
; 7285 : 		TCHAR* pszGUID = OLE2T_EX(szGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 7286 : 		if (pszGUID != NULL)
; 7287 : 		{
; 7288 : 			TCHAR szKey[128];
; 7289 : #ifdef UNICODE
; 7290 : 			Checked::wcscpy_s(szKey, _countof(szKey), _T("CLSID\\"));
; 7291 : 			Checked::wcscat_s(szKey, _countof(szKey), pszGUID);
; 7292 : 			Checked::wcscat_s(szKey, _countof(szKey), _T("\\Required Categories"));
; 7293 : #else
; 7294 : 			Checked::strcpy_s(szKey, _countof(szKey), _T("CLSID\\"));
; 7295 : 			Checked::strcat_s(szKey, _countof(szKey), pszGUID);
; 7296 : 			Checked::strcat_s(szKey, _countof(szKey), _T("\\Required Categories"));
; 7297 : #endif
; 7298 : 
; 7299 : 			CRegKey root(HKEY_CLASSES_ROOT);
; 7300 : 			CRegKey key;
; 7301 : 			DWORD cbSubKeys = 0;
; 7302 : 
; 7303 : 			LRESULT lRes = key.Open(root, szKey, KEY_READ);
; 7304 : 			if (lRes == ERROR_SUCCESS)
; 7305 : 			{
; 7306 : 				lRes = RegQueryInfoKey(key, NULL, NULL, NULL, &cbSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
; 7307 : 				key.Close();
; 7308 : 				if (lRes == ERROR_SUCCESS && cbSubKeys == 0)
; 7309 : 				{
; 7310 : 					root.DeleteSubKey(szKey);
; 7311 : 				}
; 7312 : 			}
; 7313 : 
; 7314 : #ifdef UNICODE
; 7315 : 			Checked::wcscpy_s(szKey, _countof(szKey), _T("CLSID\\"));
; 7316 : 			Checked::wcscat_s(szKey, _countof(szKey), pszGUID);
; 7317 : 			Checked::wcscat_s(szKey, _countof(szKey), _T("\\Implemented Categories"));
; 7318 : #else
; 7319 : 			Checked::strcpy_s(szKey, _countof(szKey), _T("CLSID\\"));
; 7320 : 			Checked::strcat_s(szKey, _countof(szKey), pszGUID);
; 7321 : 			Checked::strcat_s(szKey, _countof(szKey), _T("\\Implemented Categories"));
; 7322 : #endif
; 7323 : 			lRes = key.Open(root, szKey, KEY_READ);
; 7324 : 			if (lRes == ERROR_SUCCESS)
; 7325 : 			{
; 7326 : 				lRes = RegQueryInfoKey(key, NULL, NULL, NULL, &cbSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
; 7327 : 				key.Close();
; 7328 : 				if (lRes == ERROR_SUCCESS && cbSubKeys == 0)
; 7329 : 				{
; 7330 : 					root.DeleteSubKey(szKey);
; 7331 : 				}
; 7332 : 			}
; 7333 : 		}
; 7334 : 	}
; 7335 : 	return(S_OK);
; 7336 : }
; 7337 : 
; 7338 : static inline UINT WINAPI AtlGetDirLen(_In_z_ LPCOLESTR lpszPathName) throw()
; 7339 : {
; 7340 : 	ATLASSERT(lpszPathName != NULL);
; 7341 : 	if(lpszPathName == NULL)
; 7342 : 		return 0;
; 7343 : 
; 7344 : 	// always capture the complete file name including extension (if present)
; 7345 : 	LPCOLESTR lpszTemp = lpszPathName;
; 7346 : 	for (LPCOLESTR lpsz = lpszPathName; *lpsz != '\0'; )
; 7347 : 	{
; 7348 : 
; 7349 : 		LPCOLESTR lp = CharNextW(lpsz);
; 7350 : 
; 7351 : 		// remember last directory/drive separator
; 7352 : 		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
; 7353 : 			lpszTemp = lp;
; 7354 : 		lpsz = lp;
; 7355 : 	}
; 7356 : 
; 7357 : 	return UINT( lpszTemp-lpszPathName );
; 7358 : }
; 7359 : 
; 7360 : ATLINLINE ATLAPIINL AtlUnRegisterTypeLib(
; 7361 : 	_In_ HINSTANCE hInstTypeLib,
; 7362 : 	_In_opt_z_ LPCOLESTR lpszIndex)
; 7363 : {
; 7364 : 	CComBSTR bstrPath;
; 7365 : 	CComPtr<ITypeLib> pTypeLib;
; 7366 : 	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);
; 7367 : 	if (SUCCEEDED(hr))
; 7368 : 	{
; 7369 : 		TLIBATTR* ptla;
; 7370 : 		hr = pTypeLib->GetLibAttr(&ptla);
; 7371 : 		if (SUCCEEDED(hr))
; 7372 : 		{
; 7373 : 			typedef HRESULT (STDAPICALLTYPE *PFNUNREGISTERTYPELIB)(REFGUID, WORD /* wVerMajor */, WORD /* wVerMinor */, LCID, SYSKIND);
; 7374 : 			PFNUNREGISTERTYPELIB pfnUnRegisterTypeLib = NULL;
; 7375 : 
; 7376 : 			bool bRedirectionEnabled = false;
; 7377 : 			hr = AtlGetPerUserRegistration(&bRedirectionEnabled);
; 7378 : 			if( FAILED(hr) )
; 7379 : 			{
; 7380 : 				return hr;
; 7381 : 			}
; 7382 : 
; 7383 : 			if( true == bRedirectionEnabled )
; 7384 : 			{
; 7385 : 				HMODULE hmodOleAut=::GetModuleHandleW(L"OLEAUT32.DLL");
; 7386 : 				if(hmodOleAut)
; 7387 : 				{
; 7388 : 					pfnUnRegisterTypeLib=reinterpret_cast<PFNUNREGISTERTYPELIB>(::GetProcAddress(hmodOleAut, "UnRegisterTypeLibForUser"));
; 7389 : 				}
; 7390 : 			}
; 7391 : 
; 7392 : 			if( NULL == pfnUnRegisterTypeLib )
; 7393 : 			{
; 7394 : 				pfnUnRegisterTypeLib = (PFNUNREGISTERTYPELIB)&UnRegisterTypeLib;
; 7395 : 			}
; 7396 : 
; 7397 : 			hr = pfnUnRegisterTypeLib(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);
; 7398 : 
; 7399 : 			pTypeLib->ReleaseTLibAttr(ptla);
; 7400 : 		}
; 7401 : 	}
; 7402 : 	return hr;
; 7403 : }
; 7404 : 
; 7405 : ATLINLINE ATLAPIINL AtlRegisterTypeLib(
; 7406 : 	_In_ HINSTANCE hInstTypeLib,
; 7407 : 	_In_opt_z_ LPCOLESTR lpszIndex)
; 7408 : {
; 7409 : 	CComBSTR bstrPath;
; 7410 : 	CComPtr<ITypeLib> pTypeLib;
; 7411 : 	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);
; 7412 : 	if (SUCCEEDED(hr))
; 7413 : 	{
; 7414 : 		LPCOLESTR szDir=NULL;
; 7415 : 		OLECHAR szDirBuffer[MAX_PATH];
; 7416 : 		CComBSTR bstrHelpFile;
; 7417 : 		hr = pTypeLib->GetDocumentation(-1, NULL, NULL, NULL, &bstrHelpFile);
; 7418 : 		if (SUCCEEDED(hr) && bstrHelpFile != NULL)
; 7419 : 		{
; 7420 : 			Checked::wcsncpy_s(szDirBuffer, MAX_PATH, bstrHelpFile.m_str, bstrHelpFile.Length());
; 7421 : 			szDirBuffer[MAX_PATH - 1] = 0;
; 7422 : 
; 7423 : 			// truncate at the directory level
; 7424 : 			szDirBuffer[AtlGetDirLen(szDirBuffer)] = 0;
; 7425 : 
; 7426 : 			szDir=&szDirBuffer[0];
; 7427 : 		}
; 7428 : 
; 7429 : 		typedef HRESULT (STDAPICALLTYPE *PFNREGISTERTYPELIB)(ITypeLib *, LPCOLESTR /* const szFullPath */, LPCOLESTR /* const szHelpDir */);
; 7430 : 		PFNREGISTERTYPELIB pfnRegisterTypeLib = NULL;
; 7431 : 
; 7432 : 		bool bRedirectionEnabled = false;
; 7433 : 		hr = AtlGetPerUserRegistration(&bRedirectionEnabled);
; 7434 : 		if( FAILED(hr) )
; 7435 : 		{
; 7436 : 			return hr;
; 7437 : 		}
; 7438 : 
; 7439 : 		if( true == bRedirectionEnabled )
; 7440 : 		{
; 7441 : 			HMODULE hmodOleAut=::GetModuleHandleW(L"OLEAUT32.DLL");
; 7442 : 			if(hmodOleAut)
; 7443 : 			{
; 7444 : 				pfnRegisterTypeLib=reinterpret_cast<PFNREGISTERTYPELIB>(::GetProcAddress(hmodOleAut, "RegisterTypeLibForUser"));
; 7445 : 			}
; 7446 : 		}
; 7447 : 
; 7448 : 		if( NULL == pfnRegisterTypeLib )
; 7449 : 		{
; 7450 : 			pfnRegisterTypeLib = (PFNREGISTERTYPELIB)&RegisterTypeLib;
; 7451 : 		}
; 7452 : 
; 7453 : 		hr = pfnRegisterTypeLib(pTypeLib, bstrPath, szDir);
; 7454 : 
; 7455 : 	}
; 7456 : 	return hr;
; 7457 : }
; 7458 : 
; 7459 : #ifndef _ATL_STATIC_LIB_IMPL
; 7460 : 
; 7461 : inline ATL_DEPRECATED("AtlModuleRegisterTypeLib has been replaced by AtlRegisterTypeLib")
; 7462 : HRESULT AtlModuleRegisterTypeLib(
; 7463 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7464 : 	_In_z_ LPCOLESTR lpszIndex)
; 7465 : {
; 7466 : 	return AtlRegisterTypeLib(_AtlComModule.m_hInstTypeLib, lpszIndex);
; 7467 : }
; 7468 : 
; 7469 : inline ATL_DEPRECATED("AtlModuleUnRegisterTypeLib has been replaced by AtlUnRegisterTypeLib")
; 7470 : HRESULT AtlModuleUnRegisterTypeLib(
; 7471 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7472 : 	_In_z_ LPCOLESTR lpszIndex)
; 7473 : {
; 7474 : 	return AtlUnRegisterTypeLib(_AtlComModule.m_hInstTypeLib, lpszIndex);
; 7475 : }
; 7476 : 
; 7477 : inline ATL_DEPRECATED("AtlModuleLoadTypeLib has been replaced by AtlLoadTypeLib")
; 7478 : HRESULT AtlModuleLoadTypeLib(
; 7479 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7480 : 	_In_z_ LPCOLESTR lpszIndex,
; 7481 : 	_Outptr_result_z_ BSTR* pbstrPath,
; 7482 : 	_Outptr_ ITypeLib** ppTypeLib)
; 7483 : {
; 7484 : 	return AtlLoadTypeLib(_AtlComModule.m_hInstTypeLib, lpszIndex, pbstrPath, ppTypeLib);
; 7485 : }
; 7486 : 
; 7487 : inline ATL_DEPRECATED("AtlModuleUpdateRegistryFromResourceD has been replaced by AtlUpdateRegistryFromResourceD")
; 7488 : HRESULT AtlModuleUpdateRegistryFromResourceD(
; 7489 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7490 : 	_In_z_ LPCOLESTR lpszRes,
; 7491 : 	_In_ BOOL bRegister,
; 7492 : 	_In_ struct _ATL_REGMAP_ENTRY* pMapEntries,
; 7493 : 	_In_opt_ IRegistrar* pReg = NULL)
; 7494 : {
; 7495 : 	return AtlUpdateRegistryFromResourceD(_AtlBaseModule.GetModuleInstance(), lpszRes, bRegister, pMapEntries, pReg);
; 7496 : }
; 7497 : 
; 7498 : inline ATL_DEPRECATED("AtlModuleRegisterClassObjects has been replaced by AtlComModuleRegisterClassObjects")
; 7499 : HRESULT AtlModuleRegisterClassObjects(
; 7500 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7501 : 	_In_ DWORD dwClsContext,
; 7502 : 	_In_ DWORD dwFlags)
; 7503 : {
; 7504 : 	return AtlComModuleRegisterClassObjects(&_AtlComModule, dwClsContext, dwFlags);
; 7505 : }
; 7506 : 
; 7507 : inline ATL_DEPRECATED("AtlModuleRevokeClassObjects has been replaced by AtlComModuleRevokeClassObjects")
; 7508 : HRESULT AtlModuleRevokeClassObjects(_In_opt_ _ATL_MODULE* /*pM*/)
; 7509 : {
; 7510 : 	return AtlComModuleRevokeClassObjects(&_AtlComModule);
; 7511 : }
; 7512 : 
; 7513 : inline ATL_DEPRECATED("AtlModuleGetClassObject has been replaced by AtlComModuleGetClassObject")
; 7514 : HRESULT AtlModuleGetClassObject(
; 7515 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7516 : 	_In_ REFCLSID rclsid,
; 7517 : 	_In_ REFIID riid,
; 7518 : 	_COM_Outptr_ LPVOID* ppv)
; 7519 : {
; 7520 : 	return AtlComModuleGetClassObject(&_AtlComModule, rclsid, riid, ppv);
; 7521 : }
; 7522 : 
; 7523 : inline ATL_DEPRECATED("AtlModuleRegisterServer has been replaced by AtlComModuleRegisterServer")
; 7524 : HRESULT AtlModuleRegisterServer(
; 7525 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7526 : 	_In_ BOOL bRegTypeLib,
; 7527 : 	_In_opt_ const CLSID* pCLSID = NULL)
; 7528 : {
; 7529 : 	return AtlComModuleRegisterServer(&_AtlComModule, bRegTypeLib, pCLSID);
; 7530 : }
; 7531 : 
; 7532 : inline ATL_DEPRECATED("AtlModuleUnregisterServer has been replaced by AtlComModuleUnregisterServer")
; 7533 : HRESULT AtlModuleUnregisterServer(
; 7534 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7535 : 	_In_opt_ const CLSID* pCLSID = NULL)
; 7536 : {
; 7537 : 	return AtlComModuleUnregisterServer(&_AtlComModule, FALSE, pCLSID);
; 7538 : }
; 7539 : 
; 7540 : inline ATL_DEPRECATED("AtlModuleUnregisterServerEx has been replaced by AtlComModuleUnregisterServer")
; 7541 : HRESULT AtlModuleUnregisterServerEx(
; 7542 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7543 : 	_In_ BOOL bUnRegTypeLib,
; 7544 : 	_In_opt_ const CLSID* pCLSID = NULL)
; 7545 : {
; 7546 : 	return AtlComModuleUnregisterServer(&_AtlComModule, bUnRegTypeLib, pCLSID);
; 7547 : }
; 7548 : 
; 7549 : inline ATL_DEPRECATED("AtlModuleInit is no longer required")
; 7550 : HRESULT AtlModuleInit(
; 7551 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7552 : 	_In_opt_ _ATL_OBJMAP_ENTRY* /*p*/,
; 7553 : 	_In_ HINSTANCE /*h*/)
; 7554 : {
; 7555 : 	return S_OK;
; 7556 : }
; 7557 : 
; 7558 : inline ATL_DEPRECATED("AtlModuleTerm is no longer required")
; 7559 : HRESULT AtlModuleTerm(_In_opt_ _ATL_MODULE* /*pM*/)
; 7560 : {
; 7561 : 	return S_OK;
; 7562 : }
; 7563 : 
; 7564 : #ifndef _ATL_NO_WIN_SUPPORT
; 7565 : 
; 7566 : inline ATL_DEPRECATED("AtlModuleAddCreateWndData has been replaced by AtlWinModuleAddCreateWndData")
; 7567 : void AtlModuleAddCreateWndData(
; 7568 : 	_In_opt_ _ATL_MODULE* /*pM*/,
; 7569 : 	_In_ _AtlCreateWndData* pData,
; 7570 : 	_In_ void* pObject)
; 7571 : {
; 7572 : 	AtlWinModuleAddCreateWndData(&_AtlWinModule, pData, pObject);
; 7573 : }
; 7574 : 
; 7575 : inline ATL_DEPRECATED("AtlModuleExtractCreateWndData has been replaced by AtlWinModuleExtractCreateWndData")
; 7576 : void* AtlModuleExtractCreateWndData(_In_opt_ _ATL_MODULE* /*pM*/)
; 7577 : {
; 7578 : 	return AtlWinModuleExtractCreateWndData(&_AtlWinModule);
; 7579 : }
; 7580 : #endif // _ATL_NO_WIN_SUPPORT
; 7581 : 
; 7582 : #endif // _ATL_STATIC_LIB_IMPL
; 7583 : 
; 7584 : /////////////////////////////////////////////////////////////////////////////
; 7585 : // Registration
; 7586 : 
; 7587 : // AtlComModuleRegisterServer walks the ATL Autogenerated Object Map and registers each object in the map
; 7588 : // If pCLSID is not NULL then only the object referred to by pCLSID is registered (The default case)
; 7589 : // otherwise all the objects are registered
; 7590 : ATLINLINE ATLAPIINL AtlComModuleRegisterServer(
; 7591 : 	_Inout_ _ATL_COM_MODULE* pComModule,
; 7592 : 	_In_ BOOL bRegTypeLib,
; 7593 : 	_In_opt_ const CLSID* pCLSID)
; 7594 : {
; 7595 : 	ATLASSERT(pComModule != NULL);
; 7596 : 	if (pComModule == NULL)
; 7597 : 		return E_INVALIDARG;
; 7598 : 	ATLASSERT(pComModule->m_hInstTypeLib != NULL);
; 7599 : 
; 7600 : 	HRESULT hr = S_OK;
; 7601 : 
; 7602 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)
; 7603 : 	{
; 7604 : 		if (*ppEntry != NULL)
; 7605 : 		{
; 7606 : 			_ATL_OBJMAP_ENTRY_EX* pEntry = *ppEntry;
; 7607 : 			if (pCLSID != NULL)
; 7608 : 			{
; 7609 : 				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
; 7610 : 					continue;
; 7611 : 			}
; 7612 : 			hr = pEntry->pfnUpdateRegistry(TRUE);
; 7613 : 			if (FAILED(hr))
; 7614 : 				break;
; 7615 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
; 7616 : 				pEntry->pfnGetCategoryMap(), TRUE );
; 7617 : 			if (FAILED(hr))
; 7618 : 				break;
; 7619 : 		}
; 7620 : 	}
; 7621 : 
; 7622 : 	if (SUCCEEDED(hr) && bRegTypeLib)
; 7623 : 	{
; 7624 : 		ATLASSUME(pComModule->m_hInstTypeLib != NULL);
; 7625 : 		hr = AtlRegisterTypeLib(pComModule->m_hInstTypeLib, 0);
; 7626 : 	}
; 7627 : 
; 7628 : 	return hr;
; 7629 : }
; 7630 : 
; 7631 : // AtlComUnregisterServer walks the ATL Object Map and unregisters each object in the map
; 7632 : // If pCLSID is not NULL then only the object referred to by pCLSID is unregistered (The default case)
; 7633 : // otherwise all the objects are unregistered.
; 7634 : ATLINLINE ATLAPIINL AtlComModuleUnregisterServer(
; 7635 : 	_Inout_ _ATL_COM_MODULE* pComModule,
; 7636 : 	_In_ BOOL bUnRegTypeLib,
; 7637 : 	_In_opt_ const CLSID* pCLSID)
; 7638 : {
; 7639 : 	ATLASSERT(pComModule != NULL);
; 7640 : 	if (pComModule == NULL)
; 7641 : 		return E_INVALIDARG;
; 7642 : 
; 7643 : 	HRESULT hr = S_OK;
; 7644 : 
; 7645 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)
; 7646 : 	{
; 7647 : 		if (*ppEntry != NULL)
; 7648 : 		{
; 7649 : 			_ATL_OBJMAP_ENTRY_EX* pEntry = *ppEntry;
; 7650 : 			if (pCLSID != NULL)
; 7651 : 			{
; 7652 : 				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
; 7653 : 					continue;
; 7654 : 			}
; 7655 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid, pEntry->pfnGetCategoryMap(), FALSE );
; 7656 : 			if (FAILED(hr))
; 7657 : 				break;
; 7658 : 			hr = pEntry->pfnUpdateRegistry(FALSE); //unregister
; 7659 : 			if (FAILED(hr))
; 7660 : 				break;
; 7661 : 		}
; 7662 : 	}
; 7663 : 	if (SUCCEEDED(hr) && bUnRegTypeLib)
; 7664 : 		hr = AtlUnRegisterTypeLib(pComModule->m_hInstTypeLib, 0);
; 7665 : 
; 7666 : 	return hr;
; 7667 : }
; 7668 : 
; 7669 : #ifndef _ATL_NO_WIN_SUPPORT
; 7670 : ATLINLINE ATLAPIINL AtlWinModuleTerm(
; 7671 : 	_Inout_ _ATL_WIN_MODULE* pWinModule,
; 7672 : 	_In_ HINSTANCE hInst)
; 7673 : {
; 7674 : 	if (pWinModule == NULL)
; 7675 : 		return E_INVALIDARG;
; 7676 : 	if (pWinModule->cbSize == 0)
; 7677 : 		return S_OK;
; 7678 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))
; 7679 : 		return E_INVALIDARG;
; 7680 : 
; 7681 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)
; 7682 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);
; 7683 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();
; 7684 : 	pWinModule->m_csWindowCreate.Term();
; 7685 : 	pWinModule->cbSize = 0;
; 7686 : 	return S_OK;
; 7687 : }
; 7688 : #endif
; 7689 : 
; 7690 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 7691 : 
; 7692 : #ifndef _ATL_NO_COMMODULE
; 7693 : 
; 7694 : #ifndef _ATL_NO_WIN_SUPPORT
; 7695 : 
; 7696 : inline CRITICAL_SECTION& CComModule::get_m_csWindowCreate() throw()
; 7697 : {
; 7698 : 	return _AtlWinModule.m_csWindowCreate.m_sec;
; 7699 : }
; 7700 : 
; 7701 : inline _AtlCreateWndData*& CComModule::get_m_pCreateWndList()  throw()
; 7702 : {
; 7703 : 	return _AtlWinModule.m_pCreateWndList;
; 7704 : }
; 7705 : inline void CComModule::put_m_pCreateWndList(_In_ _AtlCreateWndData* p) throw()
; 7706 : {
; 7707 : 	_AtlWinModule.m_pCreateWndList = p;
; 7708 : }
; 7709 : 
; 7710 : #endif // _ATL_NO_WIN_SUPPORT
; 7711 : 
; 7712 : inline CRITICAL_SECTION& CComModule::get_m_csObjMap() throw()
; 7713 : {
; 7714 : 	return _AtlComModule.m_csObjMap.m_sec;
; 7715 : }
; 7716 : 
; 7717 : inline CRITICAL_SECTION& CComModule::get_m_csStaticDataInit() throw()
; 7718 : {
; 7719 : 	return m_csStaticDataInitAndTypeInfo.m_sec;
; 7720 : }
; 7721 : 
; 7722 : #ifdef _ATL_DEBUG_INTERFACES
; 7723 : inline UINT& CComModule::get_m_nIndexQI() throw()
; 7724 : {
; 7725 : 	return _AtlDebugInterfacesModule.m_nIndexQI;
; 7726 : }
; 7727 : inline void CComModule::put_m_nIndexQI(_In_ UINT nIndex) throw()
; 7728 : {
; 7729 : 	_AtlDebugInterfacesModule.m_nIndexQI = nIndex;
; 7730 : }
; 7731 : inline UINT& CComModule::get_m_nIndexBreakAt() throw()
; 7732 : {
; 7733 : 	return _AtlDebugInterfacesModule.m_nIndexBreakAt;
; 7734 : }
; 7735 : inline void CComModule::put_m_nIndexBreakAt(_In_ UINT nIndex) throw()
; 7736 : {
; 7737 : 	_AtlDebugInterfacesModule.m_nIndexBreakAt = nIndex;
; 7738 : }
; 7739 : inline CSimpleArray<_QIThunk*>* CComModule::get_m_paThunks() throw()
; 7740 : {
; 7741 : 	return &_AtlDebugInterfacesModule.m_aThunks;
; 7742 : }
; 7743 : inline HRESULT CComModule::AddThunk(
; 7744 : 	_Inout_ _Deref_pre_valid_ _Deref_post_valid_ IUnknown** pp,
; 7745 : 	_In_z_ LPCTSTR lpsz,
; 7746 : 	_In_ REFIID iid) throw()
; 7747 : {
; 7748 : 	return _AtlDebugInterfacesModule.AddThunk(pp, lpsz, iid);
; 7749 : }
; 7750 : inline HRESULT CComModule::AddNonAddRefThunk(
; 7751 : 	_Inout_ IUnknown* p,
; 7752 : 	_In_z_ LPCTSTR lpsz,
; 7753 : 	_Outptr_ IUnknown** ppThunkRet) throw()
; 7754 : {
; 7755 : 	return _AtlDebugInterfacesModule.AddNonAddRefThunk(p, lpsz, ppThunkRet);
; 7756 : }
; 7757 : 
; 7758 : inline void CComModule::DeleteNonAddRefThunk(_In_ IUnknown* pUnk) throw()
; 7759 : {
; 7760 : 	_AtlDebugInterfacesModule.DeleteNonAddRefThunk(pUnk);
; 7761 : }
; 7762 : 
; 7763 : inline void CComModule::DeleteThunk(_In_ _QIThunk* p) throw()
; 7764 : {
; 7765 : 	_AtlDebugInterfacesModule.DeleteThunk(p);
; 7766 : }
; 7767 : 
; 7768 : inline bool CComModule::DumpLeakedThunks() throw()
; 7769 : {
; 7770 : 	return _AtlDebugInterfacesModule.DumpLeakedThunks();
; 7771 : }
; 7772 : #endif // _ATL_DEBUG_INTERFACES
; 7773 : 
; 7774 : inline HRESULT CComModule::Init(
; 7775 : 	_In_ _ATL_OBJMAP_ENTRY* p,
; 7776 : 	_In_ HINSTANCE /*h*/,
; 7777 : 	_In_opt_ const GUID* plibid) throw()
; 7778 : {
; 7779 : 	if (plibid != NULL)
; 7780 : 		m_libid = *plibid;
; 7781 : 
; 7782 : 	_ATL_OBJMAP_ENTRY* pEntry;
; 7783 : 	if (p != (_ATL_OBJMAP_ENTRY*)-1)
; 7784 : 	{
; 7785 : 		m_pObjMap = p;
; 7786 : 		if (m_pObjMap != NULL)
; 7787 : 		{
; 7788 : 			pEntry = m_pObjMap;
; 7789 : 			while (pEntry->pclsid != NULL)
; 7790 : 			{
; 7791 : 				pEntry->pfnObjectMain(true); //initialize class resources
; 7792 : 				pEntry++;
; 7793 : 			}
; 7794 : 		}
; 7795 : 	}
; 7796 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)
; 7797 : 	{
; 7798 : 		if (*ppEntry != NULL)
; 7799 : 			(*ppEntry)->pfnObjectMain(true); //initialize class resources
; 7800 : 	}
; 7801 : 	return S_OK;
; 7802 : }
; 7803 : 
; 7804 : inline void CComModule::Term() throw()
; 7805 : {
; 7806 : 	_ATL_OBJMAP_ENTRY* pEntry;
; 7807 : 	if (m_pObjMap != NULL)
; 7808 : 	{
; 7809 : 		pEntry = m_pObjMap;
; 7810 : 		while (pEntry->pclsid != NULL)
; 7811 : 		{
; 7812 : 			if (pEntry->pCF != NULL)
; 7813 : 				pEntry->pCF->Release();
; 7814 : 			pEntry->pCF = NULL;
; 7815 : 			pEntry->pfnObjectMain(false); //cleanup class resources
; 7816 : 			pEntry++;
; 7817 : 		}
; 7818 : 	}
; 7819 : 
; 7820 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)
; 7821 : 	{
; 7822 : 		if (*ppEntry != NULL)
; 7823 : 			(*ppEntry)->pfnObjectMain(false); //cleanup class resources
; 7824 : 	}
; 7825 : #if defined(_DEBUG) && !defined(_ATL_NO_WIN_SUPPORT)
; 7826 : 	// Prevent false memory leak reporting. ~CAtlWinModule may be too late.
; 7827 : 	_AtlWinModule.Term();
; 7828 : #endif	// _DEBUG
; 7829 : 
; 7830 : 	CAtlModuleT<CComModule>::Term();
; 7831 : }
; 7832 : 
; 7833 : inline HRESULT CComModule::GetClassObject(
; 7834 : 	_In_ REFCLSID rclsid,
; 7835 : 	_In_ REFIID riid,
; 7836 : 	_COM_Outptr_ LPVOID* ppv) throw()
; 7837 : {
; 7838 : 	*ppv = NULL;
; 7839 : 	HRESULT hr = S_OK;
; 7840 : 
; 7841 : 	if (m_pObjMap != NULL)
; 7842 : 	{
; 7843 : 		const _ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
; 7844 : 
; 7845 : 		while (pEntry->pclsid != NULL)
; 7846 : 		{
; 7847 : 			if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
; 7848 : 			{
; 7849 : 				if (pEntry->pCF == NULL)
; 7850 : 				{
; 7851 : 					CComCritSecLock<CComCriticalSection> lock(_AtlComModule.m_csObjMap, false);
; 7852 : 					hr = lock.Lock();
; 7853 : 					if (FAILED(hr))
; 7854 : 					{
; 7855 : 						ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in CComModule::GetClassObject\n"));
; 7856 : 						ATLASSERT(FALSE);
; 7857 : 						break;
; 7858 : 					}
; 7859 : 
; 7860 : 					if (pEntry->pCF == NULL)
; 7861 : 					{
; 7862 : 						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), (LPVOID*)&pEntry->pCF);
; 7863 : 					}
; 7864 : 				}
; 7865 : 
; 7866 : 				if (pEntry->pCF != NULL)
; 7867 : 				{
; 7868 : 					hr = pEntry->pCF->QueryInterface(riid, ppv);
; 7869 : 				}
; 7870 : 				break;
; 7871 : 			}
; 7872 : 			pEntry++;
; 7873 : 		}
; 7874 : 	}
; 7875 : 
; 7876 : 	if (*ppv == NULL && hr == S_OK)
; 7877 : 	{
; 7878 : 		hr = AtlComModuleGetClassObject(&_AtlComModule, rclsid, riid, ppv);
; 7879 : 	}
; 7880 : 
; 7881 : 	return hr;
; 7882 : }
; 7883 : 
; 7884 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 7885 : // Register/Revoke All Class Factories with the OS (EXE only)
; 7886 : inline HRESULT CComModule::RegisterClassObjects(
; 7887 : 	_In_ DWORD dwClsContext,
; 7888 : 	_In_ DWORD dwFlags) throw()
; 7889 : {
; 7890 : 	HRESULT hr = S_OK;
; 7891 : 	_ATL_OBJMAP_ENTRY* pEntry;
; 7892 : 	if (m_pObjMap != NULL)
; 7893 : 	{
; 7894 : 		pEntry = m_pObjMap;
; 7895 : 		while (pEntry->pclsid != NULL && hr == S_OK)
; 7896 : 		{
; 7897 : 			hr = pEntry->RegisterClassObject(dwClsContext, dwFlags);
; 7898 : 			pEntry++;
; 7899 : 		}
; 7900 : 	}
; 7901 : 	if (hr == S_OK)
; 7902 : 		hr = AtlComModuleRegisterClassObjects(&_AtlComModule, dwClsContext, dwFlags);
; 7903 : 	return hr;
; 7904 : }
; 7905 : inline HRESULT CComModule::RevokeClassObjects() throw()
; 7906 : {
; 7907 : 	HRESULT hr = S_OK;
; 7908 : 	_ATL_OBJMAP_ENTRY* pEntry;
; 7909 : 	if (m_pObjMap != NULL)
; 7910 : 	{
; 7911 : 		pEntry = m_pObjMap;
; 7912 : 		while (pEntry->pclsid != NULL && hr == S_OK)
; 7913 : 		{
; 7914 : 			hr = pEntry->RevokeClassObject();
; 7915 : 			pEntry++;
; 7916 : 		}
; 7917 : 	}
; 7918 : 	if (hr == S_OK)
; 7919 : 		hr = AtlComModuleRevokeClassObjects(&_AtlComModule);
; 7920 : 	return hr;
; 7921 : }
; 7922 : 
; 7923 : // Registry support (helpers)
; 7924 : inline HRESULT CComModule::RegisterTypeLib() throw()
; 7925 : {
; 7926 : 	return _AtlComModule.RegisterTypeLib();
; 7927 : }
; 7928 : inline HRESULT CComModule::RegisterTypeLib(_In_z_ LPCTSTR lpszIndex) throw()
; 7929 : {
; 7930 : 	return _AtlComModule.RegisterTypeLib(lpszIndex);
; 7931 : }
; 7932 : inline HRESULT CComModule::UnRegisterTypeLib() throw()
; 7933 : {
; 7934 : 	return _AtlComModule.UnRegisterTypeLib();
; 7935 : }
; 7936 : inline HRESULT CComModule::UnRegisterTypeLib(_In_z_ LPCTSTR lpszIndex) throw()
; 7937 : {
; 7938 : 	return _AtlComModule.UnRegisterTypeLib(lpszIndex);
; 7939 : }
; 7940 : 
; 7941 : inline HRESULT CComModule::RegisterServer(
; 7942 : 	_In_ BOOL bRegTypeLib /*= FALSE*/,
; 7943 : 	_In_opt_ const CLSID* pCLSID /*= NULL*/) throw()
; 7944 : {
; 7945 : 	HRESULT hr = S_OK;
; 7946 : 	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
; 7947 : 	if (pEntry != NULL)
; 7948 : 	{
; 7949 : 		for (;pEntry->pclsid != NULL; pEntry++)
; 7950 : 		{
; 7951 : 			if (pCLSID != NULL)
; 7952 : 			{
; 7953 : 				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
; 7954 : 					continue;
; 7955 : 			}
; 7956 : 			hr = pEntry->pfnUpdateRegistry(TRUE);
; 7957 : 			if (FAILED(hr))
; 7958 : 				break;
; 7959 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
; 7960 : 				pEntry->pfnGetCategoryMap(), TRUE );
; 7961 : 			if (FAILED(hr))
; 7962 : 				break;
; 7963 : 		}
; 7964 : 	}
; 7965 : 	if (SUCCEEDED(hr))
; 7966 : 		hr = CAtlModuleT<CComModule>::RegisterServer(bRegTypeLib, pCLSID);
; 7967 : 	return hr;
; 7968 : }
; 7969 : 
; 7970 : inline HRESULT CComModule::UnregisterServer(
; 7971 : 	_In_ BOOL bUnRegTypeLib,
; 7972 : 	_In_opt_ const CLSID* pCLSID /*= NULL*/) throw()
; 7973 : {
; 7974 : 	HRESULT hr = S_OK;
; 7975 : 	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
; 7976 : 	if (pEntry != NULL)
; 7977 : 	{
; 7978 : 		for (;pEntry->pclsid != NULL; pEntry++)
; 7979 : 		{
; 7980 : 			if (pCLSID != NULL)
; 7981 : 			{
; 7982 : 				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
; 7983 : 					continue;
; 7984 : 			}
; 7985 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
; 7986 : 				pEntry->pfnGetCategoryMap(), FALSE );
; 7987 : 			if (FAILED(hr))
; 7988 : 				break;
; 7989 : 			hr = pEntry->pfnUpdateRegistry(FALSE); //unregister
; 7990 : 			if (FAILED(hr))
; 7991 : 				break;
; 7992 : 		}
; 7993 : 	}
; 7994 : 	if (SUCCEEDED(hr))
; 7995 : 		hr = CAtlModuleT<CComModule>::UnregisterServer(bUnRegTypeLib, pCLSID);
; 7996 : 	return hr;
; 7997 : }
; 7998 : 
; 7999 : inline HRESULT CComModule::UnregisterServer(_In_opt_ const CLSID* pCLSID /*= NULL*/) throw()
; 8000 : {
; 8001 : 	return UnregisterServer(FALSE, pCLSID);
; 8002 : }
; 8003 : 
; 8004 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 8005 : 
; 8006 : #endif	// !_ATL_NO_COMMODULE
; 8007 : 
; 8008 : #pragma warning( pop )  // disable 4702/4571
; 8009 : 
; 8010 : /////////////////////////////////////////////////////////////////////////////
; 8011 : // Connection Point Helpers
; 8012 : 
; 8013 : ATLINLINE ATLAPI AtlAdvise(
; 8014 : 	_Inout_ IUnknown* pUnkCP,
; 8015 : 	_Inout_opt_ IUnknown* pUnk,
; 8016 : 	_In_ const IID& iid,
; 8017 : 	_Out_ LPDWORD pdw)
; 8018 : {
; 8019 : 	if(pUnkCP == NULL)
; 8020 : 		return E_INVALIDARG;
; 8021 : 
; 8022 : 	CComPtr<IConnectionPointContainer> pCPC;
; 8023 : 	CComPtr<IConnectionPoint> pCP;
; 8024 : 	HRESULT hRes = pUnkCP->QueryInterface(__uuidof(IConnectionPointContainer), (void**)&pCPC);
; 8025 : 	if (SUCCEEDED(hRes))
; 8026 : 		hRes = pCPC->FindConnectionPoint(iid, &pCP);
; 8027 : 	if (SUCCEEDED(hRes))
; 8028 : 		hRes = pCP->Advise(pUnk, pdw);
; 8029 : 	return hRes;
; 8030 : }
; 8031 : 
; 8032 : ATLINLINE ATLAPI AtlUnadvise(
; 8033 : 	_Inout_ IUnknown* pUnkCP,
; 8034 : 	_In_ const IID& iid,
; 8035 : 	_In_ DWORD dw)
; 8036 : {
; 8037 : 	if(pUnkCP == NULL)
; 8038 : 		return E_INVALIDARG;
; 8039 : 
; 8040 : 	CComPtr<IConnectionPointContainer> pCPC;
; 8041 : 	CComPtr<IConnectionPoint> pCP;
; 8042 : 	HRESULT hRes = pUnkCP->QueryInterface(__uuidof(IConnectionPointContainer), (void**)&pCPC);
; 8043 : 	if (SUCCEEDED(hRes))
; 8044 : 		hRes = pCPC->FindConnectionPoint(iid, &pCP);
; 8045 : 	if (SUCCEEDED(hRes))
; 8046 : 		hRes = pCP->Unadvise(dw);
; 8047 : 	return hRes;
; 8048 : }
; 8049 : 
; 8050 : /////////////////////////////////////////////////////////////////////////////
; 8051 : // Inproc Marshaling helpers
; 8052 : 
; 8053 : //This API should be called from the same thread that called
; 8054 : //AtlMarshalPtrInProc
; 8055 : ATLINLINE ATLAPI AtlFreeMarshalStream(_Inout_ IStream* pStream)
; 8056 : {
; 8057 : 	HRESULT hRes=S_OK;
; 8058 : 	if (pStream != NULL)
; 8059 : 	{
; 8060 : 		LARGE_INTEGER l;
; 8061 : 		l.QuadPart = 0;
; 8062 : 		pStream->Seek(l, STREAM_SEEK_SET, NULL);
; 8063 : 		hRes=CoReleaseMarshalData(pStream);
; 8064 : 		pStream->Release();
; 8065 : 	}
; 8066 : 	return hRes;
; 8067 : }
; 8068 : 
; 8069 : ATLPREFAST_SUPPRESS(6387)
; 8070 : ATLINLINE ATLAPI AtlMarshalPtrInProc(
; 8071 : 	_Inout_ IUnknown* pUnk,
; 8072 : 	_In_ const IID& iid,
; 8073 : 	_Outptr_ IStream** ppStream)
; 8074 : {
; 8075 : 	ATLASSERT(ppStream != NULL);
; 8076 : 	if (ppStream == NULL)
; 8077 : 		return E_POINTER;
; 8078 : 
; 8079 : 	HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
; 8080 : 	if (SUCCEEDED(hRes))
; 8081 : 	{
; 8082 : 		hRes = CoMarshalInterface(*ppStream, iid,
; 8083 : 			pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
; 8084 : 		if (FAILED(hRes))
; 8085 : 		{
; 8086 : 			(*ppStream)->Release();
; 8087 : 			*ppStream = NULL;
; 8088 : 		}
; 8089 : 	}
; 8090 : 	return hRes;
; 8091 : }
; 8092 : ATLPREFAST_UNSUPPRESS()
; 8093 : 
; 8094 : ATLINLINE ATLAPI AtlUnmarshalPtr(
; 8095 : 	_Inout_ IStream* pStream,
; 8096 : 	_In_ const IID& iid,
; 8097 : 	_Outptr_ IUnknown** ppUnk)
; 8098 : {
; 8099 : 	ATLASSERT(ppUnk != NULL);
; 8100 : 	if (ppUnk == NULL)
; 8101 : 		return E_POINTER;
; 8102 : 
; 8103 : 	*ppUnk = NULL;
; 8104 : 	HRESULT hRes = E_INVALIDARG;
; 8105 : 	if (pStream != NULL)
; 8106 : 	{
; 8107 : 		LARGE_INTEGER l;
; 8108 : 		l.QuadPart = 0;
; 8109 : 		pStream->Seek(l, STREAM_SEEK_SET, NULL);
; 8110 : 		hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
; 8111 : 	}
; 8112 : 	return hRes;
; 8113 : }
; 8114 : 
; 8115 : /////////////////////////////////////////////////////////////////////////////
; 8116 : // Module
; 8117 : ATLPREFAST_SUPPRESS(6387 28196)
; 8118 : ATLINLINE ATLAPI AtlComModuleGetClassObject(
; 8119 : 	_Inout_ _ATL_COM_MODULE* pComModule,
; 8120 : 	_In_ REFCLSID rclsid,
; 8121 : 	_In_ REFIID riid,
; 8122 : 	_COM_Outptr_ LPVOID* ppv)
; 8123 : {
; 8124 : 	if (ppv == NULL)
; 8125 : 	{
; 8126 : 		return E_POINTER;
; 8127 : 	}
; 8128 : 
; 8129 : 	*ppv = NULL;
; 8130 : 
; 8131 : 	ATLASSERT(pComModule != NULL);
; 8132 : 	if (pComModule == NULL)
; 8133 : 	{
; 8134 : 		return E_INVALIDARG;
; 8135 : 	}
; 8136 : 
; 8137 : 	if (pComModule->cbSize == 0)  // Module hasn't been initialized
; 8138 : 	{
; 8139 : 		return E_UNEXPECTED;
; 8140 : 	}
; 8141 : 
; 8142 : 	HRESULT hr = S_OK;
; 8143 : 
; 8144 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)
; 8145 : 	{
; 8146 : 		if (*ppEntry != NULL)
; 8147 : 		{
; 8148 : 			const _ATL_OBJMAP_ENTRY_EX* pEntry = *ppEntry;
; 8149 : 
; 8150 : 			if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
; 8151 : 			{
; 8152 : 				_ATL_OBJMAP_CACHE* pCache = pEntry->pCache;
; 8153 : 				
; 8154 : 				if (pCache->pCF == NULL)
; 8155 : 				{
; 8156 : 					CComCritSecLock<CComCriticalSection> lock(pComModule->m_csObjMap, false);
; 8157 : 					hr = lock.Lock();
; 8158 : 					if (FAILED(hr))
; 8159 : 					{
; 8160 : 						ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in AtlComModuleGetClassObject\n"));
; 8161 : 						ATLASSERT(FALSE);
; 8162 : 						break;
; 8163 : 					}
; 8164 : 
; 8165 : 					if (pCache->pCF == NULL)
; 8166 : 					{
; 8167 : 						IUnknown *factory = NULL;
; 8168 : 						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), reinterpret_cast<void**>(&factory));
; 8169 : 						if (SUCCEEDED(hr))
; 8170 : 						{
; 8171 : 							pCache->pCF = reinterpret_cast<IUnknown*>(::EncodePointer(factory));
; 8172 : 						}
; 8173 : 					}
; 8174 : 				}
; 8175 : 
; 8176 : 				if (pCache->pCF != NULL)
; 8177 : 				{
; 8178 : 					// Decode factory pointer
; 8179 : 					IUnknown* factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));
; 8180 : 					_Analysis_assume_(factory != nullptr);
; 8181 : 					hr = factory->QueryInterface(riid, ppv);
; 8182 : 				}
; 8183 : 				break;
; 8184 : 			}
; 8185 : 		}
; 8186 : 	}
; 8187 : 
; 8188 : 	if (*ppv == NULL && hr == S_OK)
; 8189 : 	{
; 8190 : 		hr = CLASS_E_CLASSNOTAVAILABLE;
; 8191 : 	}
; 8192 : 
; 8193 : 	return hr;
; 8194 : }
; 8195 : ATLPREFAST_UNSUPPRESS()
; 8196 : 
; 8197 : ATLINLINE ATLAPI AtlComModuleRegisterClassObjects(
; 8198 : 	_Inout_ _ATL_COM_MODULE* pComModule,
; 8199 : 	_In_ DWORD dwClsContext,
; 8200 : 	_In_ DWORD dwFlags)
; 8201 : {
; 8202 : 	ATLASSERT(pComModule != NULL);
; 8203 : 	if (pComModule == NULL)
; 8204 : 		return E_INVALIDARG;
; 8205 : 
; 8206 : 	HRESULT hr = S_FALSE;
; 8207 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast && SUCCEEDED(hr); ppEntry++)
; 8208 : 	{
; 8209 : 		if (*ppEntry != NULL)
; 8210 : 			hr = (*ppEntry)->RegisterClassObject(dwClsContext, dwFlags);
; 8211 : 	}
; 8212 : 	return hr;
; 8213 : }
; 8214 : 
; 8215 : ATLINLINE ATLAPI AtlComModuleRevokeClassObjects(
; 8216 : 	_Inout_ _ATL_COM_MODULE* pComModule)
; 8217 : {
; 8218 : 	ATLASSERT(pComModule != NULL);
; 8219 : 	if (pComModule == NULL)
; 8220 : 		return E_INVALIDARG;
; 8221 : 
; 8222 : 	HRESULT hr = S_OK;
; 8223 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast && hr == S_OK; ppEntry++)
; 8224 : 	{
; 8225 : 		if (*ppEntry != NULL)
; 8226 : 			hr = (*ppEntry)->RevokeClassObject();
; 8227 : 	}
; 8228 : 	return hr;
; 8229 : }
; 8230 : 
; 8231 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 8232 : 
; 8233 : ATLINLINE ATLAPI_(BOOL) AtlWaitWithMessageLoop(_In_ HANDLE hEvent)
; 8234 : {
; 8235 : 	DWORD dwRet;
; 8236 : 	MSG msg;
; 8237 : 
; 8238 : 	while(1)
; 8239 : 	{
; 8240 : 		dwRet = MsgWaitForMultipleObjectsEx(1, &hEvent, INFINITE, QS_ALLINPUT, MWMO_INPUTAVAILABLE);
; 8241 : 
; 8242 : 		if (dwRet == WAIT_OBJECT_0)
; 8243 : 			return TRUE;    // The event was signaled
; 8244 : 
; 8245 : 		if (dwRet != WAIT_OBJECT_0 + 1)
; 8246 : 			break;          // Something else happened
; 8247 : 
; 8248 : 		// There is one or more window message available. Dispatch them
; 8249 : 		while(PeekMessage(&msg,0,0,0,PM_NOREMOVE))
; 8250 : 		{
; 8251 : 			// check for unicode window so we call the appropriate functions
; 8252 : 			BOOL bUnicode = ::IsWindowUnicode(msg.hwnd);
; 8253 : 			BOOL bRet;
; 8254 : 
; 8255 : 			if (bUnicode)
; 8256 : 				bRet = ::GetMessageW(&msg, NULL, 0, 0);
; 8257 : 			else
; 8258 : 				bRet = ::GetMessageA(&msg, NULL, 0, 0);
; 8259 : 
; 8260 : 			if (bRet > 0)
; 8261 : 			{
; 8262 : 				::TranslateMessage(&msg);
; 8263 : 
; 8264 : 				if (bUnicode)
; 8265 : 					::DispatchMessageW(&msg);
; 8266 : 				else
; 8267 : 					::DispatchMessageA(&msg);
; 8268 : 			}
; 8269 : 
; 8270 : 			if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
; 8271 : 				return TRUE; // Event is now signaled.
; 8272 : 		}
; 8273 : 	}
; 8274 : 	return FALSE;
; 8275 : }
; 8276 : 
; 8277 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 8278 : 
; 8279 : /////////////////////////////////////////////////////////////////////////////
; 8280 : // QI support
; 8281 : ATLINLINE ATLAPI AtlInternalQueryInterface(
; 8282 : 	_Inout_ void* pThis,
; 8283 : 	_In_ const _ATL_INTMAP_ENTRY* pEntries,
; 8284 : 	_In_ REFIID iid,
; 8285 : 	_COM_Outptr_ void** ppvObject)
; 8286 : {
; 8287 : 	ATLASSERT(pThis != NULL);
; 8288 : 	ATLASSERT(pEntries!= NULL);
; 8289 :  
; 8290 : 	if(pThis == NULL || pEntries == NULL)
; 8291 : 		return E_INVALIDARG;
; 8292 : 
; 8293 : 	// First entry in the com map should be a simple map entry
; 8294 : 	ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
; 8295 :  
; 8296 : 	if (ppvObject == NULL)
; 8297 : 		return E_POINTER;
; 8298 : 
; 8299 : 	if (InlineIsEqualUnknown(iid)) // use first interface
; 8300 : 	{
; 8301 : 		IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);
; 8302 : 		pUnk->AddRef();
; 8303 : 		*ppvObject = pUnk;
; 8304 : 		return S_OK;
; 8305 : 	}
; 8306 :  
; 8307 : 	HRESULT hRes;
; 8308 :  
; 8309 : 	for (;; pEntries++)
; 8310 : 	{
; 8311 : 		if (pEntries->pFunc == NULL)
; 8312 : 		{
; 8313 : 			hRes = E_NOINTERFACE;
; 8314 : 			break;
; 8315 : 		}
; 8316 : 
; 8317 : 		BOOL bBlind = (pEntries->piid == NULL);
; 8318 : 		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
; 8319 : 		{
; 8320 : 			if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
; 8321 : 			{
; 8322 : 				ATLASSERT(!bBlind);
; 8323 : 				IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);
; 8324 : 				pUnk->AddRef();
; 8325 : 				*ppvObject = pUnk;
; 8326 : 				return S_OK;
; 8327 : 			}
; 8328 :  
; 8329 : 			// Actual function call
; 8330 :  
; 8331 : 			hRes = pEntries->pFunc(pThis,
; 8332 : 				iid, ppvObject, pEntries->dw);
; 8333 : 			if (hRes == S_OK)
; 8334 : 				return S_OK;
; 8335 : 			if (!bBlind && FAILED(hRes))
; 8336 : 				break;
; 8337 : 		}
; 8338 : 	}
; 8339 :  
; 8340 : 	*ppvObject = NULL;
; 8341 :  
; 8342 : 	return hRes;
; 8343 : }
; 8344 : 
; 8345 : ATLINLINE ATLAPI_(DWORD) AtlGetVersion(_In_opt_ void* /* pReserved */)
; 8346 : {
; 8347 : 	return _ATL_VER;
; 8348 : }
; 8349 : 
; 8350 : /////////////////////////////////////////////////////////////////////////////
; 8351 : // Windowing
; 8352 : 
; 8353 : ATLINLINE ATLAPI_(void) AtlWinModuleAddCreateWndData(
; 8354 : 	_Inout_ _ATL_WIN_MODULE* pWinModule,
; 8355 : 	_Inout_ _AtlCreateWndData* pData,
; 8356 : 	_In_ void* pObject)
; 8357 : {
; 8358 : 	if (pWinModule == NULL)
; 8359 : 		_AtlRaiseException((DWORD)EXCEPTION_ACCESS_VIOLATION);
; 8360 : 
; 8361 : 	ATLASSERT(pData != NULL && pObject != NULL);
; 8362 : 	if(pData == NULL || pObject == NULL)
; 8363 : 		_AtlRaiseException((DWORD)EXCEPTION_ACCESS_VIOLATION);
; 8364 : 
; 8365 : 	pData->m_pThis = pObject;
; 8366 : 	pData->m_dwThreadID = ::GetCurrentThreadId();
; 8367 : 	CComCritSecLock<CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);
; 8368 : 	if (FAILED(lock.Lock()))
; 8369 : 	{
; 8370 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to lock critical section in AtlWinModuleAddCreateWndData\n"));
; 8371 : 		ATLASSERT(0);
; 8372 : 		return;
; 8373 : 	}
; 8374 : 	pData->m_pNext = pWinModule->m_pCreateWndList;
; 8375 : 	pWinModule->m_pCreateWndList = pData;
; 8376 : }
; 8377 : 
; 8378 : ATLINLINE ATLAPI_(void*) AtlWinModuleExtractCreateWndData(
; 8379 : 	_Inout_opt_ _ATL_WIN_MODULE* pWinModule)
; 8380 : {
; 8381 : 	if (pWinModule == NULL)
; 8382 : 		return NULL;
; 8383 : 
; 8384 : 	void* pv = NULL;
; 8385 : 	CComCritSecLock<CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);
; 8386 : 	if (FAILED(lock.Lock()))
; 8387 : 	{
; 8388 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to lock critical section in AtlWinModuleExtractCreateWndData\n"));
; 8389 : 		ATLASSERT(0);
; 8390 : 		return pv;
; 8391 : 	}
; 8392 : 	_AtlCreateWndData* pEntry = pWinModule->m_pCreateWndList;
; 8393 : 	if(pEntry != NULL)
; 8394 : 	{
; 8395 : 		DWORD dwThreadID = ::GetCurrentThreadId();
; 8396 : 		_AtlCreateWndData* pPrev = NULL;
; 8397 : 		while(pEntry != NULL)
; 8398 : 		{
; 8399 : 			if(pEntry->m_dwThreadID == dwThreadID)
; 8400 : 			{
; 8401 : 				if(pPrev == NULL)
; 8402 : 					pWinModule->m_pCreateWndList = pEntry->m_pNext;
; 8403 : 				else
; 8404 : 					pPrev->m_pNext = pEntry->m_pNext;
; 8405 : 				pv = pEntry->m_pThis;
; 8406 : 				break;
; 8407 : 			}
; 8408 : 			pPrev = pEntry;
; 8409 : 			pEntry = pEntry->m_pNext;
; 8410 : 		}
; 8411 : 	}
; 8412 : 	return pv;
; 8413 : }
; 8414 : 
; 8415 : ATLINLINE ATLAPI AtlWinModuleInit(
; 8416 : 	_Inout_ _ATL_WIN_MODULE* pWinModule)
; 8417 : {
; 8418 : 	if (pWinModule == NULL)
; 8419 : 		return E_INVALIDARG;
; 8420 : 
; 8421 : 	// check only in the DLL
; 8422 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))
; 8423 : 		return E_INVALIDARG;
; 8424 : 
; 8425 : 	pWinModule->m_pCreateWndList = NULL;

	mov	DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h

; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN26@CAtlWinMod

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN27@CAtlWinMod
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 2790 : 		if (FAILED(hr))

	test	eax, eax
$LN27@CAtlWinMod:

; 2795 : 			return;
; 2796 : 		}
; 2797 : 	}

	mov	eax, esi

; 2790 : 		if (FAILED(hr))

	jns	SHORT $LN1@CAtlWinMod

; 2791 : 		{
; 2792 : 			ATLASSERT(0);
; 2793 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2794 : 			cbSize = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 2795 : 			return;
; 2796 : 		}
; 2797 : 	}

	ret	0
$LN26@CAtlWinMod:
	mov	eax, esi
$LN1@CAtlWinMod:
	pop	esi
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT

; 2457 : 		Term();

	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2458 : 	}

	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	jmp	??1_ATL_COM_MODULE70@ATL@@QAE@XZ
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h

; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
	push	OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN3@dynamic

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN19@dynamic
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 2444 : 		if (FAILED(m_csObjMap.Init()))

	test	eax, eax
$LN19@dynamic:
	jns	SHORT $LN3@dynamic

; 2565 : __declspec(selectany) CAtlComModule _AtlComModule;

	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2445 : 		{
; 2446 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2447 : 			ATLASSERT(0);
; 2448 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2565 : __declspec(selectany) CAtlComModule _AtlComModule;

	call	_atexit
	pop	ecx
	ret	0
$LN3@dynamic:
	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2449 : 			return;
; 2450 : 		}
; 2451 : 		// Set cbSize on success.
; 2452 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 40 ; 00000028H

; 2565 : __declspec(selectany) CAtlComModule _AtlComModule;

	call	_atexit
	pop	ecx
	ret	0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2462 : 	{

	push	edi
	mov	edi, ecx

; 2463 : 		if (cbSize == 0)

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN7@Term

; 2464 : 			return;
; 2465 : 
; 2466 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	push	esi
	mov	esi, DWORD PTR [edi+8]
	cmp	esi, DWORD PTR [edi+12]
	jae	SHORT $LN3@Term
	push	ebx
$LL5@Term:

; 2467 : 		{
; 2468 : 			if (*ppEntry != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Term

; 2469 : 			{
; 2470 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

	mov	ebx, DWORD PTR [eax+16]

; 2471 : 				
; 2472 : 				if (pCache->pCF != NULL)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN4@Term

; 2473 : 				{
; 2474 : 					// Decode factory pointer if it's not null
; 2475 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

	push	eax
	call	DWORD PTR __imp__DecodePointer@4

; 2476 : 					_Analysis_assume_(factory != nullptr);
; 2477 : 					factory->Release();					

	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 2478 : 					pCache->pCF = NULL;

	mov	DWORD PTR [ebx], 0
$LN4@Term:

; 2464 : 			return;
; 2465 : 
; 2466 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	add	esi, 4
	cmp	esi, DWORD PTR [edi+12]
	jb	SHORT $LL5@Term
	pop	ebx
$LN3@Term:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 140  : 		DeleteCriticalSection(&m_sec);

	lea	eax, DWORD PTR [edi+16]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 2486 : 		cbSize = 0;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN7@Term:
	pop	edi

; 2487 : 	}

	ret	0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2457 : 		Term();

	jmp	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2435 : 	CAtlComModule() throw()

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movdqu	XMMWORD PTR [eax], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h

; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h

; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 2437 : 		cbSize = 0;

	mov	DWORD PTR [esi], 0

; 2438 : 
; 2439 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

	mov	DWORD PTR [esi+4], OFFSET ___ImageBase

; 2440 : 
; 2441 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

	mov	DWORD PTR [esi+8], OFFSET ___pobjMapEntryFirst+4

; 2442 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

	mov	DWORD PTR [esi+12], OFFSET ___pobjMapEntryLast
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h

; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN1@CAtlComMod

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN17@CAtlComMod
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 2444 : 		if (FAILED(m_csObjMap.Init()))

	test	eax, eax
$LN17@CAtlComMod:
	jns	SHORT $LN1@CAtlComMod

; 2453 : 	}

	mov	eax, esi
	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
	pop	esi
	ret	0
$LN1@CAtlComMod:

; 2445 : 		{
; 2446 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2447 : 			ATLASSERT(0);
; 2448 : 			CAtlBaseModule::m_bInitFailed = true;
; 2449 : 			return;
; 2450 : 		}
; 2451 : 		// Set cbSize on success.
; 2452 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	DWORD PTR [esi], 40			; 00000028H

; 2453 : 	}

	mov	eax, esi
	pop	esi
	ret	0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7673 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 7674 : 	if (pWinModule == NULL)

	mov	esi, DWORD PTR _pWinModule$[ebp]
	test	esi, esi
	jne	SHORT $LN6@AtlWinModu
$LN37@AtlWinModu:

; 7675 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	pop	esi

; 7687 : }

	pop	ebp
	ret	8
$LN6@AtlWinModu:

; 7676 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN36@AtlWinModu

; 7677 : 		return S_OK;
; 7678 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN37@AtlWinModu

; 7679 : 		return E_INVALIDARG;
; 7680 : 
; 7681 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+36], edi
	jle	SHORT $LN1@AtlWinModu

; 7682 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	push	ebx
	mov	ebx, DWORD PTR _hInst$[ebp]
	npad	4
$LL3@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h

; 232  : 		if(nIndex < 0 || nIndex >= m_nSize)

	test	edi, edi
	js	SHORT $LN28@AtlWinModu
	cmp	edi, DWORD PTR [esi+36]
	jge	SHORT $LN28@AtlWinModu
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 7682 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	eax, DWORD PTR [esi+32]
	push	ebx
	movzx	eax, WORD PTR [eax+edi*2]
	push	eax
	call	DWORD PTR __imp__UnregisterClassW@8
	inc	edi
	cmp	edi, DWORD PTR [esi+36]
	jl	SHORT $LL3@AtlWinModu
	pop	ebx
$LN1@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h

; 210  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	pop	edi
	test	eax, eax
	je	SHORT $LN21@AtlWinModu

; 211  : 		{
; 212  : 			for(int i = 0; i < m_nSize; i++)
; 213  : 				m_aT[i].~T();
; 214  : 			free(m_aT);

	push	eax
	call	_free
	add	esp, 4

; 215  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN21@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 140  : 		DeleteCriticalSection(&m_sec);

	lea	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h

; 217  : 		m_nSize = 0;

	mov	DWORD PTR [esi+36], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 140  : 		DeleteCriticalSection(&m_sec);

	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h

; 218  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 140  : 		DeleteCriticalSection(&m_sec);

	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 7685 : 	pWinModule->cbSize = 0;

	mov	DWORD PTR [esi], 0
$LN36@AtlWinModu:

; 7686 : 	return S_OK;

	xor	eax, eax
	pop	esi

; 7687 : }

	pop	ebp
	ret	8
$LN28@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	push	0
	push	0
	push	1
	push	-1073741684				; c000008cH
	call	DWORD PTR __imp__RaiseException@16
$LN39@AtlWinModu:
$LN38@AtlWinModu:
	int	3
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8417 : {

	push	ebp
	mov	ebp, esp

; 8418 : 	if (pWinModule == NULL)

	mov	eax, DWORD PTR _pWinModule$[ebp]
	test	eax, eax
	jne	SHORT $LN3@AtlWinModu
$LN15@AtlWinModu:

; 8419 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H

; 8434 : }

	pop	ebp
	ret	4
$LN3@AtlWinModu:

; 8420 : 
; 8421 : 	// check only in the DLL
; 8422 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	DWORD PTR [eax], 44			; 0000002cH
	jne	SHORT $LN15@AtlWinModu
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 129  : 		HRESULT hRes = S_OK;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 8425 : 	pWinModule->m_pCreateWndList = NULL;

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h

; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	esi
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	add	eax, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h

; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	eax
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN14@AtlWinModu

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	mov	esi, eax
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	esi, esi
	jle	SHORT $LN14@AtlWinModu
	movzx	esi, si
	or	esi, -2147024896			; 80070000H
$LN14@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlbase.h

; 8433 : 	return hr;

	mov	eax, esi
	pop	esi

; 8434 : }

	pop	ebp
	ret	4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 210  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN18@ATL_WIN_MO

; 211  : 		{
; 212  : 			for(int i = 0; i < m_nSize; i++)
; 213  : 				m_aT[i].~T();
; 214  : 			free(m_aT);

	push	eax
	call	_free
	add	esp, 4

; 215  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN18@ATL_WIN_MO:

; 216  : 		}
; 217  : 		m_nSize = 0;
; 218  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	xorps	xmm0, xmm0
	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movdqu	XMMWORD PTR [ecx+4], xmm0
	movq	QWORD PTR [ecx+20], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h

; 120  : 	{

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 230  : 	{

	push	ebp
	mov	ebp, esp

; 231  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 232  : 		if(nIndex < 0 || nIndex >= m_nSize)

	mov	edx, DWORD PTR _nIndex$[ebp]
	test	edx, edx
	js	SHORT $LN1@operator
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN1@operator

; 233  : 		{
; 234  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
; 235  : 		}
; 236  : 		return m_aT[nIndex];

	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*2]

; 237  : 	}

	pop	ebp
	ret	4
$LN1@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	push	0
	push	0
	push	1
	push	-1073741684				; c000008cH
	call	DWORD PTR __imp__RaiseException@16
$LN9@operator:
$LN8@operator:
	int	3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 209  : 	{

	push	esi
	mov	esi, ecx

; 210  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@RemoveAll

; 211  : 		{
; 212  : 			for(int i = 0; i < m_nSize; i++)
; 213  : 				m_aT[i].~T();
; 214  : 			free(m_aT);

	push	eax
	call	_free
	add	esp, 4

; 215  : 			m_aT = NULL;

	mov	DWORD PTR [esi], 0
$LN11@RemoveAll:

; 216  : 		}
; 217  : 		m_nSize = 0;
; 218  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 219  :     }

	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 161  : 		return m_nSize;

	mov	eax, DWORD PTR [ecx+4]

; 162  : 	}

	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 303  : {

	push	esi
	mov	esi, ecx

; 210  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@CSimpleArr

; 211  : 		{
; 212  : 			for(int i = 0; i < m_nSize; i++)
; 213  : 				m_aT[i].~T();
; 214  : 			free(m_aT);

	push	eax
	call	_free
	add	esp, 4

; 215  : 			m_aT = NULL;

	mov	DWORD PTR [esi], 0
$LN13@CSimpleArr:

; 216  : 		}
; 217  : 		m_nSize = 0;
; 218  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 304  : 	RemoveAll();
; 305  : }

	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 120  : 	{

	mov	DWORD PTR [ecx], 0

; 121  : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	ret	0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	xorps	xmm0, xmm0
	mov	eax, ecx

; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movdqu	XMMWORD PTR [ecx+16], xmm0
	movq	QWORD PTR [ecx+32], xmm0
	ret	0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 275  : 		return m_hInst;

	mov	eax, DWORD PTR [ecx+4]

; 276  : 	}

	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 140  : 		DeleteCriticalSection(&m_sec);

	push	ecx
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 141  : 		return S_OK;

	xor	eax, eax

; 142  : 	}

	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h

; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
	push	ecx
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 130  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN10@Init

; 131  : 		{
; 132  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN9@Init
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h

; 136  : 	}

	ret	0
$LN10@Init:

; 133  : 		}
; 134  : 
; 135  : 		return hRes;

	xor	eax, eax
$LN9@Init:

; 136  : 	}

	ret	0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 115  : 	}

	ret	0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 108  : 	CComCriticalSection() throw()

	xorps	xmm0, xmm0

; 109  : 	{
; 110  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
; 111  : 	}

	mov	eax, ecx
	movdqu	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 69   : 	{

	push	ebp
	mov	ebp, esp

; 70   : 	#if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 71   : 		// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 72   : 		return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	DWORD PTR _Flags$[ebp]
	push	DWORD PTR _dwSpinCount$[ebp]
	push	DWORD PTR _lpCriticalSection$[ebp]
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12

; 73   : 	#else
; 74   : 		UNREFERENCED_PARAMETER(Flags);
; 75   : 
; 76   : 		// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 77   : 		return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 78   : 	#endif
; 79   : 	}

	pop	ebp
	ret	0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
?AtlThrowLastWin32@ATL@@YGXXZ PROC			; ATL::AtlThrowLastWin32, COMDAT

; 85   : 	DWORD dwError = ::GetLastError();

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN6@AtlThrowLa
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
$LN6@AtlThrowLa:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h

; 86   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

	push	eax
	call	?AtlThrowImpl@ATL@@YGXJ@Z		; ATL::AtlThrowImpl
$LN8@AtlThrowLa:
$LN7@AtlThrowLa:
	int	3
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )
; 69   : 	{
; 70   : 		AfxThrowMemoryException();
; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );
; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1?AVCAtlException@ATL@@
	push	eax
	call	__CxxThrowException@8
$LN6@AtlThrowIm:
$LN5@AtlThrowIm:
	int	3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 44   : 	{

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   : 	}

	mov	eax, ecx
	pop	ebp
	ret	4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	push	0
	push	0
	push	DWORD PTR _dwExceptionFlags$[ebp]
	push	DWORD PTR _dwExceptionCode$[ebp]
	call	DWORD PTR __imp__RaiseException@16

; 32   : }

	pop	ebp
	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 442  : 	(void)pszCategoryName;
; 443  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC			; ATL::_AtlGetConversionACP, COMDAT

; 106  : #ifdef _CONVERSION_DONT_USE_THREAD_LOCALE
; 107  : 	return CP_ACP;
; 108  : #else
; 109  : 	return CP_THREAD_ACP;

	mov	eax, 3

; 110  : #endif
; 111  : }

	ret	0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 105  :         {return; }

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 103  :         {return (_Where); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Where$[ebp]
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??BD3DXPLANE@@QAEPAMXZ
_TEXT	SEGMENT
??BD3DXPLANE@@QAEPAMXZ PROC				; D3DXPLANE::operator float *, COMDAT
; _this$ = ecx

; 1278 :     return (FLOAT *) &a;

	mov	eax, ecx

; 1279 : }

	ret	0
??BD3DXPLANE@@QAEPAMXZ ENDP				; D3DXPLANE::operator float *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0D3DXPLANE@@QAE@XZ
_TEXT	SEGMENT
??0D3DXPLANE@@QAE@XZ PROC				; D3DXPLANE::D3DXPLANE, COMDAT
; _this$ = ecx

; 508  :     D3DXPLANE() {};

	mov	eax, ecx
	ret	0
??0D3DXPLANE@@QAE@XZ ENDP				; D3DXPLANE::D3DXPLANE
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??0_D3DXMATRIXA16@@QAE@ABU_D3DMATRIX@@@Z
_TEXT	SEGMENT
_m$ = 8							; size = 4
??0_D3DXMATRIXA16@@QAE@ABU_D3DMATRIX@@@Z PROC		; _D3DXMATRIXA16::_D3DXMATRIXA16, COMDAT
; _this$ = ecx

; 977  : {

	push	ebp
	mov	ebp, esp

; 770  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));

	mov	eax, DWORD PTR _m$[ebp]
	movdqu	xmm0, XMMWORD PTR [eax]
	movdqu	XMMWORD PTR [ecx], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+16]
	movdqu	XMMWORD PTR [ecx+16], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+32]
	movdqu	XMMWORD PTR [ecx+32], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+48]

; 978  : }

	mov	eax, ecx

; 770  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));

	movdqu	XMMWORD PTR [ecx+48], xmm0

; 978  : }

	pop	ebp
	ret	4
??0_D3DXMATRIXA16@@QAE@ABU_D3DMATRIX@@@Z ENDP		; _D3DXMATRIXA16::_D3DXMATRIXA16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0_D3DXMATRIXA16@@QAE@XZ
_TEXT	SEGMENT
??0_D3DXMATRIXA16@@QAE@XZ PROC				; _D3DXMATRIXA16::_D3DXMATRIXA16, COMDAT
; _this$ = ecx

; 415  :     _D3DXMATRIXA16() {};

	mov	eax, ecx
	ret	0
??0_D3DXMATRIXA16@@QAE@XZ ENDP				; _D3DXMATRIXA16::_D3DXMATRIXA16
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??DD3DXMATRIX@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_mat$ = 12						; size = 4
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z PROC			; D3DXMATRIX::operator*, COMDAT
; _this$ = ecx

; 896  : {

	push	ebp
	mov	ebp, esp

; 897  :     D3DXMATRIX matT;
; 898  :     D3DXMatrixMultiply(&matT, this, &mat);

	push	DWORD PTR _mat$[ebp]
	push	ecx
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	_D3DXMatrixMultiply@12

; 899  :     return matT;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 900  : }

	pop	ebp
	ret	8
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z ENDP			; D3DXMATRIX::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??BD3DXMATRIX@@QAEPAMXZ
_TEXT	SEGMENT
??BD3DXMATRIX@@QAEPAMXZ PROC				; D3DXMATRIX::operator float *, COMDAT
; _this$ = ecx

; 816  :     return (FLOAT *) &_11;

	mov	eax, ecx

; 817  : }

	ret	0
??BD3DXMATRIX@@QAEPAMXZ ENDP				; D3DXMATRIX::operator float *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??RD3DXMATRIX@@QAEAAMII@Z
_TEXT	SEGMENT
_iRow$ = 8						; size = 4
_iCol$ = 12						; size = 4
??RD3DXMATRIX@@QAEAAMII@Z PROC				; D3DXMATRIX::operator(), COMDAT
; _this$ = ecx

; 801  : {

	push	ebp
	mov	ebp, esp

; 802  :     return m[iRow][iCol];

	mov	edx, DWORD PTR _iCol$[ebp]
	mov	eax, DWORD PTR _iRow$[ebp]
	lea	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 803  : }

	pop	ebp
	ret	8
??RD3DXMATRIX@@QAEAAMII@Z ENDP				; D3DXMATRIX::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??0D3DXMATRIX@@QAE@ABU_D3DMATRIX@@@Z
_TEXT	SEGMENT
_mat$ = 8						; size = 4
??0D3DXMATRIX@@QAE@ABU_D3DMATRIX@@@Z PROC		; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 769  : {

	push	ebp
	mov	ebp, esp

; 770  :     memcpy(&_11, &mat, sizeof(D3DXMATRIX));

	mov	eax, DWORD PTR _mat$[ebp]
	movdqu	xmm0, XMMWORD PTR [eax]
	movdqu	XMMWORD PTR [ecx], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+16]
	movdqu	XMMWORD PTR [ecx+16], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+32]
	movdqu	XMMWORD PTR [ecx+32], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+48]

; 771  : }

	mov	eax, ecx
	movdqu	XMMWORD PTR [ecx+48], xmm0
	pop	ebp
	ret	4
??0D3DXMATRIX@@QAE@ABU_D3DMATRIX@@@Z ENDP		; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 348  :     D3DXMATRIX() {};

	mov	eax, ecx
	ret	0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??BD3DXVECTOR4@@QAEPAMXZ
_TEXT	SEGMENT
??BD3DXVECTOR4@@QAEPAMXZ PROC				; D3DXVECTOR4::operator float *, COMDAT
; _this$ = ecx

; 565  :     return (FLOAT *) &x;

	mov	eax, ecx

; 566  : }

	ret	0
??BD3DXVECTOR4@@QAEPAMXZ ENDP				; D3DXVECTOR4::operator float *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??0D3DXVECTOR4@@QAE@MMMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
_fw$ = 20						; size = 4
??0D3DXVECTOR4@@QAE@MMMM@Z PROC				; D3DXVECTOR4::D3DXVECTOR4, COMDAT
; _this$ = ecx

; 553  : {

	push	ebp
	mov	ebp, esp

; 554  :     x = fx;

	movss	xmm0, DWORD PTR _fx$[ebp]

; 555  :     y = fy;
; 556  :     z = fz;
; 557  :     w = fw;
; 558  : }

	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _fy$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR _fz$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR _fw$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	16					; 00000010H
??0D3DXVECTOR4@@QAE@MMMM@Z ENDP				; D3DXVECTOR4::D3DXVECTOR4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??0D3DXVECTOR4@@QAE@ABU_D3DVECTOR@@M@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_f$ = 12						; size = 4
??0D3DXVECTOR4@@QAE@ABU_D3DVECTOR@@M@Z PROC		; D3DXVECTOR4::D3DXVECTOR4, COMDAT
; _this$ = ecx

; 544  : {

	push	ebp
	mov	ebp, esp

; 545  :     x = v.x;

	mov	edx, DWORD PTR _v$[ebp]

; 546  :     y = v.y;
; 547  :     z = v.z;
; 548  :     w = f;

	movss	xmm0, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 549  : }

	mov	eax, ecx
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	8
??0D3DXVECTOR4@@QAE@ABU_D3DVECTOR@@M@Z ENDP		; D3DXVECTOR4::D3DXVECTOR4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0D3DXVECTOR4@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR4@@QAE@XZ PROC				; D3DXVECTOR4::D3DXVECTOR4, COMDAT
; _this$ = ecx

; 273  :     D3DXVECTOR4() {};

	mov	eax, ecx
	ret	0
??0D3DXVECTOR4@@QAE@XZ ENDP				; D3DXVECTOR4::D3DXVECTOR4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??BD3DXVECTOR3@@QAEPAMXZ
_TEXT	SEGMENT
??BD3DXVECTOR3@@QAEPAMXZ PROC				; D3DXVECTOR3::operator float *, COMDAT
; _this$ = ecx

; 331  :     return (FLOAT *) &x;

	mov	eax, ecx

; 332  : }

	ret	0
??BD3DXVECTOR3@@QAEPAMXZ ENDP				; D3DXVECTOR3::operator float *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@MMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
??0D3DXVECTOR3@@QAE@MMM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 320  : {

	push	ebp
	mov	ebp, esp

; 321  :     x = fx;

	movss	xmm0, DWORD PTR _fx$[ebp]

; 322  :     y = fy;
; 323  :     z = fz;
; 324  : }

	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _fy$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR _fz$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	pop	ebp
	ret	12					; 0000000cH
??0D3DXVECTOR3@@QAE@MMM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??0D3DXVECTOR3@@QAE@PBM@Z
_TEXT	SEGMENT
_pf$ = 8						; size = 4
??0D3DXVECTOR3@@QAE@PBM@Z PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 288  : {

	push	ebp
	mov	ebp, esp

; 289  : #ifdef D3DX10_DEBUG
; 290  :     if(!pf)
; 291  :         return;
; 292  : #endif
; 293  : 
; 294  :     x = pf[0];

	mov	edx, DWORD PTR _pf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 295  :     y = pf[1];

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 296  :     z = pf[2];

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 297  : }

	mov	eax, ecx
	pop	ebp
	ret	4
??0D3DXVECTOR3@@QAE@PBM@Z ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 198  :     D3DXVECTOR3() {};

	mov	eax, ecx
	ret	0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
tv65 = 8						; size = 4
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 1132 :         {return (sinf(_X)); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0

; 1132 :         {return (sinf(_X)); }

	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]
	pop	ebp
	ret	0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 764  : {

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]

; 766  : }

	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _fmodf
_TEXT	SEGMENT
tv83 = -8						; size = 8
tv77 = -8						; size = 8
tv74 = -8						; size = 8
tv85 = 8						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_fmodf	PROC						; COMDAT

; 705  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	movss	xmm0, DWORD PTR __X$[ebp]

; 706  :     return (float)fmod(_X, _Y);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv74[ebp], xmm0
	movss	xmm0, DWORD PTR __Y$[ebp]
	fld	QWORD PTR tv74[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv77[ebp], xmm0
	fld	QWORD PTR tv77[ebp]
	call	__CIfmod
	fstp	QWORD PTR tv83[ebp]
	movsd	xmm0, QWORD PTR tv83[ebp]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR tv85[ebp], xmm0
	fld	DWORD PTR tv85[ebp]

; 707  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fmodf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _hypot
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 8
_hypot	PROC						; COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp

; 557  :     return _hypot(_X, _Y);

	movsd	xmm0, QWORD PTR __Y$[ebp]
	sub	esp, 16					; 00000010H
	movsd	QWORD PTR [esp+8], xmm0
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	__hypot
	add	esp, 16					; 00000010H

; 558  : }

	pop	ebp
	ret	0
_hypot	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	jle	SHORT $LN4@HRESULT_FR
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
$LN4@HRESULT_FR:
	pop	ebp
	ret	0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	dec	esi
	js	SHORT $LN1@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	dec	esi
	jns	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN1@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
