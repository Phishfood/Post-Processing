; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Simon\Documents\GitHub\Post-Processing\Import\Math\MathIO.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@I$07@std@@2IB	; std::integral_constant<unsigned int,8>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?value@?$integral_constant@I$03@std@@2IB	; std::integral_constant<unsigned int,4>::value
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@I$01@std@@2IB	; std::integral_constant<unsigned int,2>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$integral_constant@I$00@std@@2IB	; std::integral_constant<unsigned int,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Maximum@$S@std@@2IB			; std::_Maximum<>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Maximum@$S@std@@2IB
CONST	SEGMENT
?value@?$_Maximum@$S@std@@2IB DD 00H			; std::_Maximum<>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$00@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$00@std@@2IB DD 01H		; std::integral_constant<unsigned int,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$01@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$01@std@@2IB DD 02H		; std::integral_constant<unsigned int,2>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$03@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$03@std@@2IB DD 04H		; std::integral_constant<unsigned int,4>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$07@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$07@std@@2IB DD 08H		; std::integral_constant<unsigned int,8>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
CONST	SEGMENT
_kfPi	DD	040490fdbr			; 3.14159
_kfEpsilon DD	0350637bdr			; 5e-007
_kfPi64	DQ	0400921fb54442d18r		; 3.14159
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
PUBLIC	_hypot
PUBLIC	_ldexpf
PUBLIC	_ldexpl
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?_Init_atomic_counter@std@@YAXAAKK@Z		; std::_Init_atomic_counter
PUBLIC	?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??0runtime_error@std@@QAE@PBD@Z			; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	??0?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Tidy@?$_Yarn@_W@std@@AAEXXZ			; std::_Yarn<wchar_t>::_Tidy
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??0_Facet_base@std@@QAE@XZ			; std::_Facet_base::_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?c_str@locale@std@@QBEPBDXZ			; std::locale::c_str
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
PUBLIC	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z		; std::ctype<char>::widen
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??1_System_error@std@@UAE@XZ			; std::_System_error::~_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	??Bios_base@std@@QBE_NXZ			; std::ios_base::operator bool
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?precision@ios_base@std@@QBE_JXZ		; std::ios_base::precision
PUBLIC	?width@ios_base@std@@QBE_JXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAE_J_J@Z			; std::ios_base::width
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	?Set@CVector2@gen@@QAEXMM@Z			; gen::CVector2::Set
PUBLIC	?Set@CVector3@gen@@QAEXMMM@Z			; gen::CVector3::Set
PUBLIC	?Set@CVector4@gen@@QAEXMMMM@Z			; gen::CVector4::Set
PUBLIC	?Set@CQuaternion@gen@@QAEXMMMM@Z		; gen::CQuaternion::Set
PUBLIC	??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector2@0@@Z ; gen::operator<<
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector3@0@@Z ; gen::operator<<
PUBLIC	??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector4@0@@Z ; gen::operator<<
PUBLIC	??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector2@0@@Z ; gen::operator>>
PUBLIC	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
PUBLIC	??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector3@0@@Z ; gen::operator>>
PUBLIC	??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector4@0@@Z ; gen::operator>>
PUBLIC	??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix2x2@0@@Z ; gen::operator<<
PUBLIC	??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix3x3@0@@Z ; gen::operator<<
PUBLIC	??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix4x4@0@@Z ; gen::operator<<
PUBLIC	??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix2x2@0@@Z ; gen::operator>>
PUBLIC	??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix3x3@0@@Z ; gen::operator>>
PUBLIC	??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix4x4@0@@Z ; gen::operator>>
PUBLIC	??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCQuaternion@0@@Z ; gen::operator<<
PUBLIC	??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCQuaternion@0@@Z ; gen::operator>>
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
PUBLIC	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
PUBLIC	?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx
PUBLIC	??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
PUBLIC	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
PUBLIC	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z	; std::numpunct<char>::numpunct<char>
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator!=<char,char>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
PUBLIC	??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
PUBLIC	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
PUBLIC	??$_Find_elem@D@std@@YAIPADD@Z			; std::_Find_elem<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator==<std::allocator<char>,std::allocator<char> >
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ; std::numpunct<char>::_Getvals<char>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_0CB@NBMGHEOM@Visual?5C?$CL?$CL?58?40?5?$CI2005?$CJ?5or?5greater@ ; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_03JJJGFCCH@?0?5?5?$AA@			; `string'
PUBLIC	?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_C@_02EAOCLKAK@ld?$AA@			; `string'
PUBLIC	??_C@_02BDDLJJBK@lu?$AA@			; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld?$AA@			; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu?$AA@			; `string'
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_02MDKMJEGG@eE?$AA@			; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP?$AA@			; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld'::`2'::_Src
PUBLIC	?_Src@?3??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld'::`4'::_Src
PUBLIC	?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx'::`2'::_Src
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@38aa95a5b7f87a0f
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4202a05f20000000
PUBLIC	__real@4733426172c74d82
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	__hypot:PROC
EXTRN	_ldexp:PROC
EXTRN	_sprintf_s:PROC
EXTRN	_free:PROC
EXTRN	_memmove:PROC
EXTRN	_strcspn:PROC
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??0bad_cast@std@@QAE@PBD@Z:PROC			; std::bad_cast::bad_cast
EXTRN	??0bad_cast@std@@QAE@ABV01@@Z:PROC		; std::bad_cast::bad_cast
EXTRN	??1bad_cast@std@@UAE@XZ:PROC			; std::bad_cast::~bad_cast
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	__Stofx:PROC
EXTRN	__Stodx:PROC
EXTRN	__Stoldx:PROC
EXTRN	__Stolx:PROC
EXTRN	__Stoulx:PROC
EXTRN	__Stollx:PROC
EXTRN	__Stoullx:PROC
EXTRN	?Set@CMatrix2x2@gen@@QAEXMMMM@Z:PROC		; gen::CMatrix2x2::Set
EXTRN	?Set@CMatrix3x3@gen@@QAEXMMMMMMMMM@Z:PROC	; gen::CMatrix3x3::Set
EXTRN	?Set@CMatrix4x4@gen@@QAEXMMMMMMMMMMMMMMMM@Z:PROC ; gen::CMatrix4x4::Set
EXTRN	??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
CRT$XCU	SEGMENT
_ksCompiler$initializer$ DD FLAT:??__EksCompiler@gen@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@4733426172c74d82
CONST	SEGMENT
__real@4733426172c74d82 DQ 04733426172c74d82r	; 1e+035
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+010
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@38aa95a5b7f87a0f
CONST	SEGMENT
__real@38aa95a5b7f87a0f DQ 038aa95a5b7f87a0fr	; 1e-035
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$r	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$r	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$r	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$r	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$r	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB
CONST	SEGMENT
?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB DB '0'
	DB	'123456789ABCDEFabcdef-+XxPp', 00H		; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx'::`2'::_Src
CONST	ENDS
;	COMDAT ?_Src@?3??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB
CONST	SEGMENT
?_Src@?3??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB DB '0'
	DB	'123456789-+Ee', 00H				; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld'::`4'::_Src
CONST	ENDS
;	COMDAT ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB
CONST	SEGMENT
?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB DB '0'
	DB	'123456789ABCDEFabcdef-+Xx', 00H		; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld'::`2'::_Src
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP?$AA@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP?$AA@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE?$AA@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE?$AA@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu?$AA@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld?$AA@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu?$AA@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld?$AA@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
CONST	ENDS
;	COMDAT ??_C@_03JJJGFCCH@?0?5?5?$AA@
CONST	SEGMENT
??_C@_03JJJGFCCH@?0?5?5?$AA@ DB ',  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NBMGHEOM@Visual?5C?$CL?$CL?58?40?5?$CI2005?$CJ?5or?5greater@
CONST	SEGMENT
??_C@_0CB@NBMGHEOM@Visual?5C?$CL?$CL?58?40?5?$CI2005?$CJ?5or?5greater@ DB 'V'
	DB	'isual C++ 8.0 (2005) or greater', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_ksCompiler DB	00H
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
_ksPathSeparator DB 00H
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
_ksNewline DB	00H
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
_DATA	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_DATA	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD FLAT:??_7_System_error_category@std@@6B@ ; std::_Error_objects<int>::_System_object
_DATA	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_DATA	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD FLAT:??_7_Iostream_error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object
_DATA	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_DATA	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD FLAT:??_7_Generic_error_category@std@@6B@ ; std::_Error_objects<int>::_Generic_object
_DATA	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z$0
__ehfuncinfo$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0
__ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$3
__ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3
__ehfuncinfo$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3
__ehfuncinfo$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$1
__ehfuncinfo$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z$0
__tryblocktable$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z$10
__unwindtable$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$10
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
__ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$11
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$3
	DD	01H
	DD	00H
	DD	01H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$5
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z$0
__tryblocktable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z DD 03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z$11
__ehfuncinfo$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z
	DD	01H
	DD	FLAT:__tryblocktable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z$3
	DD	01H
	DD	00H
	DD	01H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$12
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
__ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_ksPathSeparator$initializer$ DD FLAT:??__EksPathSeparator@gen@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ksNewline$initializer$ DD FLAT:??__EksNewline@gen@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Ptr$ = 12						; size = 4
__Cvt$ = 16						; size = 44
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<char>::_Getvals<char>, COMDAT
; _this$ = ecx

; 148  : 		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)

	push	ebp
	mov	ebp, esp

; 149  : 		{	// get values
; 150  : 		_Dp = _MAKLOCCHR(_Elem2, _Ptr->decimal_point[0], _Cvt);

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ecx+12], al

; 151  : 		_Kseparator = _MAKLOCCHR(_Elem2, _Ptr->thousands_sep[0], _Cvt);

	mov	eax, DWORD PTR [edx+4]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ecx+13], al

; 152  : 		}

	pop	ebp
	ret	52					; 00000034H
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<char>::_Getvals<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 694  : 	{	// convert char to _Elem using _Cvtvec

	push	ebp
	mov	ebp, esp

; 695  : 	return ((_Elem)(unsigned char)_Byte);

	mov	al, BYTE PTR __Byte$[ebp]

; 696  : 	}

	pop	ebp
	ret	0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 727  : 	{	// convert C string to _Elem sequence using _Cvtvec

	push	ebp
	mov	ebp, esp
	push	esi

; 728  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	esi, DWORD PTR __Ptr$[ebp]
	mov	ecx, esi
	push	edi
	lea	edx, DWORD PTR [ecx+1]
	npad	3
$LL10@Maklocstr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL10@Maklocstr
	sub	ecx, edx
	lea	edi, DWORD PTR [ecx+1]

; 729  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

	push	edi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 730  : 
; 731  :  #pragma warning(push)
; 732  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 733  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	test	edi, edi
	je	SHORT $LN1@Maklocstr
	mov	edx, eax
	sub	edx, esi
	npad	3
$LL3@Maklocstr:

; 734  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	dec	edi
	jne	SHORT $LL3@Maklocstr
$LN1@Maklocstr:
	pop	edi
	pop	esi

; 735  :  #pragma warning(pop)
; 736  : 
; 737  : 	return (_Ptrdest);
; 738  : 	}

	pop	ebp
	ret	0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

	mov	al, 1

; 894  : 	}

	ret	0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 661  : 	return (true);

	mov	al, 1

; 662  : 	}

	ret	0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT

; 159  : 		{	// destroy the object

	mov	DWORD PTR ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_System_object
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	pop	ecx
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 159  : 		{	// destroy the object

	mov	DWORD PTR ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	pop	ecx
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 159  : 		{	// destroy the object

	mov	DWORD PTR ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_Generic_object
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	pop	ecx
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN1@Allocate
	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	jne	SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	jmp	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, ecx

; 32   : 	}

	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??$_Find_elem@D@std@@YAIPADD@Z
_TEXT	SEGMENT
__Base$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$_Find_elem@D@std@@YAIPADD@Z PROC			; std::_Find_elem<char>, COMDAT

; 55   : 	{	// lookup _Ch in NUL-terminated string _Base

	push	ebp
	mov	ebp, esp
	push	esi

; 56   : 	_Elem *_Ptr = _Base;

	mov	esi, DWORD PTR __Base$[ebp]
	mov	eax, esi

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR [esi]
	test	cl, cl
	je	SHORT $LN10@Find_elem
	mov	dl, BYTE PTR __Ch$[ebp]
$LL3@Find_elem:
	cmp	cl, dl
	je	SHORT $LN10@Find_elem
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@Find_elem
$LN10@Find_elem:

; 58   : 		;
; 59   : 	return ((size_t)(_Ptr - _Base));

	sub	eax, esi
	pop	esi

; 60   : 	}

	pop	ebp
	ret	0
??$_Find_elem@D@std@@YAIPADD@Z ENDP			; std::_Find_elem<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator!=<char,std::char_traits<char> >, COMDAT

; 603  : 	{	// test for istreambuf_iterator inequality

	push	ebp
	mov	ebp, esp

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	xor	ecx, ecx
	test	al, al
	sete	cl
	mov	al, cl

; 605  : 	}

	pop	ebp
	ret	0
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator!=<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 901  : 	return (!(_Left == _Right));

	xor	al, al

; 902  : 	}

	ret	0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator==<char,std::char_traits<char> >, COMDAT

; 594  : 	{	// test for istreambuf_iterator equality

	push	ebp
	mov	ebp, esp

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 596  : 	}

	pop	ebp
	ret	0
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT
__Last$GSCopy$1$ = -64					; size = 4
__Numfields$1$ = -60					; size = 4
__Ans$1$ = -56						; size = 4
__Field$1$ = -52					; size = 4
__Column$1$ = -48					; size = 4
__Prefix$1$ = -41					; size = 1
__Str$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Numfields$ = 16					; size = 4
__Ptr$ = 20						; size = 4
??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z PROC ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT

; 614  : 	{	// find field at _Ptr that matches longest in [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 615  : 	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	edi, DWORD PTR __First$[ebp]

; 616  : 		if (_Ptr[_Off] == _Ptr[0])

	mov	esi, DWORD PTR __Numfields$[ebp]
	mov	dl, BYTE PTR [ebx]
	mov	DWORD PTR __Last$GSCopy$1$[ebp], eax
	test	dl, dl
	je	SHORT $LN199@Getloctxt
	mov	al, dl
	mov	ecx, ebx
$LL23@Getloctxt:
	cmp	al, dl
	jne	SHORT $LN22@Getloctxt

; 617  : 			++_Numfields;	// add fields with leading mark to initial count

	inc	esi
$LN22@Getloctxt:

; 615  : 	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)

	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL23@Getloctxt
$LN199@Getloctxt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 796  : 		assign(_Count, _Ch);

	push	0
	push	esi
	lea	ecx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 615  : 	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)

	mov	DWORD PTR __Numfields$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$[ebp+20], 15		; 0000000fH

; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR __Str$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 796  : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 621  : 	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)

	mov	ecx, 1
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, -2					; fffffffeH
	mov	DWORD PTR __Column$1$[ebp], ecx
$LN206@Getloctxt:

; 622  : 		{	// test each element against all viable fields
; 623  : 		bool _Prefix = false;	// seen at least one valid prefix
; 624  : 		size_t _Off = 0;	// offset into fields
; 625  : 		size_t _Field = 0;	// current field number
; 626  : 
; 627  : 		for (; _Field < _Numfields; ++_Field)

	xor	edx, edx
	mov	DWORD PTR __Ans$1$[ebp], eax
	xor	esi, esi
	mov	BYTE PTR __Prefix$1$[ebp], 0
	mov	DWORD PTR __Field$1$[ebp], edx
	cmp	DWORD PTR __Numfields$1$[ebp], edx
	jbe	$LN186@Getloctxt
	jmp	SHORT $LN16@Getloctxt
	npad	2
$LL201@Getloctxt:
	mov	ecx, DWORD PTR __Column$1$[ebp]
$LN16@Getloctxt:

; 628  : 			{	// test element at _Column in field _Field
; 629  : 			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)

	mov	al, BYTE PTR [esi+ebx]
	test	al, al
	je	SHORT $LN11@Getloctxt
	mov	cl, BYTE PTR [ebx]
	npad	4
$LL13@Getloctxt:
	cmp	al, cl
	je	SHORT $LN200@Getloctxt
	mov	al, BYTE PTR [esi+ebx+1]
	inc	esi
	test	al, al
	jne	SHORT $LL13@Getloctxt
$LN200@Getloctxt:
	mov	ecx, DWORD PTR __Column$1$[ebp]
$LN11@Getloctxt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR __Str$[ebp]
	cmovae	eax, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 632  : 			if (_Str[_Field] != '\0')

	cmp	BYTE PTR [eax+edx], 0
	je	SHORT $LN10@Getloctxt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR __Str$[ebp]
	cmovae	eax, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 633  : 				_Off += _Str[_Field];	// skip tested columns in field

	movsx	eax, BYTE PTR [eax+edx]
	add	esi, eax

; 634  : 			else if (_Ptr[_Off += _Column] == _Ptr[0]

	jmp	$LN205@Getloctxt
$LN10@Getloctxt:

; 635  : 				|| _Ptr[_Off] == (_Elem)0)

	add	esi, ecx
	mov	al, BYTE PTR [esi+ebx]
	cmp	al, BYTE PTR [ebx]
	je	$LN7@Getloctxt
	test	al, al
	je	$LN7@Getloctxt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, edi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 641  : 			else if (_First == _Last || _Ptr[_Off] != *_First)

	test	al, al
	jne	SHORT $LN4@Getloctxt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [edi+4], al
	jne	SHORT $LN120@Getloctxt

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN118@Getloctxt

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN124@Getloctxt
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN124@Getloctxt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN125@Getloctxt
$LN124@Getloctxt:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN125@Getloctxt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN118@Getloctxt

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN117@Getloctxt
$LN118@Getloctxt:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN117@Getloctxt:

; 572  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN120@Getloctxt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 641  : 			else if (_First == _Last || _Ptr[_Off] != *_First)

	mov	al, BYTE PTR [esi+ebx]
	cmp	al, BYTE PTR [edi+5]
	jne	SHORT $LN4@Getloctxt

; 645  : 				_Prefix = true;	// still a valid prefix

	mov	edx, DWORD PTR __Field$1$[ebp]
	mov	ah, 1
	mov	BYTE PTR __Prefix$1$[ebp], ah
	jmp	SHORT $LN15@Getloctxt
$LN4@Getloctxt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H
	lea	edx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 643  : 					? _Column : 127);	// no match, just save skip count

	mov	eax, DWORD PTR __Column$1$[ebp]
	mov	ecx, 127				; 0000007fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmovae	edx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 643  : 					? _Column : 127);	// no match, just save skip count

	cmp	DWORD PTR __Column$1$[ebp], ecx
	movzx	eax, al
	cmovb	ecx, eax
	mov	eax, DWORD PTR __Field$1$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 644  : 			else

	mov	edx, eax
	jmp	SHORT $LN205@Getloctxt
$LN7@Getloctxt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H
	lea	edx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 638  : 					? _Column : 127);	// save skip count if small enough

	mov	eax, DWORD PTR __Column$1$[ebp]
	mov	ecx, 127				; 0000007fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmovae	edx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 638  : 					? _Column : 127);	// save skip count if small enough

	cmp	DWORD PTR __Column$1$[ebp], ecx
	movzx	eax, al
	cmovb	ecx, eax
	mov	eax, DWORD PTR __Field$1$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 639  : 				_Ans = (int)_Field;	// save answer

	mov	edx, eax
	mov	DWORD PTR __Ans$1$[ebp], edx
$LN205@Getloctxt:
	mov	ah, BYTE PTR __Prefix$1$[ebp]
$LN15@Getloctxt:

; 622  : 		{	// test each element against all viable fields
; 623  : 		bool _Prefix = false;	// seen at least one valid prefix
; 624  : 		size_t _Off = 0;	// offset into fields
; 625  : 		size_t _Field = 0;	// current field number
; 626  : 
; 627  : 		for (; _Field < _Numfields; ++_Field)

	inc	edx
	mov	DWORD PTR __Field$1$[ebp], edx
	cmp	edx, DWORD PTR __Numfields$1$[ebp]
	jb	$LL201@Getloctxt

; 648  : 		if (!_Prefix || _First == _Last)

	test	ah, ah
	je	SHORT $LN203@Getloctxt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, edi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 648  : 		if (!_Prefix || _First == _Last)

	test	al, al
	jne	SHORT $LN203@Getloctxt

; 621  : 	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)

	inc	DWORD PTR __Column$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN68@Getloctxt

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN74@Getloctxt
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN74@Getloctxt

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN75@Getloctxt
$LN74@Getloctxt:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN75@Getloctxt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN68@Getloctxt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 621  : 	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)

	mov	ecx, DWORD PTR __Column$1$[ebp]
	or	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 560  : 			_Got = false;

	mov	BYTE PTR [edi+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 621  : 	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)

	jmp	$LN206@Getloctxt
$LN68@Getloctxt:
	mov	ecx, DWORD PTR __Column$1$[ebp]
	or	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [edi], 0
	mov	BYTE PTR [edi+4], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 621  : 	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)

	jmp	$LN206@Getloctxt
$LN203@Getloctxt:
	mov	eax, DWORD PTR __Ans$1$[ebp]
$LN186@Getloctxt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR __Str$[ebp+20], 16		; 00000010H
	jb	SHORT $LN170@Getloctxt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Str$[ebp]
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 651  : 	return (_Ans);	// return field number or negative value on failure

	mov	eax, DWORD PTR __Ans$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	add	esp, 4
$LN170@Getloctxt:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 652  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z$0:
	lea	ecx, DWORD PTR __Str$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ENDP ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator!=<char,char>, COMDAT

; 669  : 	return (!(_Left == _Right));

	xor	al, al

; 670  : 	}

	ret	0
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator!=<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 218  : 		_DELETE_CRT_VEC((void *)_Grouping);

	push	DWORD PTR [esi+8]

; 135  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@

; 218  : 		_DELETE_CRT_VEC((void *)_Grouping);

	call	??_V@YAXPAX@Z				; operator delete[]

; 219  : 		_DELETE_CRT_VEC((void *)_Falsename);

	push	DWORD PTR [esi+16]
	call	??_V@YAXPAX@Z				; operator delete[]

; 220  : 		_DELETE_CRT_VEC((void *)_Truename);

	push	DWORD PTR [esi+20]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN12@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 217  : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 218  : 		_DELETE_CRT_VEC((void *)_Grouping);

	push	DWORD PTR [esi+8]
	call	??_V@YAXPAX@Z				; operator delete[]

; 219  : 		_DELETE_CRT_VEC((void *)_Falsename);

	push	DWORD PTR [esi+16]
	call	??_V@YAXPAX@Z				; operator delete[]

; 220  : 		_DELETE_CRT_VEC((void *)_Truename);

	push	DWORD PTR [esi+20]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
	pop	esi

; 221  : 		}

	ret	0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 211  : 		{	// return name for true

	push	ebp
	mov	ebp, esp
	push	ecx

; 212  : 		return (string_type(_Truename));

	mov	edx, DWORD PTR [ecx+20]
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN47@do_truenam
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 212  : 		return (string_type(_Truename));

	mov	eax, esi
	pop	esi

; 213  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN47@do_truenam:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL49@do_truenam:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL49@do_truenam
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 212  : 		return (string_type(_Truename));

	mov	eax, esi
	pop	esi

; 213  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 206  : 		{	// return name for false

	push	ebp
	mov	ebp, esp
	push	ecx

; 207  : 		return (string_type(_Falsename));

	mov	edx, DWORD PTR [ecx+16]
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN47@do_falsena
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 207  : 		return (string_type(_Falsename));

	mov	eax, esi
	pop	esi

; 208  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN47@do_falsena:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL49@do_falsena:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL49@do_falsena
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 207  : 		return (string_type(_Falsename));

	mov	eax, esi
	pop	esi

; 208  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 201  : 		{	// return grouping string

	push	ebp
	mov	ebp, esp
	push	ecx

; 202  : 		return (string(_Grouping));

	mov	edx, DWORD PTR [ecx+8]
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN47@do_groupin
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 202  : 		return (string(_Grouping));

	mov	eax, esi
	pop	esi

; 203  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN47@do_groupin:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL49@do_groupin:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL49@do_groupin
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 202  : 		return (string(_Grouping));

	mov	eax, esi
	pop	esi

; 203  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 197  : 		return (_Kseparator);

	mov	al, BYTE PTR [ecx+13]

; 198  : 		}

	ret	0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 192  : 		return (_Dp);

	mov	al, BYTE PTR [ecx+12]

; 193  : 		}

	ret	0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
$T2 = -68						; size = 44
$T3 = -68						; size = 44
__Ptr$1$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 162  : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 127  : 		return (localeconv());

	call	_localeconv
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 163  : 		const lconv *_Ptr = _Lobj._Getlconv();

	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 122  : 		return (::_Getcvt());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 163  : 		const lconv *_Ptr = _Lobj._Getlconv();

	mov	DWORD PTR __Ptr$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 122  : 		return (::_Getcvt());

	call	__Getcvt
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 166  : 		_Grouping = 0;

	mov	DWORD PTR [ebx+8], 0

; 171  : 		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,

	cmp	BYTE PTR __Isdef$[ebp], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	je	SHORT $LN6@Init
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN7@Init
$LN6@Init:
	mov	esi, DWORD PTR [esi+8]
$LN7@Init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 122  : 		return (::_Getcvt());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__Getcvt
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 728  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 122  : 		return (::_Getcvt());

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 728  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	lea	ecx, DWORD PTR [edi+1]
$LL59@Init:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL59@Init
	sub	edi, ecx
	inc	edi

; 729  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

	push	edi
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	edx, eax

; 730  : 
; 731  :  #pragma warning(push)
; 732  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 733  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	test	edi, edi
	je	SHORT $LN18@Init
	mov	ecx, edx
	sub	ecx, esi
$LL20@Init:

; 734  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	dec	edi
	jne	SHORT $LL20@Init
$LN18@Init:

; 728  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 171  : 		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,

	mov	DWORD PTR [ebx+8], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 729  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 173  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);

	mov	esi, OFFSET ??_C@_05LAPONLG@false?$AA@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 729  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

	call	??_U@YAPAXI@Z				; operator new[]

; 730  : 
; 731  :  #pragma warning(push)
; 732  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 733  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	mov	edx, eax
	add	esp, 4
	sub	edx, esi
$LL27@Init:

; 734  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	dec	edi
	jne	SHORT $LL27@Init

; 728  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 173  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);

	mov	DWORD PTR [ebx+16], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 729  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 174  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);

	mov	esi, OFFSET ??_C@_04LOAJBDKD@true?$AA@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 729  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

	call	??_U@YAPAXI@Z				; operator new[]

; 730  : 
; 731  :  #pragma warning(push)
; 732  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 733  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	mov	edx, eax
	add	esp, 4
	sub	edx, esi
	npad	4
$LL34@Init:

; 734  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	cl, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [edx+esi-1], cl
	dec	edi
	jne	SHORT $LL34@Init
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 174  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);

	cmp	BYTE PTR __Isdef$[ebp], 0
	mov	DWORD PTR [ebx+20], eax

; 178  : 		_CATCH_END
; 179  : 
; 180  : 		if (_Isdef)

	je	SHORT $LN2@Init

; 181  : 			{	// apply defaults for required facets
; 182  : //			_Grouping = _MAKLOCSTR(char, "", _Cvt);
; 183  : 			_Dp = _MAKLOCCHR(_Elem, '.', _Cvt);

	mov	WORD PTR [ebx+12], 11310		; 00002c2eH

; 184  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);
; 185  : 			}
; 186  : 		else
; 187  : 			_Getvals((_Elem)0, _Ptr, _Cvt);
; 188  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@Init:

; 150  : 		_Dp = _MAKLOCCHR(_Elem2, _Ptr->decimal_point[0], _Cvt);

	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ebx+12], al

; 151  : 		_Kseparator = _MAKLOCCHR(_Elem2, _Ptr->thousands_sep[0], _Cvt);

	mov	eax, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ebx+13], al

; 184  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);
; 185  : 			}
; 186  : 		else
; 187  : 			_Getvals((_Elem)0, _Ptr, _Cvt);
; 188  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0:

; 175  : 		_CATCH_ALL
; 176  : 		_Tidy();

	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy

; 177  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN62@Init:
$LN61@Init:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 135  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 138  : 
; 139  : 	numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
; 140  : 		: locale::facet(_Refs)
; 141  : 		{	// construct from specified locale
; 142  : 		_BEGIN_LOCINFO(_Lobj(_Locname))
; 143  : 			_Init(_Lobj, _Isdef);
; 144  : 		_END_LOCINFO()
; 145  : 		}
; 146  : 
; 147  : 	template<class _Elem2>
; 148  : 		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
; 149  : 		{	// get values
; 150  : 		_Dp = _MAKLOCCHR(_Elem2, _Ptr->decimal_point[0], _Cvt);
; 151  : 		_Kseparator = _MAKLOCCHR(_Elem2, _Ptr->thousands_sep[0], _Cvt);
; 152  : 		}
; 153  : 
; 154  : 	template<>
; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
; 156  : 		{	// get values
; 157  : 		_Dp = (_Elem)_Ptr->_W_decimal_point[0];
; 158  : 		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
; 159  : 		}
; 160  : 
; 161  : 	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
; 162  : 		{	// initialize from _Lobj
; 163  : 		const lconv *_Ptr = _Lobj._Getlconv();
; 164  : 		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	// conversion information
; 165  : 
; 166  : 		_Grouping = 0;
; 167  : 		_Falsename = 0;
; 168  : 		_Truename = 0;
; 169  : 
; 170  : 		_TRY_BEGIN
; 171  : 		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,
; 172  : 			_Lobj._Getcvt());
; 173  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);
; 174  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);
; 175  : 		_CATCH_ALL
; 176  : 		_Tidy();
; 177  : 		_RERAISE;
; 178  : 		_CATCH_END
; 179  : 
; 180  : 		if (_Isdef)
; 181  : 			{	// apply defaults for required facets
; 182  : //			_Grouping = _MAKLOCSTR(char, "", _Cvt);
; 183  : 			_Dp = _MAKLOCCHR(_Elem, '.', _Cvt);
; 184  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);
; 185  : 			}
; 186  : 		else
; 187  : 			_Getvals((_Elem)0, _Ptr, _Cvt);
; 188  : 		}
; 189  : 
; 190  : 	virtual _Elem __CLR_OR_THIS_CALL do_decimal_point() const
; 191  : 		{	// return decimal point
; 192  : 		return (_Dp);
; 193  : 		}
; 194  : 
; 195  : 	virtual _Elem __CLR_OR_THIS_CALL do_thousands_sep() const
; 196  : 		{	// return thousands separator
; 197  : 		return (_Kseparator);
; 198  : 		}
; 199  : 
; 200  : 	virtual string __CLR_OR_THIS_CALL do_grouping() const
; 201  : 		{	// return grouping string
; 202  : 		return (string(_Grouping));
; 203  : 		}
; 204  : 
; 205  : 	virtual string_type __CLR_OR_THIS_CALL do_falsename() const
; 206  : 		{	// return name for false
; 207  : 		return (string_type(_Falsename));
; 208  : 		}
; 209  : 
; 210  : 	virtual string_type __CLR_OR_THIS_CALL do_truename() const
; 211  : 		{	// return name for true
; 212  : 		return (string_type(_Truename));
; 213  : 		}
; 214  : 
; 215  : private:
; 216  : 	void _Tidy()
; 217  : 		{	// free all storage
; 218  : 		_DELETE_CRT_VEC((void *)_Grouping);

	push	DWORD PTR [esi+8]

; 135  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@

; 138  : 
; 139  : 	numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
; 140  : 		: locale::facet(_Refs)
; 141  : 		{	// construct from specified locale
; 142  : 		_BEGIN_LOCINFO(_Lobj(_Locname))
; 143  : 			_Init(_Lobj, _Isdef);
; 144  : 		_END_LOCINFO()
; 145  : 		}
; 146  : 
; 147  : 	template<class _Elem2>
; 148  : 		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
; 149  : 		{	// get values
; 150  : 		_Dp = _MAKLOCCHR(_Elem2, _Ptr->decimal_point[0], _Cvt);
; 151  : 		_Kseparator = _MAKLOCCHR(_Elem2, _Ptr->thousands_sep[0], _Cvt);
; 152  : 		}
; 153  : 
; 154  : 	template<>
; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
; 156  : 		{	// get values
; 157  : 		_Dp = (_Elem)_Ptr->_W_decimal_point[0];
; 158  : 		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
; 159  : 		}
; 160  : 
; 161  : 	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
; 162  : 		{	// initialize from _Lobj
; 163  : 		const lconv *_Ptr = _Lobj._Getlconv();
; 164  : 		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	// conversion information
; 165  : 
; 166  : 		_Grouping = 0;
; 167  : 		_Falsename = 0;
; 168  : 		_Truename = 0;
; 169  : 
; 170  : 		_TRY_BEGIN
; 171  : 		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,
; 172  : 			_Lobj._Getcvt());
; 173  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);
; 174  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);
; 175  : 		_CATCH_ALL
; 176  : 		_Tidy();
; 177  : 		_RERAISE;
; 178  : 		_CATCH_END
; 179  : 
; 180  : 		if (_Isdef)
; 181  : 			{	// apply defaults for required facets
; 182  : //			_Grouping = _MAKLOCSTR(char, "", _Cvt);
; 183  : 			_Dp = _MAKLOCCHR(_Elem, '.', _Cvt);
; 184  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);
; 185  : 			}
; 186  : 		else
; 187  : 			_Getvals((_Elem)0, _Ptr, _Cvt);
; 188  : 		}
; 189  : 
; 190  : 	virtual _Elem __CLR_OR_THIS_CALL do_decimal_point() const
; 191  : 		{	// return decimal point
; 192  : 		return (_Dp);
; 193  : 		}
; 194  : 
; 195  : 	virtual _Elem __CLR_OR_THIS_CALL do_thousands_sep() const
; 196  : 		{	// return thousands separator
; 197  : 		return (_Kseparator);
; 198  : 		}
; 199  : 
; 200  : 	virtual string __CLR_OR_THIS_CALL do_grouping() const
; 201  : 		{	// return grouping string
; 202  : 		return (string(_Grouping));
; 203  : 		}
; 204  : 
; 205  : 	virtual string_type __CLR_OR_THIS_CALL do_falsename() const
; 206  : 		{	// return name for false
; 207  : 		return (string_type(_Falsename));
; 208  : 		}
; 209  : 
; 210  : 	virtual string_type __CLR_OR_THIS_CALL do_truename() const
; 211  : 		{	// return name for true
; 212  : 		return (string_type(_Truename));
; 213  : 		}
; 214  : 
; 215  : private:
; 216  : 	void _Tidy()
; 217  : 		{	// free all storage
; 218  : 		_DELETE_CRT_VEC((void *)_Grouping);

	call	??_V@YAXPAX@Z				; operator delete[]

; 219  : 		_DELETE_CRT_VEC((void *)_Falsename);

	push	DWORD PTR [esi+16]
	call	??_V@YAXPAX@Z				; operator delete[]

; 220  : 		_DELETE_CRT_VEC((void *)_Truename);

	push	DWORD PTR [esi+20]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 137  : 		}

	ret	0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 126  : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	xor	ebx, ebx
	mov	DWORD PTR $T3[ebp], ebx

; 127  : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	edi, DWORD PTR __Ppf$[ebp]
	test	edi, edi
	je	SHORT $LN28@Getcat
	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN28@Getcat

; 129  : 				_Locinfo(_Ploc->c_str()), 0, true);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	test	esi, esi
	je	SHORT $LN4@Getcat
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR __Ploc$[ebp]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN12@Getcat
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN17@Getcat
$LN12@Getcat:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3398 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN17@Getcat
	lea	eax, DWORD PTR [ecx+28]
$LN17@Getcat:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 129  : 				_Locinfo(_Ploc->c_str()), 0, true);

	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	ebx, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR $T3[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 121  : 		_Init(_Lobj, _Isdef);

	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init

; 129  : 				_Locinfo(_Ploc->c_str()), 0, true);

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	esi, esi
$LN5@Getcat:
	mov	DWORD PTR [edi], esi
	test	bl, 1
	je	SHORT $LN28@Getcat
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN28@Getcat:

; 130  : 		return (_X_NUMERIC);

	mov	eax, 4

; 131  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T3[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T3[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN8@Getcat:
	ret	0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2:
	mov	ecx, DWORD PTR $T4[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx

; 120  : 		{	// construct from specified locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	eax, DWORD PTR __Refs$[ebp]
	mov	DWORD PTR [esi+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 121  : 		_Init(_Lobj, _Isdef);

	push	DWORD PTR __Isdef$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	DWORD PTR __Lobj$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init

; 122  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<char>::numpunct<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 103  : 		{	// return name for true

	push	ebp
	mov	ebp, esp
	push	ecx

; 104  : 		return (do_truename());

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	DWORD PTR [edx+28]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 105  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 98   : 		{	// return name for false

	push	ebp
	mov	ebp, esp
	push	ecx

; 99   : 		return (do_falsename());

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	DWORD PTR [edx+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 100  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 93   : 		{	// return grouping string

	push	ebp
	mov	ebp, esp
	push	ecx

; 94   : 		return (do_grouping());

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	DWORD PTR [edx+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 95   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 89   : 		return (do_thousands_sep());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	jmp	eax
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 84   : 		return (do_decimal_point());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	jmp	eax
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 561  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 562  :  #if _NO_LOCALES
; 563  : 	static _Wrap_facet<_Facet> _Wfac;
; 564  : 	return (*(_Facet *)&_Wfac);
; 565  : 
; 566  :  #else /* _NO_LOCALES */
; 567  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 79   : 			if (_Id == 0)

	mov	edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id

; 568  : 		const locale::facet *_Psave =
; 569  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __Psave$5[ebp], ebx

; 79   : 			if (_Id == 0)

	test	edi, edi
	jne	SHORT $LN11@use_facet

; 80   : 				{	// still zero, allocate stamp
; 81   : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 82   : 					if (_Id == 0)

	cmp	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, edi ; std::numpunct<char>::id
	jne	SHORT $LN10@use_facet

; 83   : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN10@use_facet:

; 84   : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
$LN11@use_facet:

; 85   : 				}
; 86   : 			return (_Id);
; 87   : 			}
; 88   : 
; 89   : 	private:
; 90   : 		size_t _Id;	// the identifier stamp
; 91   : 
; 92   : 		__PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 93   : 
; 94   : 	public:
; 95   : 		__CLR_OR_THIS_CALL id(const id&) = delete;
; 96   : 		id& __CLR_OR_THIS_CALL operator=(const id&) = delete;
; 97   : 		};
; 98   : 
; 99   : 	class _Locimp;
; 100  : 
; 101  : 			// CLASS facet
; 102  : 	class _CRTIMP2_PURE facet
; 103  : 		: public _Facet_base
; 104  : 		{	// base class for all locale facets, performs reference counting
; 105  : 		friend class locale;
; 106  : 		friend class _Locimp;
; 107  : 
; 108  : 		template<class _Ty>
; 109  : 			friend void __CLRCALL_OR_CDECL _DebugHeapDelete(_Ty *_Ptr);
; 110  : 
; 111  : 	public:
; 112  : 		static size_t __CLRCALL_OR_CDECL _Getcat(const facet ** = 0,
; 113  : 			const locale * = 0)
; 114  : 			{	// get category value, or -1 if no corresponding C category
; 115  : 			return ((size_t)(-1));
; 116  : 			}
; 117  : 
; 118  :   #if defined(_DEBUG) && !defined(_M_X64)
; 119  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size)
; 120  : 			{	// replace operator new
; 121  : 			return (operator new(_Size, _DebugHeapTag_func(),
; 122  : 				__FILE__, __LINE__));
; 123  : 			}
; 124  : 
; 125  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size,
; 126  : 			const _DebugHeapTag_t& _Tag, char *_File, int _Line)
; 127  : 			{	// replace debugging operator new
; 128  : 			return (::operator new(_Size, _Tag, _File, _Line));
; 129  : 			}
; 130  : 
; 131  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr,
; 132  : 			const _DebugHeapTag_t&, char *, int)
; 133  : 			{	// replace debugging operator delete
; 134  : 			operator delete(_Ptr);
; 135  : 			}
; 136  : 
; 137  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr)
; 138  : 			{	// replace operator delete
; 139  : 			_DebugHeapDelete((facet *)_Ptr);
; 140  : 			}
; 141  :   #endif /* defined(_DEBUG) etc. */
; 142  : 
; 143  : 		virtual void __CLR_OR_THIS_CALL _Incref()
; 144  : 			{   // increment use count
; 145  : 			_MT_INCR(_Mtx, _Refs);
; 146  : 			}
; 147  : 
; 148  : 		virtual _Facet_base *__CLR_OR_THIS_CALL _Decref()
; 149  : 			{   // decrement use count
; 150  : 			if (_MT_DECR(_Mtx, _Refs) == 0)
; 151  : 				return (this);
; 152  : 			else
; 153  : 				return (0);
; 154  : 			}
; 155  : 
; 156  : 	private:
; 157  : 		_Atomic_counter_t _Refs;	// the reference count
; 158  : 
; 159  : 	protected:
; 160  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 161  : 			{	// construct with initial reference count
; 162  : 			_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
; 163  : 			}
; 164  : 
; 165  : 		virtual __CLR_OR_THIS_CALL ~facet() _NOEXCEPT
; 166  : 			{	// ensure that derived classes can be destroyed properly
; 167  : 			}
; 168  : 
; 169  : 	public:
; 170  : 		__CLR_OR_THIS_CALL facet(const facet&) = delete;
; 171  : 		facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 172  : 		};
; 173  : 
; 174  : 			// CLASS _Locimp
; 175  :  #pragma warning(push)
; 176  :  #pragma warning(disable: 4275)
; 177  : 
; 178  : 	class _CRTIMP2_PURE _Locimp
; 179  : 		: public facet
; 180  : 		{	// reference-counted actual implementation of a locale
; 181  : 	protected:
; 182  : 		__CLR_OR_THIS_CALL ~_Locimp() _NOEXCEPT
; 183  : 		{	// destroy the object
; 184  : 		_Locimp_dtor(this);
; 185  : 		}
; 186  : 
; 187  : 	private:
; 188  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 189  : 			_New_Locimp(bool _Transparent = false);
; 190  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 191  : 			_New_Locimp(const _Locimp& _Right);
; 192  : 
; 193  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 194  : 			_Locimp_dtor(_Locimp *);
; 195  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 196  : 			_Locimp_Addfac(_Locimp *, facet *, size_t);	// add a facet
; 197  : 		static void __CLRCALL_PURE_OR_CDECL
; 198  : 			_Locimp_ctor(_Locimp *, const _Locimp&);
; 199  : 
; 200  : 		friend class locale;
; 201  : 
; 202  : 		__CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 203  : 			: locale::facet(1), _Facetvec(0), _Facetcount(0),
; 204  : 				_Catmask(none), _Xparent(_Transparent),
; 205  : 					_Name("*")
; 206  : 			{	// construct an empty _Locimp
; 207  : 			}
; 208  : 
; 209  : 		__CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 210  : 			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
; 211  : 				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
; 212  : 					_Name(_Right._Name.c_str())
; 213  : 			{	// construct by copying
; 214  : 			_Locimp_ctor(this, _Right);
; 215  : 			}
; 216  : 
; 217  : 		void __CLR_OR_THIS_CALL _Addfac(facet *_Pfacet, size_t _Id)
; 218  : 			{	// add a facet
; 219  : 			_Locimp_Addfac(this, _Pfacet, _Id);
; 220  : 			}
; 221  : 
; 222  : 		static _Locimp *__CLRCALL_OR_CDECL _Makeloc(const _Locinfo&,
; 223  : 			category, _Locimp *, const locale *);	// make essential facets
; 224  : 
; 225  : 		static void __CLRCALL_OR_CDECL _Makewloc(const _Locinfo&,
; 226  : 			category, _Locimp *, const locale *);	// make wchar_t facets
; 227  : 
; 228  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 229  : 		static void __CLRCALL_OR_CDECL _Makeushloc(const _Locinfo&,
; 230  : 			category, _Locimp *, const locale *);	// make ushort facets
; 231  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 232  : 
; 233  : 		static void __CLRCALL_OR_CDECL _Makexloc(const _Locinfo&,
; 234  : 			category, _Locimp *, const locale *);	// make remaining facets
; 235  : 
; 236  : 		facet **_Facetvec;	// pointer to vector of facets
; 237  : 		size_t _Facetcount;	// size of vector of facets
; 238  : 		category _Catmask;	// mask describing implemented categories
; 239  : 		bool _Xparent;	// true if locale is transparent
; 240  : 		_Yarn<char> _Name;	// locale name, or "*" if not known
; 241  : 
; 242  : 		__PURE_APPDOMAIN_GLOBAL static _Locimp *_Clocptr;
; 243  : 
; 244  : public:
; 245  : 		_Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 246  : 		};
; 247  : 
; 248  :  #pragma warning(pop)
; 249  : 
; 250  : 	template<class _Elem,
; 251  : 		class _Traits,
; 252  : 		class _Alloc>
; 253  : 		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 254  : 			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
; 255  : 		{	// compare _Left and _Right strings using collate facet in locale
; 256  : 		const _STD collate<_Elem>& _Coll_fac =
; 257  : 			use_facet<_STD collate<_Elem> >(*this);
; 258  : 
; 259  : 		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
; 260  : 			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
; 261  : 		}
; 262  : 
; 263  : 	template<class _Facet>
; 264  : 		locale combine(const locale& _Loc) const
; 265  : 		{	// combine two locales
; 266  : 		_Facet *_Facptr;
; 267  : 
; 268  : 		_TRY_BEGIN
; 269  : 			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
; 270  : 		_CATCH_ALL
; 271  : 			_Xruntime_error("locale::combine facet missing");
; 272  : 		_CATCH_END
; 273  : 
; 274  : 		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
; 275  : 		_Newimp->_Addfac(_Facptr, _Facet::id);
; 276  : 		_Newimp->_Catmask = 0;
; 277  : 		_Newimp->_Name = "*";
; 278  : 		return (locale(_Newimp));
; 279  : 		}
; 280  : 
; 281  : 	template<class _Facet>
; 282  : 		locale(const locale& _Loc, const _Facet *_Facptr)
; 283  : 			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 284  : 		{	// construct from _Loc, replacing facet with *_Facptr
; 285  : 		if (_Facptr != 0)
; 286  : 			{	// replace facet
; 287  : 			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
; 288  : 			if (_Facet::_Getcat() != (size_t)(-1))
; 289  : 				{	// no C category
; 290  : 				_Ptr->_Catmask = 0;
; 291  : 				_Ptr->_Name = "*";
; 292  : 				}
; 293  : 			}
; 294  : 		}
; 295  : 
; 296  : 	locale(_Uninitialized)
; 297  : 		{	// defer construction
; 298  : 		}
; 299  : 
; 300  :  #if _NO_LOCALES
; 301  : 	locale(const locale& _Right) _THROW0()
; 302  : 		: _Ptr(0)
; 303  : 		{	// construct by copying
; 304  : 		}
; 305  : 
; 306  : 	locale() _THROW0()
; 307  : 		: _Ptr(0)
; 308  : 		{	// construct from current locale
; 309  : 		}
; 310  : 
; 311  : 	~locale() _NOEXCEPT
; 312  : 		{	// destroy the object
; 313  : 		}
; 314  : 
; 315  : 	locale& operator=(const locale& _Right) _THROW0()
; 316  : 		{	// assign a locale
; 317  : 		return (*this);
; 318  : 		}
; 319  : 
; 320  :  #else /* _NO_LOCALES */
; 321  : 	locale(const locale& _Right) _THROW0()
; 322  : 		: _Ptr(_Right._Ptr)
; 323  : 		{	// construct by copying
; 324  : 		_Ptr->_Incref();
; 325  : 		}
; 326  : 
; 327  : 	locale() _THROW0()
; 328  : 		: _Ptr(_Init(true))
; 329  : 		{	// construct from current locale
; 330  : 		}
; 331  : 
; 332  :  #if !defined(MRTDLL) || !defined(_CRTBLD)
; 333  : 	locale(const locale& _Loc, const locale& _Other,
; 334  : 		category _Cat)
; 335  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 336  : 		{	// construct a locale by copying named facets
; 337  : 		_TRY_BEGIN
; 338  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 339  : 			_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
; 340  : 				_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
; 341  : 		_END_LOCINFO()
; 342  : 		_CATCH_ALL
; 343  : 		_DELETE_CRT(_Ptr->_Decref());
; 344  : 		_RERAISE;
; 345  : 		_CATCH_END
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	void _Construct(const string &_Str,
; 350  : 		category _Cat)	// construct from named locale for category
; 351  : 		{	// construct a locale with named facets
; 352  : 		bool _Bad = false;
; 353  : 		_TRY_BEGIN
; 354  : 		_Init();
; 355  : 		_BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 356  : 			if (_Badname(_Lobj))
; 357  : 				_Bad = true;
; 358  : 			else
; 359  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 360  : 		_END_LOCINFO()
; 361  : 		_CATCH_ALL
; 362  : 		_DELETE_CRT(_Ptr->_Decref());
; 363  : 		_RERAISE;
; 364  : 		_CATCH_END
; 365  : 
; 366  : 		if (_Bad)
; 367  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 368  : 			_DELETE_CRT(_Ptr->_Decref());
; 369  : 			_Xruntime_error("bad locale name");
; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 	void _Construct(const locale& _Loc, const string &_Str,
; 374  : 		category _Cat)
; 375  : 		{	// construct a locale by copying, replacing named facets
; 376  : 		bool _Bad = false;
; 377  : 		_TRY_BEGIN
; 378  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 379  : 			bool _Hadname = !_Badname(_Lobj);
; 380  : 			_Lobj._Addcats(_Cat, _Str.c_str());
; 381  : 
; 382  : 			if (_Hadname && _Badname(_Lobj))
; 383  : 				_Bad = true;
; 384  : 			else
; 385  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 386  : 		_END_LOCINFO()
; 387  : 		_CATCH_ALL
; 388  : 		_DELETE_CRT(_Ptr->_Decref());
; 389  : 		_RERAISE;
; 390  : 		_CATCH_END
; 391  : 
; 392  : 		if (_Bad)
; 393  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 394  : 			_DELETE_CRT(_Ptr->_Decref());
; 395  : 			_Xruntime_error("bad locale name");
; 396  : 			}
; 397  : 		}
; 398  : 
; 399  : public:
; 400  : 	explicit locale(const char *_Locname,
; 401  : 		category _Cat = all)	// construct from named locale for category
; 402  : 		: _Ptr(_Locimp::_New_Locimp())
; 403  : 		{	// construct a locale with named facets
; 404  : 		// _Locname might have been returned from setlocale().
; 405  : 		// Therefore, _Construct() takes const string&.
; 406  : 		if (_Locname == 0)
; 407  : 			_Xruntime_error("bad locale name");
; 408  : 		_Construct(_Locname, _Cat);
; 409  : 		}
; 410  : 
; 411  : 	locale(const locale& _Loc, const char *_Locname,
; 412  : 		category _Cat)
; 413  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 414  : 		{	// construct a locale by copying, replacing named facets
; 415  : 		// _Locname might have been returned from setlocale().
; 416  : 		// Therefore, _Construct() takes const string&.
; 417  : 		if (_Locname == 0)
; 418  : 			_Xruntime_error("bad locale name");
; 419  : 		_Construct(_Loc, _Locname, _Cat);
; 420  : 		}
; 421  : 
; 422  : 	explicit locale(const string& _Str,
; 423  : 		category _Cat = all)	// construct from named locale for category
; 424  : 		: _Ptr(_Locimp::_New_Locimp())
; 425  : 		{	// construct a locale with named facets
; 426  : 		_Construct(_Str, _Cat);
; 427  : 		}
; 428  : 
; 429  : 	locale(const locale& _Loc, const string& _Str,
; 430  : 		category _Cat)
; 431  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 432  : 		{	// construct a locale by copying, replacing named facets
; 433  : 		_Construct(_Loc, _Str, _Cat);
; 434  : 		}
; 435  :  #endif /* !MRTDLL || !_CRTBLD */
; 436  : 
; 437  : 	~locale() _NOEXCEPT
; 438  : 		{	// destroy the object
; 439  : 		if (_Ptr != 0)
; 440  : 			_DELETE_CRT(_Ptr->_Decref());
; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	mov	ecx, DWORD PTR __Loc$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN20@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	SHORT $LN1@use_facet
	jmp	SHORT $LN24@use_facet
$LN20@use_facet:

; 85   : 				}
; 86   : 			return (_Id);
; 87   : 			}
; 88   : 
; 89   : 	private:
; 90   : 		size_t _Id;	// the identifier stamp
; 91   : 
; 92   : 		__PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 93   : 
; 94   : 	public:
; 95   : 		__CLR_OR_THIS_CALL id(const id&) = delete;
; 96   : 		id& __CLR_OR_THIS_CALL operator=(const id&) = delete;
; 97   : 		};
; 98   : 
; 99   : 	class _Locimp;
; 100  : 
; 101  : 			// CLASS facet
; 102  : 	class _CRTIMP2_PURE facet
; 103  : 		: public _Facet_base
; 104  : 		{	// base class for all locale facets, performs reference counting
; 105  : 		friend class locale;
; 106  : 		friend class _Locimp;
; 107  : 
; 108  : 		template<class _Ty>
; 109  : 			friend void __CLRCALL_OR_CDECL _DebugHeapDelete(_Ty *_Ptr);
; 110  : 
; 111  : 	public:
; 112  : 		static size_t __CLRCALL_OR_CDECL _Getcat(const facet ** = 0,
; 113  : 			const locale * = 0)
; 114  : 			{	// get category value, or -1 if no corresponding C category
; 115  : 			return ((size_t)(-1));
; 116  : 			}
; 117  : 
; 118  :   #if defined(_DEBUG) && !defined(_M_X64)
; 119  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size)
; 120  : 			{	// replace operator new
; 121  : 			return (operator new(_Size, _DebugHeapTag_func(),
; 122  : 				__FILE__, __LINE__));
; 123  : 			}
; 124  : 
; 125  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size,
; 126  : 			const _DebugHeapTag_t& _Tag, char *_File, int _Line)
; 127  : 			{	// replace debugging operator new
; 128  : 			return (::operator new(_Size, _Tag, _File, _Line));
; 129  : 			}
; 130  : 
; 131  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr,
; 132  : 			const _DebugHeapTag_t&, char *, int)
; 133  : 			{	// replace debugging operator delete
; 134  : 			operator delete(_Ptr);
; 135  : 			}
; 136  : 
; 137  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr)
; 138  : 			{	// replace operator delete
; 139  : 			_DebugHeapDelete((facet *)_Ptr);
; 140  : 			}
; 141  :   #endif /* defined(_DEBUG) etc. */
; 142  : 
; 143  : 		virtual void __CLR_OR_THIS_CALL _Incref()
; 144  : 			{   // increment use count
; 145  : 			_MT_INCR(_Mtx, _Refs);
; 146  : 			}
; 147  : 
; 148  : 		virtual _Facet_base *__CLR_OR_THIS_CALL _Decref()
; 149  : 			{   // decrement use count
; 150  : 			if (_MT_DECR(_Mtx, _Refs) == 0)
; 151  : 				return (this);
; 152  : 			else
; 153  : 				return (0);
; 154  : 			}
; 155  : 
; 156  : 	private:
; 157  : 		_Atomic_counter_t _Refs;	// the reference count
; 158  : 
; 159  : 	protected:
; 160  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 161  : 			{	// construct with initial reference count
; 162  : 			_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
; 163  : 			}
; 164  : 
; 165  : 		virtual __CLR_OR_THIS_CALL ~facet() _NOEXCEPT
; 166  : 			{	// ensure that derived classes can be destroyed properly
; 167  : 			}
; 168  : 
; 169  : 	public:
; 170  : 		__CLR_OR_THIS_CALL facet(const facet&) = delete;
; 171  : 		facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 172  : 		};
; 173  : 
; 174  : 			// CLASS _Locimp
; 175  :  #pragma warning(push)
; 176  :  #pragma warning(disable: 4275)
; 177  : 
; 178  : 	class _CRTIMP2_PURE _Locimp
; 179  : 		: public facet
; 180  : 		{	// reference-counted actual implementation of a locale
; 181  : 	protected:
; 182  : 		__CLR_OR_THIS_CALL ~_Locimp() _NOEXCEPT
; 183  : 		{	// destroy the object
; 184  : 		_Locimp_dtor(this);
; 185  : 		}
; 186  : 
; 187  : 	private:
; 188  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 189  : 			_New_Locimp(bool _Transparent = false);
; 190  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 191  : 			_New_Locimp(const _Locimp& _Right);
; 192  : 
; 193  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 194  : 			_Locimp_dtor(_Locimp *);
; 195  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 196  : 			_Locimp_Addfac(_Locimp *, facet *, size_t);	// add a facet
; 197  : 		static void __CLRCALL_PURE_OR_CDECL
; 198  : 			_Locimp_ctor(_Locimp *, const _Locimp&);
; 199  : 
; 200  : 		friend class locale;
; 201  : 
; 202  : 		__CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 203  : 			: locale::facet(1), _Facetvec(0), _Facetcount(0),
; 204  : 				_Catmask(none), _Xparent(_Transparent),
; 205  : 					_Name("*")
; 206  : 			{	// construct an empty _Locimp
; 207  : 			}
; 208  : 
; 209  : 		__CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 210  : 			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
; 211  : 				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
; 212  : 					_Name(_Right._Name.c_str())
; 213  : 			{	// construct by copying
; 214  : 			_Locimp_ctor(this, _Right);
; 215  : 			}
; 216  : 
; 217  : 		void __CLR_OR_THIS_CALL _Addfac(facet *_Pfacet, size_t _Id)
; 218  : 			{	// add a facet
; 219  : 			_Locimp_Addfac(this, _Pfacet, _Id);
; 220  : 			}
; 221  : 
; 222  : 		static _Locimp *__CLRCALL_OR_CDECL _Makeloc(const _Locinfo&,
; 223  : 			category, _Locimp *, const locale *);	// make essential facets
; 224  : 
; 225  : 		static void __CLRCALL_OR_CDECL _Makewloc(const _Locinfo&,
; 226  : 			category, _Locimp *, const locale *);	// make wchar_t facets
; 227  : 
; 228  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 229  : 		static void __CLRCALL_OR_CDECL _Makeushloc(const _Locinfo&,
; 230  : 			category, _Locimp *, const locale *);	// make ushort facets
; 231  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 232  : 
; 233  : 		static void __CLRCALL_OR_CDECL _Makexloc(const _Locinfo&,
; 234  : 			category, _Locimp *, const locale *);	// make remaining facets
; 235  : 
; 236  : 		facet **_Facetvec;	// pointer to vector of facets
; 237  : 		size_t _Facetcount;	// size of vector of facets
; 238  : 		category _Catmask;	// mask describing implemented categories
; 239  : 		bool _Xparent;	// true if locale is transparent
; 240  : 		_Yarn<char> _Name;	// locale name, or "*" if not known
; 241  : 
; 242  : 		__PURE_APPDOMAIN_GLOBAL static _Locimp *_Clocptr;
; 243  : 
; 244  : public:
; 245  : 		_Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 246  : 		};
; 247  : 
; 248  :  #pragma warning(pop)
; 249  : 
; 250  : 	template<class _Elem,
; 251  : 		class _Traits,
; 252  : 		class _Alloc>
; 253  : 		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 254  : 			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
; 255  : 		{	// compare _Left and _Right strings using collate facet in locale
; 256  : 		const _STD collate<_Elem>& _Coll_fac =
; 257  : 			use_facet<_STD collate<_Elem> >(*this);
; 258  : 
; 259  : 		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
; 260  : 			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
; 261  : 		}
; 262  : 
; 263  : 	template<class _Facet>
; 264  : 		locale combine(const locale& _Loc) const
; 265  : 		{	// combine two locales
; 266  : 		_Facet *_Facptr;
; 267  : 
; 268  : 		_TRY_BEGIN
; 269  : 			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
; 270  : 		_CATCH_ALL
; 271  : 			_Xruntime_error("locale::combine facet missing");
; 272  : 		_CATCH_END
; 273  : 
; 274  : 		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
; 275  : 		_Newimp->_Addfac(_Facptr, _Facet::id);
; 276  : 		_Newimp->_Catmask = 0;
; 277  : 		_Newimp->_Name = "*";
; 278  : 		return (locale(_Newimp));
; 279  : 		}
; 280  : 
; 281  : 	template<class _Facet>
; 282  : 		locale(const locale& _Loc, const _Facet *_Facptr)
; 283  : 			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 284  : 		{	// construct from _Loc, replacing facet with *_Facptr
; 285  : 		if (_Facptr != 0)
; 286  : 			{	// replace facet
; 287  : 			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
; 288  : 			if (_Facet::_Getcat() != (size_t)(-1))
; 289  : 				{	// no C category
; 290  : 				_Ptr->_Catmask = 0;
; 291  : 				_Ptr->_Name = "*";
; 292  : 				}
; 293  : 			}
; 294  : 		}
; 295  : 
; 296  : 	locale(_Uninitialized)
; 297  : 		{	// defer construction
; 298  : 		}
; 299  : 
; 300  :  #if _NO_LOCALES
; 301  : 	locale(const locale& _Right) _THROW0()
; 302  : 		: _Ptr(0)
; 303  : 		{	// construct by copying
; 304  : 		}
; 305  : 
; 306  : 	locale() _THROW0()
; 307  : 		: _Ptr(0)
; 308  : 		{	// construct from current locale
; 309  : 		}
; 310  : 
; 311  : 	~locale() _NOEXCEPT
; 312  : 		{	// destroy the object
; 313  : 		}
; 314  : 
; 315  : 	locale& operator=(const locale& _Right) _THROW0()
; 316  : 		{	// assign a locale
; 317  : 		return (*this);
; 318  : 		}
; 319  : 
; 320  :  #else /* _NO_LOCALES */
; 321  : 	locale(const locale& _Right) _THROW0()
; 322  : 		: _Ptr(_Right._Ptr)
; 323  : 		{	// construct by copying
; 324  : 		_Ptr->_Incref();
; 325  : 		}
; 326  : 
; 327  : 	locale() _THROW0()
; 328  : 		: _Ptr(_Init(true))
; 329  : 		{	// construct from current locale
; 330  : 		}
; 331  : 
; 332  :  #if !defined(MRTDLL) || !defined(_CRTBLD)
; 333  : 	locale(const locale& _Loc, const locale& _Other,
; 334  : 		category _Cat)
; 335  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 336  : 		{	// construct a locale by copying named facets
; 337  : 		_TRY_BEGIN
; 338  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 339  : 			_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
; 340  : 				_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
; 341  : 		_END_LOCINFO()
; 342  : 		_CATCH_ALL
; 343  : 		_DELETE_CRT(_Ptr->_Decref());
; 344  : 		_RERAISE;
; 345  : 		_CATCH_END
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	void _Construct(const string &_Str,
; 350  : 		category _Cat)	// construct from named locale for category
; 351  : 		{	// construct a locale with named facets
; 352  : 		bool _Bad = false;
; 353  : 		_TRY_BEGIN
; 354  : 		_Init();
; 355  : 		_BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 356  : 			if (_Badname(_Lobj))
; 357  : 				_Bad = true;
; 358  : 			else
; 359  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 360  : 		_END_LOCINFO()
; 361  : 		_CATCH_ALL
; 362  : 		_DELETE_CRT(_Ptr->_Decref());
; 363  : 		_RERAISE;
; 364  : 		_CATCH_END
; 365  : 
; 366  : 		if (_Bad)
; 367  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 368  : 			_DELETE_CRT(_Ptr->_Decref());
; 369  : 			_Xruntime_error("bad locale name");
; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 	void _Construct(const locale& _Loc, const string &_Str,
; 374  : 		category _Cat)
; 375  : 		{	// construct a locale by copying, replacing named facets
; 376  : 		bool _Bad = false;
; 377  : 		_TRY_BEGIN
; 378  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 379  : 			bool _Hadname = !_Badname(_Lobj);
; 380  : 			_Lobj._Addcats(_Cat, _Str.c_str());
; 381  : 
; 382  : 			if (_Hadname && _Badname(_Lobj))
; 383  : 				_Bad = true;
; 384  : 			else
; 385  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 386  : 		_END_LOCINFO()
; 387  : 		_CATCH_ALL
; 388  : 		_DELETE_CRT(_Ptr->_Decref());
; 389  : 		_RERAISE;
; 390  : 		_CATCH_END
; 391  : 
; 392  : 		if (_Bad)
; 393  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 394  : 			_DELETE_CRT(_Ptr->_Decref());
; 395  : 			_Xruntime_error("bad locale name");
; 396  : 			}
; 397  : 		}
; 398  : 
; 399  : public:
; 400  : 	explicit locale(const char *_Locname,
; 401  : 		category _Cat = all)	// construct from named locale for category
; 402  : 		: _Ptr(_Locimp::_New_Locimp())
; 403  : 		{	// construct a locale with named facets
; 404  : 		// _Locname might have been returned from setlocale().
; 405  : 		// Therefore, _Construct() takes const string&.
; 406  : 		if (_Locname == 0)
; 407  : 			_Xruntime_error("bad locale name");
; 408  : 		_Construct(_Locname, _Cat);
; 409  : 		}
; 410  : 
; 411  : 	locale(const locale& _Loc, const char *_Locname,
; 412  : 		category _Cat)
; 413  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 414  : 		{	// construct a locale by copying, replacing named facets
; 415  : 		// _Locname might have been returned from setlocale().
; 416  : 		// Therefore, _Construct() takes const string&.
; 417  : 		if (_Locname == 0)
; 418  : 			_Xruntime_error("bad locale name");
; 419  : 		_Construct(_Loc, _Locname, _Cat);
; 420  : 		}
; 421  : 
; 422  : 	explicit locale(const string& _Str,
; 423  : 		category _Cat = all)	// construct from named locale for category
; 424  : 		: _Ptr(_Locimp::_New_Locimp())
; 425  : 		{	// construct a locale with named facets
; 426  : 		_Construct(_Str, _Cat);
; 427  : 		}
; 428  : 
; 429  : 	locale(const locale& _Loc, const string& _Str,
; 430  : 		category _Cat)
; 431  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 432  : 		{	// construct a locale by copying, replacing named facets
; 433  : 		_Construct(_Loc, _Str, _Cat);
; 434  : 		}
; 435  :  #endif /* !MRTDLL || !_CRTBLD */
; 436  : 
; 437  : 	~locale() _NOEXCEPT
; 438  : 		{	// destroy the object
; 439  : 		if (_Ptr != 0)
; 440  : 			_DELETE_CRT(_Ptr->_Decref());
; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	xor	esi, esi
$LN24@use_facet:

; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN15@use_facet

; 470  : 			return (_Facptr);	// found facet or not transparent
; 471  : 		else
; 472  : 			{	// look in current locale
; 473  : 			locale::_Locimp *_Ptr = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 474  : 			return (_Id < _Ptr->_Facetcount
; 475  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 476  : 				: 0);	// no entry in current locale

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN25@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 570  : 
; 571  : 		size_t _Id = _Facet::id;
; 572  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 573  : 
; 574  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN1@use_facet
$LN25@use_facet:

; 575  : 			;	// got facet from locale
; 576  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet

; 577  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN1@use_facet
$LN4@use_facet:

; 578  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	push	DWORD PTR __Loc$[ebp]
	lea	eax, DWORD PTR __Psave$5[ebp]
	push	eax
	call	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN2@use_facet

; 579  : 
; 580  :  #if _HAS_EXCEPTIONS
; 581  : 
; 582  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
$LN29@use_facet:
$LN2@use_facet:

; 583  : 
; 584  :  #else /* _HAS_EXCEPTIONS */
; 585  : 			abort();	// lazy disallowed
; 586  :  #endif /* _HAS_EXCEPTIONS */
; 587  : 
; 588  : 		else
; 589  : 			{	// queue up lazy facet for destruction
; 590  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$5[ebp]

; 591  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 592  : 
; 593  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 594  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+4]

; 595  : 
; 596  :  #if defined(_M_CEE)
; 597  : 			_Facet_Register_m(_Pfmod);
; 598  : 
; 599  :  #else /* defined(_M_CEE) */
; 600  : 			_Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4
$LN1@use_facet:

; 601  :  #endif /* defined(_M_CEE) */
; 602  : 			}
; 603  : 
; 604  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 605  : 	_END_LOCK()
; 606  :  #endif /* _NO_LOCALES */
; 607  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$3[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 656  : 		return (_Failed);

	mov	al, BYTE PTR [ecx]

; 657  : 		}

	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 646  : 		return (*this);

	mov	eax, ecx

; 647  : 		}

	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 641  : 		return (*this);

	mov	eax, ecx

; 642  : 		}

	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 631  : 		{	// store element and increment

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 634  : 				_Strbuf->sputc(_Right)))

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN1@operator

; 304  : 		}
; 305  : 
; 306  : 	streamsize __CLR_OR_THIS_CALL _Pnavail() const
; 307  : 		{	// count number of available positions in write buffer
; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	test	eax, eax
	jle	SHORT $LN7@operator

; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);
; 278  : 		}
; 279  : 
; 280  : 	void __CLR_OR_THIS_CALL pbump(int _Off)
; 281  : 		{	// alter current position in write buffer by _Off
; 282  : 		*_IPcount -= _Off;
; 283  : 		*_IPnext += _Off;
; 284  : 		}
; 285  : 
; 286  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
; 287  : 		{	// set pointers for write buffer
; 288  : 		*_IPfirst = _First;
; 289  : 		*_IPnext = _First;
; 290  : 		*_IPcount = (int)(_Last - _First);
; 291  : 		}
; 292  : 
; 293  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 294  : 		{	// set pointers for write buffer, extended version
; 295  : 		*_IPfirst = _First;
; 296  : 		*_IPnext = _Next;
; 297  : 		*_IPcount = (int)(_Last - _Next);
; 298  : 		}
; 299  : 
; 300  : 	_Elem *__CLR_OR_THIS_CALL _Pninc()
; 301  : 		{	// increment current position in write buffer
; 302  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 303  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	al, BYTE PTR __Right$[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	jmp	SHORT $LN8@operator
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	push	eax
	call	DWORD PTR [edx+12]
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 634  : 				_Strbuf->sputc(_Right)))

	jne	SHORT $LN24@operator
$LN1@operator:

; 635  : 			_Failed = true;

	mov	BYTE PTR [esi], 1
$LN24@operator:

; 636  : 		return (*this);

	mov	eax, esi
	pop	esi

; 637  : 		}

	pop	ebp
	ret	4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 622  : 		{	// construct from stream buffer _Sb

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Sb$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 623  : 		}

	mov	eax, ecx
	mov	BYTE PTR [ecx], 0
	pop	ebp
	ret	4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1557 : 		{	// put _Count * _Ch to _Dest

	push	ebp
	mov	ebp, esp
	push	esi

; 1558 : 		for (; 0 < _Count; --_Count, ++_Dest)

	mov	esi, DWORD PTR __Dest$[ebp+4]
	push	edi
	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	SHORT $LN1@Rep
	push	ebx
	mov	bl, BYTE PTR __Ch$[ebp]
$LL6@Rep:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 634  : 				_Strbuf->sputc(_Right)))

	test	esi, esi
	je	SHORT $LN10@Rep

; 304  : 		}
; 305  : 
; 306  : 	streamsize __CLR_OR_THIS_CALL _Pnavail() const
; 307  : 		{	// count number of available positions in write buffer
; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@Rep
	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [ecx]

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	test	eax, eax
	jle	SHORT $LN16@Rep

; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);
; 278  : 		}
; 279  : 
; 280  : 	void __CLR_OR_THIS_CALL pbump(int _Off)
; 281  : 		{	// alter current position in write buffer by _Off
; 282  : 		*_IPcount -= _Off;
; 283  : 		*_IPnext += _Off;
; 284  : 		}
; 285  : 
; 286  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
; 287  : 		{	// set pointers for write buffer
; 288  : 		*_IPfirst = _First;
; 289  : 		*_IPnext = _First;
; 290  : 		*_IPcount = (int)(_Last - _First);
; 291  : 		}
; 292  : 
; 293  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 294  : 		{	// set pointers for write buffer, extended version
; 295  : 		*_IPfirst = _First;
; 296  : 		*_IPnext = _Next;
; 297  : 		*_IPcount = (int)(_Last - _Next);
; 298  : 		}
; 299  : 
; 300  : 	_Elem *__CLR_OR_THIS_CALL _Pninc()
; 301  : 		{	// increment current position in write buffer
; 302  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [ecx], eax

; 303  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	BYTE PTR [edx], bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	jmp	SHORT $LN17@Rep
$LN16@Rep:
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, bl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	push	eax
	call	DWORD PTR [edx+12]
$LN17@Rep:

; 634  : 				_Strbuf->sputc(_Right)))

	mov	esi, DWORD PTR __Dest$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 634  : 				_Strbuf->sputc(_Right)))

	jne	SHORT $LN2@Rep
$LN10@Rep:

; 635  : 			_Failed = true;

	mov	BYTE PTR __Dest$[ebp], 1
$LN2@Rep:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1558 : 		for (; 0 < _Count; --_Count, ++_Dest)

	dec	edi
	jne	SHORT $LL6@Rep
	pop	ebx
$LN1@Rep:

; 1559 : 			*_Dest = _Ch;
; 1560 : 		return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 1561 : 		}

	pop	ebp
	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
__Ch$1$ = 31						; size = 1
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1549 : 		{	// put [_Ptr, _Ptr + _Count) to _Dest

	push	ebp
	mov	ebp, esp
	push	esi

; 1550 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	mov	esi, DWORD PTR __Count$[ebp]
	push	edi
	mov	edi, DWORD PTR __Dest$[ebp+4]
	test	esi, esi
	je	SHORT $LN1@Put
	push	ebx
	mov	ebx, DWORD PTR __Ptr$[ebp]
$LL3@Put:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 634  : 				_Strbuf->sputc(_Right)))

	test	edi, edi
	je	SHORT $LN10@Put

; 304  : 		}
; 305  : 
; 306  : 	streamsize __CLR_OR_THIS_CALL _Pnavail() const
; 307  : 		{	// count number of available positions in write buffer
; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [edi+32]

; 634  : 				_Strbuf->sputc(_Right)))

	mov	cl, BYTE PTR [ebx]
	mov	BYTE PTR __Ch$1$[ebp], cl

; 304  : 		}
; 305  : 
; 306  : 	streamsize __CLR_OR_THIS_CALL _Pnavail() const
; 307  : 		{	// count number of available positions in write buffer
; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@Put
	mov	edx, DWORD PTR [edi+48]
	mov	eax, DWORD PTR [edx]

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	test	eax, eax
	jle	SHORT $LN16@Put

; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);
; 278  : 		}
; 279  : 
; 280  : 	void __CLR_OR_THIS_CALL pbump(int _Off)
; 281  : 		{	// alter current position in write buffer by _Off
; 282  : 		*_IPcount -= _Off;
; 283  : 		*_IPnext += _Off;
; 284  : 		}
; 285  : 
; 286  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
; 287  : 		{	// set pointers for write buffer
; 288  : 		*_IPfirst = _First;
; 289  : 		*_IPnext = _First;
; 290  : 		*_IPcount = (int)(_Last - _First);
; 291  : 		}
; 292  : 
; 293  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 294  : 		{	// set pointers for write buffer, extended version
; 295  : 		*_IPfirst = _First;
; 296  : 		*_IPnext = _Next;
; 297  : 		*_IPcount = (int)(_Last - _Next);
; 298  : 		}
; 299  : 
; 300  : 	_Elem *__CLR_OR_THIS_CALL _Pninc()
; 301  : 		{	// increment current position in write buffer
; 302  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 303  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	al, BYTE PTR __Ch$1$[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	jmp	SHORT $LN17@Put
$LN16@Put:
	mov	edx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, cl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	ecx, edi
	push	eax
	call	DWORD PTR [edx+12]
$LN17@Put:

; 634  : 				_Strbuf->sputc(_Right)))

	mov	edi, DWORD PTR __Dest$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 634  : 				_Strbuf->sputc(_Right)))

	jne	SHORT $LN2@Put
$LN10@Put:

; 635  : 			_Failed = true;

	mov	BYTE PTR __Dest$[ebp], 1
$LN2@Put:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1550 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	inc	ebx
	dec	esi
	jne	SHORT $LL3@Put
	pop	ebx
$LN1@Put:

; 1551 : 			*_Dest = *_Ptr;
; 1552 : 		return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 1553 : 		}

	pop	ebp
	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -88				; size = 4
__Punct_fac$1$ = -84					; size = 4
$T2 = -84						; size = 4
$T3 = -80						; size = 8
$T4 = -80						; size = 8
$T5 = -80						; size = 8
$T6 = -80						; size = 8
$T7 = -80						; size = 8
$T8 = -80						; size = 8
__Iosbase$GSCopy$1$ = -76				; size = 4
__Dest$3$ = -72						; size = 4
__Ctype_fac$1$ = -72					; size = 4
__Count$GSCopy$2$ = -68					; size = 4
__Buf$GSCopy$1$ = -68					; size = 4
__Kseparator$9 = -68					; size = 1
$T10 = -68						; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1489 : 		{	// put formatted integer to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	ecx, DWORD PTR __Buf$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	DWORD PTR __Iosbase$GSCopy$1$[ebp], esi
	mov	DWORD PTR __Buf$GSCopy$1$[ebp], ecx

; 1490 : 		_DEBUG_POINTER(_Dest);
; 1491 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
; 1492 : 			? 1 : 0;

	test	edi, edi
	je	SHORT $LN14@Iput
	mov	al, BYTE PTR [ecx]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN13@Iput
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN14@Iput
$LN13@Iput:
	mov	ebx, 1
	jmp	SHORT $LN15@Iput
$LN14@Iput:
	xor	ebx, ebx
$LN15@Iput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 367  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [esi+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1495 : 			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

	and	eax, 3584				; 00000e00H
	cmp	eax, 2048				; 00000800H
	jne	SHORT $LN10@Iput
	lea	eax, DWORD PTR [ebx+2]
	cmp	eax, edi
	ja	SHORT $LN10@Iput
	cmp	BYTE PTR [ecx+ebx], 48			; 00000030H
	jne	SHORT $LN10@Iput
	mov	cl, BYTE PTR [ecx+ebx+1]
	cmp	cl, 120					; 00000078H
	je	SHORT $LN9@Iput
	cmp	cl, 88					; 00000058H
	jne	SHORT $LN10@Iput
$LN9@Iput:

; 1496 : 			_Prefix += 2;

	mov	ebx, eax
$LN10@Iput:

; 1499 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);

	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, esi
	push	eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1499 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);

	add	esp, 4
	mov	DWORD PTR __Ctype_fac$1$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN27@Iput

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN27@Iput
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN27@Iput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 796  : 		assign(_Count, _Ch);

	push	0
	push	edi
	lea	ecx, DWORD PTR __Groupstring$[ebp]

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Groupstring$[ebp+20], 15	; 0000000fH

; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Groupstring$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR __Groupstring$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 796  : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
	lea	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1501 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	mov	ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2424 : 		return (do_widen(_First, _Last, _Dest));

	mov	edx, DWORD PTR __Ctype_fac$1$[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1501 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	lea	eax, DWORD PTR [edi+ecx]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2424 : 		return (do_widen(_First, _Last, _Dest));

	push	eax
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR __Ctype_fac$1$[ebp]
	call	DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1503 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	eax, DWORD PTR $T10[ebp]
	mov	ecx, esi
	push	eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T10[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1503 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	esi, eax
	mov	DWORD PTR __Punct_fac$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN80@Iput

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN80@Iput
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN80@Iput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1504 : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[ebp]
	mov	ecx, esi
	push	eax
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H
	lea	esi, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1504 : 		const string _Grouping = _Punct_fac.grouping();

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmovae	esi, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1506 : 		if (*_Pg != CHAR_MAX && '\0' < *_Pg)

	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	je	SHORT $LN6@Iput
	test	al, al
	jle	SHORT $LN6@Iput

; 89   : 		return (do_thousands_sep());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 1507 : 			{	// grouping specified, add thousands separators
; 1508 : 			const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	BYTE PTR __Kseparator$9[ebp], al

; 1509 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1510 : 				&& (size_t)*_Pg < _Count - _Prefix)

	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	je	SHORT $LN6@Iput
$LL7@Iput:
	test	al, al
	jle	SHORT $LN6@Iput
	movsx	ecx, al
	mov	eax, edi
	sub	eax, ebx
	cmp	ecx, eax
	jae	SHORT $LN6@Iput

; 1511 : 				{	// insert thousands separator
; 1512 : 				_Count -= *_Pg;
; 1513 : 				_Groupstring.insert(_Count, 1, _Kseparator);

	push	DWORD PTR __Kseparator$9[ebp]
	sub	edi, ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	push	1
	push	edi
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1514 : 				if ('\0' < _Pg[1])

	cmp	BYTE PTR [esi+1], 0
	lea	eax, DWORD PTR [esi+1]
	cmovg	esi, eax
	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	jne	SHORT $LL7@Iput
$LN6@Iput:

; 1522 : 				? 0 : (size_t)_Iosbase.width() - _Count;

	mov	esi, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR __Groupstring$[ebp+16]
	mov	DWORD PTR __Count$GSCopy$2$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1522 : 				? 0 : (size_t)_Iosbase.width() - _Count;

	cmp	DWORD PTR [esi+36], 0
	jl	SHORT $LN16@Iput
	jg	SHORT $LN204@Iput
	cmp	DWORD PTR [esi+32], 0
	jbe	SHORT $LN16@Iput
$LN204@Iput:
	mov	edi, DWORD PTR [esi+32]
	cmp	edi, eax
	jbe	SHORT $LN16@Iput
	sub	edi, eax
	jmp	SHORT $LN17@Iput
$LN16@Iput:
	xor	edi, edi
$LN17@Iput:

; 1523 : 
; 1524 : 		ios_base::fmtflags _Adjustfield =
; 1525 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [esi+20]
	and	eax, 448				; 000001c0H

; 1526 : 		if (_Adjustfield != ios_base::left
; 1527 : 			&& _Adjustfield != ios_base::internal)

	cmp	eax, 64					; 00000040H
	je	$LN2@Iput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN203@Iput

; 1529 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	push	edi
	push	DWORD PTR __Fill$[ebp]
	lea	eax, DWORD PTR $T8[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	lea	ecx, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1530 : 			_Fillcount = 0;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1531 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmovae	ecx, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1529 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Dest$[ebp], eax
	mov	eax, DWORD PTR [edx+4]

; 1531 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	ecx
	mov	DWORD PTR __Dest$[ebp+4], eax
	lea	eax, DWORD PTR $T7[ebp]
	push	DWORD PTR [edx+4]
	push	DWORD PTR [edx]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 48					; 00000030H

; 1532 : 			}
; 1533 : 		else if (_Adjustfield == ios_base::internal)

	jmp	SHORT $LN208@Iput
$LN203@Iput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
	lea	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1535 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1535 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[ebp+4]
	lea	eax, DWORD PTR $T6[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	ecx, eax

; 1536 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	push	edi
	push	DWORD PTR __Fill$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Dest$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Dest$[ebp+4], eax
	lea	eax, DWORD PTR $T5[ebp]
	push	DWORD PTR [ecx+4]
	push	DWORD PTR [ecx]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H

; 1537 : 			_Fillcount = 0;

	xor	edi, edi

; 1538 : 			}
; 1539 : 		else

	jmp	SHORT $LN208@Iput
$LN2@Iput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
	lea	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1540 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1540 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[ebp+4]
	lea	eax, DWORD PTR $T4[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
$LN208@Iput:
	mov	edx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1542 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	ecx, DWORD PTR __Count$GSCopy$2$[ebp]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$3$[ebp], eax
	mov	DWORD PTR __Dest$[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	lea	eax, DWORD PTR __Groupstring$[ebp]
	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1542 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	sub	ecx, ebx
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1691 : 		return (this->_Myptr()[_Off]);

	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1542 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	ebx, DWORD PTR _this$[ebp]
	push	eax
	push	DWORD PTR __Dest$3$[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	push	edx
	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1544 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	push	edi
	push	DWORD PTR __Fill$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 418  : 		_Wide = _Newwidth;

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1544 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	push	esi
	push	ebx
	mov	DWORD PTR __Dest$[ebp+4], eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H
	jb	SHORT $LN156@Iput
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Grouping$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN156@Iput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Grouping$[ebp+20], 15	; 0000000fH

; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Grouping$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR __Grouping$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN205@Iput
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Groupstring$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN205@Iput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1544 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	eax, esi

; 1545 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1461 : 		{	// generate sprintf format for integer

	push	ebp
	mov	ebp, esp

; 1462 : 		char *_Ptr = _Fmt;
; 1463 : 		*_Ptr++ = '%';
; 1464 : 
; 1465 : 		if (_Flags & ios_base::showpos)

	mov	ecx, DWORD PTR __Flags$[ebp]
	push	esi
	mov	esi, DWORD PTR __Fmt$[ebp]
	push	edi
	mov	BYTE PTR [esi], 37			; 00000025H
	lea	eax, DWORD PTR [esi+1]
	test	cl, 32					; 00000020H
	je	SHORT $LN4@Ifmt

; 1466 : 			*_Ptr++ = '+';

	mov	BYTE PTR [eax], 43			; 0000002bH
	inc	eax
$LN4@Ifmt:

; 1467 : 		if (_Flags & ios_base::showbase)

	test	cl, 8
	je	SHORT $LN3@Ifmt

; 1468 : 			*_Ptr++ = '#';

	mov	BYTE PTR [eax], 35			; 00000023H
	inc	eax
$LN3@Ifmt:

; 1469 : 		if (_Spec[0] != 'L')

	mov	edi, DWORD PTR __Spec$[ebp]
	mov	dl, BYTE PTR [edi]
	cmp	dl, 76					; 0000004cH
	je	SHORT $LN2@Ifmt

; 1470 : 			*_Ptr++ = _Spec[0];	// qualifier

	mov	BYTE PTR [eax], dl
	inc	eax

; 1471 : 		else

	jmp	SHORT $LN1@Ifmt
$LN2@Ifmt:

; 1472 : 
; 1473 : 			{	/* change L to I64 */
; 1474 : 			*_Ptr++ = 'I';

	mov	WORD PTR [eax], 13897			; 00003649H

; 1475 : 			*_Ptr++ = '6';
; 1476 : 			*_Ptr++ = '4';

	mov	BYTE PTR [eax+2], 52			; 00000034H
	add	eax, 3
$LN1@Ifmt:

; 1477 : 			}
; 1478 : 
; 1479 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	edx, ecx
	and	edx, 3584				; 00000e00H

; 1480 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1481 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1482 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	cmp	edx, 1024				; 00000400H
	jne	SHORT $LN9@Ifmt
	mov	cl, 111					; 0000006fH
	mov	BYTE PTR [eax], cl

; 1483 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax+1], 0

; 1484 : 		return (_Fmt);

	mov	eax, esi
	pop	edi
	pop	esi

; 1485 : 		}

	pop	ebp
	ret	0
$LN9@Ifmt:

; 1480 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1481 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1482 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	cmp	edx, 2048				; 00000800H
	je	SHORT $LN7@Ifmt
	mov	cl, BYTE PTR [edi+1]
	mov	BYTE PTR [eax], cl

; 1483 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax+1], 0

; 1484 : 		return (_Fmt);

	mov	eax, esi
	pop	edi
	pop	esi

; 1485 : 		}

	pop	ebp
	ret	0
$LN7@Ifmt:

; 1480 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1481 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1482 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	shl	cl, 3
	not	cl
	and	cl, 32					; 00000020H
	or	cl, 88					; 00000058H
	mov	BYTE PTR [eax], cl

; 1483 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax+1], 0

; 1484 : 		return (_Fmt);

	mov	eax, esi
	pop	edi
	pop	esi

; 1485 : 		}

	pop	ebp
	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -112				; size = 4
__E0$ = -108						; size = 1
__Eoff$1$ = -104					; size = 4
__Poff$1$ = -100					; size = 4
$T2 = -96						; size = 4
$T3 = -96						; size = 4
$T4 = -92						; size = 8
$T5 = -92						; size = 8
$T6 = -92						; size = 8
$T7 = -92						; size = 8
$T8 = -92						; size = 8
$T9 = -92						; size = 8
__Iosbase$GSCopy$1$ = -88				; size = 4
__Count$GSCopy$1$ = -84					; size = 4
__Count$GSCopy$2$ = -80					; size = 4
__Kseparator$ = -80					; size = 1
__Punct_fac$1$ = -76					; size = 4
__Ctype_fac$1$ = -76					; size = 4
__Dp$ = -72						; size = 2
__Dest$3$ = -68						; size = 4
__Prefix$1$ = -68					; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Beforepoint$ = 36					; size = 4
__Afterpoint$ = 40					; size = 4
__Trailing$ = 44					; size = 4
__Count$ = 48						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1375 : 		{	// put formatted floating-point to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	ebx, DWORD PTR __Buf$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	DWORD PTR __Iosbase$GSCopy$1$[ebp], esi
	mov	DWORD PTR __Count$GSCopy$1$[ebp], ecx

; 1376 : 		_DEBUG_POINTER(_Dest);
; 1377 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
; 1378 : 			? 1 : 0;

	test	ecx, ecx
	je	SHORT $LN17@Fput
	mov	al, BYTE PTR [ebx]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN16@Fput
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN17@Fput
$LN16@Fput:
	mov	edi, 1
	jmp	SHORT $LN223@Fput
$LN17@Fput:
	xor	edi, edi
$LN223@Fput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 367  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [esi+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1381 : 		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)

	and	eax, 12288				; 00003000H
	mov	DWORD PTR __Prefix$1$[ebp], edi
	cmp	eax, 12288				; 00003000H
	je	SHORT $LN13@Fput

; 1382 : 			_Exps = "eE";

	mov	edx, OFFSET ??_C@_02MDKMJEGG@eE?$AA@

; 1383 : 		else

	jmp	SHORT $LN11@Fput
$LN13@Fput:

; 1384 : 			{	// correct for hexadecimal floating-point
; 1385 : 			_Exps = "pP";
; 1386 : 			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1387 : 				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

	lea	eax, DWORD PTR [edi+2]
	mov	edx, OFFSET ??_C@_02OOPEBDOJ@pP?$AA@
	cmp	eax, ecx
	ja	SHORT $LN11@Fput
	cmp	BYTE PTR [ebx+edi], 48			; 00000030H
	jne	SHORT $LN11@Fput
	mov	cl, BYTE PTR [ebx+edi+1]
	cmp	cl, 120					; 00000078H
	je	SHORT $LN10@Fput
	cmp	cl, 88					; 00000058H
	jne	SHORT $LN11@Fput
$LN10@Fput:

; 1388 : 				_Prefix += 2;

	mov	edi, eax
	mov	DWORD PTR __Prefix$1$[ebp], edi
$LN11@Fput:

; 1389 : 			}
; 1390 : 		const size_t _Eoff =
; 1391 : 			_CSTD strcspn(&_Buf[0], _Exps);	// find exponent

	push	edx
	push	ebx
	call	_strcspn
	mov	DWORD PTR __Eoff$1$[ebp], eax

; 1392 : 		char _Dp[2] = {"."};

	mov	eax, 46					; 0000002eH
	mov	WORD PTR __Dp$[ebp], ax

; 1393 : 		_Dp[0] = _CSTD localeconv()->decimal_point[0];

	call	_localeconv
	mov	eax, DWORD PTR [eax]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR __Dp$[ebp], al

; 1394 : 		const size_t _Poff =
; 1395 : 			_CSTD strcspn(&_Buf[0], &_Dp[0]);	// find decimal point

	lea	eax, DWORD PTR __Dp$[ebp]
	push	eax
	push	ebx
	call	_strcspn
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Poff$1$[ebp], eax

; 1398 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);

	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, esi
	push	eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1398 : 			_USE(_Iosbase.getloc(), ctype<_Elem>);

	add	esp, 4
	mov	DWORD PTR __Ctype_fac$1$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN30@Fput

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN30@Fput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN30@Fput:

; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)
; 470  : 			return (_Facptr);	// found facet or not transparent
; 471  : 		else
; 472  : 			{	// look in current locale
; 473  : 			locale::_Locimp *_Ptr = _Getgloballocale();
; 474  : 			return (_Id < _Ptr->_Facetcount
; 475  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 476  : 				: 0);	// no entry in current locale
; 477  : 			}
; 478  : 		}
; 479  : 
; 480  : 	bool operator==(const locale& _Loc) const
; 481  : 		{	// compare locales for equality
; 482  : 		return (_Ptr == _Loc._Ptr
; 483  : 			|| (name().compare("*") != 0
; 484  : 				&& name().compare(_Loc.name()) == 0));
; 485  : 		}
; 486  : 
; 487  : 	bool operator!=(const locale& _Right) const
; 488  : 		{	// test for locale inequality
; 489  : 		return (!(*this == _Right));
; 490  : 		}
; 491  : 
; 492  : 	static _MRTIMP2_PURE const locale& __CLRCALL_PURE_OR_CDECL
; 493  : 		classic();	// classic "C" locale
; 494  : 
; 495  : 	static _MRTIMP2_PURE locale __CLRCALL_PURE_OR_CDECL
; 496  : 		global(const locale&);	// current locale
; 497  : 
; 498  : 	static _MRTIMP2_PURE locale __CLRCALL_PURE_OR_CDECL
; 499  : 		empty();	// empty (transparent) locale
; 500  : 
; 501  : private:
; 502  : 	locale(_Locimp *_Ptrimp)
; 503  : 		: _Ptr(_Ptrimp)
; 504  : 		{	// construct from _Locimp pointer
; 505  : 		}
; 506  : 
; 507  :     static _MRTIMP2_PURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 508  : 		_Init(bool _Do_incref = false);	// initialize locale
; 509  : 	static _MRTIMP2_PURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 510  : 		_Getgloballocale();
; 511  : 	static _MRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL
; 512  : 		_Setgloballocale(void *);
; 513  : 
; 514  : 	bool _Badname(const _Locinfo& _Lobj)
; 515  : 		{	// test if name is "*"
; 516  : 		return (_CSTD strcmp(_Lobj._Getname(), "*") == 0);
; 517  : 		}
; 518  : 
; 519  : 	_Locimp *_Ptr;	// pointer to locale implementation object
; 520  : 	};
; 521  : 
; 522  : 		// SUPPORT TEMPLATES
; 523  : 
; 524  :  #if _NO_LOCALES
; 525  : inline _Locinfo& _Get_locinfo()
; 526  : 	{	// get reference to common locale info
; 527  : 	static _Locinfo _Lobj;
; 528  : 	return (_Lobj);
; 529  : 	}
; 530  : 
; 531  : template<class _Facet>
; 532  : 	class _Wrap_facet
; 533  : 		: public _Facet
; 534  : 	{	// makes a facet destructible and shareable
; 535  : public:
; 536  : 	_Wrap_facet()
; 537  : 		: _Facet(_Get_locinfo())
; 538  : 		{	// construct from locale object
; 539  : 		}
; 540  : 	};
; 541  :  #endif /* _NO_LOCALES */
; 542  : 
; 543  : template<class _Facet>
; 544  : 	struct _Facetptr
; 545  : 	{	// store pointer to lazy facet for use_facet
; 546  : 	__PURE_APPDOMAIN_GLOBAL static const locale::facet *_Psave;
; 547  : 	};
; 548  : 
; 549  : template<class _Facet>
; 550  : 	__PURE_APPDOMAIN_GLOBAL const locale::facet *_Facetptr<_Facet>::
; 551  : 		_Psave = 0;
; 552  : 
; 553  :   #define _ADDFAC(loc, pfac)	locale(loc, pfac)	/* add facet to locale */
; 554  : 
; 555  :   #define _USE(loc, fac)	\
; 556  : 	use_facet< fac >(loc)	/* get facet reference from locale */
; 557  : 
; 558  : template<class _Facet> inline
; 559  : 	const _Facet& __CRTDECL use_facet(const locale& _Loc)
; 560  : 
; 561  : 	{	// get facet reference from locale
; 562  :  #if _NO_LOCALES
; 563  : 	static _Wrap_facet<_Facet> _Wfac;
; 564  : 	return (*(_Facet *)&_Wfac);
; 565  : 
; 566  :  #else /* _NO_LOCALES */
; 567  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic
; 568  : 		const locale::facet *_Psave =
; 569  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 570  : 
; 571  : 		size_t _Id = _Facet::id;
; 572  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 573  : 
; 574  : 		if (_Pf != 0)
; 575  : 			;	// got facet from locale
; 576  : 		else if (_Psave != 0)
; 577  : 			_Pf = _Psave;	// lazy facet already allocated
; 578  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))
; 579  : 
; 580  :  #if _HAS_EXCEPTIONS
; 581  : 
; 582  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed
; 583  : 
; 584  :  #else /* _HAS_EXCEPTIONS */
; 585  : 			abort();	// lazy disallowed
; 586  :  #endif /* _HAS_EXCEPTIONS */
; 587  : 
; 588  : 		else
; 589  : 			{	// queue up lazy facet for destruction
; 590  : 			_Pf = _Psave;
; 591  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 592  : 
; 593  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 594  : 			_Pfmod->_Incref();
; 595  : 
; 596  :  #if defined(_M_CEE)
; 597  : 			_Facet_Register_m(_Pfmod);
; 598  : 
; 599  :  #else /* defined(_M_CEE) */
; 600  : 			_Facet_Register(_Pfmod);
; 601  :  #endif /* defined(_M_CEE) */
; 602  : 			}
; 603  : 
; 604  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast
; 605  : 	_END_LOCK()
; 606  :  #endif /* _NO_LOCALES */
; 607  : 	}	// end of use_facet body
; 608  : 
; 609  : 		// TEMPLATE FUNCTION _Getloctxt
; 610  : template<class _Elem,
; 611  : 	class _InIt> inline
; 612  : 	int __CRTDECL _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
; 613  : 		const _Elem *_Ptr)
; 614  : 	{	// find field at _Ptr that matches longest in [_First, _Last)
; 615  : 	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
; 616  : 		if (_Ptr[_Off] == _Ptr[0])
; 617  : 			++_Numfields;	// add fields with leading mark to initial count
; 618  : 	string _Str(_Numfields, '\0');	// one column counter for each field
; 619  : 
; 620  : 	int _Ans = -2;	// no candidates so far
; 621  : 	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
; 622  : 		{	// test each element against all viable fields
; 623  : 		bool _Prefix = false;	// seen at least one valid prefix
; 624  : 		size_t _Off = 0;	// offset into fields
; 625  : 		size_t _Field = 0;	// current field number
; 626  : 
; 627  : 		for (; _Field < _Numfields; ++_Field)
; 628  : 			{	// test element at _Column in field _Field
; 629  : 			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
; 630  : 				;	// find beginning of field
; 631  : 
; 632  : 			if (_Str[_Field] != '\0')
; 633  : 				_Off += _Str[_Field];	// skip tested columns in field
; 634  : 			else if (_Ptr[_Off += _Column] == _Ptr[0]
; 635  : 				|| _Ptr[_Off] == (_Elem)0)
; 636  : 				{	// matched all of field, save as possible answer
; 637  : 				_Str[_Field] = (char)(_Column < 127
; 638  : 					? _Column : 127);	// save skip count if small enough
; 639  : 				_Ans = (int)_Field;	// save answer
; 640  : 				}
; 641  : 			else if (_First == _Last || _Ptr[_Off] != *_First)
; 642  : 				_Str[_Field] = (char)(_Column < 127
; 643  : 					? _Column : 127);	// no match, just save skip count
; 644  : 			else
; 645  : 				_Prefix = true;	// still a valid prefix
; 646  : 			}
; 647  : 
; 648  : 		if (!_Prefix || _First == _Last)
; 649  : 			break;	// no pending prefixes or no input, give up
; 650  : 		}
; 651  : 	return (_Ans);	// return field number or negative value on failure
; 652  : 	}
; 653  : 
; 654  : 		// TEMPLATE FUNCTION _Maklocbyte
; 655  : #define _MAKLOCBYTE(Elem, chr, cvt) \
; 656  : 	_Maklocbyte((_Elem)chr, cvt)	/* convert Elem to char */
; 657  : 
; 658  : template<class _Elem> inline
; 659  : 	char __CRTDECL _Maklocbyte(_Elem _Char,
; 660  : 		const _Locinfo::_Cvtvec&)
; 661  : 	{	// convert _Elem to char using _Cvtvec
; 662  : 	return ((char)(unsigned char)_Char);
; 663  : 	}
; 664  : 
; 665  : template<> inline
; 666  : 	char __CRTDECL _Maklocbyte(wchar_t _Char,
; 667  : 		const _Locinfo::_Cvtvec& _Cvt)
; 668  : 	{	// convert wchar_t to char using _Cvtvec
; 669  : 	char _Byte = '\0';
; 670  : 	_Mbstinit(_Mbst1);
; 671  : 	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
; 672  : 	return (_Byte);
; 673  : 	}
; 674  : 
; 675  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 676  : template<> inline
; 677  : 	char __CRTDECL _Maklocbyte(unsigned short _Char,
; 678  : 		const _Locinfo::_Cvtvec &_Cvt)
; 679  : 	{	// convert unsigned short to char using _Cvtvec
; 680  : 	char _Byte = '\0';
; 681  : 	_Mbstinit(_Mbst1);
; 682  : 	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
; 683  : 	return (_Byte);
; 684  : 	}
; 685  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 686  : 
; 687  : 		// TEMPLATE FUNCTION _Maklocchr
; 688  : #define _MAKLOCCHR(Elem, chr, cvt) \
; 689  : 	_Maklocchr(chr, (Elem *)0, cvt)	/* convert char to Elem */
; 690  : 
; 691  : template<class _Elem> inline
; 692  : 	_Elem __CRTDECL _Maklocchr(char _Byte, _Elem *,
; 693  : 		const _Locinfo::_Cvtvec&)
; 694  : 	{	// convert char to _Elem using _Cvtvec
; 695  : 	return ((_Elem)(unsigned char)_Byte);
; 696  : 	}
; 697  : 
; 698  : template<> inline
; 699  : 	wchar_t __CRTDECL _Maklocchr(char _Byte, wchar_t *,
; 700  : 		const _Locinfo::_Cvtvec& _Cvt)
; 701  : 	{	// convert char to wchar_t using _Cvtvec
; 702  : 	wchar_t _Wc = L'\0';
; 703  : 	_Mbstinit(_Mbst1);
; 704  : 	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
; 705  : 	return (_Wc);
; 706  : 	}
; 707  : 
; 708  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 709  : template<> inline
; 710  : 	unsigned short __CRTDECL _Maklocchr(char _Byte, unsigned short *,
; 711  : 		const _Locinfo::_Cvtvec &_Cvt)
; 712  : 	{	// convert char to unsigned short using _Cvtvec
; 713  : 	unsigned short _Wc = (unsigned short)0;
; 714  : 	_Mbstinit(_Mbst1);
; 715  : 	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
; 716  : 	return (_Wc);
; 717  : 	}
; 718  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 719  : 
; 720  : 		// TEMPLATE FUNCTION _Maklocstr
; 721  : #define _MAKLOCSTR(Elem, str, cvt)	\
; 722  : 	_Maklocstr(str, (Elem *)0, cvt)	/* convert C string to Elem sequence */
; 723  : 
; 724  : template<class _Elem> inline
; 725  : 	_Elem *__CRTDECL _Maklocstr(const char *_Ptr, _Elem *,
; 726  : 		const _Locinfo::_Cvtvec&)
; 727  : 	{	// convert C string to _Elem sequence using _Cvtvec
; 728  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;
; 729  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];
; 730  : 
; 731  :  #pragma warning(push)
; 732  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 733  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
; 734  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
; 735  :  #pragma warning(pop)
; 736  : 
; 737  : 	return (_Ptrdest);
; 738  : 	}
; 739  : 
; 740  : template<> inline
; 741  : 	wchar_t *__CRTDECL _Maklocstr(const char *_Ptr, wchar_t *,
; 742  : 		const _Locinfo::_Cvtvec& _Cvt)
; 743  : 	{	// convert C string to wchar_t sequence using _Cvtvec
; 744  : 	size_t _Count, _Count1;
; 745  : 	size_t _Wchars;
; 746  : 	const char *_Ptr1;
; 747  : 	int _Bytes;
; 748  : 	wchar_t _Wc;
; 749  : 	_Mbstinit(_Mbst1);
; 750  : 
; 751  : 	_Count1 = _CSTD strlen(_Ptr) + 1;
; 752  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
; 753  : 		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
; 754  : 		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
; 755  : 			break;
; 756  : 	++_Wchars;	// count terminating nul
; 757  : 
; 758  : 	wchar_t *_Ptrdest = _NEW_CRT wchar_t[_Wchars];
; 759  : 	wchar_t *_Ptrnext = _Ptrdest;
; 760  : 	_Mbstinit(_Mbst2);
; 761  : 
; 762  :  #pragma warning(push)
; 763  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 764  : 	for (; 0 < _Wchars;
; 765  : 		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
; 766  : 		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
; 767  : 			break;
; 768  : 	*_Ptrnext = L'\0';
; 769  :  #pragma warning(pop)
; 770  : 
; 771  : 	return (_Ptrdest);
; 772  : 	}
; 773  : 
; 774  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 775  : template<> inline
; 776  : 	unsigned short *__CRTDECL _Maklocstr(const char *_Ptr, unsigned short *,
; 777  : 		const _Locinfo::_Cvtvec &_Cvt)
; 778  : 	{	// convert C string to unsigned short sequence using _Cvtvec
; 779  : 	size_t _Count, _Count1;
; 780  : 	size_t _Wchars;
; 781  : 	const char *_Ptr1;
; 782  : 	int _Bytes;
; 783  : 	unsigned short _Wc;
; 784  : 	_Mbstinit(_Mbst1);
; 785  : 
; 786  : 	_Count1 = _CSTD strlen(_Ptr) + 1;
; 787  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
; 788  : 		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
; 789  : 		if ((_Bytes =
; 790  : 			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
; 791  : 			break;
; 792  : 	++_Wchars;	// count terminating nul
; 793  : 
; 794  : 	wchar_t *_Ptrdest = _NEW_CRT wchar_t[_Wchars];
; 795  : 	wchar_t *_Ptrnext = _Ptrdest;
; 796  : 	_Mbstinit(_Mbst2);
; 797  : 	for (; 0 < _Wchars;
; 798  : 		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
; 799  : 		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
; 800  : 			break;
; 801  : 	*_Ptrnext = L'\0';
; 802  : 	return ((unsigned short *)_Ptrdest);
; 803  : 	}
; 804  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 805  : 
; 806  : 		// STRUCT codecvt_base
; 807  :  #pragma warning(push)
; 808  :  #pragma warning(disable: 4275)
; 809  : 
; 810  : class _CRTIMP2_PURE codecvt_base
; 811  : 	: public locale::facet
; 812  : 	{	// base class for codecvt
; 813  : public:
; 814  : 	enum
; 815  : 		{	// constants for different parse states
; 816  : 		ok, partial, error, noconv};
; 817  : 	typedef int result;
; 818  : 
; 819  : 	__CLR_OR_THIS_CALL codecvt_base(size_t _Refs = 0)
; 820  : 		: locale::facet(_Refs)
; 821  : 		{	// default constructor
; 822  : 		}
; 823  : 
; 824  : 	bool __CLR_OR_THIS_CALL always_noconv() const _THROW0()
; 825  : 		{	// return true if conversions never change input (from codecvt)
; 826  : 		return (do_always_noconv());
; 827  : 		}
; 828  : 
; 829  : 	int __CLR_OR_THIS_CALL max_length() const _THROW0()
; 830  : 		{	// return maximum length required for a conversion (from codecvt)
; 831  : 		return (do_max_length());
; 832  : 		}
; 833  : 
; 834  : 	int __CLR_OR_THIS_CALL encoding() const _THROW0()
; 835  : 		{	// return length of code sequence (from codecvt)
; 836  : 		return (do_encoding());
; 837  : 		}
; 838  : 
; 839  : 	__CLR_OR_THIS_CALL ~codecvt_base() _NOEXCEPT
; 840  : 		{	// destroy the object
; 841  : 		}
; 842  : 
; 843  : protected:
; 844  : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 845  : 		{	// return true if conversions never change input (from codecvt)
; 846  : 		return (false);
; 847  : 		}
; 848  : 
; 849  : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 850  : 		{	// return maximum length required for a conversion (from codecvt)
; 851  : 		return (1);
; 852  : 		}
; 853  : 
; 854  : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 855  : 		{	// return length of code sequence (from codecvt)
; 856  : 		return (1);	// -1 ==> state dependent, 0 ==> varying length
; 857  : 		}
; 858  : 	};
; 859  : 
; 860  :  #pragma warning(pop)
; 861  : 
; 862  : 		// TEMPLATE CLASS codecvt
; 863  : template<class _Elem,
; 864  : 	class _Byte,
; 865  : 	class _Statype>
; 866  : 	class codecvt
; 867  : 		: public codecvt_base
; 868  : 	{	// facet for converting between _Elem and char (_Byte) sequences
; 869  : public:
; 870  : 	typedef _Elem intern_type;
; 871  : 	typedef _Byte extern_type;
; 872  : 	typedef _Statype state_type;
; 873  : 
; 874  : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 875  : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 876  : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 877  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 878  : 		return (do_in(_State,
; 879  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 880  : 		}
; 881  : 
; 882  : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 883  : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 884  : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 885  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)
; 886  : 		return (do_out(_State,
; 887  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 888  : 		}
; 889  : 
; 890  : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 891  : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 892  : 		{	// generate bytes to return to default shift state
; 893  : 		return (do_unshift(_State, _First2, _Last2, _Mid2));
; 894  : 		}
; 895  : 
; 896  : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 897  : 		const _Byte *_Last1, size_t _Count) const
; 898  : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 899  : 		return (do_length(_State, _First1, _Last1, _Count));
; 900  : 		}
; 901  : 
; 902  : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id
; 903  : 
; 904  : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 905  : 		: codecvt_base(_Refs)
; 906  : 		{	// construct from current locale
; 907  : 		_Init(_Locinfo());
; 908  : 		}
; 909  : 
; 910  : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 911  : 		: codecvt_base(_Refs)
; 912  : 		{	// construct from specified locale
; 913  : 		_Init(_Lobj);
; 914  : 		}
; 915  : 
; 916  : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 917  : 		const locale *_Ploc = 0)
; 918  : 		{	// return locale category mask and construct standard facet
; 919  : 		if (_Ppf != 0 && *_Ppf == 0)
; 920  : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 921  : 				_Locinfo(_Ploc->c_str()));
; 922  : 		return (_X_CTYPE);
; 923  : 		}
; 924  : 
; 925  : protected:
; 926  : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 927  : 		{	// destroy the object
; 928  : 		}
; 929  : 
; 930  : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
; 931  : 		{	// initialize from _Locinfo object
; 932  : 		}
; 933  : 
; 934  : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 935  : 		{	// return true if conversions never change input (from codecvt)
; 936  : 		return (is_same<_Byte, _Elem>::value);
; 937  : 		}
; 938  : 
; 939  : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype&,
; 940  : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 941  : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 942  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 943  : 		_Mid1 = _First1, _Mid2 = _First2;
; 944  : 		if (is_same<_Byte, _Elem>::value)
; 945  : 			return (noconv);	// convert nothing
; 946  : 		else
; 947  : 			{	// types differ, copy one for one
; 948  : 			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
; 949  : 				*_Mid2 = (_Elem)*_Mid1;
; 950  : 			return (ok);
; 951  : 			}
; 952  : 		}
; 953  : 
; 954  : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype&,
; 955  : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 956  : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 957  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 958  : 		_Mid1 = _First1, _Mid2 = _First2;
; 959  : 		if (is_same<_Byte, _Elem>::value)
; 960  : 			return (noconv);	// convert nothing
; 961  : 		else
; 962  : 			{	// types differ, copy one for one
; 963  : 			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
; 964  : 				*_Mid2 = (_Byte)*_Mid1;
; 965  : 			return (ok);
; 966  : 			}
; 967  : 		}
; 968  : 
; 969  : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&,
; 970  : 		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
; 971  : 		{	// generate bytes to return to default shift state
; 972  : 		_Mid2 = _First2;
; 973  : 		return (ok);	// convert nothing
; 974  : 		}
; 975  : 
; 976  : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype&, const _Byte *_First1,
; 977  : 		const _Byte *_Last1, size_t _Count) const
; 978  : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 979  : 		return ((int)(_Count < (size_t)(_Last1 - _First1)
; 980  : 			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion
; 981  : 		}
; 982  : 	};
; 983  : 
; 984  : 		// STATIC codecvt::id OBJECT
; 985  : template<class _Elem,
; 986  : 	class _Byte,
; 987  : 	class _Statype>
; 988  : 	__PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;
; 989  : 
; 990  :  #if _HAS_CHAR16_T_LANGUAGE_SUPPORT
; 991  : 		// ENUM _Codecvt_mode
; 992  : enum _Codecvt_mode {
; 993  : 	_Consume_header = 4,
; 994  : 	_Generate_header = 2
; 995  : 	};
; 996  : 
; 997  : 		// CLASS codecvt<char16_t, char, _Mbstatet>
; 998  : template<>
; 999  : 	class _CRTIMP2_PURE codecvt<char16_t, char, _Mbstatet>
; 1000 : 	: public codecvt_base
; 1001 : 	{	// facet for converting between char16_t and UTF-8 byte sequences
; 1002 : public:
; 1003 : 	typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
; 1004 : 	typedef char16_t _Elem;
; 1005 : 	typedef char _Byte;
; 1006 : 	typedef _Mbstatet _Statype;
; 1007 : 	typedef _Elem intern_type;
; 1008 : 	typedef _Byte extern_type;
; 1009 : 	typedef _Statype state_type;
; 1010 : 
; 1011 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1012 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1013 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1014 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1015 : 		return (do_in(_State,
; 1016 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1017 : 		}
; 1018 : 
; 1019 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1020 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1021 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1022 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1023 : 		return (do_out(_State,
; 1024 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1025 : 		}
; 1026 : 
; 1027 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1028 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1029 : 		{	// generate bytes to return to default shift state
; 1030 : 		return (do_unshift(_State,
; 1031 : 			_First2, _Last2, _Mid2));
; 1032 : 		}
; 1033 : 
; 1034 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1035 : 		const _Byte *_Last1, size_t _Count) const
; 1036 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1037 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1038 : 		}
; 1039 : 
; 1040 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1041 : 
; 1042 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1043 : 		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
; 1044 : 		{	// construct from current locale
; 1045 : 		_BEGIN_LOCINFO(_Lobj)
; 1046 : 			_Init(_Lobj);
; 1047 : 		_END_LOCINFO()
; 1048 : 		}
; 1049 : 
; 1050 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1051 : 		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
; 1052 : 		{	// construct from specified locale
; 1053 : 		_Init(_Lobj);
; 1054 : 		}
; 1055 : 
; 1056 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
; 1057 : 		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
; 1058 : 		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
; 1059 : 		{	// construct from specified locale and parameters
; 1060 : 		_Init(_Lobj);
; 1061 : 		}
; 1062 : 
; 1063 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1064 : 		const locale *_Ploc = 0)
; 1065 : 		{	// return locale category mask and construct standard facet
; 1066 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1067 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1068 : 				_Locinfo(_Ploc->c_str()));
; 1069 : 		return (_X_CTYPE);
; 1070 : 		}
; 1071 : 
; 1072 : protected:
; 1073 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1074 : 		{	// destroy the object
; 1075 : 		}
; 1076 : 
; 1077 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
; 1078 : 		{	// initialize
; 1079 : 		}
; 1080 : 
; 1081 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1082 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1083 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1084 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last2)
; 1085 : 		unsigned short *_Pstate = (unsigned short *)&_State;
; 1086 : 		_Mid1 = _First1;
; 1087 : 		_Mid2 = _First2;
; 1088 : 
; 1089 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1090 : 			{	// convert a multibyte sequence
; 1091 : 			unsigned char _By = (unsigned char)*_Mid1;
; 1092 : 			unsigned long _Ch;
; 1093 : 			int _Nextra, _Nskip;
; 1094 : 
; 1095 : 			if (*_Pstate <= 1)
; 1096 : 				;	// no leftover word
; 1097 : 			else if (_By < 0x80 || 0xc0 <= _By)
; 1098 : 				return (_Mybase::error);	// not continuation byte
; 1099 : 			else
; 1100 : 				{	// deliver second half of two-word value
; 1101 : 				++_Mid1;
; 1102 : 				*_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
; 1103 : 				*_Pstate = 1;
; 1104 : 				continue;
; 1105 : 				}
; 1106 : 
; 1107 : 			if (_By < 0x80)
; 1108 : 				_Ch = _By, _Nextra = 0;
; 1109 : 			else if (_By < 0xc0)
; 1110 : 				{	// 0x80-0xdf not first byte
; 1111 : 				++_Mid1;
; 1112 : 				return (_Mybase::error);
; 1113 : 				}
; 1114 : 			else if (_By < 0xe0)
; 1115 : 				_Ch = _By & 0x1f, _Nextra = 1;
; 1116 : 			else if (_By < 0xf0)
; 1117 : 				_Ch = _By & 0x0f, _Nextra = 2;
; 1118 : 			else if (_By < 0xf8)
; 1119 : 				_Ch = _By & 0x07, _Nextra = 3;
; 1120 : 			else
; 1121 : 				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;
; 1122 : 
; 1123 : 			_Nskip = _Nextra < 3 ? 0 : 1;	// leave a byte for 2nd word
; 1124 : 			_First1 = _Mid1;	// roll back point
; 1125 : 
; 1126 : 			if (_Nextra == 0)
; 1127 : 				++_Mid1;
; 1128 : 			else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
; 1129 : 				break;	// not enough input
; 1130 : 			else
; 1131 : 				for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
; 1132 : 					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
; 1133 : 						return (_Mybase::error);	// not continuation byte
; 1134 : 					else
; 1135 : 						_Ch = _Ch << 6 | (_By & 0x3f);
; 1136 : 			if (0 < _Nskip)
; 1137 : 				_Ch <<= 6;	// get last byte on next call
; 1138 : 
; 1139 : 			if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
; 1140 : 				return (_Mybase::error);	// value too large
; 1141 : 			else if (0xffff < _Ch)
; 1142 : 				{	// deliver first half of two-word value, save second word
; 1143 : 				unsigned short _Ch0 =
; 1144 : 					(unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);
; 1145 : 
; 1146 : 				*_Mid2++ = (_Elem)_Ch0;
; 1147 : 				*_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
; 1148 : 				continue;
; 1149 : 				}
; 1150 : 
; 1151 : 			if (_Nskip == 0)
; 1152 : 				;
; 1153 : 			else if (_Mid1 == _Last1)
; 1154 : 				{	// not enough bytes, noncanonical value
; 1155 : 				_Mid1 = _First1;
; 1156 : 				break;
; 1157 : 				}
; 1158 : 			else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
; 1159 : 				return (_Mybase::error);	// not continuation byte
; 1160 : 			else
; 1161 : 				_Ch |= _By & 0x3f;	// complete noncanonical value
; 1162 : 
; 1163 : 			if (*_Pstate == 0)
; 1164 : 				{	// first time, maybe look for and consume header
; 1165 : 				*_Pstate = 1;
; 1166 : 
; 1167 : 				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
; 1168 : 					{	// drop header and retry
; 1169 : 					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
; 1170 : 						_First2, _Last2, _Mid2);
; 1171 : 
; 1172 : 					if (_Ans == _Mybase::partial)
; 1173 : 						{	// roll back header determination
; 1174 : 						*_Pstate = 0;
; 1175 : 						_Mid1 = _First1;
; 1176 : 						}
; 1177 : 					return (_Ans);
; 1178 : 					}
; 1179 : 				}
; 1180 : 
; 1181 : 			*_Mid2++ = (_Elem)_Ch;
; 1182 : 			}
; 1183 : 
; 1184 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1185 : 		}
; 1186 : 
; 1187 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1188 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1189 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1190 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1191 : 		unsigned short *_Pstate = (unsigned short *)&_State;
; 1192 : 		_Mid1 = _First1;
; 1193 : 		_Mid2 = _First2;
; 1194 : 
; 1195 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1196 : 			{	// convert and put a wide char
; 1197 : 			unsigned long _Ch;
; 1198 : 			unsigned short _Ch1 = (unsigned short)*_Mid1;
; 1199 : 			bool _Save = false;
; 1200 : 
; 1201 : 			if (1 < *_Pstate)
; 1202 : 				{	// get saved MS 11 bits from *_Pstate
; 1203 : 				if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
; 1204 : 					return (_Mybase::error);	// bad second word
; 1205 : 				_Ch = (*_Pstate << 10) | (_Ch1 - 0xdc00);
; 1206 : 				}
; 1207 : 			else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
; 1208 : 				{	// get new first word
; 1209 : 				_Ch = (_Ch1 - 0xd800 + 0x0040) << 10;
; 1210 : 				_Save = true;	// put only first byte, rest with second word
; 1211 : 				}
; 1212 : 			else
; 1213 : 				_Ch = _Ch1;	// not first word, just put it
; 1214 : 
; 1215 : 			_Byte _By;
; 1216 : 			int _Nextra;
; 1217 : 
; 1218 : 			if (_Ch < 0x0080)
; 1219 : 				_By = (_Byte)_Ch, _Nextra = 0;
; 1220 : 			else if (_Ch < 0x0800)
; 1221 : 				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
; 1222 : 			else if (_Ch < 0x10000)
; 1223 : 				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
; 1224 : 			else
; 1225 : 				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
; 1226 : 
; 1227 : 			int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;
; 1228 : 
; 1229 : 			if (_Last2 - _Mid2 < _Nput)
; 1230 : 				break;	// not enough room, even without header
; 1231 : 			else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
; 1232 : 				;	// no header to put
; 1233 : 			else if (_Last2 - _Mid2 < 3 + _Nput)
; 1234 : 				break;	// not enough room for header + output
; 1235 : 			else
; 1236 : 				{	// prepend header
; 1237 : 				*_Mid2++ = (_Byte)(unsigned char)0xef;
; 1238 : 				*_Mid2++ = (_Byte)(unsigned char)0xbb;
; 1239 : 				*_Mid2++ = (_Byte)(unsigned char)0xbf;
; 1240 : 				}
; 1241 : 
; 1242 : 			++_Mid1;
; 1243 : 			if (_Save || _Nextra < 3)
; 1244 : 				{	// put first byte of sequence, if not already put
; 1245 : 				*_Mid2++ = _By;
; 1246 : 				--_Nput;
; 1247 : 				}
; 1248 : 			for (; 0 < _Nput; --_Nput)
; 1249 : 				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
; 1250 : 
; 1251 : 			*_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
; 1252 : 			}
; 1253 : 
; 1254 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1255 : 		}
; 1256 : 
; 1257 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
; 1258 : 		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
; 1259 : 		{	// generate bytes to return to default shift state
; 1260 : 		unsigned short *_Pstate = (unsigned short *)&_State;
; 1261 : 		_Mid2 = _First2;
; 1262 : 
; 1263 : 		return (1 < *_Pstate
; 1264 : 			? _Mybase::error : _Mybase::ok);	// fail if trailing first word
; 1265 : 		}
; 1266 : 
; 1267 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 1268 : 		const _Byte *_Last1, size_t _Count) const _THROW0()
; 1269 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1270 : 		size_t _Wchars = 0;
; 1271 : 		_Statype _Mystate = _State;
; 1272 : 
; 1273 : 		for (; _Wchars < _Count && _First1 != _Last1; )
; 1274 : 			{	// convert another wide character
; 1275 : 			const _Byte *_Mid1;
; 1276 : 			_Elem *_Mid2;
; 1277 : 			_Elem _Ch;
; 1278 : 
; 1279 : 			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
; 1280 : 				&_Ch, &_Ch + 1, _Mid2))
; 1281 : 				{	// test result of single wide-char conversion
; 1282 : 			case _Mybase::noconv:
; 1283 : 				return ((int)(_Wchars + (_Last1 - _First1)));
; 1284 : 
; 1285 : 			case _Mybase::ok:
; 1286 : 				if (_Mid2 == &_Ch + 1)
; 1287 : 					++_Wchars;	// replacement do_in might not convert one
; 1288 : 				_First1 = _Mid1;
; 1289 : 				break;
; 1290 : 
; 1291 : 			default:
; 1292 : 				return ((int)_Wchars);	// error or partial
; 1293 : 				}
; 1294 : 			}
; 1295 : 
; 1296 : 		return ((int)_Wchars);
; 1297 : 		}
; 1298 : 
; 1299 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 1300 : 		{	// return true if conversions never change input
; 1301 : 		return (false);
; 1302 : 		}
; 1303 : 
; 1304 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 1305 : 		{	// return maximum length required for a conversion
; 1306 : 		return ((_Mode & _Consume_header) != 0 ? 9	// header + max input
; 1307 : 			: (_Mode & _Generate_header) != 0 ? 7	// header + max output
; 1308 : 			: 6);	// 6-byte max input sequence, no 3-byte header
; 1309 : 		}
; 1310 : 
; 1311 : 	virtual int do_encoding() const _THROW0()
; 1312 : 		{	// return length of code sequence (from codecvt)
; 1313 : 		return (0);	// 0 => varying length
; 1314 : 		}
; 1315 : 
; 1316 : private:
; 1317 : 	unsigned long _Maxcode;	// default: 0x10ffff
; 1318 : 	_Codecvt_mode _Mode;	// default: _Consume_header
; 1319 : 	};
; 1320 : 
; 1321 : 		// CLASS codecvt<char32_t, char, _Mbstatet>
; 1322 : template<>
; 1323 : 	class _CRTIMP2_PURE codecvt<char32_t, char, _Mbstatet>
; 1324 : 	: public codecvt_base
; 1325 : 	{	// facet for converting between char32_t and UTF-8 byte sequences
; 1326 : public:
; 1327 : 	typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
; 1328 : 	typedef char32_t _Elem;
; 1329 : 	typedef char _Byte;
; 1330 : 	typedef _Mbstatet _Statype;
; 1331 : 	typedef _Elem intern_type;
; 1332 : 	typedef _Byte extern_type;
; 1333 : 	typedef _Statype state_type;
; 1334 : 
; 1335 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1336 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1337 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1338 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1339 : 		return (do_in(_State,
; 1340 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1341 : 		}
; 1342 : 
; 1343 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1344 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1345 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1346 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1347 : 		return (do_out(_State,
; 1348 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1349 : 		}
; 1350 : 
; 1351 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1352 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1353 : 		{	// generate bytes to return to default shift state
; 1354 : 		return (do_unshift(_State,
; 1355 : 			_First2, _Last2, _Mid2));
; 1356 : 		}
; 1357 : 
; 1358 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1359 : 		const _Byte *_Last1, size_t _Count) const
; 1360 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1361 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1365 : 
; 1366 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1367 : 		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
; 1368 : 		{	// construct from current locale
; 1369 : 		_BEGIN_LOCINFO(_Lobj)
; 1370 : 			_Init(_Lobj);
; 1371 : 		_END_LOCINFO()
; 1372 : 		}
; 1373 : 
; 1374 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1375 : 		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
; 1376 : 		{	// construct from specified locale
; 1377 : 		_Init(_Lobj);
; 1378 : 		}
; 1379 : 
; 1380 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
; 1381 : 		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
; 1382 : 		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
; 1383 : 		{	// construct from specified locale and parameters
; 1384 : 		_Init(_Lobj);
; 1385 : 		}
; 1386 : 
; 1387 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1388 : 		const locale *_Ploc = 0)
; 1389 : 		{	// return locale category mask and construct standard facet
; 1390 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1391 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1392 : 				_Locinfo(_Ploc->c_str()));
; 1393 : 		return (_X_CTYPE);
; 1394 : 		}
; 1395 : 
; 1396 : protected:
; 1397 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1398 : 		{	// destroy the object
; 1399 : 		}
; 1400 : 
; 1401 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
; 1402 : 		{	// initialize
; 1403 : 		}
; 1404 : 
; 1405 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1406 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1407 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1408 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1409 : 		char *_Pstate = (char *)&_State;
; 1410 : 		_Mid1 = _First1;
; 1411 : 		_Mid2 = _First2;
; 1412 : 
; 1413 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1414 : 			{	// convert a multibyte sequence
; 1415 : 			unsigned char _By = (unsigned char)*_Mid1;
; 1416 : 			unsigned long _Ch;
; 1417 : 			int _Nextra;
; 1418 : 
; 1419 : 			if (_By < 0x80)
; 1420 : 				_Ch = _By, _Nextra = 0;
; 1421 : 			else if (_By < 0xc0)
; 1422 : 				{	// 0x80-0xdf not first byte
; 1423 : 				++_Mid1;
; 1424 : 				return (_Mybase::error);
; 1425 : 				}
; 1426 : 			else if (_By < 0xe0)
; 1427 : 				_Ch = _By & 0x1f, _Nextra = 1;
; 1428 : 			else if (_By < 0xf0)
; 1429 : 				_Ch = _By & 0x0f, _Nextra = 2;
; 1430 : 			else if (_By < 0xf8)
; 1431 : 				_Ch = _By & 0x07, _Nextra = 3;
; 1432 : 			else
; 1433 : 				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;
; 1434 : 
; 1435 : 			if (_Nextra == 0)
; 1436 : 				++_Mid1;
; 1437 : 			else if (_Last1 - _Mid1 < _Nextra + 1)
; 1438 : 				break;	// not enough input
; 1439 : 			else
; 1440 : 				for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
; 1441 : 					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
; 1442 : 						return (_Mybase::error);	// not continuation byte
; 1443 : 					else
; 1444 : 						_Ch = _Ch << 6 | (_By & 0x3f);
; 1445 : 
; 1446 : 			if (*_Pstate == 0)
; 1447 : 				{	// first time, maybe look for and consume header
; 1448 : 				*_Pstate = 1;
; 1449 : 
; 1450 : 				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
; 1451 : 					{	// drop header and retry
; 1452 : 					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
; 1453 : 						_First2, _Last2, _Mid2);
; 1454 : 
; 1455 : 					if (_Ans == _Mybase::partial)
; 1456 : 						{	// roll back header determination
; 1457 : 						*_Pstate = 0;
; 1458 : 						_Mid1 = _First1;
; 1459 : 						}
; 1460 : 					return (_Ans);
; 1461 : 					}
; 1462 : 				}
; 1463 : 
; 1464 : 			if (_Maxcode < _Ch)
; 1465 : 				return (_Mybase::error);	// code too large
; 1466 : 			*_Mid2++ = (_Elem)_Ch;
; 1467 : 			}
; 1468 : 
; 1469 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1470 : 		}
; 1471 : 
; 1472 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1473 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1474 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1475 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1476 : 		char *_Pstate = (char *)&_State;
; 1477 : 		_Mid1 = _First1;
; 1478 : 		_Mid2 = _First2;
; 1479 : 
; 1480 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1481 : 			{	// convert and put a wide char
; 1482 : 			_Byte _By;
; 1483 : 			int _Nextra;
; 1484 : 			unsigned long _Ch = (unsigned long)*_Mid1;
; 1485 : 
; 1486 : 			if (_Maxcode < _Ch)
; 1487 : 				return (_Mybase::error);
; 1488 : 
; 1489 : 			if (_Ch < 0x0080)
; 1490 : 				_By = (_Byte)_Ch, _Nextra = 0;
; 1491 : 			else if (_Ch < 0x0800)
; 1492 : 				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
; 1493 : 			else if (_Ch < 0x00010000)
; 1494 : 				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
; 1495 : 			else if (_Ch < 0x00200000)
; 1496 : 				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
; 1497 : 			else if (_Ch < 0x04000000)
; 1498 : 				_By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
; 1499 : 			else
; 1500 : 				_By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;
; 1501 : 
; 1502 : 			if (*_Pstate == 0)
; 1503 : 				{	// first time, maybe generate header
; 1504 : 				*_Pstate = 1;
; 1505 : 				if ((_Mode & _Generate_header) == 0)
; 1506 : 					;
; 1507 : 				else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
; 1508 : 					return (_Mybase::partial);	// not enough room for both
; 1509 : 				else
; 1510 : 					{	// prepend header
; 1511 : 					*_Mid2++ = (_Byte)(unsigned char)0xef;
; 1512 : 					*_Mid2++ = (_Byte)(unsigned char)0xbb;
; 1513 : 					*_Mid2++ = (_Byte)(unsigned char)0xbf;
; 1514 : 					}
; 1515 : 				}
; 1516 : 
; 1517 : 			if (_Last2 - _Mid2 < 1 + _Nextra)
; 1518 : 				break;	// not enough room for output
; 1519 : 
; 1520 : 			++_Mid1;
; 1521 : 			for (*_Mid2++ = _By; 0 < _Nextra; )
; 1522 : 				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
; 1523 : 			}
; 1524 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1525 : 		}
; 1526 : 
; 1527 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&,
; 1528 : 		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
; 1529 : 		{	// generate bytes to return to default shift state
; 1530 : 		_Mid2 = _First2;
; 1531 : 		return (_Mybase::ok);
; 1532 : 		}
; 1533 : 
; 1534 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 1535 : 		const _Byte *_Last1, size_t _Count) const _THROW0()
; 1536 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1537 : 		int _Wchars = 0;
; 1538 : 		_Statype _Mystate = _State;
; 1539 : 
; 1540 : 		for (; (size_t)_Wchars < _Count && _First1 != _Last1; )
; 1541 : 			{	// convert another wide character
; 1542 : 			const _Byte *_Mid1;
; 1543 : 			_Elem *_Mid2;
; 1544 : 			_Elem _Ch;
; 1545 : 
; 1546 : 			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
; 1547 : 				&_Ch, &_Ch + 1, _Mid2))
; 1548 : 				{	// test result of single wide-char conversion
; 1549 : 			case _Mybase::noconv:
; 1550 : 				return ((int)(_Wchars + (int)(_Last1 - _First1)));
; 1551 : 
; 1552 : 			case _Mybase::ok:
; 1553 : 				if (_Mid2 == &_Ch + 1)
; 1554 : 					++_Wchars;	// replacement do_in might not convert one
; 1555 : 				_First1 = _Mid1;
; 1556 : 				break;
; 1557 : 
; 1558 : 			default:
; 1559 : 				return ((int)_Wchars);	// error or partial
; 1560 : 				}
; 1561 : 			}
; 1562 : 
; 1563 : 		return ((int)_Wchars);
; 1564 : 		}
; 1565 : 
; 1566 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 1567 : 		{	// return true if conversions never change input
; 1568 : 		return (false);
; 1569 : 		}
; 1570 : 
; 1571 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 1572 : 		{	// return maximum length required for a conversion
; 1573 : 		return ((_Mode & (_Consume_header | _Generate_header)) != 0
; 1574 : 			? 9 : 6);
; 1575 : 		}
; 1576 : 
; 1577 : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 1578 : 		{	// return length of code sequence (from codecvt)
; 1579 : 		return ((_Mode & (_Consume_header | _Generate_header)) != 0
; 1580 : 			? -1 : 0);	// -1 => state dependent, 0 => varying length
; 1581 : 		}
; 1582 : 
; 1583 : private:
; 1584 : 	unsigned long _Maxcode;	// default: 0xffffffff
; 1585 : 	_Codecvt_mode _Mode;	// default: _Consume_header
; 1586 : 	};
; 1587 :  #endif /* _HAS_CHAR16_T_LANGUAGE_SUPPORT */
; 1588 : 
; 1589 : 		// CLASS codecvt<wchar_t, char, _Mbstatet>
; 1590 : template<>
; 1591 : 	class _CRTIMP2_PURE codecvt<wchar_t, char, _Mbstatet>
; 1592 : 	: public codecvt_base
; 1593 : 	{	// facet for converting between wchar_t and char (_Byte) sequences
; 1594 : public:
; 1595 : 	typedef wchar_t _Elem;
; 1596 : 	typedef char _Byte;
; 1597 : 	typedef _Mbstatet _Statype;
; 1598 : 	typedef _Elem intern_type;
; 1599 : 	typedef _Byte extern_type;
; 1600 : 	typedef _Statype state_type;
; 1601 : 
; 1602 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1603 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1604 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1605 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1606 : 		return (do_in(_State,
; 1607 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1608 : 		}
; 1609 : 
; 1610 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1611 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1612 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1613 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1614 : 		return (do_out(_State,
; 1615 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1616 : 		}
; 1617 : 
; 1618 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1619 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1620 : 		{	// generate bytes to return to default shift state
; 1621 : 		return (do_unshift(_State,
; 1622 : 			_First2, _Last2, _Mid2));
; 1623 : 		}
; 1624 : 
; 1625 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1626 : 		const _Byte *_Last1, size_t _Count) const
; 1627 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1628 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1629 : 		}
; 1630 : 
; 1631 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1632 : 
; 1633 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1634 : 		: codecvt_base(_Refs)
; 1635 : 		{	// construct from current locale
; 1636 : 		_BEGIN_LOCINFO(_Lobj)
; 1637 : 			_Init(_Lobj);
; 1638 : 		_END_LOCINFO()
; 1639 : 		}
; 1640 : 
; 1641 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1642 : 		: codecvt_base(_Refs)
; 1643 : 		{	// construct from specified locale
; 1644 : 		_Init(_Lobj);
; 1645 : 		}
; 1646 : 
; 1647 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1648 : 		const locale *_Ploc = 0)
; 1649 : 		{	// return locale category mask and construct standard facet
; 1650 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1651 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1652 : 				_Locinfo(_Ploc->c_str()));
; 1653 : 		return (_X_CTYPE);
; 1654 : 		}
; 1655 : 
; 1656 : protected:
; 1657 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1658 : 		{	// destroy the object
; 1659 : 		}
; 1660 : 
; 1661 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 1662 : 		{	// initialize from _Lobj
; 1663 : 		_Cvt = _Lobj._Getcvt();
; 1664 : 		}
; 1665 : 
; 1666 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1667 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1668 : 			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1669 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1670 : 		_DEBUG_RANGE(_First1, _Last1);
; 1671 : 		_DEBUG_RANGE(_First2, _Last2);
; 1672 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1673 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1674 : 		int _Bytes;
; 1675 : 
; 1676 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1677 : 			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
; 1678 : 				&_State, &_Cvt))
; 1679 : 			{	// test result of locale-specific mbrtowc call
; 1680 : 			case -2:	// partial conversion
; 1681 : 				_Mid1 = _Last1;
; 1682 : 				return (_Ans);
; 1683 : 
; 1684 : 			case -1:	// failed conversion
; 1685 : 				return (error);
; 1686 : 
; 1687 : 			case 0:	// may have converted null character
; 1688 : 				if (*_Mid2 == (_Elem)0)
; 1689 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 1690 : 				// fall through
; 1691 : 
; 1692 : 			default:	// converted _Bytes bytes to a wchar_t
; 1693 : 				if (_Bytes == -3)
; 1694 : 					_Bytes = 0;	// wchar_t generated from state info
; 1695 : 				_Mid1 += _Bytes;
; 1696 : 				++_Mid2;
; 1697 : 				_Ans = ok;
; 1698 : 			}
; 1699 : 		return (_Ans);
; 1700 : 		}
; 1701 : 
; 1702 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1703 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1704 : 			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1705 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1706 : 		_DEBUG_RANGE(_First1, _Last1);
; 1707 : 		_DEBUG_RANGE(_First2, _Last2);
; 1708 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1709 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1710 : 		int _Bytes;
; 1711 : 
; 1712 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1713 : 			if ((int)MB_CUR_MAX <= _Last2 - _Mid2)
; 1714 : 				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
; 1715 : 					&_State, &_Cvt)) < 0)
; 1716 : 					return (error);	// locale-specific wcrtomb failed
; 1717 : 				else
; 1718 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1719 : 			else
; 1720 : 				{	// destination too small, convert into buffer
; 1721 : 				_Byte _Buf[MB_LEN_MAX];
; 1722 : 				_Statype _Stsave = _State;
; 1723 : 
; 1724 : 				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
; 1725 : 					&_State, &_Cvt)) < 0)
; 1726 : 					return (error);	// locale-specific wcrtomb failed
; 1727 : 				else if (_Last2 - _Mid2 < _Bytes)
; 1728 : 					{	// converted too many, roll back and return previous
; 1729 : 					_State = _Stsave;
; 1730 : 					return (_Ans);
; 1731 : 					}
; 1732 : 				else
; 1733 : 					{	// copy converted bytes from buffer
; 1734 : 					_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1735 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1736 : 					}
; 1737 : 				}
; 1738 : 		return (_Ans);
; 1739 : 		}
; 1740 : 
; 1741 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
; 1742 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1743 : 		{	// generate bytes to return to default shift state
; 1744 : 		_DEBUG_RANGE(_First2, _Last2);
; 1745 : 		_Mid2 = _First2;
; 1746 : 		result _Ans = ok;
; 1747 : 		int _Bytes;
; 1748 : 		_Byte _Buf[MB_LEN_MAX];
; 1749 : 		_Statype _Stsave = _State;
; 1750 : 
; 1751 : 		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
; 1752 : 			_Ans = error;	// locale-specific wcrtomb failed
; 1753 : 		else if (_Last2 - _Mid2 < --_Bytes)
; 1754 : 			{	// converted too many, roll back and return
; 1755 : 			_State = _Stsave;
; 1756 : 			_Ans = partial;
; 1757 : 			}
; 1758 : 		else if (0 < _Bytes)
; 1759 : 			{	// copy converted bytes from buffer
; 1760 : 			_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1761 : 			_Mid2 += _Bytes;
; 1762 : 			}
; 1763 : 		return (_Ans);
; 1764 : 		}
; 1765 : 
; 1766 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 1767 : 		const _Byte *_Last1, size_t _Count) const
; 1768 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1769 : 		_DEBUG_RANGE(_First1, _Last1);
; 1770 : 		int _Wchars;
; 1771 : 		const _Byte *_Mid1;
; 1772 : 		_Statype _Mystate = _State;
; 1773 : 
; 1774 : 		for (_Wchars = 0, _Mid1 = _First1;
; 1775 : 			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
; 1776 : 			{	// convert another wchar_t
; 1777 : 			int _Bytes;
; 1778 : 			_Elem _Ch;
; 1779 : 
; 1780 : 			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
; 1781 : 				&_Mystate, &_Cvt))
; 1782 : 				{	// test result of locale-specific mbrtowc call
; 1783 : 			case -2:	// partial conversion
; 1784 : 				return (_Wchars);
; 1785 : 
; 1786 : 			case -1:	// failed conversion
; 1787 : 				return (_Wchars);
; 1788 : 
; 1789 : 			case 0:	// may have converted null character
; 1790 : 				if (_Ch == (_Elem)0)
; 1791 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 1792 : 				// fall through
; 1793 : 
; 1794 : 			default:	// converted _Bytes bytes to a wchar_t
; 1795 : 				if (_Bytes == -3)
; 1796 : 					_Bytes = 0;	// wchar_t generated from state info
; 1797 : 				_Mid1 += _Bytes;
; 1798 : 				++_Wchars;
; 1799 : 				}
; 1800 : 			}
; 1801 : 		return (_Wchars);
; 1802 : 		}
; 1803 : 
; 1804 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 1805 : 		{	// return true if conversions never change input
; 1806 : 		return (false);
; 1807 : 		}
; 1808 : 
; 1809 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 1810 : 		{	// return maximum length required for a conversion (from codecvt)
; 1811 : 		return (MB_LEN_MAX);
; 1812 : 		}
; 1813 : 
; 1814 : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 1815 : 		{	// return length of code sequence (from codecvt)
; 1816 : 		return (0);	// 0 => varying length
; 1817 : 		}
; 1818 : 
; 1819 : private:
; 1820 : 	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
; 1821 : 	};
; 1822 : 
; 1823 :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 1824 : 		// CLASS codecvt<unsigned short, char, _Mbstatet>
; 1825 : template<>
; 1826 : 	class _CRTIMP2_PURE codecvt<unsigned short, char, _Mbstatet>
; 1827 : 	: public codecvt_base
; 1828 : 	{	// facet for converting between unsigned short and char sequences
; 1829 : public:
; 1830 : 	typedef unsigned short _Elem;
; 1831 : 	typedef char _Byte;
; 1832 : 	typedef _Mbstatet _Statype;
; 1833 : 	typedef _Elem intern_type;
; 1834 : 	typedef _Byte extern_type;
; 1835 : 	typedef _Statype state_type;
; 1836 : 
; 1837 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1838 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1839 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1840 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1841 : 		return (do_in(_State,
; 1842 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1843 : 		}
; 1844 : 
; 1845 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1846 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1847 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1848 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1849 : 		return (do_out(_State,
; 1850 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1851 : 		}
; 1852 : 
; 1853 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1854 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1855 : 		{	// generate bytes to return to default shift state
; 1856 : 		return (do_unshift(_State,
; 1857 : 			_First2, _Last2, _Mid2));
; 1858 : 		}
; 1859 : 
; 1860 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1861 : 		const _Byte *_Last1, size_t _Count) const
; 1862 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1863 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1864 : 		}
; 1865 : 
; 1866 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1867 : 
; 1868 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1869 : 		: codecvt_base(_Refs)
; 1870 : 		{	// construct from current locale
; 1871 : 		_BEGIN_LOCINFO(_Lobj)
; 1872 : 			_Init(_Lobj);
; 1873 : 		_END_LOCINFO()
; 1874 : 		}
; 1875 : 
; 1876 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1877 : 		: codecvt_base(_Refs)
; 1878 : 		{	// construct from specified locale
; 1879 : 		_Init(_Lobj);
; 1880 : 		}
; 1881 : 
; 1882 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1883 : 		const locale *_Ploc = 0)
; 1884 : 		{	// return locale category mask and construct standard facet
; 1885 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1886 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1887 : 				_Locinfo(_Ploc->c_str()));
; 1888 : 		return (_X_CTYPE);
; 1889 : 		}
; 1890 : 
; 1891 : protected:
; 1892 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1893 : 		{	// destroy the object
; 1894 : 		}
; 1895 : 
; 1896 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 1897 : 		{	// initialize from _Lobj
; 1898 : 		_Cvt = _Lobj._Getcvt();
; 1899 : 		}
; 1900 : 
; 1901 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1902 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1903 : 			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1904 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1905 : 		_DEBUG_RANGE(_First1, _Last1);
; 1906 : 		_DEBUG_RANGE(_First2, _Last2);
; 1907 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1908 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1909 : 		int _Bytes;
; 1910 : 
; 1911 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1912 : 			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
; 1913 : 				&_State, &_Cvt))
; 1914 : 			{	// test result of locale-specific mbrtowc call
; 1915 : 			case -2:	// partial conversion
; 1916 : 				_Mid1 = _Last1;
; 1917 : 				return (_Ans);
; 1918 : 
; 1919 : 			case -1:	// failed conversion
; 1920 : 				return (error);
; 1921 : 
; 1922 : 			case 0:	// may have converted null character
; 1923 : 				if (*_Mid2 == (_Elem)0)
; 1924 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 1925 : 				// fall through
; 1926 : 
; 1927 : 			default:	// converted _Bytes bytes to an unsigned short
; 1928 : 				if (_Bytes == -3)
; 1929 : 					_Bytes = 0;	// wchar_t generated from state info
; 1930 : 				_Mid1 += _Bytes;
; 1931 : 				++_Mid2;
; 1932 : 				_Ans = ok;
; 1933 : 			}
; 1934 : 		return (_Ans);
; 1935 : 		}
; 1936 : 
; 1937 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1938 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1939 : 			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1940 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1941 : 		_DEBUG_RANGE(_First1, _Last1);
; 1942 : 		_DEBUG_RANGE(_First2, _Last2);
; 1943 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1944 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1945 : 		int _Bytes;
; 1946 : 
; 1947 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1948 : 			if ((int)MB_CUR_MAX <= _Last2 - _Mid2)
; 1949 : 				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
; 1950 : 					&_State, &_Cvt)) < 0)
; 1951 : 					return (error);	// locale-specific wcrtomb failed
; 1952 : 				else
; 1953 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1954 : 			else
; 1955 : 				{	// destination too small, convert into buffer
; 1956 : 				_Byte _Buf[MB_LEN_MAX];
; 1957 : 				_Statype _Stsave = _State;
; 1958 : 
; 1959 : 				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
; 1960 : 					&_State, &_Cvt)) < 0)
; 1961 : 					return (error);	// locale-specific wcrtomb failed
; 1962 : 				else if (_Last2 - _Mid2 < _Bytes)
; 1963 : 					{	// converted too many, roll back and return previous
; 1964 : 					_State = _Stsave;
; 1965 : 					return (_Ans);
; 1966 : 					}
; 1967 : 				else
; 1968 : 					{	// copy converted bytes from buffer
; 1969 : 					_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1970 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1971 : 					}
; 1972 : 				}
; 1973 : 		return (_Ans);
; 1974 : 		}
; 1975 : 
; 1976 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
; 1977 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1978 : 		{	// generate bytes to return to default shift state
; 1979 : 		_DEBUG_RANGE(_First2, _Last2);
; 1980 : 		_Mid2 = _First2;
; 1981 : 		result _Ans = ok;
; 1982 : 		int _Bytes;
; 1983 : 		_Byte _Buf[MB_LEN_MAX];
; 1984 : 		_Statype _Stsave = _State;
; 1985 : 
; 1986 : 		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
; 1987 : 			_Ans = error;	// locale-specific wcrtomb failed
; 1988 : 		else if (_Last2 - _Mid2 < --_Bytes)
; 1989 : 			{	// converted too many, roll back and return
; 1990 : 			_State = _Stsave;
; 1991 : 			_Ans = partial;
; 1992 : 			}
; 1993 : 		else if (0 < _Bytes)
; 1994 : 			{	// copy converted bytes from buffer
; 1995 : 			_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1996 : 			_Mid2 += _Bytes;
; 1997 : 			}
; 1998 : 		return (_Ans);
; 1999 : 		}
; 2000 : 
; 2001 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 2002 : 		const _Byte *_Last1, size_t _Count) const
; 2003 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 2004 : 		_DEBUG_RANGE(_First1, _Last1);
; 2005 : 		int _Wchars;
; 2006 : 		const _Byte *_Mid1;
; 2007 : 		_Statype _Mystate = _State;
; 2008 : 
; 2009 : 		for (_Wchars = 0, _Mid1 = _First1;
; 2010 : 			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
; 2011 : 			{	// convert another unsigned char
; 2012 : 			int _Bytes;
; 2013 : 			_Elem _Ch;
; 2014 : 
; 2015 : 			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
; 2016 : 				&_Mystate, &_Cvt))
; 2017 : 				{	// test result of locale-specific mbrtowc call
; 2018 : 			case -2:	// partial conversion
; 2019 : 				return (_Wchars);
; 2020 : 
; 2021 : 			case -1:	// failed conversion
; 2022 : 				return (_Wchars);
; 2023 : 
; 2024 : 			case 0:	// may have converted null character
; 2025 : 				if (_Ch == (_Elem)0)
; 2026 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 2027 : 				// fall through
; 2028 : 
; 2029 : 			default:	// converted _Bytes bytes to an unsigned char
; 2030 : 				if (_Bytes == -3)
; 2031 : 					_Bytes = 0;	// wchar_t generated from state info
; 2032 : 				_Mid1 += _Bytes;
; 2033 : 				++_Wchars;
; 2034 : 				}
; 2035 : 			}
; 2036 : 		return (_Wchars);
; 2037 : 		}
; 2038 : 
; 2039 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 2040 : 		{	// return true if conversions never change input
; 2041 : 		return (false);
; 2042 : 		}
; 2043 : 
; 2044 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 2045 : 		{	// return maximum length required for a conversion (from codecvt)
; 2046 : 		return (MB_LEN_MAX);
; 2047 : 		}
; 2048 : 
; 2049 : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 2050 : 		{	// return length of code sequence (from codecvt)
; 2051 : 		return (0);	// 0 => varying length
; 2052 : 		}
; 2053 : 
; 2054 : private:
; 2055 : 	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
; 2056 : 	};
; 2057 :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 2058 : 
; 2059 : 		// TEMPLATE CLASS codecvt_byname
; 2060 : template<class _Elem,
; 2061 : 	class _Byte,
; 2062 : 	class _Statype>
; 2063 : 	class codecvt_byname
; 2064 : 		: public codecvt<_Elem, _Byte, _Statype>
; 2065 : 	{	// codecvt for named locale
; 2066 : public:
; 2067 : 	explicit __CLR_OR_THIS_CALL codecvt_byname(const char *_Locname, size_t _Refs = 0)
; 2068 : 		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
; 2069 : 		{	// construct for named locale
; 2070 : 		}
; 2071 : 
; 2072 : 	explicit __CLR_OR_THIS_CALL codecvt_byname(const string& _Str, size_t _Refs = 0)
; 2073 : 		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
; 2074 : 		{	// construct for named locale
; 2075 : 		}
; 2076 : 
; 2077 : protected:
; 2078 : 	virtual __CLR_OR_THIS_CALL ~codecvt_byname() _NOEXCEPT
; 2079 : 		{	// destroy the object
; 2080 : 		}
; 2081 : 	};
; 2082 : 
; 2083 : 		// STRUCT ctype_base
; 2084 :  #pragma warning(push)
; 2085 :  #pragma warning(disable: 4275)
; 2086 : 
; 2087 : struct _CRTIMP2_PURE ctype_base
; 2088 : 	: public locale::facet
; 2089 : 	{	// base for ctype
; 2090 : 	enum
; 2091 : 		{	// constants for character classifications
; 2092 : 		alnum = _DI | _LO | _UP | _XA, alpha = _LO | _UP | _XA,
; 2093 : 		cntrl = _BB, digit = _DI, graph = _DI | _LO | _PU | _UP | _XA,
; 2094 : 		lower = _LO, print = _DI | _LO | _PU | _SP | _UP | _XA | _XD,
; 2095 : 		punct = _PU, space = _CN | _SP | _XS, upper = _UP,
; 2096 : 		xdigit = _XD, blank = _CN | _SP | _XS | _XB};
; 2097 : 	typedef short mask;	// to match <ctype.h>
; 2098 : 
; 2099 : 	__CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0)
; 2100 : 		: locale::facet(_Refs)
; 2101 : 		{	// default constructor
; 2102 : 		}
; 2103 : 
; 2104 : 	__CLR_OR_THIS_CALL ~ctype_base() _NOEXCEPT
; 2105 : 		{	// destroy the object
; 2106 : 		}
; 2107 : 	};
; 2108 : 
; 2109 :  #pragma warning(pop)
; 2110 : 
; 2111 : 		// TEMPLATE CLASS ctype
; 2112 : template<class _Elem>
; 2113 : 	class ctype
; 2114 : 		: public ctype_base
; 2115 : 	{	// facet for classifying elements, converting cases
; 2116 : public:
; 2117 : 	typedef _Elem char_type;
; 2118 : 
; 2119 : 	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
; 2120 : 		{	// test if element fits any mask classifications
; 2121 : 		return (do_is(_Maskval, _Ch));
; 2122 : 		}
; 2123 : 
; 2124 : 	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First, const _Elem *_Last,
; 2125 : 		mask *_Dest) const
; 2126 : 		{	// get mask sequence for elements in [_First, _Last)
; 2127 : 		return (do_is(_First, _Last, _Dest));
; 2128 : 		}
; 2129 : 
; 2130 : 	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem *_First,
; 2131 : 		const _Elem *_Last) const
; 2132 : 		{	// find first in [_First, _Last) that fits mask classification
; 2133 : 		return (do_scan_is(_Maskval, _First, _Last));
; 2134 : 		}
; 2135 : 
; 2136 : 	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem *_First,
; 2137 : 		const _Elem *_Last) const
; 2138 : 		{	// find first in [_First, _Last) not fitting mask classification
; 2139 : 		return (do_scan_not(_Maskval, _First, _Last));
; 2140 : 		}
; 2141 : 
; 2142 : 	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
; 2143 : 		{	// convert element to lower case
; 2144 : 		return (do_tolower(_Ch));
; 2145 : 		}
; 2146 : 
; 2147 : 	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
; 2148 : 		{	// convert [_First, _Last) in place to lower case
; 2149 : 		return (do_tolower(_First, _Last));
; 2150 : 		}
; 2151 : 
; 2152 : 	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
; 2153 : 		{	// convert element to upper case
; 2154 : 		return (do_toupper(_Ch));
; 2155 : 		}
; 2156 : 
; 2157 : 	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
; 2158 : 		{	// convert [_First, _Last) in place to upper case
; 2159 : 		return (do_toupper(_First, _Last));
; 2160 : 		}
; 2161 : 
; 2162 : 	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
; 2163 : 		{	// widen char
; 2164 : 		return (do_widen(_Byte));
; 2165 : 		}
; 2166 : 
; 2167 : 	const char *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
; 2168 : 		_Elem *_Dest) const
; 2169 : 		{	// widen chars in [_First, _Last)
; 2170 : 		return (do_widen(_First, _Last, _Dest));
; 2171 : 		}
; 2172 : 
; 2173 : 	char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
; 2174 : 		{	// narrow element to char
; 2175 : 		return (do_narrow(_Ch, _Dflt));
; 2176 : 		}
; 2177 : 
; 2178 : 	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
; 2179 : 		char _Dflt, char *_Dest) const
; 2180 : 		{	// narrow elements in [_First, _Last) to chars
; 2181 : 		return (do_narrow(_First, _Last, _Dflt, _Dest));
; 2182 : 		}
; 2183 : 
; 2184 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 2185 : 
; 2186 : 	explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0)
; 2187 : 		: ctype_base(_Refs)
; 2188 : 		{	// construct from current locale
; 2189 : 		_BEGIN_LOCINFO(_Lobj)
; 2190 : 			_Init(_Lobj);
; 2191 : 		_END_LOCINFO()
; 2192 : 		}
; 2193 : 
; 2194 : 	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
; 2195 : 		: ctype_base(_Refs)
; 2196 : 		{	// construct from specified locale
; 2197 : 		_Init(_Lobj);
; 2198 : 		}
; 2199 : 
; 2200 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 2201 : 		const locale *_Ploc = 0)
; 2202 : 		{	// return locale category mask and construct standard facet
; 2203 : 		if (_Ppf != 0 && *_Ppf == 0)
; 2204 : 			*_Ppf = _NEW_CRT ctype<_Elem>(
; 2205 : 				_Locinfo(_Ploc->c_str()));
; 2206 : 		return (_X_CTYPE);
; 2207 : 		}
; 2208 : 
; 2209 : protected:
; 2210 : 	virtual __CLR_OR_THIS_CALL ~ctype() _NOEXCEPT
; 2211 : 		{	// destroy the object
; 2212 : 		if (_Ctype._Delfl)
; 2213 : 			free((void *)_Ctype._Table);
; 2214 : 
; 2215 : 		free((void *)_Ctype._LocaleName);
; 2216 : 		}
; 2217 : 
; 2218 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 2219 : 		{	// initialize from _Lobj
; 2220 : 		_Ctype = _Lobj._Getctype();
; 2221 : 		_Cvt = _Lobj._Getcvt();
; 2222 : 		}
; 2223 : 
; 2224 : 	virtual bool __CLR_OR_THIS_CALL do_is(mask _Maskval, _Elem _Ch) const
; 2225 : 		{	// test if element fits any mask classifications
; 2226 : 		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
; 2227 : 			& _Maskval) != 0);
; 2228 : 		}
; 2229 : 
; 2230 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_is(const _Elem *_First, const _Elem *_Last,
; 2231 : 		mask *_Dest) const
; 2232 : 		{	// get mask sequence for elements in [_First, _Last)
; 2233 : 		_DEBUG_RANGE(_First, _Last);
; 2234 : 		_DEBUG_POINTER(_Dest);
; 2235 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2236 : 			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
; 2237 : 		return (_First);
; 2238 : 		}
; 2239 : 
; 2240 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_is(mask _Maskval,
; 2241 : 		const _Elem *_First, const _Elem *_Last) const
; 2242 : 		{	// find first in [_First, _Last) that fits mask classification
; 2243 : 		_DEBUG_RANGE(_First, _Last);
; 2244 : 		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
; 2245 : 			;
; 2246 : 		return (_First);
; 2247 : 		}
; 2248 : 
; 2249 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_not(mask _Maskval,
; 2250 : 		const _Elem *_First, const _Elem *_Last) const
; 2251 : 		{	// find first in [_First, _Last) not fitting mask classification
; 2252 : 		_DEBUG_RANGE(_First, _Last);
; 2253 : 		for (; _First != _Last && is(_Maskval, *_First); ++_First)
; 2254 : 			;
; 2255 : 		return (_First);
; 2256 : 		}
; 2257 : 
; 2258 : 	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
; 2259 : 		{	// convert element to lower case
; 2260 : 		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
; 2261 : 		if (_Byte == '\0')
; 2262 : 			return (_Ch);
; 2263 : 		else
; 2264 : 			return (widen((char)_Tolower(_Byte, &_Ctype)));
; 2265 : 		}
; 2266 : 
; 2267 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First,
; 2268 : 		const _Elem *_Last) const
; 2269 : 		{	// convert [_First, _Last) in place to lower case
; 2270 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2271 : 		for (; _First != _Last; ++_First)
; 2272 : 			{	// convert *_First to lower case
; 2273 : 			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
; 2274 : 			if (_Byte != '\0')
; 2275 : 				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
; 2276 : 			}
; 2277 : 		return ((const _Elem *)_First);
; 2278 : 		}
; 2279 : 
; 2280 : 	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
; 2281 : 		{	// convert element to upper case
; 2282 : 		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
; 2283 : 		if (_Byte == '\0')
; 2284 : 			return (_Ch);
; 2285 : 		else
; 2286 : 			return (widen((char)_Toupper(_Byte, &_Ctype)));
; 2287 : 		}
; 2288 : 
; 2289 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First,
; 2290 : 		const _Elem *_Last) const
; 2291 : 		{	// convert [_First, _Last) in place to upper case
; 2292 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2293 : 		for (; _First != _Last; ++_First)
; 2294 : 			{	// convert *_First to upper case
; 2295 : 			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
; 2296 : 			if (_Byte != '\0')
; 2297 : 				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
; 2298 : 			}
; 2299 : 		return ((const _Elem *)_First);
; 2300 : 		}
; 2301 : 
; 2302 : 	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
; 2303 : 		{	// widen char
; 2304 : 		return (_MAKLOCCHR(_Elem, _Byte, _Cvt));
; 2305 : 		}
; 2306 : 
; 2307 : 	virtual const char *__CLR_OR_THIS_CALL do_widen(const char *_First,
; 2308 : 		const char *_Last, _Elem *_Dest) const
; 2309 : 		{	// widen chars in [_First, _Last)
; 2310 : 		_DEBUG_RANGE(_First, _Last);
; 2311 : 		_DEBUG_POINTER(_Dest);
; 2312 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2313 : 			*_Dest = _MAKLOCCHR(_Elem, *_First, _Cvt);
; 2314 : 		return (_First);
; 2315 : 		}
; 2316 : 
; 2317 : 	char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const
; 2318 : 		{	// narrow element to char
; 2319 : 		char _Byte;
; 2320 : 		if (_Ch == (_Elem)0)
; 2321 : 			return ('\0');
; 2322 : 		else if ((_Byte = _MAKLOCBYTE(_Elem, _Ch, _Cvt)) == '\0')
; 2323 : 			return (_Dflt);
; 2324 : 		else
; 2325 : 			return (_Byte);
; 2326 : 		}
; 2327 : 
; 2328 : 	virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const
; 2329 : 		{	// narrow element to char
; 2330 : 		return (_Donarrow(_Ch, _Dflt));
; 2331 : 		}
; 2332 : 
; 2333 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
; 2334 : 		const _Elem *_Last, char _Dflt, char *_Dest) const
; 2335 : 		{	// narrow elements in [_First, _Last) to chars
; 2336 : 		_DEBUG_RANGE(_First, _Last);
; 2337 : 		_DEBUG_POINTER(_Dest);
; 2338 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2339 : 			*_Dest = _Donarrow(*_First, _Dflt);
; 2340 : 		return (_First);
; 2341 : 		}
; 2342 : 
; 2343 : private:
; 2344 : 	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
; 2345 : 	_Locinfo::_Cvtvec _Cvt;		// conversion information
; 2346 : 	};
; 2347 : 
; 2348 : 		// STATIC ctype::id OBJECT
; 2349 : template<class _Elem>
; 2350 : 	locale::id ctype<_Elem>::id;
; 2351 : 
; 2352 : 		// CLASS ctype<char>
; 2353 : template<>
; 2354 : 	class _CRTIMP2_PURE ctype<char>
; 2355 : 	: public ctype_base
; 2356 : 	{	// facet for classifying char elements, converting cases
; 2357 : 	typedef ctype<char> _Myt;
; 2358 : 
; 2359 : public:
; 2360 : 	typedef char _Elem;
; 2361 : 	typedef _Elem char_type;
; 2362 : 
; 2363 : 	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
; 2364 : 		{	// test if element fits any mask classifications
; 2365 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
; 2366 : 		}
; 2367 : 
; 2368 : 	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First,
; 2369 : 		const _Elem *_Last, mask *_Dest) const
; 2370 : 		{	// get mask sequence for elements in [_First, _Last)
; 2371 : 		_DEBUG_RANGE(_First, _Last);
; 2372 : 		_DEBUG_POINTER(_Dest);
; 2373 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2374 : 			*_Dest = _Ctype._Table[(unsigned char)*_First];
; 2375 : 		return (_First);
; 2376 : 		}
; 2377 : 
; 2378 : 	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval,
; 2379 : 		const _Elem *_First, const _Elem *_Last) const
; 2380 : 		{	// find first in [_First, _Last) that fits mask classification
; 2381 : 		_DEBUG_RANGE(_First, _Last);
; 2382 : 		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
; 2383 : 			;
; 2384 : 		return (_First);
; 2385 : 		}
; 2386 : 
; 2387 : 	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval,
; 2388 : 		const _Elem *_First, const _Elem *_Last) const
; 2389 : 		{	// find first in [_First, _Last) not fitting mask classification
; 2390 : 		_DEBUG_RANGE(_First, _Last);
; 2391 : 		for (; _First != _Last && is(_Maskval, *_First); ++_First)
; 2392 : 			;
; 2393 : 		return (_First);
; 2394 : 		}
; 2395 : 
; 2396 : 	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
; 2397 : 		{	// convert element to lower case
; 2398 : 		return (do_tolower(_Ch));
; 2399 : 		}
; 2400 : 
; 2401 : 	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
; 2402 : 		{	// convert [_First, _Last) in place to lower case
; 2403 : 		return (do_tolower(_First, _Last));
; 2404 : 		}
; 2405 : 
; 2406 : 	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
; 2407 : 		{	// convert element to upper case
; 2408 : 		return (do_toupper(_Ch));
; 2409 : 		}
; 2410 : 
; 2411 : 	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
; 2412 : 		{	// convert [_First, _Last) in place to upper case
; 2413 : 		return (do_toupper(_First, _Last));
; 2414 : 		}
; 2415 : 
; 2416 : 	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
; 2417 : 		{	// widen char
; 2418 : 		return (do_widen(_Byte));

	mov	ecx, DWORD PTR __Ctype_fac$1$[ebp]
	push	48					; 00000030H
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+32]
	call	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 796  : 		assign(_Count, _Ch);

	push	0
	push	DWORD PTR __Count$GSCopy$1$[ebp]
	lea	ecx, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1399 : 		const _Elem _E0 = _Ctype_fac.widen('0');

	mov	BYTE PTR __E0$[ebp], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Groupstring$[ebp+20], 15	; 0000000fH

; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Groupstring$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR __Groupstring$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 796  : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
	lea	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2424 : 		return (do_widen(_First, _Last, _Dest));

	mov	ecx, DWORD PTR __Ctype_fac$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2424 : 		return (do_widen(_First, _Last, _Dest));

	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1401 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	mov	eax, DWORD PTR __Count$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2424 : 		return (do_widen(_First, _Last, _Dest));

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1401 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2424 : 		return (do_widen(_First, _Last, _Dest));

	push	eax
	push	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1400 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2424 : 		return (do_widen(_First, _Last, _Dest));

	call	DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1403 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, esi
	push	eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1403 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ebx, eax
	mov	DWORD PTR __Punct_fac$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN85@Fput

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN85@Fput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN85@Fput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1404 : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[ebp]
	mov	ecx, ebx
	push	eax
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 85   : 		}
; 86   : 
; 87   : 	_Elem thousands_sep() const
; 88   : 		{	// return thousands separator
; 89   : 		return (do_thousands_sep());

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx

; 1404 : 		const string _Grouping = _Punct_fac.grouping();

	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 85   : 		}
; 86   : 
; 87   : 	_Elem thousands_sep() const
; 88   : 		{	// return thousands separator
; 89   : 		return (do_thousands_sep());

	mov	eax, DWORD PTR [eax+16]
	call	eax

; 1405 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();
; 1406 : 
; 1407 : 		size_t _Off = _Beforepoint;	// offset of (effective) decimal point
; 1408 : 		if (_Poff == _Count)
; 1409 : 			{	// no decimal point, ignore _Afterpoint and _Trailing
; 1410 : 			_Off += _Eoff;

	mov	ecx, DWORD PTR __Eoff$1$[ebp]
	mov	BYTE PTR __Kseparator$[ebp], al
	mov	eax, DWORD PTR __Poff$1$[ebp]
	cmp	eax, DWORD PTR __Count$GSCopy$1$[ebp]
	jne	SHORT $LN9@Fput
	mov	eax, DWORD PTR __Beforepoint$[ebp]

; 1411 : 			_Groupstring.insert(_Eoff, _Beforepoint, _E0);

	push	DWORD PTR __E0$[ebp]
	push	eax
	lea	ebx, DWORD PTR [ecx+eax]
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1412 : 			}
; 1413 : 		else

	jmp	SHORT $LN8@Fput
$LN9@Fput:

; 1414 : 			{	// fill in zeros around decimal point
; 1415 : 			_Off += _Poff;
; 1416 : 			_Groupstring.insert(_Eoff, _Trailing, _E0);

	mov	esi, DWORD PTR __E0$[ebp]
	mov	edi, DWORD PTR __Beforepoint$[ebp]
	push	esi
	push	DWORD PTR __Trailing$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	lea	ebx, DWORD PTR [eax+edi]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1417 : 			_Groupstring.insert(_Poff + 1, _Afterpoint, _E0);

	mov	eax, DWORD PTR __Poff$1$[ebp]
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	push	esi
	push	DWORD PTR __Afterpoint$[ebp]
	inc	eax
	push	eax
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 84   : 		return (do_decimal_point());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 84   : 		return (do_decimal_point());

	mov	cl, al

; 1418 : 			_Groupstring[_Poff] = _Punct_fac.decimal_point();

	mov	edx, DWORD PTR __Poff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	lea	eax, DWORD PTR __Groupstring$[ebp]
	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1419 : 			_Groupstring.insert(_Poff, _Beforepoint, _E0);

	push	esi
	push	edi
	push	edx
	mov	BYTE PTR [eax+edx], cl
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	mov	edi, DWORD PTR __Prefix$1$[ebp]
$LN8@Fput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H
	lea	esi, DWORD PTR __Grouping$[ebp]
	cmovae	esi, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1424 : 			&& (size_t)*_Pg < _Off - _Prefix)

	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	je	SHORT $LN6@Fput
$LL7@Fput:
	test	al, al
	jle	SHORT $LN6@Fput
	movsx	ecx, al
	mov	eax, ebx
	sub	eax, edi
	cmp	ecx, eax
	jae	SHORT $LN6@Fput

; 1425 : 			{	// add thousands separator
; 1426 : 			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);

	push	DWORD PTR __Kseparator$[ebp]
	sub	ebx, ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	push	1
	push	ebx
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1427 : 			if ('\0' < _Pg[1])

	cmp	BYTE PTR [esi+1], 0
	lea	eax, DWORD PTR [esi+1]
	cmovg	esi, eax
	mov	al, BYTE PTR [esi]
	cmp	al, 127					; 0000007fH
	jne	SHORT $LL7@Fput
$LN6@Fput:

; 1434 : 				? 0 : (size_t)_Iosbase.width() - _Count;

	mov	ebx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR __Groupstring$[ebp+16]
	mov	DWORD PTR __Count$GSCopy$2$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1434 : 				? 0 : (size_t)_Iosbase.width() - _Count;

	cmp	DWORD PTR [ebx+36], 0
	jl	SHORT $LN19@Fput
	jg	SHORT $LN219@Fput
	cmp	DWORD PTR [ebx+32], 0
	jbe	SHORT $LN19@Fput
$LN219@Fput:
	mov	esi, DWORD PTR [ebx+32]
	cmp	esi, eax
	jbe	SHORT $LN19@Fput
	sub	esi, eax
	jmp	SHORT $LN20@Fput
$LN19@Fput:
	xor	esi, esi
$LN20@Fput:

; 1435 : 
; 1436 : 		ios_base::fmtflags _Adjustfield =
; 1437 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [ebx+20]
	and	eax, 448				; 000001c0H

; 1438 : 		if (_Adjustfield != ios_base::left
; 1439 : 			&& _Adjustfield != ios_base::internal)

	cmp	eax, 64					; 00000040H
	je	$LN2@Fput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN218@Fput

; 1440 : 			{	// put leading fill
; 1441 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	DWORD PTR __Fill$[ebp]
	lea	eax, DWORD PTR $T9[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, eax

; 1442 : 			_Fillcount = 0;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1443 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edi
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Dest$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Dest$[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	lea	eax, DWORD PTR __Groupstring$[ebp]
	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1443 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T8[ebp]
	push	DWORD PTR [ecx]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 48					; 00000030H

; 1444 : 			}
; 1445 : 		else if (_Adjustfield == ios_base::internal)

	jmp	SHORT $LN224@Fput
$LN218@Fput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
	lea	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1447 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1447 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[ebp+4]
	lea	eax, DWORD PTR $T7[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	ecx, eax

; 1448 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	DWORD PTR __Fill$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Dest$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Dest$[ebp+4], eax
	lea	eax, DWORD PTR $T6[ebp]
	push	DWORD PTR [ecx+4]
	push	DWORD PTR [ecx]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H

; 1449 : 			_Fillcount = 0;

	xor	esi, esi

; 1450 : 			}
; 1451 : 		else

	jmp	SHORT $LN224@Fput
$LN2@Fput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
	lea	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1452 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1452 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[ebp+4]
	lea	eax, DWORD PTR $T5[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
$LN224@Fput:
	mov	edx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1454 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	ecx, DWORD PTR __Count$GSCopy$2$[ebp]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$3$[ebp], eax
	mov	DWORD PTR __Dest$[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	lea	eax, DWORD PTR __Groupstring$[ebp]
	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1454 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	sub	ecx, edi
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1691 : 		return (this->_Myptr()[_Off]);

	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1454 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	edi, DWORD PTR _this$[ebp]
	push	eax
	push	DWORD PTR __Dest$3$[ebp]
	lea	eax, DWORD PTR $T4[ebp]
	push	edx
	push	eax
	push	edi
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1456 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	push	esi
	push	DWORD PTR __Fill$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 418  : 		_Wide = _Newwidth;

	mov	DWORD PTR [ebx+32], 0
	mov	DWORD PTR [ebx+36], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1456 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	ebx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	push	ebx
	push	edi
	mov	DWORD PTR __Dest$[ebp+4], eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H
	jb	SHORT $LN171@Fput
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Grouping$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN171@Fput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Grouping$[ebp+20], 15	; 0000000fH

; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Grouping$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR __Grouping$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN220@Fput
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Groupstring$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN220@Fput:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1456 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	eax, ebx

; 1457 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$1:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$2:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z$3:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1344 : 		{	// generate sprintf format for floating-point

	push	ebp
	mov	ebp, esp

; 1345 : 		char *_Ptr = _Fmt;
; 1346 : 		*_Ptr++ = '%';
; 1347 : 
; 1348 : 		if (_Flags & ios_base::showpos)

	mov	edx, DWORD PTR __Flags$[ebp]
	push	esi
	mov	esi, DWORD PTR __Fmt$[ebp]
	mov	BYTE PTR [esi], 37			; 00000025H
	lea	eax, DWORD PTR [esi+1]
	test	dl, 32					; 00000020H
	je	SHORT $LN5@Ffmt

; 1349 : 			*_Ptr++ = '+';

	mov	BYTE PTR [eax], 43			; 0000002bH
	inc	eax
$LN5@Ffmt:

; 1350 : 		if (_Flags & ios_base::showpoint)

	test	dl, 16					; 00000010H
	je	SHORT $LN4@Ffmt

; 1351 : 			*_Ptr++ = '#';

	mov	BYTE PTR [eax], 35			; 00000023H
	inc	eax
$LN4@Ffmt:

; 1352 : 		*_Ptr++ = '.';
; 1353 : 		*_Ptr++ = '*';	// for precision argument
; 1354 : 		if (_Spec != '\0')

	mov	cl, BYTE PTR __Spec$[ebp]
	mov	WORD PTR [eax], 10798			; 00002a2eH
	add	eax, 2
	test	cl, cl
	je	SHORT $LN3@Ffmt

; 1355 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

	mov	BYTE PTR [eax], cl
	inc	eax
$LN3@Ffmt:

; 1356 : 
; 1357 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	mov	ecx, edx
	and	ecx, 12288				; 00003000H

; 1358 : 		if (_Flags & ios_base::uppercase)

	test	dl, 4
	je	SHORT $LN2@Ffmt

; 1359 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1360 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1361 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier

	cmp	ecx, 8192				; 00002000H
	je	SHORT $LN16@Ffmt
	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN8@Ffmt
	mov	cl, 65					; 00000041H

; 1362 : 		else
; 1363 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1364 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1365 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	mov	BYTE PTR [eax], cl

; 1366 : 
; 1367 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax+1], 0

; 1368 : 		return (_Fmt);

	mov	eax, esi
	pop	esi

; 1369 : 		}

	pop	ebp
	ret	0
$LN8@Ffmt:

; 1359 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1360 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1361 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier

	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx*2+69]

; 1362 : 		else
; 1363 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1364 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1365 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	mov	BYTE PTR [eax], cl

; 1366 : 
; 1367 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax+1], 0

; 1368 : 		return (_Fmt);

	mov	eax, esi
	pop	esi

; 1369 : 		}

	pop	ebp
	ret	0
$LN2@Ffmt:

; 1362 : 		else
; 1363 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1364 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1365 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	ecx, 8192				; 00002000H
	jne	SHORT $LN14@Ffmt
$LN16@Ffmt:
	mov	cl, 102					; 00000066H
	mov	BYTE PTR [eax], cl

; 1366 : 
; 1367 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax+1], 0

; 1368 : 		return (_Fmt);

	mov	eax, esi
	pop	esi

; 1369 : 		}

	pop	ebp
	ret	0
$LN14@Ffmt:

; 1362 : 		else
; 1363 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1364 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1365 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN12@Ffmt
	mov	cl, 97					; 00000061H
	mov	BYTE PTR [eax], cl

; 1366 : 
; 1367 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax+1], 0

; 1368 : 		return (_Fmt);

	mov	eax, esi
	pop	esi

; 1369 : 		}

	pop	ebp
	ret	0
$LN12@Ffmt:

; 1362 : 		else
; 1363 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1364 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1365 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx*2+101]
	mov	BYTE PTR [eax], cl

; 1366 : 
; 1367 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax+1], 0

; 1368 : 		return (_Fmt);

	mov	eax, esi
	pop	esi

; 1369 : 		}

	pop	ebp
	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1334 : 		{	// put formatted void pointer to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	push	edi

; 1335 : 		char _Buf[2 * _MAX_INT_DIG];
; 1336 : 
; 1337 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1338 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));

	push	eax
	push	OFFSET ??_C@_02BBAHNLBA@?$CFp?$AA@
	lea	eax, DWORD PTR __Buf$[ebp]
	mov	edi, ecx
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1339 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	xor	ecx, ebp
	pop	edi
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -144				; size = 4
_this$GSCopy$1$ = -140					; size = 4
__Significance$1$ = -136				; size = 4
__Beforepoint$1$ = -132					; size = 4
__Afterpoint$1$ = -128					; size = 4
__Iosbase$GSCopy$1$ = -124				; size = 4
__Buf$ = -120						; size = 108
__Fmt$ = -12						; size = 8
$T1 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1293 : 		{	// put formatted long double to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	esi
	push	edi
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx

; 1294 : 		char _Buf[_MAX_EXP_DIG + _MAX_SIG_DIG + 64], _Fmt[8];
; 1295 : 		streamsize _Precision = _Iosbase.precision() <= 0
; 1296 : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 1297 : 				? 6 : _Iosbase.precision();	// desired precision

	mov	edi, DWORD PTR [eax+28]
	mov	esi, DWORD PTR [eax+24]
	mov	DWORD PTR __Iosbase$GSCopy$1$[ebp], eax
	test	edi, edi
	jg	SHORT $LN36@do_put
	jl	SHORT $LN35@do_put
	test	esi, esi
	jne	SHORT $LN13@do_put
$LN35@do_put:
	test	DWORD PTR [eax+20], 8192		; 00002000H
	jne	SHORT $LN13@do_put
	mov	esi, 6
	xor	edi, edi
$LN13@do_put:

; 1298 : 		int _Significance = _MAX_SIG_DIG < _Precision
; 1299 : 			? _MAX_SIG_DIG : (int)_Precision;	// actual sprintf precision

	test	edi, edi
	jl	SHORT $LN15@do_put
	jg	SHORT $LN36@do_put
	cmp	esi, 36					; 00000024H
	jbe	SHORT $LN15@do_put
$LN36@do_put:
	mov	eax, 36					; 00000024H
	mov	DWORD PTR __Significance$1$[ebp], eax
	jmp	SHORT $LN16@do_put
$LN15@do_put:
	mov	eax, esi
	mov	DWORD PTR __Significance$1$[ebp], esi
$LN16@do_put:

; 1300 : 		_Precision -= _Significance;
; 1301 : 		size_t _Beforepoint = 0;	// zeros to add before decimal point
; 1302 : 		size_t _Afterpoint = 0;	// zeros to add after decimal point
; 1303 : 
; 1304 : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)
; 1305 : 			{	// scale silly fixed-point value
; 1306 : 			bool _Signed = _Val < 0;

	movsd	xmm0, QWORD PTR __Val$[ebp]
	cdq
	sub	esi, eax
	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
	sbb	edi, edx
	xor	edx, edx
	xor	ecx, ecx
	mov	DWORD PTR __Beforepoint$1$[ebp], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR $T1[ebp], eax
	and	eax, 12288				; 00003000H
	mov	DWORD PTR __Afterpoint$1$[ebp], ecx
	cmp	eax, 8192				; 00002000H
	jne	$LN1@do_put

; 1307 : 			if (_Signed)

	movsd	xmm4, QWORD PTR __xmm@80000000000000008000000000000000
	xorps	xmm3, xmm3
	comisd	xmm3, xmm0
	seta	al
	test	al, al
	je	SHORT $LN9@do_put

; 1308 : 				_Val = -_Val;

	xorpd	xmm0, xmm4
$LN9@do_put:

; 1309 : 
; 1310 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	movsd	xmm1, QWORD PTR __real@4733426172c74d82
	comisd	xmm0, xmm1
	movsd	xmm2, QWORD PTR __real@4202a05f20000000
	jb	SHORT $LN6@do_put
	npad	6
$LL8@do_put:
	cmp	edx, 5000				; 00001388H
	jae	SHORT $LN41@do_put

; 1311 : 				_Val /= 1e10;	// drop 10 zeros before decimal point

	divsd	xmm0, xmm2
	add	edx, 10					; 0000000aH
	comisd	xmm0, xmm1
	jae	SHORT $LL8@do_put
$LN41@do_put:
	mov	DWORD PTR __Beforepoint$1$[ebp], edx
$LN6@do_put:

; 1312 : 
; 1313 : 			if (0 < _Val)

	comisd	xmm0, xmm3
	jbe	SHORT $LN38@do_put

; 1314 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1315 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	test	edi, edi
	jl	SHORT $LN38@do_put
	jg	SHORT $LN39@do_put
	cmp	esi, 10					; 0000000aH
	jb	SHORT $LN38@do_put
$LN39@do_put:
	movsd	xmm1, QWORD PTR __real@38aa95a5b7f87a0f
$LL37@do_put:
	comisd	xmm1, xmm0
	jb	SHORT $LN42@do_put
	cmp	ecx, 5000				; 00001388H
	jae	SHORT $LN42@do_put

; 1316 : 					{	// drop 10 zeros after decimal point
; 1317 : 					_Val *= 1e10;
; 1318 : 					_Precision -= 10;

	add	esi, -10				; fffffff6H
	mulsd	xmm0, xmm2
	adc	edi, -1
	add	ecx, 10					; 0000000aH
	test	edi, edi
	jg	SHORT $LL37@do_put

; 1314 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1315 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	jl	SHORT $LN42@do_put
	cmp	esi, 10					; 0000000aH
	jae	SHORT $LL37@do_put
$LN42@do_put:
	mov	DWORD PTR __Afterpoint$1$[ebp], ecx
$LN38@do_put:

; 1319 : 					}
; 1320 : 
; 1321 : 			if (_Signed)

	test	al, al
	je	SHORT $LN1@do_put

; 1322 : 				_Val = -_Val;

	xorpd	xmm0, xmm4
$LN1@do_put:

; 1323 : 			}
; 1324 : 
; 1325 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1326 : 			_Beforepoint, _Afterpoint, (size_t)_Precision,
; 1327 : 				_CSTD sprintf_s(_Buf, sizeof (_Buf),
; 1328 : 					_Ffmt(_Fmt, 'L', _Iosbase.flags()),
; 1329 : 					_Significance, _Val)));	// convert and put

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR __Fmt$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR __Significance$1$[ebp]
	push	DWORD PTR $T1[ebp]
	push	76					; 0000004cH
	push	eax
	push	edi
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	108					; 0000006cH
	push	eax
	call	_sprintf_s
	push	eax
	push	esi
	push	DWORD PTR __Afterpoint$1$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	lea	eax, DWORD PTR __Buf$[ebp]
	push	DWORD PTR __Beforepoint$1$[ebp]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	DWORD PTR __Iosbase$GSCopy$1$[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	esi
	push	edi
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput

; 1330 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 68					; 00000044H
	mov	eax, esi
	xor	ecx, ebp
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -144				; size = 4
_this$GSCopy$1$ = -140					; size = 4
__Significance$1$ = -136				; size = 4
__Beforepoint$1$ = -132					; size = 4
__Afterpoint$1$ = -128					; size = 4
__Iosbase$GSCopy$1$ = -124				; size = 4
__Buf$ = -120						; size = 108
__Fmt$ = -12						; size = 8
$T1 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1251 : 		{	// put formatted double to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	esi
	push	edi
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx

; 1252 : 		char _Buf[_MAX_EXP_DIG + _MAX_SIG_DIG + 64], _Fmt[8];
; 1253 : 		streamsize _Precision = _Iosbase.precision() <= 0
; 1254 : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 1255 : 				? 6 : _Iosbase.precision();	// desired precision

	mov	edi, DWORD PTR [eax+28]
	mov	esi, DWORD PTR [eax+24]
	mov	DWORD PTR __Iosbase$GSCopy$1$[ebp], eax
	test	edi, edi
	jg	SHORT $LN36@do_put
	jl	SHORT $LN35@do_put
	test	esi, esi
	jne	SHORT $LN13@do_put
$LN35@do_put:
	test	DWORD PTR [eax+20], 8192		; 00002000H
	jne	SHORT $LN13@do_put
	mov	esi, 6
	xor	edi, edi
$LN13@do_put:

; 1256 : 		int _Significance = _MAX_SIG_DIG < _Precision
; 1257 : 			? _MAX_SIG_DIG : (int)_Precision;	// actual sprintf precision

	test	edi, edi
	jl	SHORT $LN15@do_put
	jg	SHORT $LN36@do_put
	cmp	esi, 36					; 00000024H
	jbe	SHORT $LN15@do_put
$LN36@do_put:
	mov	eax, 36					; 00000024H
	mov	DWORD PTR __Significance$1$[ebp], eax
	jmp	SHORT $LN16@do_put
$LN15@do_put:
	mov	eax, esi
	mov	DWORD PTR __Significance$1$[ebp], esi
$LN16@do_put:

; 1258 : 		_Precision -= _Significance;
; 1259 : 		size_t _Beforepoint = 0;	// zeros to add before decimal point
; 1260 : 		size_t _Afterpoint = 0;	// zeros to add after decimal point
; 1261 : 
; 1262 : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed
; 1263 : 			&& _Val * 0.5 != _Val)	// skip -Inf, 0, Inf

	movsd	xmm1, QWORD PTR __Val$[ebp]
	cdq
	sub	esi, eax
	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
	sbb	edi, edx
	xor	edx, edx
	xor	ecx, ecx
	mov	DWORD PTR __Beforepoint$1$[ebp], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR $T1[ebp], eax
	and	eax, 12288				; 00003000H
	mov	DWORD PTR __Afterpoint$1$[ebp], ecx
	cmp	eax, 8192				; 00002000H
	jne	$LN1@do_put
	movapd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	ucomisd	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN1@do_put

; 1264 : 			{	// scale silly fixed-point value
; 1265 : 			bool _Signed = _Val < 0;
; 1266 : 			if (_Signed)

	movsd	xmm4, QWORD PTR __xmm@80000000000000008000000000000000
	xorps	xmm3, xmm3
	comisd	xmm3, xmm1
	seta	al
	test	al, al
	je	SHORT $LN9@do_put

; 1267 : 				_Val = -_Val;

	xorpd	xmm1, xmm4
$LN9@do_put:

; 1268 : 
; 1269 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	movsd	xmm0, QWORD PTR __real@4733426172c74d82
	comisd	xmm1, xmm0
	movsd	xmm2, QWORD PTR __real@4202a05f20000000
	jb	SHORT $LN6@do_put
$LL8@do_put:
	cmp	edx, 5000				; 00001388H
	jae	SHORT $LN41@do_put

; 1270 : 				_Val /= 1e10;	// drop 10 zeros before decimal point

	divsd	xmm1, xmm2
	add	edx, 10					; 0000000aH
	comisd	xmm1, xmm0
	jae	SHORT $LL8@do_put
$LN41@do_put:
	mov	DWORD PTR __Beforepoint$1$[ebp], edx
$LN6@do_put:

; 1271 : 
; 1272 : 			if (0 < _Val)

	comisd	xmm1, xmm3
	jbe	SHORT $LN38@do_put

; 1273 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1274 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	test	edi, edi
	jl	SHORT $LN38@do_put
	jg	SHORT $LN39@do_put
	cmp	esi, 10					; 0000000aH
	jb	SHORT $LN38@do_put
$LN39@do_put:
	movsd	xmm0, QWORD PTR __real@38aa95a5b7f87a0f
$LL37@do_put:
	comisd	xmm0, xmm1
	jb	SHORT $LN42@do_put
	cmp	ecx, 5000				; 00001388H
	jae	SHORT $LN42@do_put

; 1275 : 					{	// drop 10 zeros after decimal point
; 1276 : 					_Val *= 1e10;
; 1277 : 					_Precision -= 10;

	add	esi, -10				; fffffff6H
	mulsd	xmm1, xmm2
	adc	edi, -1
	add	ecx, 10					; 0000000aH
	test	edi, edi
	jg	SHORT $LL37@do_put

; 1273 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1274 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	jl	SHORT $LN42@do_put
	cmp	esi, 10					; 0000000aH
	jae	SHORT $LL37@do_put
$LN42@do_put:
	mov	DWORD PTR __Afterpoint$1$[ebp], ecx
$LN38@do_put:

; 1278 : 					}
; 1279 : 
; 1280 : 			if (_Signed)

	test	al, al
	je	SHORT $LN1@do_put

; 1281 : 				_Val = -_Val;

	xorpd	xmm1, xmm4
$LN1@do_put:

; 1282 : 			}
; 1283 : 
; 1284 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1285 : 			_Beforepoint, _Afterpoint, (size_t)_Precision,
; 1286 : 				_CSTD sprintf_s(_Buf, sizeof (_Buf),
; 1287 : 					_Ffmt(_Fmt, 0, _Iosbase.flags()),
; 1288 : 					_Significance, _Val)));	// convert and put

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR __Fmt$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	push	DWORD PTR __Significance$1$[ebp]
	push	DWORD PTR $T1[ebp]
	push	0
	push	eax
	push	edi
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	108					; 0000006cH
	push	eax
	call	_sprintf_s
	push	eax
	push	esi
	push	DWORD PTR __Afterpoint$1$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	lea	eax, DWORD PTR __Buf$[ebp]
	push	DWORD PTR __Beforepoint$1$[ebp]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	DWORD PTR __Iosbase$GSCopy$1$[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	esi
	push	edi
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput

; 1289 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 68					; 00000044H
	mov	eax, esi
	xor	ecx, ebp
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1240 : 		{	// put formatted unsigned long long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1241 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1242 : 
; 1243 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1244 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
; 1245 : 				_Iosbase.flags()), _Val)));

	lea	eax, DWORD PTR __Fmt$[ebp]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	push	edi
	push	DWORD PTR __Val$[ebp+4]
	mov	edi, ecx
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02CLHGNPPK@Lu?$AA@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1246 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 52					; 00000034H
	mov	eax, ebx
	xor	ecx, ebp
	pop	edi
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1230 : 		{	// put formatted long long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1231 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1232 : 
; 1233 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1234 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
; 1235 : 				_Iosbase.flags()), _Val)));

	lea	eax, DWORD PTR __Fmt$[ebp]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	push	edi
	push	DWORD PTR __Val$[ebp+4]
	mov	edi, ecx
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02HIKPPMOK@Ld?$AA@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1236 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 52					; 00000034H
	mov	eax, ebx
	xor	ecx, ebp
	pop	edi
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1219 : 		{	// put formatted unsigned long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1220 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1221 : 
; 1222 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1223 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
; 1224 : 				_Iosbase.flags()), _Val)));

	lea	eax, DWORD PTR __Fmt$[ebp]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	push	edi
	push	DWORD PTR __Val$[ebp]
	mov	edi, ecx
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02BDDLJJBK@lu?$AA@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1225 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	xor	ecx, ebp
	pop	edi
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1209 : 		{	// put formatted long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1210 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1211 : 
; 1212 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1213 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
; 1214 : 				_Iosbase.flags()), _Val)));

	lea	eax, DWORD PTR __Fmt$[ebp]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	push	edi
	push	DWORD PTR __Val$[ebp]
	mov	edi, ecx
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02EAOCLKAK@ld?$AA@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1215 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	xor	ecx, ebp
	pop	edi
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
$T2 = -80						; size = 8
$T3 = -80						; size = 8
__Dest$3$ = -76						; size = 4
$T4 = -76						; size = 4
__Fill$GSCopy$ = -72					; size = 1
_this$GSCopy$1$ = -68					; size = 4
$T5 = -64						; size = 24
$T6 = -64						; size = 24
__Str$7 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1179 : 		{	// put formatted bool to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	eax, DWORD PTR __Fill$[ebp]
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	BYTE PTR __Fill$GSCopy$[ebp], al

; 1180 : 		_DEBUG_POINTER(_Dest);
; 1181 : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

	test	DWORD PTR [esi+20], 16384		; 00004000H
	jne	SHORT $LN5@do_put

; 1182 : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, al
	push	eax
	push	DWORD PTR __Fill$GSCopy$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	call	DWORD PTR [edx+36]
	jmp	$LN167@do_put
$LN5@do_put:

; 1185 : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	eax, DWORD PTR $T4[ebp]
	mov	ecx, esi
	push	eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1185 : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN19@do_put

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN19@do_put
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN19@do_put:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$7[ebp+20], 15		; 0000000fH

; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$7[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR __Str$7[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1187 : 			if (_Val)

	cmp	BYTE PTR __Val$[ebp], 0

; 1188 : 				_Str.assign(_Punct_fac.truename());

	lea	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, edi
	push	eax
	je	SHORT $LN3@do_put
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename

; 1189 : 			else

	jmp	SHORT $LN183@do_put
$LN3@do_put:

; 1190 : 				_Str.assign(_Punct_fac.falsename());

	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
$LN183@do_put:
	push	eax
	lea	ecx, DWORD PTR __Str$7[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T5[ebp+20], 16		; 00000010H
	jb	SHORT $LN111@do_put
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T5[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN111@do_put:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1194 : 					? 0 : (size_t)_Iosbase.width() - _Str.size();

	cmp	DWORD PTR [esi+36], 0
	mov	ecx, DWORD PTR __Str$7[ebp+16]
	jl	SHORT $LN8@do_put
	jg	SHORT $LN179@do_put
	cmp	DWORD PTR [esi+32], 0
	jbe	SHORT $LN8@do_put
$LN179@do_put:
	mov	edi, DWORD PTR [esi+32]
	cmp	edi, ecx
	jbe	SHORT $LN8@do_put
	sub	edi, ecx
	jmp	SHORT $LN9@do_put
$LN8@do_put:
	xor	edi, edi
$LN9@do_put:

; 1195 : 
; 1196 : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR [esi+20]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN180@do_put

; 1197 : 				{	// put leading fill
; 1198 : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

	push	edi
	push	DWORD PTR __Fill$GSCopy$[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$GSCopy$1$[ebp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep

; 1199 : 				_Fillcount = 0;

	mov	ecx, DWORD PTR __Str$7[ebp+16]
	add	esp, 24					; 00000018H
	xor	edi, edi
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp+4], eax
	jmp	SHORT $LN184@do_put
$LN180@do_put:
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	edx, DWORD PTR __Dest$[ebp]
$LN184@do_put:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Str$7[ebp+20], 16		; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1199 : 				_Fillcount = 0;

	mov	DWORD PTR __Dest$3$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	eax, DWORD PTR __Str$7[ebp]
	cmovae	eax, DWORD PTR __Str$7[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1201 : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	push	ecx
	push	eax
	push	DWORD PTR __Dest$3$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	push	edx
	push	eax
	push	DWORD PTR _this$GSCopy$1$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1203 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	push	edi
	push	DWORD PTR __Fill$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
	push	ebx
	push	DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR __Dest$[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 418  : 		_Wide = _Newwidth;

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1203 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR __Str$7[ebp+20], 16		; 00000010H
	jb	SHORT $LN167@do_put
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Str$7[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN167@do_put:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1203 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	eax, ebx

; 1204 : 			}
; 1205 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
	lea	ecx, DWORD PTR __Str$7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1160 : 		{	// put formatted double to _Dest

	push	ebp
	mov	ebp, esp

; 1161 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	movsd	xmm0, QWORD PTR __Val$[ebp]
	sub	esp, 8
	mov	eax, DWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR __Fill$[ebp]
	push	DWORD PTR __Iosbase$[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR [eax+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1162 : 		}

	pop	ebp
	ret	28					; 0000001cH
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1119 : 		{	// construct from specified locale

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	eax, DWORD PTR __Refs$[ebp]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1121 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	pop	ebp
	ret	8
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 1106 : 		}

	ret	4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1102 : 		}

	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1090 : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1091 : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	edi, DWORD PTR __Ppf$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR $T3[ebp], ebx
	test	edi, edi
	je	SHORT $LN29@Getcat
	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN29@Getcat

; 1093 : 				_Locinfo(_Ploc->c_str()));

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	test	esi, esi
	je	SHORT $LN4@Getcat
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	ecx, DWORD PTR __Ploc$[ebp]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LN12@Getcat
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN17@Getcat
$LN12@Getcat:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3398 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN17@Getcat
	lea	eax, DWORD PTR [ecx+28]
$LN17@Getcat:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1093 : 				_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	ebx, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1119 : 		{	// construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1093 : 				_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	esi, esi
$LN5@Getcat:
	mov	DWORD PTR [edi], esi
	test	bl, 1
	je	SHORT $LN29@Getcat
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN29@Getcat:

; 1094 : 		return (_X_NUMERIC);

	mov	eax, 4

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 561  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 562  :  #if _NO_LOCALES
; 563  : 	static _Wrap_facet<_Facet> _Wfac;
; 564  : 	return (*(_Facet *)&_Wfac);
; 565  : 
; 566  :  #else /* _NO_LOCALES */
; 567  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 79   : 			if (_Id == 0)

	mov	edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id

; 568  : 		const locale::facet *_Psave =
; 569  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __Psave$5[ebp], ebx

; 79   : 			if (_Id == 0)

	test	edi, edi
	jne	SHORT $LN11@use_facet

; 80   : 				{	// still zero, allocate stamp
; 81   : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 82   : 					if (_Id == 0)

	cmp	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN10@use_facet

; 83   : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN10@use_facet:

; 84   : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN11@use_facet:

; 85   : 				}
; 86   : 			return (_Id);
; 87   : 			}
; 88   : 
; 89   : 	private:
; 90   : 		size_t _Id;	// the identifier stamp
; 91   : 
; 92   : 		__PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 93   : 
; 94   : 	public:
; 95   : 		__CLR_OR_THIS_CALL id(const id&) = delete;
; 96   : 		id& __CLR_OR_THIS_CALL operator=(const id&) = delete;
; 97   : 		};
; 98   : 
; 99   : 	class _Locimp;
; 100  : 
; 101  : 			// CLASS facet
; 102  : 	class _CRTIMP2_PURE facet
; 103  : 		: public _Facet_base
; 104  : 		{	// base class for all locale facets, performs reference counting
; 105  : 		friend class locale;
; 106  : 		friend class _Locimp;
; 107  : 
; 108  : 		template<class _Ty>
; 109  : 			friend void __CLRCALL_OR_CDECL _DebugHeapDelete(_Ty *_Ptr);
; 110  : 
; 111  : 	public:
; 112  : 		static size_t __CLRCALL_OR_CDECL _Getcat(const facet ** = 0,
; 113  : 			const locale * = 0)
; 114  : 			{	// get category value, or -1 if no corresponding C category
; 115  : 			return ((size_t)(-1));
; 116  : 			}
; 117  : 
; 118  :   #if defined(_DEBUG) && !defined(_M_X64)
; 119  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size)
; 120  : 			{	// replace operator new
; 121  : 			return (operator new(_Size, _DebugHeapTag_func(),
; 122  : 				__FILE__, __LINE__));
; 123  : 			}
; 124  : 
; 125  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size,
; 126  : 			const _DebugHeapTag_t& _Tag, char *_File, int _Line)
; 127  : 			{	// replace debugging operator new
; 128  : 			return (::operator new(_Size, _Tag, _File, _Line));
; 129  : 			}
; 130  : 
; 131  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr,
; 132  : 			const _DebugHeapTag_t&, char *, int)
; 133  : 			{	// replace debugging operator delete
; 134  : 			operator delete(_Ptr);
; 135  : 			}
; 136  : 
; 137  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr)
; 138  : 			{	// replace operator delete
; 139  : 			_DebugHeapDelete((facet *)_Ptr);
; 140  : 			}
; 141  :   #endif /* defined(_DEBUG) etc. */
; 142  : 
; 143  : 		virtual void __CLR_OR_THIS_CALL _Incref()
; 144  : 			{   // increment use count
; 145  : 			_MT_INCR(_Mtx, _Refs);
; 146  : 			}
; 147  : 
; 148  : 		virtual _Facet_base *__CLR_OR_THIS_CALL _Decref()
; 149  : 			{   // decrement use count
; 150  : 			if (_MT_DECR(_Mtx, _Refs) == 0)
; 151  : 				return (this);
; 152  : 			else
; 153  : 				return (0);
; 154  : 			}
; 155  : 
; 156  : 	private:
; 157  : 		_Atomic_counter_t _Refs;	// the reference count
; 158  : 
; 159  : 	protected:
; 160  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 161  : 			{	// construct with initial reference count
; 162  : 			_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
; 163  : 			}
; 164  : 
; 165  : 		virtual __CLR_OR_THIS_CALL ~facet() _NOEXCEPT
; 166  : 			{	// ensure that derived classes can be destroyed properly
; 167  : 			}
; 168  : 
; 169  : 	public:
; 170  : 		__CLR_OR_THIS_CALL facet(const facet&) = delete;
; 171  : 		facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 172  : 		};
; 173  : 
; 174  : 			// CLASS _Locimp
; 175  :  #pragma warning(push)
; 176  :  #pragma warning(disable: 4275)
; 177  : 
; 178  : 	class _CRTIMP2_PURE _Locimp
; 179  : 		: public facet
; 180  : 		{	// reference-counted actual implementation of a locale
; 181  : 	protected:
; 182  : 		__CLR_OR_THIS_CALL ~_Locimp() _NOEXCEPT
; 183  : 		{	// destroy the object
; 184  : 		_Locimp_dtor(this);
; 185  : 		}
; 186  : 
; 187  : 	private:
; 188  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 189  : 			_New_Locimp(bool _Transparent = false);
; 190  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 191  : 			_New_Locimp(const _Locimp& _Right);
; 192  : 
; 193  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 194  : 			_Locimp_dtor(_Locimp *);
; 195  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 196  : 			_Locimp_Addfac(_Locimp *, facet *, size_t);	// add a facet
; 197  : 		static void __CLRCALL_PURE_OR_CDECL
; 198  : 			_Locimp_ctor(_Locimp *, const _Locimp&);
; 199  : 
; 200  : 		friend class locale;
; 201  : 
; 202  : 		__CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 203  : 			: locale::facet(1), _Facetvec(0), _Facetcount(0),
; 204  : 				_Catmask(none), _Xparent(_Transparent),
; 205  : 					_Name("*")
; 206  : 			{	// construct an empty _Locimp
; 207  : 			}
; 208  : 
; 209  : 		__CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 210  : 			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
; 211  : 				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
; 212  : 					_Name(_Right._Name.c_str())
; 213  : 			{	// construct by copying
; 214  : 			_Locimp_ctor(this, _Right);
; 215  : 			}
; 216  : 
; 217  : 		void __CLR_OR_THIS_CALL _Addfac(facet *_Pfacet, size_t _Id)
; 218  : 			{	// add a facet
; 219  : 			_Locimp_Addfac(this, _Pfacet, _Id);
; 220  : 			}
; 221  : 
; 222  : 		static _Locimp *__CLRCALL_OR_CDECL _Makeloc(const _Locinfo&,
; 223  : 			category, _Locimp *, const locale *);	// make essential facets
; 224  : 
; 225  : 		static void __CLRCALL_OR_CDECL _Makewloc(const _Locinfo&,
; 226  : 			category, _Locimp *, const locale *);	// make wchar_t facets
; 227  : 
; 228  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 229  : 		static void __CLRCALL_OR_CDECL _Makeushloc(const _Locinfo&,
; 230  : 			category, _Locimp *, const locale *);	// make ushort facets
; 231  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 232  : 
; 233  : 		static void __CLRCALL_OR_CDECL _Makexloc(const _Locinfo&,
; 234  : 			category, _Locimp *, const locale *);	// make remaining facets
; 235  : 
; 236  : 		facet **_Facetvec;	// pointer to vector of facets
; 237  : 		size_t _Facetcount;	// size of vector of facets
; 238  : 		category _Catmask;	// mask describing implemented categories
; 239  : 		bool _Xparent;	// true if locale is transparent
; 240  : 		_Yarn<char> _Name;	// locale name, or "*" if not known
; 241  : 
; 242  : 		__PURE_APPDOMAIN_GLOBAL static _Locimp *_Clocptr;
; 243  : 
; 244  : public:
; 245  : 		_Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 246  : 		};
; 247  : 
; 248  :  #pragma warning(pop)
; 249  : 
; 250  : 	template<class _Elem,
; 251  : 		class _Traits,
; 252  : 		class _Alloc>
; 253  : 		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 254  : 			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
; 255  : 		{	// compare _Left and _Right strings using collate facet in locale
; 256  : 		const _STD collate<_Elem>& _Coll_fac =
; 257  : 			use_facet<_STD collate<_Elem> >(*this);
; 258  : 
; 259  : 		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
; 260  : 			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
; 261  : 		}
; 262  : 
; 263  : 	template<class _Facet>
; 264  : 		locale combine(const locale& _Loc) const
; 265  : 		{	// combine two locales
; 266  : 		_Facet *_Facptr;
; 267  : 
; 268  : 		_TRY_BEGIN
; 269  : 			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
; 270  : 		_CATCH_ALL
; 271  : 			_Xruntime_error("locale::combine facet missing");
; 272  : 		_CATCH_END
; 273  : 
; 274  : 		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
; 275  : 		_Newimp->_Addfac(_Facptr, _Facet::id);
; 276  : 		_Newimp->_Catmask = 0;
; 277  : 		_Newimp->_Name = "*";
; 278  : 		return (locale(_Newimp));
; 279  : 		}
; 280  : 
; 281  : 	template<class _Facet>
; 282  : 		locale(const locale& _Loc, const _Facet *_Facptr)
; 283  : 			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 284  : 		{	// construct from _Loc, replacing facet with *_Facptr
; 285  : 		if (_Facptr != 0)
; 286  : 			{	// replace facet
; 287  : 			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
; 288  : 			if (_Facet::_Getcat() != (size_t)(-1))
; 289  : 				{	// no C category
; 290  : 				_Ptr->_Catmask = 0;
; 291  : 				_Ptr->_Name = "*";
; 292  : 				}
; 293  : 			}
; 294  : 		}
; 295  : 
; 296  : 	locale(_Uninitialized)
; 297  : 		{	// defer construction
; 298  : 		}
; 299  : 
; 300  :  #if _NO_LOCALES
; 301  : 	locale(const locale& _Right) _THROW0()
; 302  : 		: _Ptr(0)
; 303  : 		{	// construct by copying
; 304  : 		}
; 305  : 
; 306  : 	locale() _THROW0()
; 307  : 		: _Ptr(0)
; 308  : 		{	// construct from current locale
; 309  : 		}
; 310  : 
; 311  : 	~locale() _NOEXCEPT
; 312  : 		{	// destroy the object
; 313  : 		}
; 314  : 
; 315  : 	locale& operator=(const locale& _Right) _THROW0()
; 316  : 		{	// assign a locale
; 317  : 		return (*this);
; 318  : 		}
; 319  : 
; 320  :  #else /* _NO_LOCALES */
; 321  : 	locale(const locale& _Right) _THROW0()
; 322  : 		: _Ptr(_Right._Ptr)
; 323  : 		{	// construct by copying
; 324  : 		_Ptr->_Incref();
; 325  : 		}
; 326  : 
; 327  : 	locale() _THROW0()
; 328  : 		: _Ptr(_Init(true))
; 329  : 		{	// construct from current locale
; 330  : 		}
; 331  : 
; 332  :  #if !defined(MRTDLL) || !defined(_CRTBLD)
; 333  : 	locale(const locale& _Loc, const locale& _Other,
; 334  : 		category _Cat)
; 335  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 336  : 		{	// construct a locale by copying named facets
; 337  : 		_TRY_BEGIN
; 338  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 339  : 			_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
; 340  : 				_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
; 341  : 		_END_LOCINFO()
; 342  : 		_CATCH_ALL
; 343  : 		_DELETE_CRT(_Ptr->_Decref());
; 344  : 		_RERAISE;
; 345  : 		_CATCH_END
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	void _Construct(const string &_Str,
; 350  : 		category _Cat)	// construct from named locale for category
; 351  : 		{	// construct a locale with named facets
; 352  : 		bool _Bad = false;
; 353  : 		_TRY_BEGIN
; 354  : 		_Init();
; 355  : 		_BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 356  : 			if (_Badname(_Lobj))
; 357  : 				_Bad = true;
; 358  : 			else
; 359  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 360  : 		_END_LOCINFO()
; 361  : 		_CATCH_ALL
; 362  : 		_DELETE_CRT(_Ptr->_Decref());
; 363  : 		_RERAISE;
; 364  : 		_CATCH_END
; 365  : 
; 366  : 		if (_Bad)
; 367  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 368  : 			_DELETE_CRT(_Ptr->_Decref());
; 369  : 			_Xruntime_error("bad locale name");
; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 	void _Construct(const locale& _Loc, const string &_Str,
; 374  : 		category _Cat)
; 375  : 		{	// construct a locale by copying, replacing named facets
; 376  : 		bool _Bad = false;
; 377  : 		_TRY_BEGIN
; 378  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 379  : 			bool _Hadname = !_Badname(_Lobj);
; 380  : 			_Lobj._Addcats(_Cat, _Str.c_str());
; 381  : 
; 382  : 			if (_Hadname && _Badname(_Lobj))
; 383  : 				_Bad = true;
; 384  : 			else
; 385  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 386  : 		_END_LOCINFO()
; 387  : 		_CATCH_ALL
; 388  : 		_DELETE_CRT(_Ptr->_Decref());
; 389  : 		_RERAISE;
; 390  : 		_CATCH_END
; 391  : 
; 392  : 		if (_Bad)
; 393  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 394  : 			_DELETE_CRT(_Ptr->_Decref());
; 395  : 			_Xruntime_error("bad locale name");
; 396  : 			}
; 397  : 		}
; 398  : 
; 399  : public:
; 400  : 	explicit locale(const char *_Locname,
; 401  : 		category _Cat = all)	// construct from named locale for category
; 402  : 		: _Ptr(_Locimp::_New_Locimp())
; 403  : 		{	// construct a locale with named facets
; 404  : 		// _Locname might have been returned from setlocale().
; 405  : 		// Therefore, _Construct() takes const string&.
; 406  : 		if (_Locname == 0)
; 407  : 			_Xruntime_error("bad locale name");
; 408  : 		_Construct(_Locname, _Cat);
; 409  : 		}
; 410  : 
; 411  : 	locale(const locale& _Loc, const char *_Locname,
; 412  : 		category _Cat)
; 413  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 414  : 		{	// construct a locale by copying, replacing named facets
; 415  : 		// _Locname might have been returned from setlocale().
; 416  : 		// Therefore, _Construct() takes const string&.
; 417  : 		if (_Locname == 0)
; 418  : 			_Xruntime_error("bad locale name");
; 419  : 		_Construct(_Loc, _Locname, _Cat);
; 420  : 		}
; 421  : 
; 422  : 	explicit locale(const string& _Str,
; 423  : 		category _Cat = all)	// construct from named locale for category
; 424  : 		: _Ptr(_Locimp::_New_Locimp())
; 425  : 		{	// construct a locale with named facets
; 426  : 		_Construct(_Str, _Cat);
; 427  : 		}
; 428  : 
; 429  : 	locale(const locale& _Loc, const string& _Str,
; 430  : 		category _Cat)
; 431  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 432  : 		{	// construct a locale by copying, replacing named facets
; 433  : 		_Construct(_Loc, _Str, _Cat);
; 434  : 		}
; 435  :  #endif /* !MRTDLL || !_CRTBLD */
; 436  : 
; 437  : 	~locale() _NOEXCEPT
; 438  : 		{	// destroy the object
; 439  : 		if (_Ptr != 0)
; 440  : 			_DELETE_CRT(_Ptr->_Decref());
; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	mov	ecx, DWORD PTR __Loc$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN20@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	SHORT $LN1@use_facet
	jmp	SHORT $LN24@use_facet
$LN20@use_facet:

; 85   : 				}
; 86   : 			return (_Id);
; 87   : 			}
; 88   : 
; 89   : 	private:
; 90   : 		size_t _Id;	// the identifier stamp
; 91   : 
; 92   : 		__PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 93   : 
; 94   : 	public:
; 95   : 		__CLR_OR_THIS_CALL id(const id&) = delete;
; 96   : 		id& __CLR_OR_THIS_CALL operator=(const id&) = delete;
; 97   : 		};
; 98   : 
; 99   : 	class _Locimp;
; 100  : 
; 101  : 			// CLASS facet
; 102  : 	class _CRTIMP2_PURE facet
; 103  : 		: public _Facet_base
; 104  : 		{	// base class for all locale facets, performs reference counting
; 105  : 		friend class locale;
; 106  : 		friend class _Locimp;
; 107  : 
; 108  : 		template<class _Ty>
; 109  : 			friend void __CLRCALL_OR_CDECL _DebugHeapDelete(_Ty *_Ptr);
; 110  : 
; 111  : 	public:
; 112  : 		static size_t __CLRCALL_OR_CDECL _Getcat(const facet ** = 0,
; 113  : 			const locale * = 0)
; 114  : 			{	// get category value, or -1 if no corresponding C category
; 115  : 			return ((size_t)(-1));
; 116  : 			}
; 117  : 
; 118  :   #if defined(_DEBUG) && !defined(_M_X64)
; 119  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size)
; 120  : 			{	// replace operator new
; 121  : 			return (operator new(_Size, _DebugHeapTag_func(),
; 122  : 				__FILE__, __LINE__));
; 123  : 			}
; 124  : 
; 125  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size,
; 126  : 			const _DebugHeapTag_t& _Tag, char *_File, int _Line)
; 127  : 			{	// replace debugging operator new
; 128  : 			return (::operator new(_Size, _Tag, _File, _Line));
; 129  : 			}
; 130  : 
; 131  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr,
; 132  : 			const _DebugHeapTag_t&, char *, int)
; 133  : 			{	// replace debugging operator delete
; 134  : 			operator delete(_Ptr);
; 135  : 			}
; 136  : 
; 137  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr)
; 138  : 			{	// replace operator delete
; 139  : 			_DebugHeapDelete((facet *)_Ptr);
; 140  : 			}
; 141  :   #endif /* defined(_DEBUG) etc. */
; 142  : 
; 143  : 		virtual void __CLR_OR_THIS_CALL _Incref()
; 144  : 			{   // increment use count
; 145  : 			_MT_INCR(_Mtx, _Refs);
; 146  : 			}
; 147  : 
; 148  : 		virtual _Facet_base *__CLR_OR_THIS_CALL _Decref()
; 149  : 			{   // decrement use count
; 150  : 			if (_MT_DECR(_Mtx, _Refs) == 0)
; 151  : 				return (this);
; 152  : 			else
; 153  : 				return (0);
; 154  : 			}
; 155  : 
; 156  : 	private:
; 157  : 		_Atomic_counter_t _Refs;	// the reference count
; 158  : 
; 159  : 	protected:
; 160  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 161  : 			{	// construct with initial reference count
; 162  : 			_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
; 163  : 			}
; 164  : 
; 165  : 		virtual __CLR_OR_THIS_CALL ~facet() _NOEXCEPT
; 166  : 			{	// ensure that derived classes can be destroyed properly
; 167  : 			}
; 168  : 
; 169  : 	public:
; 170  : 		__CLR_OR_THIS_CALL facet(const facet&) = delete;
; 171  : 		facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 172  : 		};
; 173  : 
; 174  : 			// CLASS _Locimp
; 175  :  #pragma warning(push)
; 176  :  #pragma warning(disable: 4275)
; 177  : 
; 178  : 	class _CRTIMP2_PURE _Locimp
; 179  : 		: public facet
; 180  : 		{	// reference-counted actual implementation of a locale
; 181  : 	protected:
; 182  : 		__CLR_OR_THIS_CALL ~_Locimp() _NOEXCEPT
; 183  : 		{	// destroy the object
; 184  : 		_Locimp_dtor(this);
; 185  : 		}
; 186  : 
; 187  : 	private:
; 188  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 189  : 			_New_Locimp(bool _Transparent = false);
; 190  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 191  : 			_New_Locimp(const _Locimp& _Right);
; 192  : 
; 193  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 194  : 			_Locimp_dtor(_Locimp *);
; 195  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 196  : 			_Locimp_Addfac(_Locimp *, facet *, size_t);	// add a facet
; 197  : 		static void __CLRCALL_PURE_OR_CDECL
; 198  : 			_Locimp_ctor(_Locimp *, const _Locimp&);
; 199  : 
; 200  : 		friend class locale;
; 201  : 
; 202  : 		__CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 203  : 			: locale::facet(1), _Facetvec(0), _Facetcount(0),
; 204  : 				_Catmask(none), _Xparent(_Transparent),
; 205  : 					_Name("*")
; 206  : 			{	// construct an empty _Locimp
; 207  : 			}
; 208  : 
; 209  : 		__CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 210  : 			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
; 211  : 				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
; 212  : 					_Name(_Right._Name.c_str())
; 213  : 			{	// construct by copying
; 214  : 			_Locimp_ctor(this, _Right);
; 215  : 			}
; 216  : 
; 217  : 		void __CLR_OR_THIS_CALL _Addfac(facet *_Pfacet, size_t _Id)
; 218  : 			{	// add a facet
; 219  : 			_Locimp_Addfac(this, _Pfacet, _Id);
; 220  : 			}
; 221  : 
; 222  : 		static _Locimp *__CLRCALL_OR_CDECL _Makeloc(const _Locinfo&,
; 223  : 			category, _Locimp *, const locale *);	// make essential facets
; 224  : 
; 225  : 		static void __CLRCALL_OR_CDECL _Makewloc(const _Locinfo&,
; 226  : 			category, _Locimp *, const locale *);	// make wchar_t facets
; 227  : 
; 228  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 229  : 		static void __CLRCALL_OR_CDECL _Makeushloc(const _Locinfo&,
; 230  : 			category, _Locimp *, const locale *);	// make ushort facets
; 231  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 232  : 
; 233  : 		static void __CLRCALL_OR_CDECL _Makexloc(const _Locinfo&,
; 234  : 			category, _Locimp *, const locale *);	// make remaining facets
; 235  : 
; 236  : 		facet **_Facetvec;	// pointer to vector of facets
; 237  : 		size_t _Facetcount;	// size of vector of facets
; 238  : 		category _Catmask;	// mask describing implemented categories
; 239  : 		bool _Xparent;	// true if locale is transparent
; 240  : 		_Yarn<char> _Name;	// locale name, or "*" if not known
; 241  : 
; 242  : 		__PURE_APPDOMAIN_GLOBAL static _Locimp *_Clocptr;
; 243  : 
; 244  : public:
; 245  : 		_Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 246  : 		};
; 247  : 
; 248  :  #pragma warning(pop)
; 249  : 
; 250  : 	template<class _Elem,
; 251  : 		class _Traits,
; 252  : 		class _Alloc>
; 253  : 		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 254  : 			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
; 255  : 		{	// compare _Left and _Right strings using collate facet in locale
; 256  : 		const _STD collate<_Elem>& _Coll_fac =
; 257  : 			use_facet<_STD collate<_Elem> >(*this);
; 258  : 
; 259  : 		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
; 260  : 			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
; 261  : 		}
; 262  : 
; 263  : 	template<class _Facet>
; 264  : 		locale combine(const locale& _Loc) const
; 265  : 		{	// combine two locales
; 266  : 		_Facet *_Facptr;
; 267  : 
; 268  : 		_TRY_BEGIN
; 269  : 			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
; 270  : 		_CATCH_ALL
; 271  : 			_Xruntime_error("locale::combine facet missing");
; 272  : 		_CATCH_END
; 273  : 
; 274  : 		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
; 275  : 		_Newimp->_Addfac(_Facptr, _Facet::id);
; 276  : 		_Newimp->_Catmask = 0;
; 277  : 		_Newimp->_Name = "*";
; 278  : 		return (locale(_Newimp));
; 279  : 		}
; 280  : 
; 281  : 	template<class _Facet>
; 282  : 		locale(const locale& _Loc, const _Facet *_Facptr)
; 283  : 			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 284  : 		{	// construct from _Loc, replacing facet with *_Facptr
; 285  : 		if (_Facptr != 0)
; 286  : 			{	// replace facet
; 287  : 			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
; 288  : 			if (_Facet::_Getcat() != (size_t)(-1))
; 289  : 				{	// no C category
; 290  : 				_Ptr->_Catmask = 0;
; 291  : 				_Ptr->_Name = "*";
; 292  : 				}
; 293  : 			}
; 294  : 		}
; 295  : 
; 296  : 	locale(_Uninitialized)
; 297  : 		{	// defer construction
; 298  : 		}
; 299  : 
; 300  :  #if _NO_LOCALES
; 301  : 	locale(const locale& _Right) _THROW0()
; 302  : 		: _Ptr(0)
; 303  : 		{	// construct by copying
; 304  : 		}
; 305  : 
; 306  : 	locale() _THROW0()
; 307  : 		: _Ptr(0)
; 308  : 		{	// construct from current locale
; 309  : 		}
; 310  : 
; 311  : 	~locale() _NOEXCEPT
; 312  : 		{	// destroy the object
; 313  : 		}
; 314  : 
; 315  : 	locale& operator=(const locale& _Right) _THROW0()
; 316  : 		{	// assign a locale
; 317  : 		return (*this);
; 318  : 		}
; 319  : 
; 320  :  #else /* _NO_LOCALES */
; 321  : 	locale(const locale& _Right) _THROW0()
; 322  : 		: _Ptr(_Right._Ptr)
; 323  : 		{	// construct by copying
; 324  : 		_Ptr->_Incref();
; 325  : 		}
; 326  : 
; 327  : 	locale() _THROW0()
; 328  : 		: _Ptr(_Init(true))
; 329  : 		{	// construct from current locale
; 330  : 		}
; 331  : 
; 332  :  #if !defined(MRTDLL) || !defined(_CRTBLD)
; 333  : 	locale(const locale& _Loc, const locale& _Other,
; 334  : 		category _Cat)
; 335  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 336  : 		{	// construct a locale by copying named facets
; 337  : 		_TRY_BEGIN
; 338  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 339  : 			_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
; 340  : 				_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
; 341  : 		_END_LOCINFO()
; 342  : 		_CATCH_ALL
; 343  : 		_DELETE_CRT(_Ptr->_Decref());
; 344  : 		_RERAISE;
; 345  : 		_CATCH_END
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	void _Construct(const string &_Str,
; 350  : 		category _Cat)	// construct from named locale for category
; 351  : 		{	// construct a locale with named facets
; 352  : 		bool _Bad = false;
; 353  : 		_TRY_BEGIN
; 354  : 		_Init();
; 355  : 		_BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 356  : 			if (_Badname(_Lobj))
; 357  : 				_Bad = true;
; 358  : 			else
; 359  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 360  : 		_END_LOCINFO()
; 361  : 		_CATCH_ALL
; 362  : 		_DELETE_CRT(_Ptr->_Decref());
; 363  : 		_RERAISE;
; 364  : 		_CATCH_END
; 365  : 
; 366  : 		if (_Bad)
; 367  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 368  : 			_DELETE_CRT(_Ptr->_Decref());
; 369  : 			_Xruntime_error("bad locale name");
; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 	void _Construct(const locale& _Loc, const string &_Str,
; 374  : 		category _Cat)
; 375  : 		{	// construct a locale by copying, replacing named facets
; 376  : 		bool _Bad = false;
; 377  : 		_TRY_BEGIN
; 378  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 379  : 			bool _Hadname = !_Badname(_Lobj);
; 380  : 			_Lobj._Addcats(_Cat, _Str.c_str());
; 381  : 
; 382  : 			if (_Hadname && _Badname(_Lobj))
; 383  : 				_Bad = true;
; 384  : 			else
; 385  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 386  : 		_END_LOCINFO()
; 387  : 		_CATCH_ALL
; 388  : 		_DELETE_CRT(_Ptr->_Decref());
; 389  : 		_RERAISE;
; 390  : 		_CATCH_END
; 391  : 
; 392  : 		if (_Bad)
; 393  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 394  : 			_DELETE_CRT(_Ptr->_Decref());
; 395  : 			_Xruntime_error("bad locale name");
; 396  : 			}
; 397  : 		}
; 398  : 
; 399  : public:
; 400  : 	explicit locale(const char *_Locname,
; 401  : 		category _Cat = all)	// construct from named locale for category
; 402  : 		: _Ptr(_Locimp::_New_Locimp())
; 403  : 		{	// construct a locale with named facets
; 404  : 		// _Locname might have been returned from setlocale().
; 405  : 		// Therefore, _Construct() takes const string&.
; 406  : 		if (_Locname == 0)
; 407  : 			_Xruntime_error("bad locale name");
; 408  : 		_Construct(_Locname, _Cat);
; 409  : 		}
; 410  : 
; 411  : 	locale(const locale& _Loc, const char *_Locname,
; 412  : 		category _Cat)
; 413  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 414  : 		{	// construct a locale by copying, replacing named facets
; 415  : 		// _Locname might have been returned from setlocale().
; 416  : 		// Therefore, _Construct() takes const string&.
; 417  : 		if (_Locname == 0)
; 418  : 			_Xruntime_error("bad locale name");
; 419  : 		_Construct(_Loc, _Locname, _Cat);
; 420  : 		}
; 421  : 
; 422  : 	explicit locale(const string& _Str,
; 423  : 		category _Cat = all)	// construct from named locale for category
; 424  : 		: _Ptr(_Locimp::_New_Locimp())
; 425  : 		{	// construct a locale with named facets
; 426  : 		_Construct(_Str, _Cat);
; 427  : 		}
; 428  : 
; 429  : 	locale(const locale& _Loc, const string& _Str,
; 430  : 		category _Cat)
; 431  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 432  : 		{	// construct a locale by copying, replacing named facets
; 433  : 		_Construct(_Loc, _Str, _Cat);
; 434  : 		}
; 435  :  #endif /* !MRTDLL || !_CRTBLD */
; 436  : 
; 437  : 	~locale() _NOEXCEPT
; 438  : 		{	// destroy the object
; 439  : 		if (_Ptr != 0)
; 440  : 			_DELETE_CRT(_Ptr->_Decref());
; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	xor	esi, esi
$LN24@use_facet:

; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN15@use_facet

; 470  : 			return (_Facptr);	// found facet or not transparent
; 471  : 		else
; 472  : 			{	// look in current locale
; 473  : 			locale::_Locimp *_Ptr = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 474  : 			return (_Id < _Ptr->_Facetcount
; 475  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 476  : 				: 0);	// no entry in current locale

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN25@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 570  : 
; 571  : 		size_t _Id = _Facet::id;
; 572  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 573  : 
; 574  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN1@use_facet
$LN25@use_facet:

; 575  : 			;	// got facet from locale
; 576  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet

; 577  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN1@use_facet
$LN4@use_facet:

; 578  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	push	DWORD PTR __Loc$[ebp]
	lea	eax, DWORD PTR __Psave$5[ebp]
	push	eax
	call	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN2@use_facet

; 579  : 
; 580  :  #if _HAS_EXCEPTIONS
; 581  : 
; 582  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
$LN29@use_facet:
$LN2@use_facet:

; 583  : 
; 584  :  #else /* _HAS_EXCEPTIONS */
; 585  : 			abort();	// lazy disallowed
; 586  :  #endif /* _HAS_EXCEPTIONS */
; 587  : 
; 588  : 		else
; 589  : 			{	// queue up lazy facet for destruction
; 590  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$5[ebp]

; 591  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 592  : 
; 593  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 594  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+4]

; 595  : 
; 596  :  #if defined(_M_CEE)
; 597  : 			_Facet_Register_m(_Pfmod);
; 598  : 
; 599  :  #else /* defined(_M_CEE) */
; 600  : 			_Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4
$LN1@use_facet:

; 601  :  #endif /* defined(_M_CEE) */
; 602  : 			}
; 603  : 
; 604  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 605  : 	_END_LOCK()
; 606  :  #endif /* _NO_LOCALES */
; 607  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$3[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 142  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 143  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

	push	esi
	mov	esi, ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN1@sentry

; 133  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN1@sentry:

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	pop	esi
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN4@sentry

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+8]
$LN4@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 100  : 			{	// lock the stream buffer, if there

	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [edi], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN5@sentry

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN5@sentry:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 123  : 			{	// construct locking and testing stream

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+4]

; 330  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+esi+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN1@sentry
	mov	ecx, DWORD PTR [eax+esi+60]
	test	ecx, ecx
	je	SHORT $LN1@sentry
	cmp	ecx, esi
	je	SHORT $LN1@sentry

; 125  : 				_Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN1@sentry:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 330  : 		return (rdstate() == goodbit);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR [edi+4], al

; 127  : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN1@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+8]
$LN1@Sentry_bas:

; 109  : 			}

	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR __Ostr$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 101  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 103  : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ
_TEXT	SEGMENT
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek, COMDAT
; _this$ = ecx

; 564  : 		{	// peek at next input element

	push	esi
	mov	esi, ecx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Peek

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN8@Peek
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN8@Peek
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN9@Peek
$LN8@Peek:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN9@Peek:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN2@Peek

; 569  : 			_Strbuf = 0;
; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	pop	esi

; 574  : 		}

	ret	0
$LN2@Peek:

; 573  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
	pop	esi

; 574  : 		}

	ret	0
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc, COMDAT
; _this$ = ecx

; 554  : 		{	// skip to next input element

	push	esi
	mov	esi, ecx

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Inc

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Inc
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN8@Inc

; 148  : 		}
; 149  : 
; 150  : 	int_type __CLR_OR_THIS_CALL sgetc()
; 151  : 		{	// get a character and don't point past it
; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());
; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN9@Inc
$LN8@Inc:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN9@Inc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN2@Inc

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	pop	esi

; 561  : 		}

	ret	0
$LN2@Inc:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
	pop	esi

; 561  : 		}

	ret	0
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::equal, COMDAT
; _this$ = ecx

; 543  : 		{	// test for equality

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx

; 544  : 		if (!_Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN12@equal

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN10@equal

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN16@equal
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN16@equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN17@equal
$LN16@equal:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN17@equal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN10@equal

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN9@equal
$LN10@equal:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN9@equal:

; 572  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN12@equal:

; 545  : 			_Peek();
; 546  : 		if (!_Right._Got)

	mov	esi, DWORD PTR __Right$[ebp]
	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN35@equal

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN33@equal

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN39@equal
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN39@equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN40@equal
$LN39@equal:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN40@equal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN33@equal

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN32@equal
$LN33@equal:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN32@equal:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN35@equal:

; 547  : 			_Right._Peek();
; 548  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)
; 549  : 			|| (_Strbuf != 0 && _Right._Strbuf != 0));

	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN55@equal
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN7@equal
$LN6@equal:
	pop	edi
	xor	al, al
	pop	esi

; 550  : 		}

	pop	ebp
	ret	4
$LN55@equal:

; 547  : 			_Right._Peek();
; 548  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)
; 549  : 			|| (_Strbuf != 0 && _Right._Strbuf != 0));

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN6@equal
$LN7@equal:
	pop	edi
	mov	al, 1
	pop	esi

; 550  : 		}

	pop	ebp
	ret	4
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 523  : 		{	// preincrement

	push	esi
	mov	esi, ecx

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@operator

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@operator
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN10@operator

; 148  : 		}
; 149  : 
; 150  : 	int_type __CLR_OR_THIS_CALL sgetc()
; 151  : 		{	// get a character and don't point past it
; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());
; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN11@operator
$LN10@operator:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN11@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN4@operator

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0

; 524  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 525  : 		if (_Strbuf == 0)
; 526  : 			_DEBUG_ERROR("istreambuf_iterator is not incrementable");
; 527  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 528  : 
; 529  : 		_Inc();
; 530  : 		return (*this);

	mov	eax, esi
	pop	esi

; 531  : 		}

	ret	0
$LN4@operator:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0

; 524  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 525  : 		if (_Strbuf == 0)
; 526  : 			_DEBUG_ERROR("istreambuf_iterator is not incrementable");
; 527  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 528  : 
; 529  : 		_Inc();
; 530  : 		return (*this);

	mov	eax, esi

; 558  : 			_Strbuf = 0, _Got = true;

	mov	BYTE PTR [esi+4], 1
	pop	esi

; 531  : 		}

	ret	0
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 505  : 		{	// return designated value

	push	esi
	mov	esi, ecx

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN27@operator

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN5@operator

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN11@operator
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN11@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN12@operator
$LN11@operator:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN12@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN5@operator

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	pop	esi

; 515  : 		}

	ret	0
$LN5@operator:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN27@operator:

; 507  : 			_Peek();
; 508  : 
; 509  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 510  : 		if (_Strbuf == 0)
; 511  : 			_DEBUG_ERROR("istreambuf_iterator is not dereferencable");
; 512  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 513  : 
; 514  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
	pop	esi

; 515  : 		}

	ret	0
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 496  : 		{	// construct from stream buffer _Sb

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Sb$[ebp]
	test	eax, eax
	mov	DWORD PTR [ecx], eax
	sete	al
	mov	BYTE PTR [ecx+4], al

; 497  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
;	COMDAT ??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
_TEXT	SEGMENT
__Phexexp$GSCopy$1$ = -136				; size = 4
$T2 = -132						; size = 4
__Punct_fac$1$ = -128					; size = 4
__Ac$GSCopy$1$ = -124					; size = 4
__Significant$1$ = -120					; size = 4
__Pg$1$ = -116						; size = 4
$T3 = -116						; size = 4
__Phex$1$ = -112					; size = 4
__Ptr$1$ = -108						; size = 4
__Bad$1$ = -102						; size = 1
__Kseparator$1$ = -101					; size = 1
__Last$GSCopy$1$ = -100					; size = 4
__Seendigit$1$ = -93					; size = 1
__Grouping$ = -92					; size = 24
__Groups$4 = -68					; size = 24
__Atoms$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Iosbase$ = 24						; size = 4
__Phexexp$ = 28						; size = 4
?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx, COMDAT

; 909  : 		{	// get hex floating-point field from [_First, _Last) into _Ac

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Last$[ebp]
	mov	edi, DWORD PTR __Iosbase$[ebp]

; 910  : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	mov	ecx, edi
	mov	ebx, DWORD PTR __Ac$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Last$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Phexexp$[ebp]
	mov	DWORD PTR __Phexexp$GSCopy$1$[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	DWORD PTR __Ac$GSCopy$1$[ebp], ebx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 910  : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ebx, eax
	mov	DWORD PTR __Punct_fac$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN86@Getffldx

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN86@Getffldx
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN86@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 911  : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[ebp]
	mov	ecx, ebx
	push	eax
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 920  : 			_USE(_Iosbase.getloc(), ctype<_Elem>);

	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	mov	ecx, edi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 920  : 			_USE(_Iosbase.getloc(), ctype<_Elem>);

	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN91@Getffldx

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN91@Getffldx
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN91@Getffldx:

; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)
; 470  : 			return (_Facptr);	// found facet or not transparent
; 471  : 		else
; 472  : 			{	// look in current locale
; 473  : 			locale::_Locimp *_Ptr = _Getgloballocale();
; 474  : 			return (_Id < _Ptr->_Facetcount
; 475  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 476  : 				: 0);	// no entry in current locale
; 477  : 			}
; 478  : 		}
; 479  : 
; 480  : 	bool operator==(const locale& _Loc) const
; 481  : 		{	// compare locales for equality
; 482  : 		return (_Ptr == _Loc._Ptr
; 483  : 			|| (name().compare("*") != 0
; 484  : 				&& name().compare(_Loc.name()) == 0));
; 485  : 		}
; 486  : 
; 487  : 	bool operator!=(const locale& _Right) const
; 488  : 		{	// test for locale inequality
; 489  : 		return (!(*this == _Right));
; 490  : 		}
; 491  : 
; 492  : 	static _MRTIMP2_PURE const locale& __CLRCALL_PURE_OR_CDECL
; 493  : 		classic();	// classic "C" locale
; 494  : 
; 495  : 	static _MRTIMP2_PURE locale __CLRCALL_PURE_OR_CDECL
; 496  : 		global(const locale&);	// current locale
; 497  : 
; 498  : 	static _MRTIMP2_PURE locale __CLRCALL_PURE_OR_CDECL
; 499  : 		empty();	// empty (transparent) locale
; 500  : 
; 501  : private:
; 502  : 	locale(_Locimp *_Ptrimp)
; 503  : 		: _Ptr(_Ptrimp)
; 504  : 		{	// construct from _Locimp pointer
; 505  : 		}
; 506  : 
; 507  :     static _MRTIMP2_PURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 508  : 		_Init(bool _Do_incref = false);	// initialize locale
; 509  : 	static _MRTIMP2_PURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 510  : 		_Getgloballocale();
; 511  : 	static _MRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL
; 512  : 		_Setgloballocale(void *);
; 513  : 
; 514  : 	bool _Badname(const _Locinfo& _Lobj)
; 515  : 		{	// test if name is "*"
; 516  : 		return (_CSTD strcmp(_Lobj._Getname(), "*") == 0);
; 517  : 		}
; 518  : 
; 519  : 	_Locimp *_Ptr;	// pointer to locale implementation object
; 520  : 	};
; 521  : 
; 522  : 		// SUPPORT TEMPLATES
; 523  : 
; 524  :  #if _NO_LOCALES
; 525  : inline _Locinfo& _Get_locinfo()
; 526  : 	{	// get reference to common locale info
; 527  : 	static _Locinfo _Lobj;
; 528  : 	return (_Lobj);
; 529  : 	}
; 530  : 
; 531  : template<class _Facet>
; 532  : 	class _Wrap_facet
; 533  : 		: public _Facet
; 534  : 	{	// makes a facet destructible and shareable
; 535  : public:
; 536  : 	_Wrap_facet()
; 537  : 		: _Facet(_Get_locinfo())
; 538  : 		{	// construct from locale object
; 539  : 		}
; 540  : 	};
; 541  :  #endif /* _NO_LOCALES */
; 542  : 
; 543  : template<class _Facet>
; 544  : 	struct _Facetptr
; 545  : 	{	// store pointer to lazy facet for use_facet
; 546  : 	__PURE_APPDOMAIN_GLOBAL static const locale::facet *_Psave;
; 547  : 	};
; 548  : 
; 549  : template<class _Facet>
; 550  : 	__PURE_APPDOMAIN_GLOBAL const locale::facet *_Facetptr<_Facet>::
; 551  : 		_Psave = 0;
; 552  : 
; 553  :   #define _ADDFAC(loc, pfac)	locale(loc, pfac)	/* add facet to locale */
; 554  : 
; 555  :   #define _USE(loc, fac)	\
; 556  : 	use_facet< fac >(loc)	/* get facet reference from locale */
; 557  : 
; 558  : template<class _Facet> inline
; 559  : 	const _Facet& __CRTDECL use_facet(const locale& _Loc)
; 560  : 
; 561  : 	{	// get facet reference from locale
; 562  :  #if _NO_LOCALES
; 563  : 	static _Wrap_facet<_Facet> _Wfac;
; 564  : 	return (*(_Facet *)&_Wfac);
; 565  : 
; 566  :  #else /* _NO_LOCALES */
; 567  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic
; 568  : 		const locale::facet *_Psave =
; 569  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 570  : 
; 571  : 		size_t _Id = _Facet::id;
; 572  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 573  : 
; 574  : 		if (_Pf != 0)
; 575  : 			;	// got facet from locale
; 576  : 		else if (_Psave != 0)
; 577  : 			_Pf = _Psave;	// lazy facet already allocated
; 578  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))
; 579  : 
; 580  :  #if _HAS_EXCEPTIONS
; 581  : 
; 582  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed
; 583  : 
; 584  :  #else /* _HAS_EXCEPTIONS */
; 585  : 			abort();	// lazy disallowed
; 586  :  #endif /* _HAS_EXCEPTIONS */
; 587  : 
; 588  : 		else
; 589  : 			{	// queue up lazy facet for destruction
; 590  : 			_Pf = _Psave;
; 591  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 592  : 
; 593  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 594  : 			_Pfmod->_Incref();
; 595  : 
; 596  :  #if defined(_M_CEE)
; 597  : 			_Facet_Register_m(_Pfmod);
; 598  : 
; 599  :  #else /* defined(_M_CEE) */
; 600  : 			_Facet_Register(_Pfmod);
; 601  :  #endif /* defined(_M_CEE) */
; 602  : 			}
; 603  : 
; 604  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast
; 605  : 	_END_LOCK()
; 606  :  #endif /* _NO_LOCALES */
; 607  : 	}	// end of use_facet body
; 608  : 
; 609  : 		// TEMPLATE FUNCTION _Getloctxt
; 610  : template<class _Elem,
; 611  : 	class _InIt> inline
; 612  : 	int __CRTDECL _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
; 613  : 		const _Elem *_Ptr)
; 614  : 	{	// find field at _Ptr that matches longest in [_First, _Last)
; 615  : 	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
; 616  : 		if (_Ptr[_Off] == _Ptr[0])
; 617  : 			++_Numfields;	// add fields with leading mark to initial count
; 618  : 	string _Str(_Numfields, '\0');	// one column counter for each field
; 619  : 
; 620  : 	int _Ans = -2;	// no candidates so far
; 621  : 	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
; 622  : 		{	// test each element against all viable fields
; 623  : 		bool _Prefix = false;	// seen at least one valid prefix
; 624  : 		size_t _Off = 0;	// offset into fields
; 625  : 		size_t _Field = 0;	// current field number
; 626  : 
; 627  : 		for (; _Field < _Numfields; ++_Field)
; 628  : 			{	// test element at _Column in field _Field
; 629  : 			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
; 630  : 				;	// find beginning of field
; 631  : 
; 632  : 			if (_Str[_Field] != '\0')
; 633  : 				_Off += _Str[_Field];	// skip tested columns in field
; 634  : 			else if (_Ptr[_Off += _Column] == _Ptr[0]
; 635  : 				|| _Ptr[_Off] == (_Elem)0)
; 636  : 				{	// matched all of field, save as possible answer
; 637  : 				_Str[_Field] = (char)(_Column < 127
; 638  : 					? _Column : 127);	// save skip count if small enough
; 639  : 				_Ans = (int)_Field;	// save answer
; 640  : 				}
; 641  : 			else if (_First == _Last || _Ptr[_Off] != *_First)
; 642  : 				_Str[_Field] = (char)(_Column < 127
; 643  : 					? _Column : 127);	// no match, just save skip count
; 644  : 			else
; 645  : 				_Prefix = true;	// still a valid prefix
; 646  : 			}
; 647  : 
; 648  : 		if (!_Prefix || _First == _Last)
; 649  : 			break;	// no pending prefixes or no input, give up
; 650  : 		}
; 651  : 	return (_Ans);	// return field number or negative value on failure
; 652  : 	}
; 653  : 
; 654  : 		// TEMPLATE FUNCTION _Maklocbyte
; 655  : #define _MAKLOCBYTE(Elem, chr, cvt) \
; 656  : 	_Maklocbyte((_Elem)chr, cvt)	/* convert Elem to char */
; 657  : 
; 658  : template<class _Elem> inline
; 659  : 	char __CRTDECL _Maklocbyte(_Elem _Char,
; 660  : 		const _Locinfo::_Cvtvec&)
; 661  : 	{	// convert _Elem to char using _Cvtvec
; 662  : 	return ((char)(unsigned char)_Char);
; 663  : 	}
; 664  : 
; 665  : template<> inline
; 666  : 	char __CRTDECL _Maklocbyte(wchar_t _Char,
; 667  : 		const _Locinfo::_Cvtvec& _Cvt)
; 668  : 	{	// convert wchar_t to char using _Cvtvec
; 669  : 	char _Byte = '\0';
; 670  : 	_Mbstinit(_Mbst1);
; 671  : 	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
; 672  : 	return (_Byte);
; 673  : 	}
; 674  : 
; 675  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 676  : template<> inline
; 677  : 	char __CRTDECL _Maklocbyte(unsigned short _Char,
; 678  : 		const _Locinfo::_Cvtvec &_Cvt)
; 679  : 	{	// convert unsigned short to char using _Cvtvec
; 680  : 	char _Byte = '\0';
; 681  : 	_Mbstinit(_Mbst1);
; 682  : 	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
; 683  : 	return (_Byte);
; 684  : 	}
; 685  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 686  : 
; 687  : 		// TEMPLATE FUNCTION _Maklocchr
; 688  : #define _MAKLOCCHR(Elem, chr, cvt) \
; 689  : 	_Maklocchr(chr, (Elem *)0, cvt)	/* convert char to Elem */
; 690  : 
; 691  : template<class _Elem> inline
; 692  : 	_Elem __CRTDECL _Maklocchr(char _Byte, _Elem *,
; 693  : 		const _Locinfo::_Cvtvec&)
; 694  : 	{	// convert char to _Elem using _Cvtvec
; 695  : 	return ((_Elem)(unsigned char)_Byte);
; 696  : 	}
; 697  : 
; 698  : template<> inline
; 699  : 	wchar_t __CRTDECL _Maklocchr(char _Byte, wchar_t *,
; 700  : 		const _Locinfo::_Cvtvec& _Cvt)
; 701  : 	{	// convert char to wchar_t using _Cvtvec
; 702  : 	wchar_t _Wc = L'\0';
; 703  : 	_Mbstinit(_Mbst1);
; 704  : 	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
; 705  : 	return (_Wc);
; 706  : 	}
; 707  : 
; 708  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 709  : template<> inline
; 710  : 	unsigned short __CRTDECL _Maklocchr(char _Byte, unsigned short *,
; 711  : 		const _Locinfo::_Cvtvec &_Cvt)
; 712  : 	{	// convert char to unsigned short using _Cvtvec
; 713  : 	unsigned short _Wc = (unsigned short)0;
; 714  : 	_Mbstinit(_Mbst1);
; 715  : 	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
; 716  : 	return (_Wc);
; 717  : 	}
; 718  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 719  : 
; 720  : 		// TEMPLATE FUNCTION _Maklocstr
; 721  : #define _MAKLOCSTR(Elem, str, cvt)	\
; 722  : 	_Maklocstr(str, (Elem *)0, cvt)	/* convert C string to Elem sequence */
; 723  : 
; 724  : template<class _Elem> inline
; 725  : 	_Elem *__CRTDECL _Maklocstr(const char *_Ptr, _Elem *,
; 726  : 		const _Locinfo::_Cvtvec&)
; 727  : 	{	// convert C string to _Elem sequence using _Cvtvec
; 728  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;
; 729  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];
; 730  : 
; 731  :  #pragma warning(push)
; 732  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 733  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
; 734  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
; 735  :  #pragma warning(pop)
; 736  : 
; 737  : 	return (_Ptrdest);
; 738  : 	}
; 739  : 
; 740  : template<> inline
; 741  : 	wchar_t *__CRTDECL _Maklocstr(const char *_Ptr, wchar_t *,
; 742  : 		const _Locinfo::_Cvtvec& _Cvt)
; 743  : 	{	// convert C string to wchar_t sequence using _Cvtvec
; 744  : 	size_t _Count, _Count1;
; 745  : 	size_t _Wchars;
; 746  : 	const char *_Ptr1;
; 747  : 	int _Bytes;
; 748  : 	wchar_t _Wc;
; 749  : 	_Mbstinit(_Mbst1);
; 750  : 
; 751  : 	_Count1 = _CSTD strlen(_Ptr) + 1;
; 752  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
; 753  : 		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
; 754  : 		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
; 755  : 			break;
; 756  : 	++_Wchars;	// count terminating nul
; 757  : 
; 758  : 	wchar_t *_Ptrdest = _NEW_CRT wchar_t[_Wchars];
; 759  : 	wchar_t *_Ptrnext = _Ptrdest;
; 760  : 	_Mbstinit(_Mbst2);
; 761  : 
; 762  :  #pragma warning(push)
; 763  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 764  : 	for (; 0 < _Wchars;
; 765  : 		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
; 766  : 		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
; 767  : 			break;
; 768  : 	*_Ptrnext = L'\0';
; 769  :  #pragma warning(pop)
; 770  : 
; 771  : 	return (_Ptrdest);
; 772  : 	}
; 773  : 
; 774  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 775  : template<> inline
; 776  : 	unsigned short *__CRTDECL _Maklocstr(const char *_Ptr, unsigned short *,
; 777  : 		const _Locinfo::_Cvtvec &_Cvt)
; 778  : 	{	// convert C string to unsigned short sequence using _Cvtvec
; 779  : 	size_t _Count, _Count1;
; 780  : 	size_t _Wchars;
; 781  : 	const char *_Ptr1;
; 782  : 	int _Bytes;
; 783  : 	unsigned short _Wc;
; 784  : 	_Mbstinit(_Mbst1);
; 785  : 
; 786  : 	_Count1 = _CSTD strlen(_Ptr) + 1;
; 787  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
; 788  : 		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
; 789  : 		if ((_Bytes =
; 790  : 			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
; 791  : 			break;
; 792  : 	++_Wchars;	// count terminating nul
; 793  : 
; 794  : 	wchar_t *_Ptrdest = _NEW_CRT wchar_t[_Wchars];
; 795  : 	wchar_t *_Ptrnext = _Ptrdest;
; 796  : 	_Mbstinit(_Mbst2);
; 797  : 	for (; 0 < _Wchars;
; 798  : 		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
; 799  : 		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
; 800  : 			break;
; 801  : 	*_Ptrnext = L'\0';
; 802  : 	return ((unsigned short *)_Ptrdest);
; 803  : 	}
; 804  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 805  : 
; 806  : 		// STRUCT codecvt_base
; 807  :  #pragma warning(push)
; 808  :  #pragma warning(disable: 4275)
; 809  : 
; 810  : class _CRTIMP2_PURE codecvt_base
; 811  : 	: public locale::facet
; 812  : 	{	// base class for codecvt
; 813  : public:
; 814  : 	enum
; 815  : 		{	// constants for different parse states
; 816  : 		ok, partial, error, noconv};
; 817  : 	typedef int result;
; 818  : 
; 819  : 	__CLR_OR_THIS_CALL codecvt_base(size_t _Refs = 0)
; 820  : 		: locale::facet(_Refs)
; 821  : 		{	// default constructor
; 822  : 		}
; 823  : 
; 824  : 	bool __CLR_OR_THIS_CALL always_noconv() const _THROW0()
; 825  : 		{	// return true if conversions never change input (from codecvt)
; 826  : 		return (do_always_noconv());
; 827  : 		}
; 828  : 
; 829  : 	int __CLR_OR_THIS_CALL max_length() const _THROW0()
; 830  : 		{	// return maximum length required for a conversion (from codecvt)
; 831  : 		return (do_max_length());
; 832  : 		}
; 833  : 
; 834  : 	int __CLR_OR_THIS_CALL encoding() const _THROW0()
; 835  : 		{	// return length of code sequence (from codecvt)
; 836  : 		return (do_encoding());
; 837  : 		}
; 838  : 
; 839  : 	__CLR_OR_THIS_CALL ~codecvt_base() _NOEXCEPT
; 840  : 		{	// destroy the object
; 841  : 		}
; 842  : 
; 843  : protected:
; 844  : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 845  : 		{	// return true if conversions never change input (from codecvt)
; 846  : 		return (false);
; 847  : 		}
; 848  : 
; 849  : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 850  : 		{	// return maximum length required for a conversion (from codecvt)
; 851  : 		return (1);
; 852  : 		}
; 853  : 
; 854  : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 855  : 		{	// return length of code sequence (from codecvt)
; 856  : 		return (1);	// -1 ==> state dependent, 0 ==> varying length
; 857  : 		}
; 858  : 	};
; 859  : 
; 860  :  #pragma warning(pop)
; 861  : 
; 862  : 		// TEMPLATE CLASS codecvt
; 863  : template<class _Elem,
; 864  : 	class _Byte,
; 865  : 	class _Statype>
; 866  : 	class codecvt
; 867  : 		: public codecvt_base
; 868  : 	{	// facet for converting between _Elem and char (_Byte) sequences
; 869  : public:
; 870  : 	typedef _Elem intern_type;
; 871  : 	typedef _Byte extern_type;
; 872  : 	typedef _Statype state_type;
; 873  : 
; 874  : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 875  : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 876  : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 877  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 878  : 		return (do_in(_State,
; 879  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 880  : 		}
; 881  : 
; 882  : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 883  : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 884  : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 885  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)
; 886  : 		return (do_out(_State,
; 887  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 888  : 		}
; 889  : 
; 890  : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 891  : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 892  : 		{	// generate bytes to return to default shift state
; 893  : 		return (do_unshift(_State, _First2, _Last2, _Mid2));
; 894  : 		}
; 895  : 
; 896  : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 897  : 		const _Byte *_Last1, size_t _Count) const
; 898  : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 899  : 		return (do_length(_State, _First1, _Last1, _Count));
; 900  : 		}
; 901  : 
; 902  : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id
; 903  : 
; 904  : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 905  : 		: codecvt_base(_Refs)
; 906  : 		{	// construct from current locale
; 907  : 		_Init(_Locinfo());
; 908  : 		}
; 909  : 
; 910  : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 911  : 		: codecvt_base(_Refs)
; 912  : 		{	// construct from specified locale
; 913  : 		_Init(_Lobj);
; 914  : 		}
; 915  : 
; 916  : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 917  : 		const locale *_Ploc = 0)
; 918  : 		{	// return locale category mask and construct standard facet
; 919  : 		if (_Ppf != 0 && *_Ppf == 0)
; 920  : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 921  : 				_Locinfo(_Ploc->c_str()));
; 922  : 		return (_X_CTYPE);
; 923  : 		}
; 924  : 
; 925  : protected:
; 926  : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 927  : 		{	// destroy the object
; 928  : 		}
; 929  : 
; 930  : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
; 931  : 		{	// initialize from _Locinfo object
; 932  : 		}
; 933  : 
; 934  : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 935  : 		{	// return true if conversions never change input (from codecvt)
; 936  : 		return (is_same<_Byte, _Elem>::value);
; 937  : 		}
; 938  : 
; 939  : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype&,
; 940  : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 941  : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 942  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 943  : 		_Mid1 = _First1, _Mid2 = _First2;
; 944  : 		if (is_same<_Byte, _Elem>::value)
; 945  : 			return (noconv);	// convert nothing
; 946  : 		else
; 947  : 			{	// types differ, copy one for one
; 948  : 			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
; 949  : 				*_Mid2 = (_Elem)*_Mid1;
; 950  : 			return (ok);
; 951  : 			}
; 952  : 		}
; 953  : 
; 954  : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype&,
; 955  : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 956  : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 957  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 958  : 		_Mid1 = _First1, _Mid2 = _First2;
; 959  : 		if (is_same<_Byte, _Elem>::value)
; 960  : 			return (noconv);	// convert nothing
; 961  : 		else
; 962  : 			{	// types differ, copy one for one
; 963  : 			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
; 964  : 				*_Mid2 = (_Byte)*_Mid1;
; 965  : 			return (ok);
; 966  : 			}
; 967  : 		}
; 968  : 
; 969  : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&,
; 970  : 		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
; 971  : 		{	// generate bytes to return to default shift state
; 972  : 		_Mid2 = _First2;
; 973  : 		return (ok);	// convert nothing
; 974  : 		}
; 975  : 
; 976  : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype&, const _Byte *_First1,
; 977  : 		const _Byte *_Last1, size_t _Count) const
; 978  : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 979  : 		return ((int)(_Count < (size_t)(_Last1 - _First1)
; 980  : 			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion
; 981  : 		}
; 982  : 	};
; 983  : 
; 984  : 		// STATIC codecvt::id OBJECT
; 985  : template<class _Elem,
; 986  : 	class _Byte,
; 987  : 	class _Statype>
; 988  : 	__PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;
; 989  : 
; 990  :  #if _HAS_CHAR16_T_LANGUAGE_SUPPORT
; 991  : 		// ENUM _Codecvt_mode
; 992  : enum _Codecvt_mode {
; 993  : 	_Consume_header = 4,
; 994  : 	_Generate_header = 2
; 995  : 	};
; 996  : 
; 997  : 		// CLASS codecvt<char16_t, char, _Mbstatet>
; 998  : template<>
; 999  : 	class _CRTIMP2_PURE codecvt<char16_t, char, _Mbstatet>
; 1000 : 	: public codecvt_base
; 1001 : 	{	// facet for converting between char16_t and UTF-8 byte sequences
; 1002 : public:
; 1003 : 	typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
; 1004 : 	typedef char16_t _Elem;
; 1005 : 	typedef char _Byte;
; 1006 : 	typedef _Mbstatet _Statype;
; 1007 : 	typedef _Elem intern_type;
; 1008 : 	typedef _Byte extern_type;
; 1009 : 	typedef _Statype state_type;
; 1010 : 
; 1011 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1012 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1013 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1014 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1015 : 		return (do_in(_State,
; 1016 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1017 : 		}
; 1018 : 
; 1019 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1020 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1021 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1022 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1023 : 		return (do_out(_State,
; 1024 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1025 : 		}
; 1026 : 
; 1027 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1028 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1029 : 		{	// generate bytes to return to default shift state
; 1030 : 		return (do_unshift(_State,
; 1031 : 			_First2, _Last2, _Mid2));
; 1032 : 		}
; 1033 : 
; 1034 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1035 : 		const _Byte *_Last1, size_t _Count) const
; 1036 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1037 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1038 : 		}
; 1039 : 
; 1040 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1041 : 
; 1042 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1043 : 		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
; 1044 : 		{	// construct from current locale
; 1045 : 		_BEGIN_LOCINFO(_Lobj)
; 1046 : 			_Init(_Lobj);
; 1047 : 		_END_LOCINFO()
; 1048 : 		}
; 1049 : 
; 1050 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1051 : 		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
; 1052 : 		{	// construct from specified locale
; 1053 : 		_Init(_Lobj);
; 1054 : 		}
; 1055 : 
; 1056 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
; 1057 : 		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
; 1058 : 		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
; 1059 : 		{	// construct from specified locale and parameters
; 1060 : 		_Init(_Lobj);
; 1061 : 		}
; 1062 : 
; 1063 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1064 : 		const locale *_Ploc = 0)
; 1065 : 		{	// return locale category mask and construct standard facet
; 1066 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1067 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1068 : 				_Locinfo(_Ploc->c_str()));
; 1069 : 		return (_X_CTYPE);
; 1070 : 		}
; 1071 : 
; 1072 : protected:
; 1073 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1074 : 		{	// destroy the object
; 1075 : 		}
; 1076 : 
; 1077 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
; 1078 : 		{	// initialize
; 1079 : 		}
; 1080 : 
; 1081 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1082 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1083 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1084 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last2)
; 1085 : 		unsigned short *_Pstate = (unsigned short *)&_State;
; 1086 : 		_Mid1 = _First1;
; 1087 : 		_Mid2 = _First2;
; 1088 : 
; 1089 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1090 : 			{	// convert a multibyte sequence
; 1091 : 			unsigned char _By = (unsigned char)*_Mid1;
; 1092 : 			unsigned long _Ch;
; 1093 : 			int _Nextra, _Nskip;
; 1094 : 
; 1095 : 			if (*_Pstate <= 1)
; 1096 : 				;	// no leftover word
; 1097 : 			else if (_By < 0x80 || 0xc0 <= _By)
; 1098 : 				return (_Mybase::error);	// not continuation byte
; 1099 : 			else
; 1100 : 				{	// deliver second half of two-word value
; 1101 : 				++_Mid1;
; 1102 : 				*_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
; 1103 : 				*_Pstate = 1;
; 1104 : 				continue;
; 1105 : 				}
; 1106 : 
; 1107 : 			if (_By < 0x80)
; 1108 : 				_Ch = _By, _Nextra = 0;
; 1109 : 			else if (_By < 0xc0)
; 1110 : 				{	// 0x80-0xdf not first byte
; 1111 : 				++_Mid1;
; 1112 : 				return (_Mybase::error);
; 1113 : 				}
; 1114 : 			else if (_By < 0xe0)
; 1115 : 				_Ch = _By & 0x1f, _Nextra = 1;
; 1116 : 			else if (_By < 0xf0)
; 1117 : 				_Ch = _By & 0x0f, _Nextra = 2;
; 1118 : 			else if (_By < 0xf8)
; 1119 : 				_Ch = _By & 0x07, _Nextra = 3;
; 1120 : 			else
; 1121 : 				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;
; 1122 : 
; 1123 : 			_Nskip = _Nextra < 3 ? 0 : 1;	// leave a byte for 2nd word
; 1124 : 			_First1 = _Mid1;	// roll back point
; 1125 : 
; 1126 : 			if (_Nextra == 0)
; 1127 : 				++_Mid1;
; 1128 : 			else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
; 1129 : 				break;	// not enough input
; 1130 : 			else
; 1131 : 				for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
; 1132 : 					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
; 1133 : 						return (_Mybase::error);	// not continuation byte
; 1134 : 					else
; 1135 : 						_Ch = _Ch << 6 | (_By & 0x3f);
; 1136 : 			if (0 < _Nskip)
; 1137 : 				_Ch <<= 6;	// get last byte on next call
; 1138 : 
; 1139 : 			if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
; 1140 : 				return (_Mybase::error);	// value too large
; 1141 : 			else if (0xffff < _Ch)
; 1142 : 				{	// deliver first half of two-word value, save second word
; 1143 : 				unsigned short _Ch0 =
; 1144 : 					(unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);
; 1145 : 
; 1146 : 				*_Mid2++ = (_Elem)_Ch0;
; 1147 : 				*_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
; 1148 : 				continue;
; 1149 : 				}
; 1150 : 
; 1151 : 			if (_Nskip == 0)
; 1152 : 				;
; 1153 : 			else if (_Mid1 == _Last1)
; 1154 : 				{	// not enough bytes, noncanonical value
; 1155 : 				_Mid1 = _First1;
; 1156 : 				break;
; 1157 : 				}
; 1158 : 			else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
; 1159 : 				return (_Mybase::error);	// not continuation byte
; 1160 : 			else
; 1161 : 				_Ch |= _By & 0x3f;	// complete noncanonical value
; 1162 : 
; 1163 : 			if (*_Pstate == 0)
; 1164 : 				{	// first time, maybe look for and consume header
; 1165 : 				*_Pstate = 1;
; 1166 : 
; 1167 : 				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
; 1168 : 					{	// drop header and retry
; 1169 : 					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
; 1170 : 						_First2, _Last2, _Mid2);
; 1171 : 
; 1172 : 					if (_Ans == _Mybase::partial)
; 1173 : 						{	// roll back header determination
; 1174 : 						*_Pstate = 0;
; 1175 : 						_Mid1 = _First1;
; 1176 : 						}
; 1177 : 					return (_Ans);
; 1178 : 					}
; 1179 : 				}
; 1180 : 
; 1181 : 			*_Mid2++ = (_Elem)_Ch;
; 1182 : 			}
; 1183 : 
; 1184 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1185 : 		}
; 1186 : 
; 1187 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1188 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1189 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1190 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1191 : 		unsigned short *_Pstate = (unsigned short *)&_State;
; 1192 : 		_Mid1 = _First1;
; 1193 : 		_Mid2 = _First2;
; 1194 : 
; 1195 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1196 : 			{	// convert and put a wide char
; 1197 : 			unsigned long _Ch;
; 1198 : 			unsigned short _Ch1 = (unsigned short)*_Mid1;
; 1199 : 			bool _Save = false;
; 1200 : 
; 1201 : 			if (1 < *_Pstate)
; 1202 : 				{	// get saved MS 11 bits from *_Pstate
; 1203 : 				if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
; 1204 : 					return (_Mybase::error);	// bad second word
; 1205 : 				_Ch = (*_Pstate << 10) | (_Ch1 - 0xdc00);
; 1206 : 				}
; 1207 : 			else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
; 1208 : 				{	// get new first word
; 1209 : 				_Ch = (_Ch1 - 0xd800 + 0x0040) << 10;
; 1210 : 				_Save = true;	// put only first byte, rest with second word
; 1211 : 				}
; 1212 : 			else
; 1213 : 				_Ch = _Ch1;	// not first word, just put it
; 1214 : 
; 1215 : 			_Byte _By;
; 1216 : 			int _Nextra;
; 1217 : 
; 1218 : 			if (_Ch < 0x0080)
; 1219 : 				_By = (_Byte)_Ch, _Nextra = 0;
; 1220 : 			else if (_Ch < 0x0800)
; 1221 : 				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
; 1222 : 			else if (_Ch < 0x10000)
; 1223 : 				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
; 1224 : 			else
; 1225 : 				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
; 1226 : 
; 1227 : 			int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;
; 1228 : 
; 1229 : 			if (_Last2 - _Mid2 < _Nput)
; 1230 : 				break;	// not enough room, even without header
; 1231 : 			else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
; 1232 : 				;	// no header to put
; 1233 : 			else if (_Last2 - _Mid2 < 3 + _Nput)
; 1234 : 				break;	// not enough room for header + output
; 1235 : 			else
; 1236 : 				{	// prepend header
; 1237 : 				*_Mid2++ = (_Byte)(unsigned char)0xef;
; 1238 : 				*_Mid2++ = (_Byte)(unsigned char)0xbb;
; 1239 : 				*_Mid2++ = (_Byte)(unsigned char)0xbf;
; 1240 : 				}
; 1241 : 
; 1242 : 			++_Mid1;
; 1243 : 			if (_Save || _Nextra < 3)
; 1244 : 				{	// put first byte of sequence, if not already put
; 1245 : 				*_Mid2++ = _By;
; 1246 : 				--_Nput;
; 1247 : 				}
; 1248 : 			for (; 0 < _Nput; --_Nput)
; 1249 : 				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
; 1250 : 
; 1251 : 			*_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
; 1252 : 			}
; 1253 : 
; 1254 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1255 : 		}
; 1256 : 
; 1257 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
; 1258 : 		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
; 1259 : 		{	// generate bytes to return to default shift state
; 1260 : 		unsigned short *_Pstate = (unsigned short *)&_State;
; 1261 : 		_Mid2 = _First2;
; 1262 : 
; 1263 : 		return (1 < *_Pstate
; 1264 : 			? _Mybase::error : _Mybase::ok);	// fail if trailing first word
; 1265 : 		}
; 1266 : 
; 1267 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 1268 : 		const _Byte *_Last1, size_t _Count) const _THROW0()
; 1269 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1270 : 		size_t _Wchars = 0;
; 1271 : 		_Statype _Mystate = _State;
; 1272 : 
; 1273 : 		for (; _Wchars < _Count && _First1 != _Last1; )
; 1274 : 			{	// convert another wide character
; 1275 : 			const _Byte *_Mid1;
; 1276 : 			_Elem *_Mid2;
; 1277 : 			_Elem _Ch;
; 1278 : 
; 1279 : 			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
; 1280 : 				&_Ch, &_Ch + 1, _Mid2))
; 1281 : 				{	// test result of single wide-char conversion
; 1282 : 			case _Mybase::noconv:
; 1283 : 				return ((int)(_Wchars + (_Last1 - _First1)));
; 1284 : 
; 1285 : 			case _Mybase::ok:
; 1286 : 				if (_Mid2 == &_Ch + 1)
; 1287 : 					++_Wchars;	// replacement do_in might not convert one
; 1288 : 				_First1 = _Mid1;
; 1289 : 				break;
; 1290 : 
; 1291 : 			default:
; 1292 : 				return ((int)_Wchars);	// error or partial
; 1293 : 				}
; 1294 : 			}
; 1295 : 
; 1296 : 		return ((int)_Wchars);
; 1297 : 		}
; 1298 : 
; 1299 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 1300 : 		{	// return true if conversions never change input
; 1301 : 		return (false);
; 1302 : 		}
; 1303 : 
; 1304 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 1305 : 		{	// return maximum length required for a conversion
; 1306 : 		return ((_Mode & _Consume_header) != 0 ? 9	// header + max input
; 1307 : 			: (_Mode & _Generate_header) != 0 ? 7	// header + max output
; 1308 : 			: 6);	// 6-byte max input sequence, no 3-byte header
; 1309 : 		}
; 1310 : 
; 1311 : 	virtual int do_encoding() const _THROW0()
; 1312 : 		{	// return length of code sequence (from codecvt)
; 1313 : 		return (0);	// 0 => varying length
; 1314 : 		}
; 1315 : 
; 1316 : private:
; 1317 : 	unsigned long _Maxcode;	// default: 0x10ffff
; 1318 : 	_Codecvt_mode _Mode;	// default: _Consume_header
; 1319 : 	};
; 1320 : 
; 1321 : 		// CLASS codecvt<char32_t, char, _Mbstatet>
; 1322 : template<>
; 1323 : 	class _CRTIMP2_PURE codecvt<char32_t, char, _Mbstatet>
; 1324 : 	: public codecvt_base
; 1325 : 	{	// facet for converting between char32_t and UTF-8 byte sequences
; 1326 : public:
; 1327 : 	typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
; 1328 : 	typedef char32_t _Elem;
; 1329 : 	typedef char _Byte;
; 1330 : 	typedef _Mbstatet _Statype;
; 1331 : 	typedef _Elem intern_type;
; 1332 : 	typedef _Byte extern_type;
; 1333 : 	typedef _Statype state_type;
; 1334 : 
; 1335 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1336 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1337 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1338 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1339 : 		return (do_in(_State,
; 1340 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1341 : 		}
; 1342 : 
; 1343 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1344 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1345 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1346 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1347 : 		return (do_out(_State,
; 1348 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1349 : 		}
; 1350 : 
; 1351 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1352 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1353 : 		{	// generate bytes to return to default shift state
; 1354 : 		return (do_unshift(_State,
; 1355 : 			_First2, _Last2, _Mid2));
; 1356 : 		}
; 1357 : 
; 1358 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1359 : 		const _Byte *_Last1, size_t _Count) const
; 1360 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1361 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1365 : 
; 1366 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1367 : 		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
; 1368 : 		{	// construct from current locale
; 1369 : 		_BEGIN_LOCINFO(_Lobj)
; 1370 : 			_Init(_Lobj);
; 1371 : 		_END_LOCINFO()
; 1372 : 		}
; 1373 : 
; 1374 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1375 : 		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
; 1376 : 		{	// construct from specified locale
; 1377 : 		_Init(_Lobj);
; 1378 : 		}
; 1379 : 
; 1380 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
; 1381 : 		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
; 1382 : 		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
; 1383 : 		{	// construct from specified locale and parameters
; 1384 : 		_Init(_Lobj);
; 1385 : 		}
; 1386 : 
; 1387 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1388 : 		const locale *_Ploc = 0)
; 1389 : 		{	// return locale category mask and construct standard facet
; 1390 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1391 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1392 : 				_Locinfo(_Ploc->c_str()));
; 1393 : 		return (_X_CTYPE);
; 1394 : 		}
; 1395 : 
; 1396 : protected:
; 1397 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1398 : 		{	// destroy the object
; 1399 : 		}
; 1400 : 
; 1401 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
; 1402 : 		{	// initialize
; 1403 : 		}
; 1404 : 
; 1405 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1406 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1407 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1408 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1409 : 		char *_Pstate = (char *)&_State;
; 1410 : 		_Mid1 = _First1;
; 1411 : 		_Mid2 = _First2;
; 1412 : 
; 1413 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1414 : 			{	// convert a multibyte sequence
; 1415 : 			unsigned char _By = (unsigned char)*_Mid1;
; 1416 : 			unsigned long _Ch;
; 1417 : 			int _Nextra;
; 1418 : 
; 1419 : 			if (_By < 0x80)
; 1420 : 				_Ch = _By, _Nextra = 0;
; 1421 : 			else if (_By < 0xc0)
; 1422 : 				{	// 0x80-0xdf not first byte
; 1423 : 				++_Mid1;
; 1424 : 				return (_Mybase::error);
; 1425 : 				}
; 1426 : 			else if (_By < 0xe0)
; 1427 : 				_Ch = _By & 0x1f, _Nextra = 1;
; 1428 : 			else if (_By < 0xf0)
; 1429 : 				_Ch = _By & 0x0f, _Nextra = 2;
; 1430 : 			else if (_By < 0xf8)
; 1431 : 				_Ch = _By & 0x07, _Nextra = 3;
; 1432 : 			else
; 1433 : 				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;
; 1434 : 
; 1435 : 			if (_Nextra == 0)
; 1436 : 				++_Mid1;
; 1437 : 			else if (_Last1 - _Mid1 < _Nextra + 1)
; 1438 : 				break;	// not enough input
; 1439 : 			else
; 1440 : 				for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
; 1441 : 					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
; 1442 : 						return (_Mybase::error);	// not continuation byte
; 1443 : 					else
; 1444 : 						_Ch = _Ch << 6 | (_By & 0x3f);
; 1445 : 
; 1446 : 			if (*_Pstate == 0)
; 1447 : 				{	// first time, maybe look for and consume header
; 1448 : 				*_Pstate = 1;
; 1449 : 
; 1450 : 				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
; 1451 : 					{	// drop header and retry
; 1452 : 					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
; 1453 : 						_First2, _Last2, _Mid2);
; 1454 : 
; 1455 : 					if (_Ans == _Mybase::partial)
; 1456 : 						{	// roll back header determination
; 1457 : 						*_Pstate = 0;
; 1458 : 						_Mid1 = _First1;
; 1459 : 						}
; 1460 : 					return (_Ans);
; 1461 : 					}
; 1462 : 				}
; 1463 : 
; 1464 : 			if (_Maxcode < _Ch)
; 1465 : 				return (_Mybase::error);	// code too large
; 1466 : 			*_Mid2++ = (_Elem)_Ch;
; 1467 : 			}
; 1468 : 
; 1469 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1470 : 		}
; 1471 : 
; 1472 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1473 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1474 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1475 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1476 : 		char *_Pstate = (char *)&_State;
; 1477 : 		_Mid1 = _First1;
; 1478 : 		_Mid2 = _First2;
; 1479 : 
; 1480 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1481 : 			{	// convert and put a wide char
; 1482 : 			_Byte _By;
; 1483 : 			int _Nextra;
; 1484 : 			unsigned long _Ch = (unsigned long)*_Mid1;
; 1485 : 
; 1486 : 			if (_Maxcode < _Ch)
; 1487 : 				return (_Mybase::error);
; 1488 : 
; 1489 : 			if (_Ch < 0x0080)
; 1490 : 				_By = (_Byte)_Ch, _Nextra = 0;
; 1491 : 			else if (_Ch < 0x0800)
; 1492 : 				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
; 1493 : 			else if (_Ch < 0x00010000)
; 1494 : 				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
; 1495 : 			else if (_Ch < 0x00200000)
; 1496 : 				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
; 1497 : 			else if (_Ch < 0x04000000)
; 1498 : 				_By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
; 1499 : 			else
; 1500 : 				_By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;
; 1501 : 
; 1502 : 			if (*_Pstate == 0)
; 1503 : 				{	// first time, maybe generate header
; 1504 : 				*_Pstate = 1;
; 1505 : 				if ((_Mode & _Generate_header) == 0)
; 1506 : 					;
; 1507 : 				else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
; 1508 : 					return (_Mybase::partial);	// not enough room for both
; 1509 : 				else
; 1510 : 					{	// prepend header
; 1511 : 					*_Mid2++ = (_Byte)(unsigned char)0xef;
; 1512 : 					*_Mid2++ = (_Byte)(unsigned char)0xbb;
; 1513 : 					*_Mid2++ = (_Byte)(unsigned char)0xbf;
; 1514 : 					}
; 1515 : 				}
; 1516 : 
; 1517 : 			if (_Last2 - _Mid2 < 1 + _Nextra)
; 1518 : 				break;	// not enough room for output
; 1519 : 
; 1520 : 			++_Mid1;
; 1521 : 			for (*_Mid2++ = _By; 0 < _Nextra; )
; 1522 : 				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
; 1523 : 			}
; 1524 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1525 : 		}
; 1526 : 
; 1527 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&,
; 1528 : 		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
; 1529 : 		{	// generate bytes to return to default shift state
; 1530 : 		_Mid2 = _First2;
; 1531 : 		return (_Mybase::ok);
; 1532 : 		}
; 1533 : 
; 1534 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 1535 : 		const _Byte *_Last1, size_t _Count) const _THROW0()
; 1536 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1537 : 		int _Wchars = 0;
; 1538 : 		_Statype _Mystate = _State;
; 1539 : 
; 1540 : 		for (; (size_t)_Wchars < _Count && _First1 != _Last1; )
; 1541 : 			{	// convert another wide character
; 1542 : 			const _Byte *_Mid1;
; 1543 : 			_Elem *_Mid2;
; 1544 : 			_Elem _Ch;
; 1545 : 
; 1546 : 			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
; 1547 : 				&_Ch, &_Ch + 1, _Mid2))
; 1548 : 				{	// test result of single wide-char conversion
; 1549 : 			case _Mybase::noconv:
; 1550 : 				return ((int)(_Wchars + (int)(_Last1 - _First1)));
; 1551 : 
; 1552 : 			case _Mybase::ok:
; 1553 : 				if (_Mid2 == &_Ch + 1)
; 1554 : 					++_Wchars;	// replacement do_in might not convert one
; 1555 : 				_First1 = _Mid1;
; 1556 : 				break;
; 1557 : 
; 1558 : 			default:
; 1559 : 				return ((int)_Wchars);	// error or partial
; 1560 : 				}
; 1561 : 			}
; 1562 : 
; 1563 : 		return ((int)_Wchars);
; 1564 : 		}
; 1565 : 
; 1566 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 1567 : 		{	// return true if conversions never change input
; 1568 : 		return (false);
; 1569 : 		}
; 1570 : 
; 1571 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 1572 : 		{	// return maximum length required for a conversion
; 1573 : 		return ((_Mode & (_Consume_header | _Generate_header)) != 0
; 1574 : 			? 9 : 6);
; 1575 : 		}
; 1576 : 
; 1577 : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 1578 : 		{	// return length of code sequence (from codecvt)
; 1579 : 		return ((_Mode & (_Consume_header | _Generate_header)) != 0
; 1580 : 			? -1 : 0);	// -1 => state dependent, 0 => varying length
; 1581 : 		}
; 1582 : 
; 1583 : private:
; 1584 : 	unsigned long _Maxcode;	// default: 0xffffffff
; 1585 : 	_Codecvt_mode _Mode;	// default: _Consume_header
; 1586 : 	};
; 1587 :  #endif /* _HAS_CHAR16_T_LANGUAGE_SUPPORT */
; 1588 : 
; 1589 : 		// CLASS codecvt<wchar_t, char, _Mbstatet>
; 1590 : template<>
; 1591 : 	class _CRTIMP2_PURE codecvt<wchar_t, char, _Mbstatet>
; 1592 : 	: public codecvt_base
; 1593 : 	{	// facet for converting between wchar_t and char (_Byte) sequences
; 1594 : public:
; 1595 : 	typedef wchar_t _Elem;
; 1596 : 	typedef char _Byte;
; 1597 : 	typedef _Mbstatet _Statype;
; 1598 : 	typedef _Elem intern_type;
; 1599 : 	typedef _Byte extern_type;
; 1600 : 	typedef _Statype state_type;
; 1601 : 
; 1602 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1603 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1604 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1605 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1606 : 		return (do_in(_State,
; 1607 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1608 : 		}
; 1609 : 
; 1610 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1611 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1612 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1613 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1614 : 		return (do_out(_State,
; 1615 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1616 : 		}
; 1617 : 
; 1618 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1619 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1620 : 		{	// generate bytes to return to default shift state
; 1621 : 		return (do_unshift(_State,
; 1622 : 			_First2, _Last2, _Mid2));
; 1623 : 		}
; 1624 : 
; 1625 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1626 : 		const _Byte *_Last1, size_t _Count) const
; 1627 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1628 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1629 : 		}
; 1630 : 
; 1631 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1632 : 
; 1633 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1634 : 		: codecvt_base(_Refs)
; 1635 : 		{	// construct from current locale
; 1636 : 		_BEGIN_LOCINFO(_Lobj)
; 1637 : 			_Init(_Lobj);
; 1638 : 		_END_LOCINFO()
; 1639 : 		}
; 1640 : 
; 1641 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1642 : 		: codecvt_base(_Refs)
; 1643 : 		{	// construct from specified locale
; 1644 : 		_Init(_Lobj);
; 1645 : 		}
; 1646 : 
; 1647 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1648 : 		const locale *_Ploc = 0)
; 1649 : 		{	// return locale category mask and construct standard facet
; 1650 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1651 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1652 : 				_Locinfo(_Ploc->c_str()));
; 1653 : 		return (_X_CTYPE);
; 1654 : 		}
; 1655 : 
; 1656 : protected:
; 1657 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1658 : 		{	// destroy the object
; 1659 : 		}
; 1660 : 
; 1661 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 1662 : 		{	// initialize from _Lobj
; 1663 : 		_Cvt = _Lobj._Getcvt();
; 1664 : 		}
; 1665 : 
; 1666 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1667 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1668 : 			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1669 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1670 : 		_DEBUG_RANGE(_First1, _Last1);
; 1671 : 		_DEBUG_RANGE(_First2, _Last2);
; 1672 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1673 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1674 : 		int _Bytes;
; 1675 : 
; 1676 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1677 : 			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
; 1678 : 				&_State, &_Cvt))
; 1679 : 			{	// test result of locale-specific mbrtowc call
; 1680 : 			case -2:	// partial conversion
; 1681 : 				_Mid1 = _Last1;
; 1682 : 				return (_Ans);
; 1683 : 
; 1684 : 			case -1:	// failed conversion
; 1685 : 				return (error);
; 1686 : 
; 1687 : 			case 0:	// may have converted null character
; 1688 : 				if (*_Mid2 == (_Elem)0)
; 1689 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 1690 : 				// fall through
; 1691 : 
; 1692 : 			default:	// converted _Bytes bytes to a wchar_t
; 1693 : 				if (_Bytes == -3)
; 1694 : 					_Bytes = 0;	// wchar_t generated from state info
; 1695 : 				_Mid1 += _Bytes;
; 1696 : 				++_Mid2;
; 1697 : 				_Ans = ok;
; 1698 : 			}
; 1699 : 		return (_Ans);
; 1700 : 		}
; 1701 : 
; 1702 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1703 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1704 : 			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1705 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1706 : 		_DEBUG_RANGE(_First1, _Last1);
; 1707 : 		_DEBUG_RANGE(_First2, _Last2);
; 1708 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1709 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1710 : 		int _Bytes;
; 1711 : 
; 1712 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1713 : 			if ((int)MB_CUR_MAX <= _Last2 - _Mid2)
; 1714 : 				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
; 1715 : 					&_State, &_Cvt)) < 0)
; 1716 : 					return (error);	// locale-specific wcrtomb failed
; 1717 : 				else
; 1718 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1719 : 			else
; 1720 : 				{	// destination too small, convert into buffer
; 1721 : 				_Byte _Buf[MB_LEN_MAX];
; 1722 : 				_Statype _Stsave = _State;
; 1723 : 
; 1724 : 				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
; 1725 : 					&_State, &_Cvt)) < 0)
; 1726 : 					return (error);	// locale-specific wcrtomb failed
; 1727 : 				else if (_Last2 - _Mid2 < _Bytes)
; 1728 : 					{	// converted too many, roll back and return previous
; 1729 : 					_State = _Stsave;
; 1730 : 					return (_Ans);
; 1731 : 					}
; 1732 : 				else
; 1733 : 					{	// copy converted bytes from buffer
; 1734 : 					_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1735 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1736 : 					}
; 1737 : 				}
; 1738 : 		return (_Ans);
; 1739 : 		}
; 1740 : 
; 1741 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
; 1742 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1743 : 		{	// generate bytes to return to default shift state
; 1744 : 		_DEBUG_RANGE(_First2, _Last2);
; 1745 : 		_Mid2 = _First2;
; 1746 : 		result _Ans = ok;
; 1747 : 		int _Bytes;
; 1748 : 		_Byte _Buf[MB_LEN_MAX];
; 1749 : 		_Statype _Stsave = _State;
; 1750 : 
; 1751 : 		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
; 1752 : 			_Ans = error;	// locale-specific wcrtomb failed
; 1753 : 		else if (_Last2 - _Mid2 < --_Bytes)
; 1754 : 			{	// converted too many, roll back and return
; 1755 : 			_State = _Stsave;
; 1756 : 			_Ans = partial;
; 1757 : 			}
; 1758 : 		else if (0 < _Bytes)
; 1759 : 			{	// copy converted bytes from buffer
; 1760 : 			_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1761 : 			_Mid2 += _Bytes;
; 1762 : 			}
; 1763 : 		return (_Ans);
; 1764 : 		}
; 1765 : 
; 1766 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 1767 : 		const _Byte *_Last1, size_t _Count) const
; 1768 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1769 : 		_DEBUG_RANGE(_First1, _Last1);
; 1770 : 		int _Wchars;
; 1771 : 		const _Byte *_Mid1;
; 1772 : 		_Statype _Mystate = _State;
; 1773 : 
; 1774 : 		for (_Wchars = 0, _Mid1 = _First1;
; 1775 : 			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
; 1776 : 			{	// convert another wchar_t
; 1777 : 			int _Bytes;
; 1778 : 			_Elem _Ch;
; 1779 : 
; 1780 : 			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
; 1781 : 				&_Mystate, &_Cvt))
; 1782 : 				{	// test result of locale-specific mbrtowc call
; 1783 : 			case -2:	// partial conversion
; 1784 : 				return (_Wchars);
; 1785 : 
; 1786 : 			case -1:	// failed conversion
; 1787 : 				return (_Wchars);
; 1788 : 
; 1789 : 			case 0:	// may have converted null character
; 1790 : 				if (_Ch == (_Elem)0)
; 1791 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 1792 : 				// fall through
; 1793 : 
; 1794 : 			default:	// converted _Bytes bytes to a wchar_t
; 1795 : 				if (_Bytes == -3)
; 1796 : 					_Bytes = 0;	// wchar_t generated from state info
; 1797 : 				_Mid1 += _Bytes;
; 1798 : 				++_Wchars;
; 1799 : 				}
; 1800 : 			}
; 1801 : 		return (_Wchars);
; 1802 : 		}
; 1803 : 
; 1804 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 1805 : 		{	// return true if conversions never change input
; 1806 : 		return (false);
; 1807 : 		}
; 1808 : 
; 1809 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 1810 : 		{	// return maximum length required for a conversion (from codecvt)
; 1811 : 		return (MB_LEN_MAX);
; 1812 : 		}
; 1813 : 
; 1814 : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 1815 : 		{	// return length of code sequence (from codecvt)
; 1816 : 		return (0);	// 0 => varying length
; 1817 : 		}
; 1818 : 
; 1819 : private:
; 1820 : 	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
; 1821 : 	};
; 1822 : 
; 1823 :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 1824 : 		// CLASS codecvt<unsigned short, char, _Mbstatet>
; 1825 : template<>
; 1826 : 	class _CRTIMP2_PURE codecvt<unsigned short, char, _Mbstatet>
; 1827 : 	: public codecvt_base
; 1828 : 	{	// facet for converting between unsigned short and char sequences
; 1829 : public:
; 1830 : 	typedef unsigned short _Elem;
; 1831 : 	typedef char _Byte;
; 1832 : 	typedef _Mbstatet _Statype;
; 1833 : 	typedef _Elem intern_type;
; 1834 : 	typedef _Byte extern_type;
; 1835 : 	typedef _Statype state_type;
; 1836 : 
; 1837 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1838 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1839 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1840 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1841 : 		return (do_in(_State,
; 1842 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1843 : 		}
; 1844 : 
; 1845 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1846 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1847 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1848 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1849 : 		return (do_out(_State,
; 1850 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1851 : 		}
; 1852 : 
; 1853 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1854 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1855 : 		{	// generate bytes to return to default shift state
; 1856 : 		return (do_unshift(_State,
; 1857 : 			_First2, _Last2, _Mid2));
; 1858 : 		}
; 1859 : 
; 1860 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1861 : 		const _Byte *_Last1, size_t _Count) const
; 1862 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1863 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1864 : 		}
; 1865 : 
; 1866 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1867 : 
; 1868 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1869 : 		: codecvt_base(_Refs)
; 1870 : 		{	// construct from current locale
; 1871 : 		_BEGIN_LOCINFO(_Lobj)
; 1872 : 			_Init(_Lobj);
; 1873 : 		_END_LOCINFO()
; 1874 : 		}
; 1875 : 
; 1876 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1877 : 		: codecvt_base(_Refs)
; 1878 : 		{	// construct from specified locale
; 1879 : 		_Init(_Lobj);
; 1880 : 		}
; 1881 : 
; 1882 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1883 : 		const locale *_Ploc = 0)
; 1884 : 		{	// return locale category mask and construct standard facet
; 1885 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1886 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1887 : 				_Locinfo(_Ploc->c_str()));
; 1888 : 		return (_X_CTYPE);
; 1889 : 		}
; 1890 : 
; 1891 : protected:
; 1892 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1893 : 		{	// destroy the object
; 1894 : 		}
; 1895 : 
; 1896 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 1897 : 		{	// initialize from _Lobj
; 1898 : 		_Cvt = _Lobj._Getcvt();
; 1899 : 		}
; 1900 : 
; 1901 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1902 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1903 : 			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1904 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1905 : 		_DEBUG_RANGE(_First1, _Last1);
; 1906 : 		_DEBUG_RANGE(_First2, _Last2);
; 1907 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1908 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1909 : 		int _Bytes;
; 1910 : 
; 1911 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1912 : 			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
; 1913 : 				&_State, &_Cvt))
; 1914 : 			{	// test result of locale-specific mbrtowc call
; 1915 : 			case -2:	// partial conversion
; 1916 : 				_Mid1 = _Last1;
; 1917 : 				return (_Ans);
; 1918 : 
; 1919 : 			case -1:	// failed conversion
; 1920 : 				return (error);
; 1921 : 
; 1922 : 			case 0:	// may have converted null character
; 1923 : 				if (*_Mid2 == (_Elem)0)
; 1924 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 1925 : 				// fall through
; 1926 : 
; 1927 : 			default:	// converted _Bytes bytes to an unsigned short
; 1928 : 				if (_Bytes == -3)
; 1929 : 					_Bytes = 0;	// wchar_t generated from state info
; 1930 : 				_Mid1 += _Bytes;
; 1931 : 				++_Mid2;
; 1932 : 				_Ans = ok;
; 1933 : 			}
; 1934 : 		return (_Ans);
; 1935 : 		}
; 1936 : 
; 1937 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1938 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1939 : 			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1940 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1941 : 		_DEBUG_RANGE(_First1, _Last1);
; 1942 : 		_DEBUG_RANGE(_First2, _Last2);
; 1943 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1944 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1945 : 		int _Bytes;
; 1946 : 
; 1947 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1948 : 			if ((int)MB_CUR_MAX <= _Last2 - _Mid2)
; 1949 : 				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
; 1950 : 					&_State, &_Cvt)) < 0)
; 1951 : 					return (error);	// locale-specific wcrtomb failed
; 1952 : 				else
; 1953 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1954 : 			else
; 1955 : 				{	// destination too small, convert into buffer
; 1956 : 				_Byte _Buf[MB_LEN_MAX];
; 1957 : 				_Statype _Stsave = _State;
; 1958 : 
; 1959 : 				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
; 1960 : 					&_State, &_Cvt)) < 0)
; 1961 : 					return (error);	// locale-specific wcrtomb failed
; 1962 : 				else if (_Last2 - _Mid2 < _Bytes)
; 1963 : 					{	// converted too many, roll back and return previous
; 1964 : 					_State = _Stsave;
; 1965 : 					return (_Ans);
; 1966 : 					}
; 1967 : 				else
; 1968 : 					{	// copy converted bytes from buffer
; 1969 : 					_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1970 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1971 : 					}
; 1972 : 				}
; 1973 : 		return (_Ans);
; 1974 : 		}
; 1975 : 
; 1976 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
; 1977 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1978 : 		{	// generate bytes to return to default shift state
; 1979 : 		_DEBUG_RANGE(_First2, _Last2);
; 1980 : 		_Mid2 = _First2;
; 1981 : 		result _Ans = ok;
; 1982 : 		int _Bytes;
; 1983 : 		_Byte _Buf[MB_LEN_MAX];
; 1984 : 		_Statype _Stsave = _State;
; 1985 : 
; 1986 : 		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
; 1987 : 			_Ans = error;	// locale-specific wcrtomb failed
; 1988 : 		else if (_Last2 - _Mid2 < --_Bytes)
; 1989 : 			{	// converted too many, roll back and return
; 1990 : 			_State = _Stsave;
; 1991 : 			_Ans = partial;
; 1992 : 			}
; 1993 : 		else if (0 < _Bytes)
; 1994 : 			{	// copy converted bytes from buffer
; 1995 : 			_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1996 : 			_Mid2 += _Bytes;
; 1997 : 			}
; 1998 : 		return (_Ans);
; 1999 : 		}
; 2000 : 
; 2001 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 2002 : 		const _Byte *_Last1, size_t _Count) const
; 2003 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 2004 : 		_DEBUG_RANGE(_First1, _Last1);
; 2005 : 		int _Wchars;
; 2006 : 		const _Byte *_Mid1;
; 2007 : 		_Statype _Mystate = _State;
; 2008 : 
; 2009 : 		for (_Wchars = 0, _Mid1 = _First1;
; 2010 : 			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
; 2011 : 			{	// convert another unsigned char
; 2012 : 			int _Bytes;
; 2013 : 			_Elem _Ch;
; 2014 : 
; 2015 : 			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
; 2016 : 				&_Mystate, &_Cvt))
; 2017 : 				{	// test result of locale-specific mbrtowc call
; 2018 : 			case -2:	// partial conversion
; 2019 : 				return (_Wchars);
; 2020 : 
; 2021 : 			case -1:	// failed conversion
; 2022 : 				return (_Wchars);
; 2023 : 
; 2024 : 			case 0:	// may have converted null character
; 2025 : 				if (_Ch == (_Elem)0)
; 2026 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 2027 : 				// fall through
; 2028 : 
; 2029 : 			default:	// converted _Bytes bytes to an unsigned char
; 2030 : 				if (_Bytes == -3)
; 2031 : 					_Bytes = 0;	// wchar_t generated from state info
; 2032 : 				_Mid1 += _Bytes;
; 2033 : 				++_Wchars;
; 2034 : 				}
; 2035 : 			}
; 2036 : 		return (_Wchars);
; 2037 : 		}
; 2038 : 
; 2039 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 2040 : 		{	// return true if conversions never change input
; 2041 : 		return (false);
; 2042 : 		}
; 2043 : 
; 2044 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 2045 : 		{	// return maximum length required for a conversion (from codecvt)
; 2046 : 		return (MB_LEN_MAX);
; 2047 : 		}
; 2048 : 
; 2049 : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 2050 : 		{	// return length of code sequence (from codecvt)
; 2051 : 		return (0);	// 0 => varying length
; 2052 : 		}
; 2053 : 
; 2054 : private:
; 2055 : 	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
; 2056 : 	};
; 2057 :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 2058 : 
; 2059 : 		// TEMPLATE CLASS codecvt_byname
; 2060 : template<class _Elem,
; 2061 : 	class _Byte,
; 2062 : 	class _Statype>
; 2063 : 	class codecvt_byname
; 2064 : 		: public codecvt<_Elem, _Byte, _Statype>
; 2065 : 	{	// codecvt for named locale
; 2066 : public:
; 2067 : 	explicit __CLR_OR_THIS_CALL codecvt_byname(const char *_Locname, size_t _Refs = 0)
; 2068 : 		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
; 2069 : 		{	// construct for named locale
; 2070 : 		}
; 2071 : 
; 2072 : 	explicit __CLR_OR_THIS_CALL codecvt_byname(const string& _Str, size_t _Refs = 0)
; 2073 : 		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
; 2074 : 		{	// construct for named locale
; 2075 : 		}
; 2076 : 
; 2077 : protected:
; 2078 : 	virtual __CLR_OR_THIS_CALL ~codecvt_byname() _NOEXCEPT
; 2079 : 		{	// destroy the object
; 2080 : 		}
; 2081 : 	};
; 2082 : 
; 2083 : 		// STRUCT ctype_base
; 2084 :  #pragma warning(push)
; 2085 :  #pragma warning(disable: 4275)
; 2086 : 
; 2087 : struct _CRTIMP2_PURE ctype_base
; 2088 : 	: public locale::facet
; 2089 : 	{	// base for ctype
; 2090 : 	enum
; 2091 : 		{	// constants for character classifications
; 2092 : 		alnum = _DI | _LO | _UP | _XA, alpha = _LO | _UP | _XA,
; 2093 : 		cntrl = _BB, digit = _DI, graph = _DI | _LO | _PU | _UP | _XA,
; 2094 : 		lower = _LO, print = _DI | _LO | _PU | _SP | _UP | _XA | _XD,
; 2095 : 		punct = _PU, space = _CN | _SP | _XS, upper = _UP,
; 2096 : 		xdigit = _XD, blank = _CN | _SP | _XS | _XB};
; 2097 : 	typedef short mask;	// to match <ctype.h>
; 2098 : 
; 2099 : 	__CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0)
; 2100 : 		: locale::facet(_Refs)
; 2101 : 		{	// default constructor
; 2102 : 		}
; 2103 : 
; 2104 : 	__CLR_OR_THIS_CALL ~ctype_base() _NOEXCEPT
; 2105 : 		{	// destroy the object
; 2106 : 		}
; 2107 : 	};
; 2108 : 
; 2109 :  #pragma warning(pop)
; 2110 : 
; 2111 : 		// TEMPLATE CLASS ctype
; 2112 : template<class _Elem>
; 2113 : 	class ctype
; 2114 : 		: public ctype_base
; 2115 : 	{	// facet for classifying elements, converting cases
; 2116 : public:
; 2117 : 	typedef _Elem char_type;
; 2118 : 
; 2119 : 	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
; 2120 : 		{	// test if element fits any mask classifications
; 2121 : 		return (do_is(_Maskval, _Ch));
; 2122 : 		}
; 2123 : 
; 2124 : 	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First, const _Elem *_Last,
; 2125 : 		mask *_Dest) const
; 2126 : 		{	// get mask sequence for elements in [_First, _Last)
; 2127 : 		return (do_is(_First, _Last, _Dest));
; 2128 : 		}
; 2129 : 
; 2130 : 	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem *_First,
; 2131 : 		const _Elem *_Last) const
; 2132 : 		{	// find first in [_First, _Last) that fits mask classification
; 2133 : 		return (do_scan_is(_Maskval, _First, _Last));
; 2134 : 		}
; 2135 : 
; 2136 : 	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem *_First,
; 2137 : 		const _Elem *_Last) const
; 2138 : 		{	// find first in [_First, _Last) not fitting mask classification
; 2139 : 		return (do_scan_not(_Maskval, _First, _Last));
; 2140 : 		}
; 2141 : 
; 2142 : 	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
; 2143 : 		{	// convert element to lower case
; 2144 : 		return (do_tolower(_Ch));
; 2145 : 		}
; 2146 : 
; 2147 : 	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
; 2148 : 		{	// convert [_First, _Last) in place to lower case
; 2149 : 		return (do_tolower(_First, _Last));
; 2150 : 		}
; 2151 : 
; 2152 : 	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
; 2153 : 		{	// convert element to upper case
; 2154 : 		return (do_toupper(_Ch));
; 2155 : 		}
; 2156 : 
; 2157 : 	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
; 2158 : 		{	// convert [_First, _Last) in place to upper case
; 2159 : 		return (do_toupper(_First, _Last));
; 2160 : 		}
; 2161 : 
; 2162 : 	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
; 2163 : 		{	// widen char
; 2164 : 		return (do_widen(_Byte));
; 2165 : 		}
; 2166 : 
; 2167 : 	const char *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
; 2168 : 		_Elem *_Dest) const
; 2169 : 		{	// widen chars in [_First, _Last)
; 2170 : 		return (do_widen(_First, _Last, _Dest));
; 2171 : 		}
; 2172 : 
; 2173 : 	char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
; 2174 : 		{	// narrow element to char
; 2175 : 		return (do_narrow(_Ch, _Dflt));
; 2176 : 		}
; 2177 : 
; 2178 : 	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
; 2179 : 		char _Dflt, char *_Dest) const
; 2180 : 		{	// narrow elements in [_First, _Last) to chars
; 2181 : 		return (do_narrow(_First, _Last, _Dflt, _Dest));
; 2182 : 		}
; 2183 : 
; 2184 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 2185 : 
; 2186 : 	explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0)
; 2187 : 		: ctype_base(_Refs)
; 2188 : 		{	// construct from current locale
; 2189 : 		_BEGIN_LOCINFO(_Lobj)
; 2190 : 			_Init(_Lobj);
; 2191 : 		_END_LOCINFO()
; 2192 : 		}
; 2193 : 
; 2194 : 	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
; 2195 : 		: ctype_base(_Refs)
; 2196 : 		{	// construct from specified locale
; 2197 : 		_Init(_Lobj);
; 2198 : 		}
; 2199 : 
; 2200 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 2201 : 		const locale *_Ploc = 0)
; 2202 : 		{	// return locale category mask and construct standard facet
; 2203 : 		if (_Ppf != 0 && *_Ppf == 0)
; 2204 : 			*_Ppf = _NEW_CRT ctype<_Elem>(
; 2205 : 				_Locinfo(_Ploc->c_str()));
; 2206 : 		return (_X_CTYPE);
; 2207 : 		}
; 2208 : 
; 2209 : protected:
; 2210 : 	virtual __CLR_OR_THIS_CALL ~ctype() _NOEXCEPT
; 2211 : 		{	// destroy the object
; 2212 : 		if (_Ctype._Delfl)
; 2213 : 			free((void *)_Ctype._Table);
; 2214 : 
; 2215 : 		free((void *)_Ctype._LocaleName);
; 2216 : 		}
; 2217 : 
; 2218 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 2219 : 		{	// initialize from _Lobj
; 2220 : 		_Ctype = _Lobj._Getctype();
; 2221 : 		_Cvt = _Lobj._Getcvt();
; 2222 : 		}
; 2223 : 
; 2224 : 	virtual bool __CLR_OR_THIS_CALL do_is(mask _Maskval, _Elem _Ch) const
; 2225 : 		{	// test if element fits any mask classifications
; 2226 : 		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
; 2227 : 			& _Maskval) != 0);
; 2228 : 		}
; 2229 : 
; 2230 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_is(const _Elem *_First, const _Elem *_Last,
; 2231 : 		mask *_Dest) const
; 2232 : 		{	// get mask sequence for elements in [_First, _Last)
; 2233 : 		_DEBUG_RANGE(_First, _Last);
; 2234 : 		_DEBUG_POINTER(_Dest);
; 2235 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2236 : 			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
; 2237 : 		return (_First);
; 2238 : 		}
; 2239 : 
; 2240 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_is(mask _Maskval,
; 2241 : 		const _Elem *_First, const _Elem *_Last) const
; 2242 : 		{	// find first in [_First, _Last) that fits mask classification
; 2243 : 		_DEBUG_RANGE(_First, _Last);
; 2244 : 		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
; 2245 : 			;
; 2246 : 		return (_First);
; 2247 : 		}
; 2248 : 
; 2249 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_not(mask _Maskval,
; 2250 : 		const _Elem *_First, const _Elem *_Last) const
; 2251 : 		{	// find first in [_First, _Last) not fitting mask classification
; 2252 : 		_DEBUG_RANGE(_First, _Last);
; 2253 : 		for (; _First != _Last && is(_Maskval, *_First); ++_First)
; 2254 : 			;
; 2255 : 		return (_First);
; 2256 : 		}
; 2257 : 
; 2258 : 	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
; 2259 : 		{	// convert element to lower case
; 2260 : 		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
; 2261 : 		if (_Byte == '\0')
; 2262 : 			return (_Ch);
; 2263 : 		else
; 2264 : 			return (widen((char)_Tolower(_Byte, &_Ctype)));
; 2265 : 		}
; 2266 : 
; 2267 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First,
; 2268 : 		const _Elem *_Last) const
; 2269 : 		{	// convert [_First, _Last) in place to lower case
; 2270 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2271 : 		for (; _First != _Last; ++_First)
; 2272 : 			{	// convert *_First to lower case
; 2273 : 			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
; 2274 : 			if (_Byte != '\0')
; 2275 : 				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
; 2276 : 			}
; 2277 : 		return ((const _Elem *)_First);
; 2278 : 		}
; 2279 : 
; 2280 : 	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
; 2281 : 		{	// convert element to upper case
; 2282 : 		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
; 2283 : 		if (_Byte == '\0')
; 2284 : 			return (_Ch);
; 2285 : 		else
; 2286 : 			return (widen((char)_Toupper(_Byte, &_Ctype)));
; 2287 : 		}
; 2288 : 
; 2289 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First,
; 2290 : 		const _Elem *_Last) const
; 2291 : 		{	// convert [_First, _Last) in place to upper case
; 2292 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2293 : 		for (; _First != _Last; ++_First)
; 2294 : 			{	// convert *_First to upper case
; 2295 : 			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
; 2296 : 			if (_Byte != '\0')
; 2297 : 				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
; 2298 : 			}
; 2299 : 		return ((const _Elem *)_First);
; 2300 : 		}
; 2301 : 
; 2302 : 	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
; 2303 : 		{	// widen char
; 2304 : 		return (_MAKLOCCHR(_Elem, _Byte, _Cvt));
; 2305 : 		}
; 2306 : 
; 2307 : 	virtual const char *__CLR_OR_THIS_CALL do_widen(const char *_First,
; 2308 : 		const char *_Last, _Elem *_Dest) const
; 2309 : 		{	// widen chars in [_First, _Last)
; 2310 : 		_DEBUG_RANGE(_First, _Last);
; 2311 : 		_DEBUG_POINTER(_Dest);
; 2312 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2313 : 			*_Dest = _MAKLOCCHR(_Elem, *_First, _Cvt);
; 2314 : 		return (_First);
; 2315 : 		}
; 2316 : 
; 2317 : 	char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const
; 2318 : 		{	// narrow element to char
; 2319 : 		char _Byte;
; 2320 : 		if (_Ch == (_Elem)0)
; 2321 : 			return ('\0');
; 2322 : 		else if ((_Byte = _MAKLOCBYTE(_Elem, _Ch, _Cvt)) == '\0')
; 2323 : 			return (_Dflt);
; 2324 : 		else
; 2325 : 			return (_Byte);
; 2326 : 		}
; 2327 : 
; 2328 : 	virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const
; 2329 : 		{	// narrow element to char
; 2330 : 		return (_Donarrow(_Ch, _Dflt));
; 2331 : 		}
; 2332 : 
; 2333 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
; 2334 : 		const _Elem *_Last, char _Dflt, char *_Dest) const
; 2335 : 		{	// narrow elements in [_First, _Last) to chars
; 2336 : 		_DEBUG_RANGE(_First, _Last);
; 2337 : 		_DEBUG_POINTER(_Dest);
; 2338 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2339 : 			*_Dest = _Donarrow(*_First, _Dflt);
; 2340 : 		return (_First);
; 2341 : 		}
; 2342 : 
; 2343 : private:
; 2344 : 	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
; 2345 : 	_Locinfo::_Cvtvec _Cvt;		// conversion information
; 2346 : 	};
; 2347 : 
; 2348 : 		// STATIC ctype::id OBJECT
; 2349 : template<class _Elem>
; 2350 : 	locale::id ctype<_Elem>::id;
; 2351 : 
; 2352 : 		// CLASS ctype<char>
; 2353 : template<>
; 2354 : 	class _CRTIMP2_PURE ctype<char>
; 2355 : 	: public ctype_base
; 2356 : 	{	// facet for classifying char elements, converting cases
; 2357 : 	typedef ctype<char> _Myt;
; 2358 : 
; 2359 : public:
; 2360 : 	typedef char _Elem;
; 2361 : 	typedef _Elem char_type;
; 2362 : 
; 2363 : 	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
; 2364 : 		{	// test if element fits any mask classifications
; 2365 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
; 2366 : 		}
; 2367 : 
; 2368 : 	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First,
; 2369 : 		const _Elem *_Last, mask *_Dest) const
; 2370 : 		{	// get mask sequence for elements in [_First, _Last)
; 2371 : 		_DEBUG_RANGE(_First, _Last);
; 2372 : 		_DEBUG_POINTER(_Dest);
; 2373 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2374 : 			*_Dest = _Ctype._Table[(unsigned char)*_First];
; 2375 : 		return (_First);
; 2376 : 		}
; 2377 : 
; 2378 : 	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval,
; 2379 : 		const _Elem *_First, const _Elem *_Last) const
; 2380 : 		{	// find first in [_First, _Last) that fits mask classification
; 2381 : 		_DEBUG_RANGE(_First, _Last);
; 2382 : 		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
; 2383 : 			;
; 2384 : 		return (_First);
; 2385 : 		}
; 2386 : 
; 2387 : 	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval,
; 2388 : 		const _Elem *_First, const _Elem *_Last) const
; 2389 : 		{	// find first in [_First, _Last) not fitting mask classification
; 2390 : 		_DEBUG_RANGE(_First, _Last);
; 2391 : 		for (; _First != _Last && is(_Maskval, *_First); ++_First)
; 2392 : 			;
; 2393 : 		return (_First);
; 2394 : 		}
; 2395 : 
; 2396 : 	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
; 2397 : 		{	// convert element to lower case
; 2398 : 		return (do_tolower(_Ch));
; 2399 : 		}
; 2400 : 
; 2401 : 	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
; 2402 : 		{	// convert [_First, _Last) in place to lower case
; 2403 : 		return (do_tolower(_First, _Last));
; 2404 : 		}
; 2405 : 
; 2406 : 	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
; 2407 : 		{	// convert element to upper case
; 2408 : 		return (do_toupper(_Ch));
; 2409 : 		}
; 2410 : 
; 2411 : 	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
; 2412 : 		{	// convert [_First, _Last) in place to upper case
; 2413 : 		return (do_toupper(_First, _Last));
; 2414 : 		}
; 2415 : 
; 2416 : 	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
; 2417 : 		{	// widen char
; 2418 : 		return (do_widen(_Byte));
; 2419 : 		}
; 2420 : 
; 2421 : 	const _Elem *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
; 2422 : 		_Elem *_Dest) const
; 2423 : 		{	// widen chars in [_First, _Last)
; 2424 : 		return (do_widen(_First, _Last, _Dest));

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR __Atoms$[ebp]
	push	ecx
	push	OFFSET ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB+28
	push	OFFSET ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx'::`2'::_Src
	mov	ecx, edi
	call	DWORD PTR [eax+28]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 923  : 		char *_Ptr = _Ac;

	mov	edi, DWORD PTR __Ac$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 923  : 		char *_Ptr = _Ac;

	mov	ebx, edi

; 924  : 		bool _Bad = false;

	mov	BYTE PTR __Bad$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 927  : 		if (_First == _Last)

	test	al, al
	jne	SHORT $LN70@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	SHORT $LN103@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN101@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN107@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN107@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN108@Getffldx
$LN107@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN108@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN101@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN100@Getffldx
$LN101@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN100@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN103@Getffldx:

; 514  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 930  : 			*_Ptr++ = '+', ++_First;	// gather plus sign

	mov	ecx, esi
	cmp	al, BYTE PTR __Atoms$[ebp+23]
	jne	SHORT $LN72@Getffldx
	mov	BYTE PTR [edi], 43			; 0000002bH
	jmp	SHORT $LN1097@Getffldx
$LN72@Getffldx:

; 931  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	cmp	al, BYTE PTR __Atoms$[ebp+22]
	jne	SHORT $LN70@Getffldx

; 932  : 			*_Ptr++ = '-', ++_First;	// gather minus sign

	mov	BYTE PTR [edi], 45			; 0000002dH
	mov	ecx, esi
$LN1097@Getffldx:
	lea	ebx, DWORD PTR [edi+1]
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN70@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 934  : 		*_Ptr++ = '0';

	mov	WORD PTR [ebx], 30768			; 00007830H

; 936  : 
; 937  : 		bool _Seendigit = false;	// seen a digit in input
; 938  : 		int _Significant = 0;	// number of significant digits

	xor	edi, edi
	add	ebx, 2
	mov	BYTE PTR __Seendigit$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 935  : 		*_Ptr++ = 'x';

	mov	DWORD PTR __Ptr$1$[ebp], ebx

; 936  : 
; 937  : 		bool _Seendigit = false;	// seen a digit in input
; 938  : 		int _Significant = 0;	// number of significant digits

	mov	DWORD PTR __Significant$1$[ebp], edi

; 939  : 		int _Phex = 0;	// power of 10 multiplier

	mov	DWORD PTR __Phex$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 941  : 		if (_First == _Last || *_First != _Atoms[0])

	test	al, al
	jne	SHORT $LN68@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	SHORT $LN131@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN129@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN135@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN135@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN136@Getffldx
$LN135@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN136@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN129@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN128@Getffldx
$LN129@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], edi
$LN128@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN131@Getffldx:

; 514  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 941  : 		if (_First == _Last || *_First != _Atoms[0])

	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	SHORT $LN68@Getffldx

; 945  : 				 || *_First == _Atoms[_NUMGET_XOFF]))

	mov	ecx, esi
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, eax
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 945  : 				 || *_First == _Atoms[_NUMGET_XOFF]))

	jne	SHORT $LN66@Getffldx
	mov	ecx, esi
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	cmp	al, BYTE PTR __Atoms$[ebp+25]
	je	SHORT $LN65@Getffldx
	mov	ecx, esi
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	cmp	al, BYTE PTR __Atoms$[ebp+24]
	jne	SHORT $LN66@Getffldx
$LN65@Getffldx:

; 946  : 			++_First;	// discard any 0x or 0X

	mov	ecx, esi
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++

; 947  : 		else

	jmp	SHORT $LN68@Getffldx
$LN66@Getffldx:

; 948  : 			_Seendigit = true;	// '0' not followed by 'x' or 'X'

	mov	BYTE PTR __Seendigit$1$[ebp], 1
$LN68@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H
	lea	eax, DWORD PTR __Grouping$[ebp]
	cmovae	eax, DWORD PTR __Grouping$[ebp]
	mov	DWORD PTR __Pg$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 951  : 		if (*_Pg == CHAR_MAX || *_Pg <= '\0')

	mov	al, BYTE PTR [eax]
	cmp	al, 127					; 0000007fH
	je	$LN62@Getffldx
	test	al, al
	jle	$LN62@Getffldx

; 963  : 					}
; 964  : 		else
; 965  : 			{	// grouping specified, gather digits and group sizes
; 966  : 			const _Elem _Kseparator = _Grouping.size() == 0
; 967  : 				? (_Elem)0 : _Punct_fac.thousands_sep();

	cmp	DWORD PTR __Grouping$[ebp+16], edi
	jne	SHORT $LN77@Getffldx
	mov	BYTE PTR __Kseparator$1$[ebp], 0
	jmp	SHORT $LN78@Getffldx
$LN77@Getffldx:

; 85   : 		}
; 86   : 
; 87   : 	_Elem thousands_sep() const
; 88   : 		{	// return thousands separator
; 89   : 		return (do_thousands_sep());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 963  : 					}
; 964  : 		else
; 965  : 			{	// grouping specified, gather digits and group sizes
; 966  : 			const _Elem _Kseparator = _Grouping.size() == 0
; 967  : 				? (_Elem)0 : _Punct_fac.thousands_sep();

	mov	BYTE PTR __Kseparator$1$[ebp], al
$LN78@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Groups$4[ebp+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	WORD PTR __Groups$4[ebp], di
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Groups$4[ebp+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 968  : 			string _Groups((size_t)1, '\0');

	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 969  : 			size_t _Group = 0;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 971  : 			for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Groups$4[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 971  : 			for (; _First != _Last; ++_First)

	jne	$LL1089@Getffldx
$LL369@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN400@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN398@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN404@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN404@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN405@Getffldx
$LN404@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN405@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN398@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN397@Getffldx
$LN398@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN397@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN400@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR __Atoms$[ebp]
	lea	eax, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	cl, cl
	je	SHORT $LN420@Getffldx
$LL422@Getffldx:
	cmp	cl, dl
	je	SHORT $LN420@Getffldx
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL422@Getffldx
$LN420@Getffldx:

; 58   : 		;
; 59   : 	return ((size_t)(_Ptr - _Base));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	sub	eax, ecx

; 972  : 				if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)

	cmp	eax, 22					; 00000016H
	jae	SHORT $LN50@Getffldx

; 973  : 					{	// got a digit, add to group size
; 974  : 					_Seendigit = true;
; 975  : 					if (_MAX_SIG_DIG <= _Significant)

	mov	edx, DWORD PTR __Significant$1$[ebp]
	mov	BYTE PTR __Seendigit$1$[ebp], 1
	cmp	edx, 36					; 00000024H
	jl	SHORT $LN49@Getffldx

; 976  : 						++_Phex;	// just scale by 10

	inc	DWORD PTR __Phex$1$[ebp]
	jmp	SHORT $LN46@Getffldx
$LN49@Getffldx:

; 977  : 					else if (_Idx == 0 && _Significant == 0)

	test	eax, eax
	jne	SHORT $LN47@Getffldx
	test	edx, edx
	je	SHORT $LN46@Getffldx
$LN47@Getffldx:

; 978  : 						;	// drop leading zeros
; 979  : 					else
; 980  : 						{	// save a significant digit
; 981  : 						*_Ptr++ = _Src[_Idx];

	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [ecx], al
	inc	ecx

; 982  : 						++_Significant;

	inc	edx
	mov	DWORD PTR __Ptr$1$[ebp], ecx
	mov	DWORD PTR __Significant$1$[ebp], edx
$LN46@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	mov	ecx, DWORD PTR __Groups$4[ebp+20]
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmp	ecx, 16					; 00000010H
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 984  : 					if (_Groups[_Group] != CHAR_MAX)

	cmp	BYTE PTR [eax+edi], 127			; 0000007fH
	je	SHORT $LN52@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	ecx, 16					; 00000010H
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 985  : 						++_Groups[_Group];

	inc	BYTE PTR [eax+edi]

; 986  : 					}
; 987  : 				else if (_Groups[_Group] == '\0'

	jmp	SHORT $LN1098@Getffldx
$LN50@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	mov	edx, DWORD PTR __Groups$4[ebp+20]
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmp	edx, 16					; 00000010H
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 989  : 					|| *_First != _Kseparator)

	cmp	BYTE PTR [eax+edi], 0
	je	SHORT $LN1004@Getffldx
	cmp	BYTE PTR __Kseparator$1$[ebp], 0
	je	SHORT $LN1004@Getffldx
	mov	ecx, esi
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	cmp	al, BYTE PTR __Kseparator$1$[ebp]
	jne	SHORT $LN1088@Getffldx

; 990  : 					break;	// not a group separator, done
; 991  : 				else
; 992  : 					{	// add a new group to _Groups string
; 993  : 					_Groups.append((size_t)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 994  : 					++_Group;

	inc	edi
$LN1098@Getffldx:
	mov	ebx, DWORD PTR __Groups$4[ebp]
$LN52@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN370@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN376@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN376@Getffldx

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN377@Getffldx
$LN376@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN377@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN370@Getffldx

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN1007@Getffldx
$LN370@Getffldx:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN1007@Getffldx:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 971  : 			for (; _First != _Last; ++_First)

	je	$LL369@Getffldx
$LN1088@Getffldx:
	mov	edx, DWORD PTR __Groups$4[ebp+20]
$LN1004@Getffldx:

; 995  : 					}
; 996  : 			if (_Group == 0)

	test	edi, edi
	je	SHORT $LL1089@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	edx, 16					; 00000010H
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 998  : 			else if ('\0' < _Groups[_Group])

	cmp	BYTE PTR [eax+edi], 0
	jle	SHORT $LN38@Getffldx

; 999  : 				++_Group;	// add trailing group to group count

	inc	edi
	npad	6
$LL1089@Getffldx:
	mov	eax, DWORD PTR __Pg$1$[ebp]
$LN36@Getffldx:

; 1002 : 
; 1003 : 			while (!_Bad && 0 < _Group)

	test	edi, edi
	je	SHORT $LN1086@Getffldx

; 1004 : 				if (*_Pg == CHAR_MAX)

	mov	cl, BYTE PTR [eax]
	cmp	cl, 127					; 0000007fH
	je	SHORT $LN1086@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	mov	edx, DWORD PTR __Groups$4[ebp+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1007 : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	dec	edi
	je	SHORT $LN30@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	edx, 16					; 00000010H
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1007 : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	cl, BYTE PTR [eax+edi]
	jne	SHORT $LN38@Getffldx
$LN30@Getffldx:
	test	edi, edi
	jne	SHORT $LN32@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	edx, 16					; 00000010H
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1007 : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	cl, BYTE PTR [eax]
	jl	SHORT $LN38@Getffldx
$LN32@Getffldx:

; 1002 : 
; 1003 : 			while (!_Bad && 0 < _Group)

	mov	eax, DWORD PTR __Pg$1$[ebp]
	inc	eax

; 1008 : 					_Bad = true;	// bad group size, fail
; 1009 : 				else if ('\0' < _Pg[1])

	cmp	BYTE PTR [eax], 0
	jle	SHORT $LL1089@Getffldx

; 1010 : 					++_Pg;	// group size okay, advance to next test

	mov	DWORD PTR __Pg$1$[ebp], eax

; 1002 : 
; 1003 : 			while (!_Bad && 0 < _Group)

	jmp	SHORT $LN36@Getffldx
$LN38@Getffldx:

; 1000 : 			else
; 1001 : 				_Bad = true;	// trailing separator, fail

	mov	BYTE PTR __Bad$1$[ebp], 1

; 1002 : 
; 1003 : 			while (!_Bad && 0 < _Group)

	jmp	SHORT $LN1005@Getffldx
$LN1086@Getffldx:
	mov	edx, DWORD PTR __Groups$4[ebp+20]
$LN1005@Getffldx:

; 1011 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	edx, 16					; 00000010H
	jb	SHORT $LN1090@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1090@Getffldx:
	mov	edi, DWORD PTR __Significant$1$[ebp]
	mov	ebx, DWORD PTR __Ptr$1$[ebp]
$LN59@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1013 : 		if (_Seendigit && _Significant == 0)

	cmp	BYTE PTR __Seendigit$1$[ebp], 0
	je	SHORT $LN27@Getffldx
$LN1038@Getffldx:
	test	edi, edi
	jne	SHORT $LN27@Getffldx

; 1014 : 			*_Ptr++ = '0';	// save at least one leading digit

	mov	BYTE PTR [ebx], 48			; 00000030H
	inc	ebx
	mov	DWORD PTR __Ptr$1$[ebp], ebx
$LN27@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1016 : 		if (_First != _Last && *_First == _Punct_fac.decimal_point())

	jne	$LN1092@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	$LN515@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	$LN513@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN519@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	$LN519@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	$LN520@Getffldx
$LN62@Getffldx:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 954  : 					_Seendigit = true, ++_First)

	jne	SHORT $LN59@Getffldx
$LL165@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN196@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN194@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN200@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN200@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN201@Getffldx
$LN200@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN201@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN194@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN193@Getffldx
$LN194@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN193@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN196@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR __Atoms$[ebp]
	lea	eax, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	cl, cl
	je	SHORT $LN216@Getffldx
	npad	1
$LL218@Getffldx:
	cmp	cl, dl
	je	SHORT $LN216@Getffldx
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL218@Getffldx
$LN216@Getffldx:

; 58   : 		;
; 59   : 	return ((size_t)(_Ptr - _Base));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	sub	eax, ecx

; 954  : 					_Seendigit = true, ++_First)

	cmp	eax, 22					; 00000016H
	jae	$LN59@Getffldx

; 955  : 				if (_MAX_SIG_DIG <= _Significant)

	cmp	edi, 36					; 00000024H
	jl	SHORT $LN58@Getffldx

; 956  : 					++_Phex;	// just scale by 10

	inc	DWORD PTR __Phex$1$[ebp]
	jmp	SHORT $LN60@Getffldx
$LN58@Getffldx:

; 957  : 				else if (_Idx == 0 && _Significant == 0)

	test	eax, eax
	jne	SHORT $LN56@Getffldx
	test	edi, edi
	je	SHORT $LN60@Getffldx
$LN56@Getffldx:

; 958  : 					;	// drop leading zeros
; 959  : 				else
; 960  : 					{	// save a significant digit
; 961  : 					*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [ebx], al
	inc	ebx

; 962  : 					++_Significant;

	inc	edi
	mov	DWORD PTR __Ptr$1$[ebp], ebx
	mov	DWORD PTR __Significant$1$[ebp], edi
$LN60@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 954  : 					_Seendigit = true, ++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN166@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN172@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN172@Getffldx

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN173@Getffldx
$LN172@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN173@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN166@Getffldx

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN1009@Getffldx
$LN166@Getffldx:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN1009@Getffldx:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 954  : 					_Seendigit = true, ++_First)

	je	$LL165@Getffldx

; 1013 : 		if (_Seendigit && _Significant == 0)

	jmp	$LN1038@Getffldx
$LN519@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN520@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN513@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN512@Getffldx
$LN513@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN512@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN515@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 84   : 		return (do_decimal_point());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	bl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 84   : 		return (do_decimal_point());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 1016 : 		if (_First != _Last && *_First == _Punct_fac.decimal_point())

	cmp	bl, al
	jne	SHORT $LN1092@Getffldx

; 1017 : 			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	// add .

	call	_localeconv
	mov	ebx, DWORD PTR __Ptr$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ebx], al
	inc	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1017 : 			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	// add .

	mov	DWORD PTR __Ptr$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN540@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN546@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN546@Getffldx

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN547@Getffldx
$LN546@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN547@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN540@Getffldx

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN539@Getffldx
$LN540@Getffldx:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
	jmp	SHORT $LN539@Getffldx
$LN1092@Getffldx:
	mov	ebx, DWORD PTR __Ptr$1$[ebp]
$LN539@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1019 : 		if (_Significant == 0)

	test	edi, edi
	jne	$LN21@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1022 : 				_Seendigit = true, ++_First)

	jne	$LN22@Getffldx
	mov	ebx, DWORD PTR __Last$GSCopy$1$[ebp]
	mov	edi, DWORD PTR __Phex$1$[ebp]
	npad	2
$LL562@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN593@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN591@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN597@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN597@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN598@Getffldx
$LN597@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN598@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN591@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN590@Getffldx
$LN591@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN590@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN593@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1022 : 				_Seendigit = true, ++_First)

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	SHORT $LN1081@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1023 : 				--_Phex;	// just count leading fraction zeros

	dec	edi
	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN563@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN569@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN569@Getffldx

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN570@Getffldx
$LN569@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN570@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN563@Getffldx

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN1010@Getffldx
$LN563@Getffldx:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN1010@Getffldx:

; 595  : 	return (_Left.equal(_Right));

	push	ebx
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1022 : 				_Seendigit = true, ++_First)

	je	$LL562@Getffldx
$LN1081@Getffldx:
	mov	ebx, DWORD PTR __Ptr$1$[ebp]
	mov	DWORD PTR __Phex$1$[ebp], edi
	mov	edi, DWORD PTR __Significant$1$[ebp]
$LN22@Getffldx:

; 1024 : 			if (_Phex < 0)

	mov	eax, DWORD PTR __Phex$1$[ebp]
	test	eax, eax
	jns	SHORT $LN21@Getffldx

; 1025 : 				*_Ptr++ = '0', ++_Phex;	// put one back

	mov	BYTE PTR [ebx], 48			; 00000030H
	inc	ebx
	inc	eax
	mov	DWORD PTR __Phex$1$[ebp], eax
$LN21@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1030 : 				_Seendigit = true, ++_First)

	jne	$LN18@Getffldx
$LL615@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN646@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN644@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN650@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN650@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN651@Getffldx
$LN650@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN651@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN644@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN643@Getffldx
$LN644@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN643@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN646@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR __Atoms$[ebp]
	lea	eax, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	cl, cl
	je	SHORT $LN666@Getffldx
	npad	3
$LL668@Getffldx:
	cmp	cl, dl
	je	SHORT $LN666@Getffldx
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL668@Getffldx
$LN666@Getffldx:

; 58   : 		;
; 59   : 	return ((size_t)(_Ptr - _Base));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	sub	eax, ecx

; 1030 : 				_Seendigit = true, ++_First)

	cmp	eax, 22					; 00000016H
	jae	SHORT $LN18@Getffldx

; 1031 : 			if (_Significant < _MAX_SIG_DIG)

	cmp	edi, 36					; 00000024H
	jge	SHORT $LN19@Getffldx

; 1032 : 				{	// save a significant fraction digit
; 1033 : 				*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [ebx], al
	inc	ebx

; 1034 : 				++_Significant;

	inc	edi
$LN19@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1030 : 				_Seendigit = true, ++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN616@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN622@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN622@Getffldx

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN623@Getffldx
$LN622@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN623@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN616@Getffldx

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN1012@Getffldx
$LN616@Getffldx:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN1012@Getffldx:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1030 : 				_Seendigit = true, ++_First)

	je	$LL615@Getffldx

; 1039 : 				|| *_First == _Atoms[_NUMGET_POFF]))

	jmp	SHORT $LN1039@Getffldx
$LN18@Getffldx:
	mov	al, BYTE PTR __Seendigit$1$[ebp]
	test	al, al
	je	$LN4@Getffldx
$LN1039@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1039 : 				|| *_First == _Atoms[_NUMGET_POFF]))

	jne	$LN1095@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	SHORT $LN681@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN679@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN685@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN685@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN686@Getffldx
$LN685@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN686@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN679@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN678@Getffldx
$LN679@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN678@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN681@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1039 : 				|| *_First == _Atoms[_NUMGET_POFF]))

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp+27]
	je	SHORT $LN15@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN707@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN705@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN711@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN711@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN712@Getffldx
$LN711@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN712@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN705@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN704@Getffldx
$LN705@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN704@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN707@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1039 : 				|| *_First == _Atoms[_NUMGET_POFF]))

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp+26]
	jne	$LN1095@Getffldx
$LN15@Getffldx:

; 1040 : 			{	// 'p' or 'P', collect exponent
; 1041 : 			*_Ptr++ = 'p', ++_First;

	mov	BYTE PTR [ebx], 112			; 00000070H
	inc	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN730@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN736@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN736@Getffldx

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN737@Getffldx
$LN736@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN737@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN730@Getffldx

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN729@Getffldx
$LN730@Getffldx:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN729@Getffldx:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1042 : 			_Seendigit = false, _Significant = 0;

	mov	BYTE PTR __Seendigit$1$[ebp], 0
	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1044 : 			if (_First == _Last)

	test	al, al
	jne	$LN1001@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	SHORT $LN758@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN756@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN762@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN762@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN763@Getffldx
$LN762@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN763@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN756@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN755@Getffldx
$LN756@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], edi
$LN755@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN758@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1046 : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp+23]
	jne	SHORT $LN12@Getffldx

; 1047 : 				*_Ptr++ = '+', ++_First;	// gather plus sign

	mov	BYTE PTR [ebx], 43			; 0000002bH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN1101@Getffldx
$LN12@Getffldx:

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN807@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN805@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN811@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN811@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN812@Getffldx
$LN811@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN812@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN805@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN804@Getffldx
$LN805@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], edi
$LN804@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN807@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1048 : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp+22]
	jne	SHORT $LN1001@Getffldx

; 1049 : 				*_Ptr++ = '-', ++_First;	// gather minus sign

	mov	BYTE PTR [ebx], 45			; 0000002dH
$LN1101@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1049 : 				*_Ptr++ = '-', ++_First;	// gather minus sign

	inc	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN830@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN836@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN836@Getffldx

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN837@Getffldx
$LN836@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN837@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN830@Getffldx

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN1001@Getffldx
$LN830@Getffldx:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	DWORD PTR [esi], edi
$LN1001@Getffldx:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1050 : 			for (; _First != _Last && *_First == _Atoms[0]; )

	jne	$LN7@Getffldx
	npad	7
$LL9@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN860@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN858@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN864@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN864@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN865@Getffldx
$LN864@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN865@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN858@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN857@Getffldx
$LN858@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], edi
$LN857@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN860@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1050 : 			for (; _First != _Last && *_First == _Atoms[0]; )

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	SHORT $LN8@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1051 : 				_Seendigit = true, ++_First;	// strip leading zeros

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN883@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN889@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN889@Getffldx

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN890@Getffldx
$LN889@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN890@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN883@Getffldx

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN882@Getffldx
$LN883@Getffldx:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], edi
	mov	BYTE PTR [esi+4], 1
$LN882@Getffldx:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1050 : 			for (; _First != _Last && *_First == _Atoms[0]; )

	je	$LL9@Getffldx

; 1052 : 			if (_Seendigit)

	jmp	SHORT $LN1040@Getffldx
$LN8@Getffldx:
	cmp	BYTE PTR __Seendigit$1$[ebp], 0
	je	SHORT $LN7@Getffldx
$LN1040@Getffldx:

; 1053 : 				*_Ptr++ = '0';	// put one back

	mov	BYTE PTR [ebx], 48			; 00000030H
	inc	ebx
$LN7@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1056 : 				_Seendigit = true, ++_First)

	jne	$LN1095@Getffldx
$LL905@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN936@Getffldx

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN934@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN940@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN940@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN941@Getffldx
$LN940@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN941@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN934@Getffldx

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN933@Getffldx
$LN934@Getffldx:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN933@Getffldx:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN936@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR __Atoms$[ebp]
	lea	eax, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	cl, cl
	je	SHORT $LN956@Getffldx
$LL958@Getffldx:
	cmp	cl, dl
	je	SHORT $LN956@Getffldx
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL958@Getffldx
$LN956@Getffldx:

; 58   : 		;
; 59   : 	return ((size_t)(_Ptr - _Base));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	sub	eax, ecx

; 1056 : 				_Seendigit = true, ++_First)

	cmp	eax, 22					; 00000016H
	jae	SHORT $LN1095@Getffldx

; 1057 : 				if (_Significant < _MAX_EXP_DIG)

	cmp	edi, 8
	jge	SHORT $LN5@Getffldx

; 1058 : 					{	// save a significant exponent digit
; 1059 : 					*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [ebx], al
	inc	ebx

; 1060 : 					++_Significant;

	inc	edi
$LN5@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1056 : 				_Seendigit = true, ++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN906@Getffldx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN912@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN912@Getffldx

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN913@Getffldx
$LN912@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN913@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN906@Getffldx

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN1014@Getffldx
$LN906@Getffldx:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN1014@Getffldx:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1056 : 				_Seendigit = true, ++_First)

	je	$LL905@Getffldx
$LN1095@Getffldx:
	mov	al, BYTE PTR __Seendigit$1$[ebp]
$LN4@Getffldx:

; 1061 : 					}
; 1062 : 			}
; 1063 : 
; 1064 : 		if (_Bad || !_Seendigit)

	cmp	BYTE PTR __Bad$1$[ebp], 0
	jne	SHORT $LN1@Getffldx
	test	al, al
	jne	SHORT $LN2@Getffldx
$LN1@Getffldx:

; 1065 : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	ebx, DWORD PTR __Ac$GSCopy$1$[ebp]
$LN2@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1067 : 		*_Phexexp = _Phex;	// power of 16 multiplier

	mov	ecx, DWORD PTR __Phexexp$GSCopy$1$[ebp]
	mov	eax, DWORD PTR __Phex$1$[ebp]
	mov	BYTE PTR [ebx], 0
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN1068@Getffldx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Grouping$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1068@Getffldx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1068 : 		return (0);	// power of 10 multiplier

	xor	eax, eax

; 1069 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3:
	lea	ecx, DWORD PTR __Groups$4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
_TEXT	SEGMENT
$T2 = -120						; size = 4
__Punct_fac$1$ = -116					; size = 4
__Ac$GSCopy$1$ = -112					; size = 4
__Pg$1$ = -108						; size = 4
$T3 = -108						; size = 4
__Significant$1$ = -104					; size = 4
__Pten$1$ = -100					; size = 4
__Ptr$1$ = -96						; size = 4
__Bad$1$ = -90						; size = 1
__Kseparator$1$ = -89					; size = 1
__Last$GSCopy$1$ = -88					; size = 4
__Seendigit$1$ = -81					; size = 1
__Grouping$ = -80					; size = 24
__Groups$4 = -56					; size = 24
__Atoms$ = -32						; size = 14
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Iosbase$ = 24						; size = 4
__Phexexp$ = 28						; size = 4
?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld, COMDAT

; 755  : 		{	// get floating-point field from [_First, _Last) into _Ac

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR __Iosbase$[ebp]
	mov	ebx, DWORD PTR __Ac$[ebp]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 367  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR __Phexexp$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 756  : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)

	and	eax, 12288				; 00003000H
	mov	DWORD PTR __Ac$GSCopy$1$[ebp], ebx
	mov	DWORD PTR __Last$GSCopy$1$[ebp], edx
	cmp	eax, 12288				; 00003000H
	jne	SHORT $LN69@Getffld

; 757  : 			return (_Getffldx(_Ac, _First, _Last,
; 758  : 				_Iosbase, _Phexexp));	// hex format

	push	ecx
	push	edi
	push	edx
	push	esi
	push	ebx
	push	DWORD PTR _this$[ebp]
	call	?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx
	add	esp, 24					; 00000018H
	jmp	$LN70@Getffld
$LN69@Getffld:

; 760  : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, edi
	push	eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 760  : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ebx, eax
	mov	DWORD PTR __Punct_fac$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN83@Getffld

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN83@Getffld
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN83@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 761  : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[ebp]
	mov	ecx, ebx
	push	eax
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 762  : 		char *_Ptr = _Ac;

	mov	ebx, DWORD PTR __Ac$GSCopy$1$[ebp]

; 771  : 			_USE(_Iosbase.getloc(), ctype<_Elem>);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __Ptr$1$[ebp], ebx
	mov	BYTE PTR __Bad$1$[ebp], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 771  : 			_USE(_Iosbase.getloc(), ctype<_Elem>);

	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN88@Getffld

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN88@Getffld
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN88@Getffld:

; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)
; 470  : 			return (_Facptr);	// found facet or not transparent
; 471  : 		else
; 472  : 			{	// look in current locale
; 473  : 			locale::_Locimp *_Ptr = _Getgloballocale();
; 474  : 			return (_Id < _Ptr->_Facetcount
; 475  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 476  : 				: 0);	// no entry in current locale
; 477  : 			}
; 478  : 		}
; 479  : 
; 480  : 	bool operator==(const locale& _Loc) const
; 481  : 		{	// compare locales for equality
; 482  : 		return (_Ptr == _Loc._Ptr
; 483  : 			|| (name().compare("*") != 0
; 484  : 				&& name().compare(_Loc.name()) == 0));
; 485  : 		}
; 486  : 
; 487  : 	bool operator!=(const locale& _Right) const
; 488  : 		{	// test for locale inequality
; 489  : 		return (!(*this == _Right));
; 490  : 		}
; 491  : 
; 492  : 	static _MRTIMP2_PURE const locale& __CLRCALL_PURE_OR_CDECL
; 493  : 		classic();	// classic "C" locale
; 494  : 
; 495  : 	static _MRTIMP2_PURE locale __CLRCALL_PURE_OR_CDECL
; 496  : 		global(const locale&);	// current locale
; 497  : 
; 498  : 	static _MRTIMP2_PURE locale __CLRCALL_PURE_OR_CDECL
; 499  : 		empty();	// empty (transparent) locale
; 500  : 
; 501  : private:
; 502  : 	locale(_Locimp *_Ptrimp)
; 503  : 		: _Ptr(_Ptrimp)
; 504  : 		{	// construct from _Locimp pointer
; 505  : 		}
; 506  : 
; 507  :     static _MRTIMP2_PURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 508  : 		_Init(bool _Do_incref = false);	// initialize locale
; 509  : 	static _MRTIMP2_PURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 510  : 		_Getgloballocale();
; 511  : 	static _MRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL
; 512  : 		_Setgloballocale(void *);
; 513  : 
; 514  : 	bool _Badname(const _Locinfo& _Lobj)
; 515  : 		{	// test if name is "*"
; 516  : 		return (_CSTD strcmp(_Lobj._Getname(), "*") == 0);
; 517  : 		}
; 518  : 
; 519  : 	_Locimp *_Ptr;	// pointer to locale implementation object
; 520  : 	};
; 521  : 
; 522  : 		// SUPPORT TEMPLATES
; 523  : 
; 524  :  #if _NO_LOCALES
; 525  : inline _Locinfo& _Get_locinfo()
; 526  : 	{	// get reference to common locale info
; 527  : 	static _Locinfo _Lobj;
; 528  : 	return (_Lobj);
; 529  : 	}
; 530  : 
; 531  : template<class _Facet>
; 532  : 	class _Wrap_facet
; 533  : 		: public _Facet
; 534  : 	{	// makes a facet destructible and shareable
; 535  : public:
; 536  : 	_Wrap_facet()
; 537  : 		: _Facet(_Get_locinfo())
; 538  : 		{	// construct from locale object
; 539  : 		}
; 540  : 	};
; 541  :  #endif /* _NO_LOCALES */
; 542  : 
; 543  : template<class _Facet>
; 544  : 	struct _Facetptr
; 545  : 	{	// store pointer to lazy facet for use_facet
; 546  : 	__PURE_APPDOMAIN_GLOBAL static const locale::facet *_Psave;
; 547  : 	};
; 548  : 
; 549  : template<class _Facet>
; 550  : 	__PURE_APPDOMAIN_GLOBAL const locale::facet *_Facetptr<_Facet>::
; 551  : 		_Psave = 0;
; 552  : 
; 553  :   #define _ADDFAC(loc, pfac)	locale(loc, pfac)	/* add facet to locale */
; 554  : 
; 555  :   #define _USE(loc, fac)	\
; 556  : 	use_facet< fac >(loc)	/* get facet reference from locale */
; 557  : 
; 558  : template<class _Facet> inline
; 559  : 	const _Facet& __CRTDECL use_facet(const locale& _Loc)
; 560  : 
; 561  : 	{	// get facet reference from locale
; 562  :  #if _NO_LOCALES
; 563  : 	static _Wrap_facet<_Facet> _Wfac;
; 564  : 	return (*(_Facet *)&_Wfac);
; 565  : 
; 566  :  #else /* _NO_LOCALES */
; 567  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic
; 568  : 		const locale::facet *_Psave =
; 569  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet
; 570  : 
; 571  : 		size_t _Id = _Facet::id;
; 572  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 573  : 
; 574  : 		if (_Pf != 0)
; 575  : 			;	// got facet from locale
; 576  : 		else if (_Psave != 0)
; 577  : 			_Pf = _Psave;	// lazy facet already allocated
; 578  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))
; 579  : 
; 580  :  #if _HAS_EXCEPTIONS
; 581  : 
; 582  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed
; 583  : 
; 584  :  #else /* _HAS_EXCEPTIONS */
; 585  : 			abort();	// lazy disallowed
; 586  :  #endif /* _HAS_EXCEPTIONS */
; 587  : 
; 588  : 		else
; 589  : 			{	// queue up lazy facet for destruction
; 590  : 			_Pf = _Psave;
; 591  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 592  : 
; 593  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 594  : 			_Pfmod->_Incref();
; 595  : 
; 596  :  #if defined(_M_CEE)
; 597  : 			_Facet_Register_m(_Pfmod);
; 598  : 
; 599  :  #else /* defined(_M_CEE) */
; 600  : 			_Facet_Register(_Pfmod);
; 601  :  #endif /* defined(_M_CEE) */
; 602  : 			}
; 603  : 
; 604  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast
; 605  : 	_END_LOCK()
; 606  :  #endif /* _NO_LOCALES */
; 607  : 	}	// end of use_facet body
; 608  : 
; 609  : 		// TEMPLATE FUNCTION _Getloctxt
; 610  : template<class _Elem,
; 611  : 	class _InIt> inline
; 612  : 	int __CRTDECL _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
; 613  : 		const _Elem *_Ptr)
; 614  : 	{	// find field at _Ptr that matches longest in [_First, _Last)
; 615  : 	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
; 616  : 		if (_Ptr[_Off] == _Ptr[0])
; 617  : 			++_Numfields;	// add fields with leading mark to initial count
; 618  : 	string _Str(_Numfields, '\0');	// one column counter for each field
; 619  : 
; 620  : 	int _Ans = -2;	// no candidates so far
; 621  : 	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
; 622  : 		{	// test each element against all viable fields
; 623  : 		bool _Prefix = false;	// seen at least one valid prefix
; 624  : 		size_t _Off = 0;	// offset into fields
; 625  : 		size_t _Field = 0;	// current field number
; 626  : 
; 627  : 		for (; _Field < _Numfields; ++_Field)
; 628  : 			{	// test element at _Column in field _Field
; 629  : 			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
; 630  : 				;	// find beginning of field
; 631  : 
; 632  : 			if (_Str[_Field] != '\0')
; 633  : 				_Off += _Str[_Field];	// skip tested columns in field
; 634  : 			else if (_Ptr[_Off += _Column] == _Ptr[0]
; 635  : 				|| _Ptr[_Off] == (_Elem)0)
; 636  : 				{	// matched all of field, save as possible answer
; 637  : 				_Str[_Field] = (char)(_Column < 127
; 638  : 					? _Column : 127);	// save skip count if small enough
; 639  : 				_Ans = (int)_Field;	// save answer
; 640  : 				}
; 641  : 			else if (_First == _Last || _Ptr[_Off] != *_First)
; 642  : 				_Str[_Field] = (char)(_Column < 127
; 643  : 					? _Column : 127);	// no match, just save skip count
; 644  : 			else
; 645  : 				_Prefix = true;	// still a valid prefix
; 646  : 			}
; 647  : 
; 648  : 		if (!_Prefix || _First == _Last)
; 649  : 			break;	// no pending prefixes or no input, give up
; 650  : 		}
; 651  : 	return (_Ans);	// return field number or negative value on failure
; 652  : 	}
; 653  : 
; 654  : 		// TEMPLATE FUNCTION _Maklocbyte
; 655  : #define _MAKLOCBYTE(Elem, chr, cvt) \
; 656  : 	_Maklocbyte((_Elem)chr, cvt)	/* convert Elem to char */
; 657  : 
; 658  : template<class _Elem> inline
; 659  : 	char __CRTDECL _Maklocbyte(_Elem _Char,
; 660  : 		const _Locinfo::_Cvtvec&)
; 661  : 	{	// convert _Elem to char using _Cvtvec
; 662  : 	return ((char)(unsigned char)_Char);
; 663  : 	}
; 664  : 
; 665  : template<> inline
; 666  : 	char __CRTDECL _Maklocbyte(wchar_t _Char,
; 667  : 		const _Locinfo::_Cvtvec& _Cvt)
; 668  : 	{	// convert wchar_t to char using _Cvtvec
; 669  : 	char _Byte = '\0';
; 670  : 	_Mbstinit(_Mbst1);
; 671  : 	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
; 672  : 	return (_Byte);
; 673  : 	}
; 674  : 
; 675  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 676  : template<> inline
; 677  : 	char __CRTDECL _Maklocbyte(unsigned short _Char,
; 678  : 		const _Locinfo::_Cvtvec &_Cvt)
; 679  : 	{	// convert unsigned short to char using _Cvtvec
; 680  : 	char _Byte = '\0';
; 681  : 	_Mbstinit(_Mbst1);
; 682  : 	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
; 683  : 	return (_Byte);
; 684  : 	}
; 685  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 686  : 
; 687  : 		// TEMPLATE FUNCTION _Maklocchr
; 688  : #define _MAKLOCCHR(Elem, chr, cvt) \
; 689  : 	_Maklocchr(chr, (Elem *)0, cvt)	/* convert char to Elem */
; 690  : 
; 691  : template<class _Elem> inline
; 692  : 	_Elem __CRTDECL _Maklocchr(char _Byte, _Elem *,
; 693  : 		const _Locinfo::_Cvtvec&)
; 694  : 	{	// convert char to _Elem using _Cvtvec
; 695  : 	return ((_Elem)(unsigned char)_Byte);
; 696  : 	}
; 697  : 
; 698  : template<> inline
; 699  : 	wchar_t __CRTDECL _Maklocchr(char _Byte, wchar_t *,
; 700  : 		const _Locinfo::_Cvtvec& _Cvt)
; 701  : 	{	// convert char to wchar_t using _Cvtvec
; 702  : 	wchar_t _Wc = L'\0';
; 703  : 	_Mbstinit(_Mbst1);
; 704  : 	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
; 705  : 	return (_Wc);
; 706  : 	}
; 707  : 
; 708  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 709  : template<> inline
; 710  : 	unsigned short __CRTDECL _Maklocchr(char _Byte, unsigned short *,
; 711  : 		const _Locinfo::_Cvtvec &_Cvt)
; 712  : 	{	// convert char to unsigned short using _Cvtvec
; 713  : 	unsigned short _Wc = (unsigned short)0;
; 714  : 	_Mbstinit(_Mbst1);
; 715  : 	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
; 716  : 	return (_Wc);
; 717  : 	}
; 718  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 719  : 
; 720  : 		// TEMPLATE FUNCTION _Maklocstr
; 721  : #define _MAKLOCSTR(Elem, str, cvt)	\
; 722  : 	_Maklocstr(str, (Elem *)0, cvt)	/* convert C string to Elem sequence */
; 723  : 
; 724  : template<class _Elem> inline
; 725  : 	_Elem *__CRTDECL _Maklocstr(const char *_Ptr, _Elem *,
; 726  : 		const _Locinfo::_Cvtvec&)
; 727  : 	{	// convert C string to _Elem sequence using _Cvtvec
; 728  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;
; 729  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];
; 730  : 
; 731  :  #pragma warning(push)
; 732  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 733  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
; 734  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
; 735  :  #pragma warning(pop)
; 736  : 
; 737  : 	return (_Ptrdest);
; 738  : 	}
; 739  : 
; 740  : template<> inline
; 741  : 	wchar_t *__CRTDECL _Maklocstr(const char *_Ptr, wchar_t *,
; 742  : 		const _Locinfo::_Cvtvec& _Cvt)
; 743  : 	{	// convert C string to wchar_t sequence using _Cvtvec
; 744  : 	size_t _Count, _Count1;
; 745  : 	size_t _Wchars;
; 746  : 	const char *_Ptr1;
; 747  : 	int _Bytes;
; 748  : 	wchar_t _Wc;
; 749  : 	_Mbstinit(_Mbst1);
; 750  : 
; 751  : 	_Count1 = _CSTD strlen(_Ptr) + 1;
; 752  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
; 753  : 		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
; 754  : 		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
; 755  : 			break;
; 756  : 	++_Wchars;	// count terminating nul
; 757  : 
; 758  : 	wchar_t *_Ptrdest = _NEW_CRT wchar_t[_Wchars];
; 759  : 	wchar_t *_Ptrnext = _Ptrdest;
; 760  : 	_Mbstinit(_Mbst2);
; 761  : 
; 762  :  #pragma warning(push)
; 763  :  #pragma warning(disable: 6011)	/* quiet prefast noise */
; 764  : 	for (; 0 < _Wchars;
; 765  : 		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
; 766  : 		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
; 767  : 			break;
; 768  : 	*_Ptrnext = L'\0';
; 769  :  #pragma warning(pop)
; 770  : 
; 771  : 	return (_Ptrdest);
; 772  : 	}
; 773  : 
; 774  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 775  : template<> inline
; 776  : 	unsigned short *__CRTDECL _Maklocstr(const char *_Ptr, unsigned short *,
; 777  : 		const _Locinfo::_Cvtvec &_Cvt)
; 778  : 	{	// convert C string to unsigned short sequence using _Cvtvec
; 779  : 	size_t _Count, _Count1;
; 780  : 	size_t _Wchars;
; 781  : 	const char *_Ptr1;
; 782  : 	int _Bytes;
; 783  : 	unsigned short _Wc;
; 784  : 	_Mbstinit(_Mbst1);
; 785  : 
; 786  : 	_Count1 = _CSTD strlen(_Ptr) + 1;
; 787  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
; 788  : 		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
; 789  : 		if ((_Bytes =
; 790  : 			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
; 791  : 			break;
; 792  : 	++_Wchars;	// count terminating nul
; 793  : 
; 794  : 	wchar_t *_Ptrdest = _NEW_CRT wchar_t[_Wchars];
; 795  : 	wchar_t *_Ptrnext = _Ptrdest;
; 796  : 	_Mbstinit(_Mbst2);
; 797  : 	for (; 0 < _Wchars;
; 798  : 		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
; 799  : 		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
; 800  : 			break;
; 801  : 	*_Ptrnext = L'\0';
; 802  : 	return ((unsigned short *)_Ptrdest);
; 803  : 	}
; 804  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 805  : 
; 806  : 		// STRUCT codecvt_base
; 807  :  #pragma warning(push)
; 808  :  #pragma warning(disable: 4275)
; 809  : 
; 810  : class _CRTIMP2_PURE codecvt_base
; 811  : 	: public locale::facet
; 812  : 	{	// base class for codecvt
; 813  : public:
; 814  : 	enum
; 815  : 		{	// constants for different parse states
; 816  : 		ok, partial, error, noconv};
; 817  : 	typedef int result;
; 818  : 
; 819  : 	__CLR_OR_THIS_CALL codecvt_base(size_t _Refs = 0)
; 820  : 		: locale::facet(_Refs)
; 821  : 		{	// default constructor
; 822  : 		}
; 823  : 
; 824  : 	bool __CLR_OR_THIS_CALL always_noconv() const _THROW0()
; 825  : 		{	// return true if conversions never change input (from codecvt)
; 826  : 		return (do_always_noconv());
; 827  : 		}
; 828  : 
; 829  : 	int __CLR_OR_THIS_CALL max_length() const _THROW0()
; 830  : 		{	// return maximum length required for a conversion (from codecvt)
; 831  : 		return (do_max_length());
; 832  : 		}
; 833  : 
; 834  : 	int __CLR_OR_THIS_CALL encoding() const _THROW0()
; 835  : 		{	// return length of code sequence (from codecvt)
; 836  : 		return (do_encoding());
; 837  : 		}
; 838  : 
; 839  : 	__CLR_OR_THIS_CALL ~codecvt_base() _NOEXCEPT
; 840  : 		{	// destroy the object
; 841  : 		}
; 842  : 
; 843  : protected:
; 844  : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 845  : 		{	// return true if conversions never change input (from codecvt)
; 846  : 		return (false);
; 847  : 		}
; 848  : 
; 849  : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 850  : 		{	// return maximum length required for a conversion (from codecvt)
; 851  : 		return (1);
; 852  : 		}
; 853  : 
; 854  : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 855  : 		{	// return length of code sequence (from codecvt)
; 856  : 		return (1);	// -1 ==> state dependent, 0 ==> varying length
; 857  : 		}
; 858  : 	};
; 859  : 
; 860  :  #pragma warning(pop)
; 861  : 
; 862  : 		// TEMPLATE CLASS codecvt
; 863  : template<class _Elem,
; 864  : 	class _Byte,
; 865  : 	class _Statype>
; 866  : 	class codecvt
; 867  : 		: public codecvt_base
; 868  : 	{	// facet for converting between _Elem and char (_Byte) sequences
; 869  : public:
; 870  : 	typedef _Elem intern_type;
; 871  : 	typedef _Byte extern_type;
; 872  : 	typedef _Statype state_type;
; 873  : 
; 874  : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 875  : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 876  : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 877  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 878  : 		return (do_in(_State,
; 879  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 880  : 		}
; 881  : 
; 882  : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 883  : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 884  : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 885  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)
; 886  : 		return (do_out(_State,
; 887  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 888  : 		}
; 889  : 
; 890  : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 891  : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 892  : 		{	// generate bytes to return to default shift state
; 893  : 		return (do_unshift(_State, _First2, _Last2, _Mid2));
; 894  : 		}
; 895  : 
; 896  : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 897  : 		const _Byte *_Last1, size_t _Count) const
; 898  : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 899  : 		return (do_length(_State, _First1, _Last1, _Count));
; 900  : 		}
; 901  : 
; 902  : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id
; 903  : 
; 904  : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 905  : 		: codecvt_base(_Refs)
; 906  : 		{	// construct from current locale
; 907  : 		_Init(_Locinfo());
; 908  : 		}
; 909  : 
; 910  : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 911  : 		: codecvt_base(_Refs)
; 912  : 		{	// construct from specified locale
; 913  : 		_Init(_Lobj);
; 914  : 		}
; 915  : 
; 916  : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 917  : 		const locale *_Ploc = 0)
; 918  : 		{	// return locale category mask and construct standard facet
; 919  : 		if (_Ppf != 0 && *_Ppf == 0)
; 920  : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 921  : 				_Locinfo(_Ploc->c_str()));
; 922  : 		return (_X_CTYPE);
; 923  : 		}
; 924  : 
; 925  : protected:
; 926  : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 927  : 		{	// destroy the object
; 928  : 		}
; 929  : 
; 930  : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
; 931  : 		{	// initialize from _Locinfo object
; 932  : 		}
; 933  : 
; 934  : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 935  : 		{	// return true if conversions never change input (from codecvt)
; 936  : 		return (is_same<_Byte, _Elem>::value);
; 937  : 		}
; 938  : 
; 939  : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype&,
; 940  : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 941  : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 942  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 943  : 		_Mid1 = _First1, _Mid2 = _First2;
; 944  : 		if (is_same<_Byte, _Elem>::value)
; 945  : 			return (noconv);	// convert nothing
; 946  : 		else
; 947  : 			{	// types differ, copy one for one
; 948  : 			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
; 949  : 				*_Mid2 = (_Elem)*_Mid1;
; 950  : 			return (ok);
; 951  : 			}
; 952  : 		}
; 953  : 
; 954  : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype&,
; 955  : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 956  : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 957  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 958  : 		_Mid1 = _First1, _Mid2 = _First2;
; 959  : 		if (is_same<_Byte, _Elem>::value)
; 960  : 			return (noconv);	// convert nothing
; 961  : 		else
; 962  : 			{	// types differ, copy one for one
; 963  : 			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
; 964  : 				*_Mid2 = (_Byte)*_Mid1;
; 965  : 			return (ok);
; 966  : 			}
; 967  : 		}
; 968  : 
; 969  : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&,
; 970  : 		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
; 971  : 		{	// generate bytes to return to default shift state
; 972  : 		_Mid2 = _First2;
; 973  : 		return (ok);	// convert nothing
; 974  : 		}
; 975  : 
; 976  : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype&, const _Byte *_First1,
; 977  : 		const _Byte *_Last1, size_t _Count) const
; 978  : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 979  : 		return ((int)(_Count < (size_t)(_Last1 - _First1)
; 980  : 			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion
; 981  : 		}
; 982  : 	};
; 983  : 
; 984  : 		// STATIC codecvt::id OBJECT
; 985  : template<class _Elem,
; 986  : 	class _Byte,
; 987  : 	class _Statype>
; 988  : 	__PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;
; 989  : 
; 990  :  #if _HAS_CHAR16_T_LANGUAGE_SUPPORT
; 991  : 		// ENUM _Codecvt_mode
; 992  : enum _Codecvt_mode {
; 993  : 	_Consume_header = 4,
; 994  : 	_Generate_header = 2
; 995  : 	};
; 996  : 
; 997  : 		// CLASS codecvt<char16_t, char, _Mbstatet>
; 998  : template<>
; 999  : 	class _CRTIMP2_PURE codecvt<char16_t, char, _Mbstatet>
; 1000 : 	: public codecvt_base
; 1001 : 	{	// facet for converting between char16_t and UTF-8 byte sequences
; 1002 : public:
; 1003 : 	typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
; 1004 : 	typedef char16_t _Elem;
; 1005 : 	typedef char _Byte;
; 1006 : 	typedef _Mbstatet _Statype;
; 1007 : 	typedef _Elem intern_type;
; 1008 : 	typedef _Byte extern_type;
; 1009 : 	typedef _Statype state_type;
; 1010 : 
; 1011 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1012 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1013 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1014 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1015 : 		return (do_in(_State,
; 1016 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1017 : 		}
; 1018 : 
; 1019 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1020 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1021 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1022 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1023 : 		return (do_out(_State,
; 1024 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1025 : 		}
; 1026 : 
; 1027 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1028 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1029 : 		{	// generate bytes to return to default shift state
; 1030 : 		return (do_unshift(_State,
; 1031 : 			_First2, _Last2, _Mid2));
; 1032 : 		}
; 1033 : 
; 1034 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1035 : 		const _Byte *_Last1, size_t _Count) const
; 1036 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1037 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1038 : 		}
; 1039 : 
; 1040 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1041 : 
; 1042 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1043 : 		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
; 1044 : 		{	// construct from current locale
; 1045 : 		_BEGIN_LOCINFO(_Lobj)
; 1046 : 			_Init(_Lobj);
; 1047 : 		_END_LOCINFO()
; 1048 : 		}
; 1049 : 
; 1050 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1051 : 		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
; 1052 : 		{	// construct from specified locale
; 1053 : 		_Init(_Lobj);
; 1054 : 		}
; 1055 : 
; 1056 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
; 1057 : 		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
; 1058 : 		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
; 1059 : 		{	// construct from specified locale and parameters
; 1060 : 		_Init(_Lobj);
; 1061 : 		}
; 1062 : 
; 1063 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1064 : 		const locale *_Ploc = 0)
; 1065 : 		{	// return locale category mask and construct standard facet
; 1066 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1067 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1068 : 				_Locinfo(_Ploc->c_str()));
; 1069 : 		return (_X_CTYPE);
; 1070 : 		}
; 1071 : 
; 1072 : protected:
; 1073 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1074 : 		{	// destroy the object
; 1075 : 		}
; 1076 : 
; 1077 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
; 1078 : 		{	// initialize
; 1079 : 		}
; 1080 : 
; 1081 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1082 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1083 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1084 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last2)
; 1085 : 		unsigned short *_Pstate = (unsigned short *)&_State;
; 1086 : 		_Mid1 = _First1;
; 1087 : 		_Mid2 = _First2;
; 1088 : 
; 1089 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1090 : 			{	// convert a multibyte sequence
; 1091 : 			unsigned char _By = (unsigned char)*_Mid1;
; 1092 : 			unsigned long _Ch;
; 1093 : 			int _Nextra, _Nskip;
; 1094 : 
; 1095 : 			if (*_Pstate <= 1)
; 1096 : 				;	// no leftover word
; 1097 : 			else if (_By < 0x80 || 0xc0 <= _By)
; 1098 : 				return (_Mybase::error);	// not continuation byte
; 1099 : 			else
; 1100 : 				{	// deliver second half of two-word value
; 1101 : 				++_Mid1;
; 1102 : 				*_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
; 1103 : 				*_Pstate = 1;
; 1104 : 				continue;
; 1105 : 				}
; 1106 : 
; 1107 : 			if (_By < 0x80)
; 1108 : 				_Ch = _By, _Nextra = 0;
; 1109 : 			else if (_By < 0xc0)
; 1110 : 				{	// 0x80-0xdf not first byte
; 1111 : 				++_Mid1;
; 1112 : 				return (_Mybase::error);
; 1113 : 				}
; 1114 : 			else if (_By < 0xe0)
; 1115 : 				_Ch = _By & 0x1f, _Nextra = 1;
; 1116 : 			else if (_By < 0xf0)
; 1117 : 				_Ch = _By & 0x0f, _Nextra = 2;
; 1118 : 			else if (_By < 0xf8)
; 1119 : 				_Ch = _By & 0x07, _Nextra = 3;
; 1120 : 			else
; 1121 : 				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;
; 1122 : 
; 1123 : 			_Nskip = _Nextra < 3 ? 0 : 1;	// leave a byte for 2nd word
; 1124 : 			_First1 = _Mid1;	// roll back point
; 1125 : 
; 1126 : 			if (_Nextra == 0)
; 1127 : 				++_Mid1;
; 1128 : 			else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
; 1129 : 				break;	// not enough input
; 1130 : 			else
; 1131 : 				for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
; 1132 : 					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
; 1133 : 						return (_Mybase::error);	// not continuation byte
; 1134 : 					else
; 1135 : 						_Ch = _Ch << 6 | (_By & 0x3f);
; 1136 : 			if (0 < _Nskip)
; 1137 : 				_Ch <<= 6;	// get last byte on next call
; 1138 : 
; 1139 : 			if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
; 1140 : 				return (_Mybase::error);	// value too large
; 1141 : 			else if (0xffff < _Ch)
; 1142 : 				{	// deliver first half of two-word value, save second word
; 1143 : 				unsigned short _Ch0 =
; 1144 : 					(unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);
; 1145 : 
; 1146 : 				*_Mid2++ = (_Elem)_Ch0;
; 1147 : 				*_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
; 1148 : 				continue;
; 1149 : 				}
; 1150 : 
; 1151 : 			if (_Nskip == 0)
; 1152 : 				;
; 1153 : 			else if (_Mid1 == _Last1)
; 1154 : 				{	// not enough bytes, noncanonical value
; 1155 : 				_Mid1 = _First1;
; 1156 : 				break;
; 1157 : 				}
; 1158 : 			else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
; 1159 : 				return (_Mybase::error);	// not continuation byte
; 1160 : 			else
; 1161 : 				_Ch |= _By & 0x3f;	// complete noncanonical value
; 1162 : 
; 1163 : 			if (*_Pstate == 0)
; 1164 : 				{	// first time, maybe look for and consume header
; 1165 : 				*_Pstate = 1;
; 1166 : 
; 1167 : 				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
; 1168 : 					{	// drop header and retry
; 1169 : 					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
; 1170 : 						_First2, _Last2, _Mid2);
; 1171 : 
; 1172 : 					if (_Ans == _Mybase::partial)
; 1173 : 						{	// roll back header determination
; 1174 : 						*_Pstate = 0;
; 1175 : 						_Mid1 = _First1;
; 1176 : 						}
; 1177 : 					return (_Ans);
; 1178 : 					}
; 1179 : 				}
; 1180 : 
; 1181 : 			*_Mid2++ = (_Elem)_Ch;
; 1182 : 			}
; 1183 : 
; 1184 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1185 : 		}
; 1186 : 
; 1187 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1188 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1189 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1190 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1191 : 		unsigned short *_Pstate = (unsigned short *)&_State;
; 1192 : 		_Mid1 = _First1;
; 1193 : 		_Mid2 = _First2;
; 1194 : 
; 1195 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1196 : 			{	// convert and put a wide char
; 1197 : 			unsigned long _Ch;
; 1198 : 			unsigned short _Ch1 = (unsigned short)*_Mid1;
; 1199 : 			bool _Save = false;
; 1200 : 
; 1201 : 			if (1 < *_Pstate)
; 1202 : 				{	// get saved MS 11 bits from *_Pstate
; 1203 : 				if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
; 1204 : 					return (_Mybase::error);	// bad second word
; 1205 : 				_Ch = (*_Pstate << 10) | (_Ch1 - 0xdc00);
; 1206 : 				}
; 1207 : 			else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
; 1208 : 				{	// get new first word
; 1209 : 				_Ch = (_Ch1 - 0xd800 + 0x0040) << 10;
; 1210 : 				_Save = true;	// put only first byte, rest with second word
; 1211 : 				}
; 1212 : 			else
; 1213 : 				_Ch = _Ch1;	// not first word, just put it
; 1214 : 
; 1215 : 			_Byte _By;
; 1216 : 			int _Nextra;
; 1217 : 
; 1218 : 			if (_Ch < 0x0080)
; 1219 : 				_By = (_Byte)_Ch, _Nextra = 0;
; 1220 : 			else if (_Ch < 0x0800)
; 1221 : 				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
; 1222 : 			else if (_Ch < 0x10000)
; 1223 : 				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
; 1224 : 			else
; 1225 : 				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
; 1226 : 
; 1227 : 			int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;
; 1228 : 
; 1229 : 			if (_Last2 - _Mid2 < _Nput)
; 1230 : 				break;	// not enough room, even without header
; 1231 : 			else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
; 1232 : 				;	// no header to put
; 1233 : 			else if (_Last2 - _Mid2 < 3 + _Nput)
; 1234 : 				break;	// not enough room for header + output
; 1235 : 			else
; 1236 : 				{	// prepend header
; 1237 : 				*_Mid2++ = (_Byte)(unsigned char)0xef;
; 1238 : 				*_Mid2++ = (_Byte)(unsigned char)0xbb;
; 1239 : 				*_Mid2++ = (_Byte)(unsigned char)0xbf;
; 1240 : 				}
; 1241 : 
; 1242 : 			++_Mid1;
; 1243 : 			if (_Save || _Nextra < 3)
; 1244 : 				{	// put first byte of sequence, if not already put
; 1245 : 				*_Mid2++ = _By;
; 1246 : 				--_Nput;
; 1247 : 				}
; 1248 : 			for (; 0 < _Nput; --_Nput)
; 1249 : 				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
; 1250 : 
; 1251 : 			*_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
; 1252 : 			}
; 1253 : 
; 1254 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1255 : 		}
; 1256 : 
; 1257 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
; 1258 : 		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
; 1259 : 		{	// generate bytes to return to default shift state
; 1260 : 		unsigned short *_Pstate = (unsigned short *)&_State;
; 1261 : 		_Mid2 = _First2;
; 1262 : 
; 1263 : 		return (1 < *_Pstate
; 1264 : 			? _Mybase::error : _Mybase::ok);	// fail if trailing first word
; 1265 : 		}
; 1266 : 
; 1267 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 1268 : 		const _Byte *_Last1, size_t _Count) const _THROW0()
; 1269 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1270 : 		size_t _Wchars = 0;
; 1271 : 		_Statype _Mystate = _State;
; 1272 : 
; 1273 : 		for (; _Wchars < _Count && _First1 != _Last1; )
; 1274 : 			{	// convert another wide character
; 1275 : 			const _Byte *_Mid1;
; 1276 : 			_Elem *_Mid2;
; 1277 : 			_Elem _Ch;
; 1278 : 
; 1279 : 			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
; 1280 : 				&_Ch, &_Ch + 1, _Mid2))
; 1281 : 				{	// test result of single wide-char conversion
; 1282 : 			case _Mybase::noconv:
; 1283 : 				return ((int)(_Wchars + (_Last1 - _First1)));
; 1284 : 
; 1285 : 			case _Mybase::ok:
; 1286 : 				if (_Mid2 == &_Ch + 1)
; 1287 : 					++_Wchars;	// replacement do_in might not convert one
; 1288 : 				_First1 = _Mid1;
; 1289 : 				break;
; 1290 : 
; 1291 : 			default:
; 1292 : 				return ((int)_Wchars);	// error or partial
; 1293 : 				}
; 1294 : 			}
; 1295 : 
; 1296 : 		return ((int)_Wchars);
; 1297 : 		}
; 1298 : 
; 1299 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 1300 : 		{	// return true if conversions never change input
; 1301 : 		return (false);
; 1302 : 		}
; 1303 : 
; 1304 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 1305 : 		{	// return maximum length required for a conversion
; 1306 : 		return ((_Mode & _Consume_header) != 0 ? 9	// header + max input
; 1307 : 			: (_Mode & _Generate_header) != 0 ? 7	// header + max output
; 1308 : 			: 6);	// 6-byte max input sequence, no 3-byte header
; 1309 : 		}
; 1310 : 
; 1311 : 	virtual int do_encoding() const _THROW0()
; 1312 : 		{	// return length of code sequence (from codecvt)
; 1313 : 		return (0);	// 0 => varying length
; 1314 : 		}
; 1315 : 
; 1316 : private:
; 1317 : 	unsigned long _Maxcode;	// default: 0x10ffff
; 1318 : 	_Codecvt_mode _Mode;	// default: _Consume_header
; 1319 : 	};
; 1320 : 
; 1321 : 		// CLASS codecvt<char32_t, char, _Mbstatet>
; 1322 : template<>
; 1323 : 	class _CRTIMP2_PURE codecvt<char32_t, char, _Mbstatet>
; 1324 : 	: public codecvt_base
; 1325 : 	{	// facet for converting between char32_t and UTF-8 byte sequences
; 1326 : public:
; 1327 : 	typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
; 1328 : 	typedef char32_t _Elem;
; 1329 : 	typedef char _Byte;
; 1330 : 	typedef _Mbstatet _Statype;
; 1331 : 	typedef _Elem intern_type;
; 1332 : 	typedef _Byte extern_type;
; 1333 : 	typedef _Statype state_type;
; 1334 : 
; 1335 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1336 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1337 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1338 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1339 : 		return (do_in(_State,
; 1340 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1341 : 		}
; 1342 : 
; 1343 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1344 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1345 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1346 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1347 : 		return (do_out(_State,
; 1348 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1349 : 		}
; 1350 : 
; 1351 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1352 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1353 : 		{	// generate bytes to return to default shift state
; 1354 : 		return (do_unshift(_State,
; 1355 : 			_First2, _Last2, _Mid2));
; 1356 : 		}
; 1357 : 
; 1358 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1359 : 		const _Byte *_Last1, size_t _Count) const
; 1360 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1361 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1365 : 
; 1366 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1367 : 		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
; 1368 : 		{	// construct from current locale
; 1369 : 		_BEGIN_LOCINFO(_Lobj)
; 1370 : 			_Init(_Lobj);
; 1371 : 		_END_LOCINFO()
; 1372 : 		}
; 1373 : 
; 1374 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1375 : 		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
; 1376 : 		{	// construct from specified locale
; 1377 : 		_Init(_Lobj);
; 1378 : 		}
; 1379 : 
; 1380 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
; 1381 : 		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
; 1382 : 		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
; 1383 : 		{	// construct from specified locale and parameters
; 1384 : 		_Init(_Lobj);
; 1385 : 		}
; 1386 : 
; 1387 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1388 : 		const locale *_Ploc = 0)
; 1389 : 		{	// return locale category mask and construct standard facet
; 1390 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1391 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1392 : 				_Locinfo(_Ploc->c_str()));
; 1393 : 		return (_X_CTYPE);
; 1394 : 		}
; 1395 : 
; 1396 : protected:
; 1397 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1398 : 		{	// destroy the object
; 1399 : 		}
; 1400 : 
; 1401 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
; 1402 : 		{	// initialize
; 1403 : 		}
; 1404 : 
; 1405 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1406 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1407 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1408 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1409 : 		char *_Pstate = (char *)&_State;
; 1410 : 		_Mid1 = _First1;
; 1411 : 		_Mid2 = _First2;
; 1412 : 
; 1413 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1414 : 			{	// convert a multibyte sequence
; 1415 : 			unsigned char _By = (unsigned char)*_Mid1;
; 1416 : 			unsigned long _Ch;
; 1417 : 			int _Nextra;
; 1418 : 
; 1419 : 			if (_By < 0x80)
; 1420 : 				_Ch = _By, _Nextra = 0;
; 1421 : 			else if (_By < 0xc0)
; 1422 : 				{	// 0x80-0xdf not first byte
; 1423 : 				++_Mid1;
; 1424 : 				return (_Mybase::error);
; 1425 : 				}
; 1426 : 			else if (_By < 0xe0)
; 1427 : 				_Ch = _By & 0x1f, _Nextra = 1;
; 1428 : 			else if (_By < 0xf0)
; 1429 : 				_Ch = _By & 0x0f, _Nextra = 2;
; 1430 : 			else if (_By < 0xf8)
; 1431 : 				_Ch = _By & 0x07, _Nextra = 3;
; 1432 : 			else
; 1433 : 				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;
; 1434 : 
; 1435 : 			if (_Nextra == 0)
; 1436 : 				++_Mid1;
; 1437 : 			else if (_Last1 - _Mid1 < _Nextra + 1)
; 1438 : 				break;	// not enough input
; 1439 : 			else
; 1440 : 				for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
; 1441 : 					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
; 1442 : 						return (_Mybase::error);	// not continuation byte
; 1443 : 					else
; 1444 : 						_Ch = _Ch << 6 | (_By & 0x3f);
; 1445 : 
; 1446 : 			if (*_Pstate == 0)
; 1447 : 				{	// first time, maybe look for and consume header
; 1448 : 				*_Pstate = 1;
; 1449 : 
; 1450 : 				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
; 1451 : 					{	// drop header and retry
; 1452 : 					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
; 1453 : 						_First2, _Last2, _Mid2);
; 1454 : 
; 1455 : 					if (_Ans == _Mybase::partial)
; 1456 : 						{	// roll back header determination
; 1457 : 						*_Pstate = 0;
; 1458 : 						_Mid1 = _First1;
; 1459 : 						}
; 1460 : 					return (_Ans);
; 1461 : 					}
; 1462 : 				}
; 1463 : 
; 1464 : 			if (_Maxcode < _Ch)
; 1465 : 				return (_Mybase::error);	// code too large
; 1466 : 			*_Mid2++ = (_Elem)_Ch;
; 1467 : 			}
; 1468 : 
; 1469 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1470 : 		}
; 1471 : 
; 1472 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1473 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1474 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1475 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1476 : 		char *_Pstate = (char *)&_State;
; 1477 : 		_Mid1 = _First1;
; 1478 : 		_Mid2 = _First2;
; 1479 : 
; 1480 : 		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
; 1481 : 			{	// convert and put a wide char
; 1482 : 			_Byte _By;
; 1483 : 			int _Nextra;
; 1484 : 			unsigned long _Ch = (unsigned long)*_Mid1;
; 1485 : 
; 1486 : 			if (_Maxcode < _Ch)
; 1487 : 				return (_Mybase::error);
; 1488 : 
; 1489 : 			if (_Ch < 0x0080)
; 1490 : 				_By = (_Byte)_Ch, _Nextra = 0;
; 1491 : 			else if (_Ch < 0x0800)
; 1492 : 				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
; 1493 : 			else if (_Ch < 0x00010000)
; 1494 : 				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
; 1495 : 			else if (_Ch < 0x00200000)
; 1496 : 				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
; 1497 : 			else if (_Ch < 0x04000000)
; 1498 : 				_By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
; 1499 : 			else
; 1500 : 				_By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;
; 1501 : 
; 1502 : 			if (*_Pstate == 0)
; 1503 : 				{	// first time, maybe generate header
; 1504 : 				*_Pstate = 1;
; 1505 : 				if ((_Mode & _Generate_header) == 0)
; 1506 : 					;
; 1507 : 				else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
; 1508 : 					return (_Mybase::partial);	// not enough room for both
; 1509 : 				else
; 1510 : 					{	// prepend header
; 1511 : 					*_Mid2++ = (_Byte)(unsigned char)0xef;
; 1512 : 					*_Mid2++ = (_Byte)(unsigned char)0xbb;
; 1513 : 					*_Mid2++ = (_Byte)(unsigned char)0xbf;
; 1514 : 					}
; 1515 : 				}
; 1516 : 
; 1517 : 			if (_Last2 - _Mid2 < 1 + _Nextra)
; 1518 : 				break;	// not enough room for output
; 1519 : 
; 1520 : 			++_Mid1;
; 1521 : 			for (*_Mid2++ = _By; 0 < _Nextra; )
; 1522 : 				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
; 1523 : 			}
; 1524 : 		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
; 1525 : 		}
; 1526 : 
; 1527 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&,
; 1528 : 		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
; 1529 : 		{	// generate bytes to return to default shift state
; 1530 : 		_Mid2 = _First2;
; 1531 : 		return (_Mybase::ok);
; 1532 : 		}
; 1533 : 
; 1534 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 1535 : 		const _Byte *_Last1, size_t _Count) const _THROW0()
; 1536 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1537 : 		int _Wchars = 0;
; 1538 : 		_Statype _Mystate = _State;
; 1539 : 
; 1540 : 		for (; (size_t)_Wchars < _Count && _First1 != _Last1; )
; 1541 : 			{	// convert another wide character
; 1542 : 			const _Byte *_Mid1;
; 1543 : 			_Elem *_Mid2;
; 1544 : 			_Elem _Ch;
; 1545 : 
; 1546 : 			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
; 1547 : 				&_Ch, &_Ch + 1, _Mid2))
; 1548 : 				{	// test result of single wide-char conversion
; 1549 : 			case _Mybase::noconv:
; 1550 : 				return ((int)(_Wchars + (int)(_Last1 - _First1)));
; 1551 : 
; 1552 : 			case _Mybase::ok:
; 1553 : 				if (_Mid2 == &_Ch + 1)
; 1554 : 					++_Wchars;	// replacement do_in might not convert one
; 1555 : 				_First1 = _Mid1;
; 1556 : 				break;
; 1557 : 
; 1558 : 			default:
; 1559 : 				return ((int)_Wchars);	// error or partial
; 1560 : 				}
; 1561 : 			}
; 1562 : 
; 1563 : 		return ((int)_Wchars);
; 1564 : 		}
; 1565 : 
; 1566 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 1567 : 		{	// return true if conversions never change input
; 1568 : 		return (false);
; 1569 : 		}
; 1570 : 
; 1571 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 1572 : 		{	// return maximum length required for a conversion
; 1573 : 		return ((_Mode & (_Consume_header | _Generate_header)) != 0
; 1574 : 			? 9 : 6);
; 1575 : 		}
; 1576 : 
; 1577 : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 1578 : 		{	// return length of code sequence (from codecvt)
; 1579 : 		return ((_Mode & (_Consume_header | _Generate_header)) != 0
; 1580 : 			? -1 : 0);	// -1 => state dependent, 0 => varying length
; 1581 : 		}
; 1582 : 
; 1583 : private:
; 1584 : 	unsigned long _Maxcode;	// default: 0xffffffff
; 1585 : 	_Codecvt_mode _Mode;	// default: _Consume_header
; 1586 : 	};
; 1587 :  #endif /* _HAS_CHAR16_T_LANGUAGE_SUPPORT */
; 1588 : 
; 1589 : 		// CLASS codecvt<wchar_t, char, _Mbstatet>
; 1590 : template<>
; 1591 : 	class _CRTIMP2_PURE codecvt<wchar_t, char, _Mbstatet>
; 1592 : 	: public codecvt_base
; 1593 : 	{	// facet for converting between wchar_t and char (_Byte) sequences
; 1594 : public:
; 1595 : 	typedef wchar_t _Elem;
; 1596 : 	typedef char _Byte;
; 1597 : 	typedef _Mbstatet _Statype;
; 1598 : 	typedef _Elem intern_type;
; 1599 : 	typedef _Byte extern_type;
; 1600 : 	typedef _Statype state_type;
; 1601 : 
; 1602 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1603 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1604 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1605 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1606 : 		return (do_in(_State,
; 1607 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1608 : 		}
; 1609 : 
; 1610 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1611 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1612 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1613 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1614 : 		return (do_out(_State,
; 1615 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1616 : 		}
; 1617 : 
; 1618 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1619 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1620 : 		{	// generate bytes to return to default shift state
; 1621 : 		return (do_unshift(_State,
; 1622 : 			_First2, _Last2, _Mid2));
; 1623 : 		}
; 1624 : 
; 1625 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1626 : 		const _Byte *_Last1, size_t _Count) const
; 1627 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1628 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1629 : 		}
; 1630 : 
; 1631 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1632 : 
; 1633 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1634 : 		: codecvt_base(_Refs)
; 1635 : 		{	// construct from current locale
; 1636 : 		_BEGIN_LOCINFO(_Lobj)
; 1637 : 			_Init(_Lobj);
; 1638 : 		_END_LOCINFO()
; 1639 : 		}
; 1640 : 
; 1641 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1642 : 		: codecvt_base(_Refs)
; 1643 : 		{	// construct from specified locale
; 1644 : 		_Init(_Lobj);
; 1645 : 		}
; 1646 : 
; 1647 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1648 : 		const locale *_Ploc = 0)
; 1649 : 		{	// return locale category mask and construct standard facet
; 1650 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1651 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1652 : 				_Locinfo(_Ploc->c_str()));
; 1653 : 		return (_X_CTYPE);
; 1654 : 		}
; 1655 : 
; 1656 : protected:
; 1657 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1658 : 		{	// destroy the object
; 1659 : 		}
; 1660 : 
; 1661 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 1662 : 		{	// initialize from _Lobj
; 1663 : 		_Cvt = _Lobj._Getcvt();
; 1664 : 		}
; 1665 : 
; 1666 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1667 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1668 : 			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1669 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1670 : 		_DEBUG_RANGE(_First1, _Last1);
; 1671 : 		_DEBUG_RANGE(_First2, _Last2);
; 1672 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1673 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1674 : 		int _Bytes;
; 1675 : 
; 1676 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1677 : 			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
; 1678 : 				&_State, &_Cvt))
; 1679 : 			{	// test result of locale-specific mbrtowc call
; 1680 : 			case -2:	// partial conversion
; 1681 : 				_Mid1 = _Last1;
; 1682 : 				return (_Ans);
; 1683 : 
; 1684 : 			case -1:	// failed conversion
; 1685 : 				return (error);
; 1686 : 
; 1687 : 			case 0:	// may have converted null character
; 1688 : 				if (*_Mid2 == (_Elem)0)
; 1689 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 1690 : 				// fall through
; 1691 : 
; 1692 : 			default:	// converted _Bytes bytes to a wchar_t
; 1693 : 				if (_Bytes == -3)
; 1694 : 					_Bytes = 0;	// wchar_t generated from state info
; 1695 : 				_Mid1 += _Bytes;
; 1696 : 				++_Mid2;
; 1697 : 				_Ans = ok;
; 1698 : 			}
; 1699 : 		return (_Ans);
; 1700 : 		}
; 1701 : 
; 1702 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1703 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1704 : 			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1705 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1706 : 		_DEBUG_RANGE(_First1, _Last1);
; 1707 : 		_DEBUG_RANGE(_First2, _Last2);
; 1708 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1709 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1710 : 		int _Bytes;
; 1711 : 
; 1712 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1713 : 			if ((int)MB_CUR_MAX <= _Last2 - _Mid2)
; 1714 : 				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
; 1715 : 					&_State, &_Cvt)) < 0)
; 1716 : 					return (error);	// locale-specific wcrtomb failed
; 1717 : 				else
; 1718 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1719 : 			else
; 1720 : 				{	// destination too small, convert into buffer
; 1721 : 				_Byte _Buf[MB_LEN_MAX];
; 1722 : 				_Statype _Stsave = _State;
; 1723 : 
; 1724 : 				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
; 1725 : 					&_State, &_Cvt)) < 0)
; 1726 : 					return (error);	// locale-specific wcrtomb failed
; 1727 : 				else if (_Last2 - _Mid2 < _Bytes)
; 1728 : 					{	// converted too many, roll back and return previous
; 1729 : 					_State = _Stsave;
; 1730 : 					return (_Ans);
; 1731 : 					}
; 1732 : 				else
; 1733 : 					{	// copy converted bytes from buffer
; 1734 : 					_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1735 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1736 : 					}
; 1737 : 				}
; 1738 : 		return (_Ans);
; 1739 : 		}
; 1740 : 
; 1741 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
; 1742 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1743 : 		{	// generate bytes to return to default shift state
; 1744 : 		_DEBUG_RANGE(_First2, _Last2);
; 1745 : 		_Mid2 = _First2;
; 1746 : 		result _Ans = ok;
; 1747 : 		int _Bytes;
; 1748 : 		_Byte _Buf[MB_LEN_MAX];
; 1749 : 		_Statype _Stsave = _State;
; 1750 : 
; 1751 : 		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
; 1752 : 			_Ans = error;	// locale-specific wcrtomb failed
; 1753 : 		else if (_Last2 - _Mid2 < --_Bytes)
; 1754 : 			{	// converted too many, roll back and return
; 1755 : 			_State = _Stsave;
; 1756 : 			_Ans = partial;
; 1757 : 			}
; 1758 : 		else if (0 < _Bytes)
; 1759 : 			{	// copy converted bytes from buffer
; 1760 : 			_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1761 : 			_Mid2 += _Bytes;
; 1762 : 			}
; 1763 : 		return (_Ans);
; 1764 : 		}
; 1765 : 
; 1766 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 1767 : 		const _Byte *_Last1, size_t _Count) const
; 1768 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1769 : 		_DEBUG_RANGE(_First1, _Last1);
; 1770 : 		int _Wchars;
; 1771 : 		const _Byte *_Mid1;
; 1772 : 		_Statype _Mystate = _State;
; 1773 : 
; 1774 : 		for (_Wchars = 0, _Mid1 = _First1;
; 1775 : 			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
; 1776 : 			{	// convert another wchar_t
; 1777 : 			int _Bytes;
; 1778 : 			_Elem _Ch;
; 1779 : 
; 1780 : 			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
; 1781 : 				&_Mystate, &_Cvt))
; 1782 : 				{	// test result of locale-specific mbrtowc call
; 1783 : 			case -2:	// partial conversion
; 1784 : 				return (_Wchars);
; 1785 : 
; 1786 : 			case -1:	// failed conversion
; 1787 : 				return (_Wchars);
; 1788 : 
; 1789 : 			case 0:	// may have converted null character
; 1790 : 				if (_Ch == (_Elem)0)
; 1791 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 1792 : 				// fall through
; 1793 : 
; 1794 : 			default:	// converted _Bytes bytes to a wchar_t
; 1795 : 				if (_Bytes == -3)
; 1796 : 					_Bytes = 0;	// wchar_t generated from state info
; 1797 : 				_Mid1 += _Bytes;
; 1798 : 				++_Wchars;
; 1799 : 				}
; 1800 : 			}
; 1801 : 		return (_Wchars);
; 1802 : 		}
; 1803 : 
; 1804 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 1805 : 		{	// return true if conversions never change input
; 1806 : 		return (false);
; 1807 : 		}
; 1808 : 
; 1809 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 1810 : 		{	// return maximum length required for a conversion (from codecvt)
; 1811 : 		return (MB_LEN_MAX);
; 1812 : 		}
; 1813 : 
; 1814 : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 1815 : 		{	// return length of code sequence (from codecvt)
; 1816 : 		return (0);	// 0 => varying length
; 1817 : 		}
; 1818 : 
; 1819 : private:
; 1820 : 	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
; 1821 : 	};
; 1822 : 
; 1823 :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 1824 : 		// CLASS codecvt<unsigned short, char, _Mbstatet>
; 1825 : template<>
; 1826 : 	class _CRTIMP2_PURE codecvt<unsigned short, char, _Mbstatet>
; 1827 : 	: public codecvt_base
; 1828 : 	{	// facet for converting between unsigned short and char sequences
; 1829 : public:
; 1830 : 	typedef unsigned short _Elem;
; 1831 : 	typedef char _Byte;
; 1832 : 	typedef _Mbstatet _Statype;
; 1833 : 	typedef _Elem intern_type;
; 1834 : 	typedef _Byte extern_type;
; 1835 : 	typedef _Statype state_type;
; 1836 : 
; 1837 : 	result __CLR_OR_THIS_CALL in(_Statype& _State,
; 1838 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1839 : 		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1840 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1841 : 		return (do_in(_State,
; 1842 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1843 : 		}
; 1844 : 
; 1845 : 	result __CLR_OR_THIS_CALL out(_Statype& _State,
; 1846 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1847 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1848 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1849 : 		return (do_out(_State,
; 1850 : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
; 1851 : 		}
; 1852 : 
; 1853 : 	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
; 1854 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1855 : 		{	// generate bytes to return to default shift state
; 1856 : 		return (do_unshift(_State,
; 1857 : 			_First2, _Last2, _Mid2));
; 1858 : 		}
; 1859 : 
; 1860 : 	int __CLR_OR_THIS_CALL length(_Statype& _State, const _Byte *_First1,
; 1861 : 		const _Byte *_Last1, size_t _Count) const
; 1862 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 1863 : 		return (do_length(_State, _First1, _Last1, _Count));
; 1864 : 		}
; 1865 : 
; 1866 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 1867 : 
; 1868 : 	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
; 1869 : 		: codecvt_base(_Refs)
; 1870 : 		{	// construct from current locale
; 1871 : 		_BEGIN_LOCINFO(_Lobj)
; 1872 : 			_Init(_Lobj);
; 1873 : 		_END_LOCINFO()
; 1874 : 		}
; 1875 : 
; 1876 : 	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
; 1877 : 		: codecvt_base(_Refs)
; 1878 : 		{	// construct from specified locale
; 1879 : 		_Init(_Lobj);
; 1880 : 		}
; 1881 : 
; 1882 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 1883 : 		const locale *_Ploc = 0)
; 1884 : 		{	// return locale category mask and construct standard facet
; 1885 : 		if (_Ppf != 0 && *_Ppf == 0)
; 1886 : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>(
; 1887 : 				_Locinfo(_Ploc->c_str()));
; 1888 : 		return (_X_CTYPE);
; 1889 : 		}
; 1890 : 
; 1891 : protected:
; 1892 : 	virtual __CLR_OR_THIS_CALL ~codecvt() _NOEXCEPT
; 1893 : 		{	// destroy the object
; 1894 : 		}
; 1895 : 
; 1896 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 1897 : 		{	// initialize from _Lobj
; 1898 : 		_Cvt = _Lobj._Getcvt();
; 1899 : 		}
; 1900 : 
; 1901 : 	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
; 1902 : 		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
; 1903 : 			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
; 1904 : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
; 1905 : 		_DEBUG_RANGE(_First1, _Last1);
; 1906 : 		_DEBUG_RANGE(_First2, _Last2);
; 1907 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1908 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1909 : 		int _Bytes;
; 1910 : 
; 1911 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1912 : 			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
; 1913 : 				&_State, &_Cvt))
; 1914 : 			{	// test result of locale-specific mbrtowc call
; 1915 : 			case -2:	// partial conversion
; 1916 : 				_Mid1 = _Last1;
; 1917 : 				return (_Ans);
; 1918 : 
; 1919 : 			case -1:	// failed conversion
; 1920 : 				return (error);
; 1921 : 
; 1922 : 			case 0:	// may have converted null character
; 1923 : 				if (*_Mid2 == (_Elem)0)
; 1924 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 1925 : 				// fall through
; 1926 : 
; 1927 : 			default:	// converted _Bytes bytes to an unsigned short
; 1928 : 				if (_Bytes == -3)
; 1929 : 					_Bytes = 0;	// wchar_t generated from state info
; 1930 : 				_Mid1 += _Bytes;
; 1931 : 				++_Mid2;
; 1932 : 				_Ans = ok;
; 1933 : 			}
; 1934 : 		return (_Ans);
; 1935 : 		}
; 1936 : 
; 1937 : 	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
; 1938 : 		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
; 1939 : 			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1940 : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
; 1941 : 		_DEBUG_RANGE(_First1, _Last1);
; 1942 : 		_DEBUG_RANGE(_First2, _Last2);
; 1943 : 		_Mid1 = _First1, _Mid2 = _First2;
; 1944 : 		result _Ans = _Mid1 == _Last1 ? ok : partial;
; 1945 : 		int _Bytes;
; 1946 : 
; 1947 : 		while (_Mid1 != _Last1 && _Mid2 != _Last2)
; 1948 : 			if ((int)MB_CUR_MAX <= _Last2 - _Mid2)
; 1949 : 				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
; 1950 : 					&_State, &_Cvt)) < 0)
; 1951 : 					return (error);	// locale-specific wcrtomb failed
; 1952 : 				else
; 1953 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1954 : 			else
; 1955 : 				{	// destination too small, convert into buffer
; 1956 : 				_Byte _Buf[MB_LEN_MAX];
; 1957 : 				_Statype _Stsave = _State;
; 1958 : 
; 1959 : 				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
; 1960 : 					&_State, &_Cvt)) < 0)
; 1961 : 					return (error);	// locale-specific wcrtomb failed
; 1962 : 				else if (_Last2 - _Mid2 < _Bytes)
; 1963 : 					{	// converted too many, roll back and return previous
; 1964 : 					_State = _Stsave;
; 1965 : 					return (_Ans);
; 1966 : 					}
; 1967 : 				else
; 1968 : 					{	// copy converted bytes from buffer
; 1969 : 					_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1970 : 					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
; 1971 : 					}
; 1972 : 				}
; 1973 : 		return (_Ans);
; 1974 : 		}
; 1975 : 
; 1976 : 	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
; 1977 : 		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
; 1978 : 		{	// generate bytes to return to default shift state
; 1979 : 		_DEBUG_RANGE(_First2, _Last2);
; 1980 : 		_Mid2 = _First2;
; 1981 : 		result _Ans = ok;
; 1982 : 		int _Bytes;
; 1983 : 		_Byte _Buf[MB_LEN_MAX];
; 1984 : 		_Statype _Stsave = _State;
; 1985 : 
; 1986 : 		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
; 1987 : 			_Ans = error;	// locale-specific wcrtomb failed
; 1988 : 		else if (_Last2 - _Mid2 < --_Bytes)
; 1989 : 			{	// converted too many, roll back and return
; 1990 : 			_State = _Stsave;
; 1991 : 			_Ans = partial;
; 1992 : 			}
; 1993 : 		else if (0 < _Bytes)
; 1994 : 			{	// copy converted bytes from buffer
; 1995 : 			_CSTD memcpy(_Mid2, _Buf, _Bytes);
; 1996 : 			_Mid2 += _Bytes;
; 1997 : 			}
; 1998 : 		return (_Ans);
; 1999 : 		}
; 2000 : 
; 2001 : 	virtual int __CLR_OR_THIS_CALL do_length(_Statype& _State, const _Byte *_First1,
; 2002 : 		const _Byte *_Last1, size_t _Count) const
; 2003 : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))
; 2004 : 		_DEBUG_RANGE(_First1, _Last1);
; 2005 : 		int _Wchars;
; 2006 : 		const _Byte *_Mid1;
; 2007 : 		_Statype _Mystate = _State;
; 2008 : 
; 2009 : 		for (_Wchars = 0, _Mid1 = _First1;
; 2010 : 			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
; 2011 : 			{	// convert another unsigned char
; 2012 : 			int _Bytes;
; 2013 : 			_Elem _Ch;
; 2014 : 
; 2015 : 			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
; 2016 : 				&_Mystate, &_Cvt))
; 2017 : 				{	// test result of locale-specific mbrtowc call
; 2018 : 			case -2:	// partial conversion
; 2019 : 				return (_Wchars);
; 2020 : 
; 2021 : 			case -1:	// failed conversion
; 2022 : 				return (_Wchars);
; 2023 : 
; 2024 : 			case 0:	// may have converted null character
; 2025 : 				if (_Ch == (_Elem)0)
; 2026 : 					_Bytes = (int)_CSTD strlen(_Mid1) + 1;
; 2027 : 				// fall through
; 2028 : 
; 2029 : 			default:	// converted _Bytes bytes to an unsigned char
; 2030 : 				if (_Bytes == -3)
; 2031 : 					_Bytes = 0;	// wchar_t generated from state info
; 2032 : 				_Mid1 += _Bytes;
; 2033 : 				++_Wchars;
; 2034 : 				}
; 2035 : 			}
; 2036 : 		return (_Wchars);
; 2037 : 		}
; 2038 : 
; 2039 : 	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
; 2040 : 		{	// return true if conversions never change input
; 2041 : 		return (false);
; 2042 : 		}
; 2043 : 
; 2044 : 	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
; 2045 : 		{	// return maximum length required for a conversion (from codecvt)
; 2046 : 		return (MB_LEN_MAX);
; 2047 : 		}
; 2048 : 
; 2049 : 	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
; 2050 : 		{	// return length of code sequence (from codecvt)
; 2051 : 		return (0);	// 0 => varying length
; 2052 : 		}
; 2053 : 
; 2054 : private:
; 2055 : 	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
; 2056 : 	};
; 2057 :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 2058 : 
; 2059 : 		// TEMPLATE CLASS codecvt_byname
; 2060 : template<class _Elem,
; 2061 : 	class _Byte,
; 2062 : 	class _Statype>
; 2063 : 	class codecvt_byname
; 2064 : 		: public codecvt<_Elem, _Byte, _Statype>
; 2065 : 	{	// codecvt for named locale
; 2066 : public:
; 2067 : 	explicit __CLR_OR_THIS_CALL codecvt_byname(const char *_Locname, size_t _Refs = 0)
; 2068 : 		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
; 2069 : 		{	// construct for named locale
; 2070 : 		}
; 2071 : 
; 2072 : 	explicit __CLR_OR_THIS_CALL codecvt_byname(const string& _Str, size_t _Refs = 0)
; 2073 : 		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
; 2074 : 		{	// construct for named locale
; 2075 : 		}
; 2076 : 
; 2077 : protected:
; 2078 : 	virtual __CLR_OR_THIS_CALL ~codecvt_byname() _NOEXCEPT
; 2079 : 		{	// destroy the object
; 2080 : 		}
; 2081 : 	};
; 2082 : 
; 2083 : 		// STRUCT ctype_base
; 2084 :  #pragma warning(push)
; 2085 :  #pragma warning(disable: 4275)
; 2086 : 
; 2087 : struct _CRTIMP2_PURE ctype_base
; 2088 : 	: public locale::facet
; 2089 : 	{	// base for ctype
; 2090 : 	enum
; 2091 : 		{	// constants for character classifications
; 2092 : 		alnum = _DI | _LO | _UP | _XA, alpha = _LO | _UP | _XA,
; 2093 : 		cntrl = _BB, digit = _DI, graph = _DI | _LO | _PU | _UP | _XA,
; 2094 : 		lower = _LO, print = _DI | _LO | _PU | _SP | _UP | _XA | _XD,
; 2095 : 		punct = _PU, space = _CN | _SP | _XS, upper = _UP,
; 2096 : 		xdigit = _XD, blank = _CN | _SP | _XS | _XB};
; 2097 : 	typedef short mask;	// to match <ctype.h>
; 2098 : 
; 2099 : 	__CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0)
; 2100 : 		: locale::facet(_Refs)
; 2101 : 		{	// default constructor
; 2102 : 		}
; 2103 : 
; 2104 : 	__CLR_OR_THIS_CALL ~ctype_base() _NOEXCEPT
; 2105 : 		{	// destroy the object
; 2106 : 		}
; 2107 : 	};
; 2108 : 
; 2109 :  #pragma warning(pop)
; 2110 : 
; 2111 : 		// TEMPLATE CLASS ctype
; 2112 : template<class _Elem>
; 2113 : 	class ctype
; 2114 : 		: public ctype_base
; 2115 : 	{	// facet for classifying elements, converting cases
; 2116 : public:
; 2117 : 	typedef _Elem char_type;
; 2118 : 
; 2119 : 	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
; 2120 : 		{	// test if element fits any mask classifications
; 2121 : 		return (do_is(_Maskval, _Ch));
; 2122 : 		}
; 2123 : 
; 2124 : 	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First, const _Elem *_Last,
; 2125 : 		mask *_Dest) const
; 2126 : 		{	// get mask sequence for elements in [_First, _Last)
; 2127 : 		return (do_is(_First, _Last, _Dest));
; 2128 : 		}
; 2129 : 
; 2130 : 	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem *_First,
; 2131 : 		const _Elem *_Last) const
; 2132 : 		{	// find first in [_First, _Last) that fits mask classification
; 2133 : 		return (do_scan_is(_Maskval, _First, _Last));
; 2134 : 		}
; 2135 : 
; 2136 : 	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem *_First,
; 2137 : 		const _Elem *_Last) const
; 2138 : 		{	// find first in [_First, _Last) not fitting mask classification
; 2139 : 		return (do_scan_not(_Maskval, _First, _Last));
; 2140 : 		}
; 2141 : 
; 2142 : 	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
; 2143 : 		{	// convert element to lower case
; 2144 : 		return (do_tolower(_Ch));
; 2145 : 		}
; 2146 : 
; 2147 : 	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
; 2148 : 		{	// convert [_First, _Last) in place to lower case
; 2149 : 		return (do_tolower(_First, _Last));
; 2150 : 		}
; 2151 : 
; 2152 : 	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
; 2153 : 		{	// convert element to upper case
; 2154 : 		return (do_toupper(_Ch));
; 2155 : 		}
; 2156 : 
; 2157 : 	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
; 2158 : 		{	// convert [_First, _Last) in place to upper case
; 2159 : 		return (do_toupper(_First, _Last));
; 2160 : 		}
; 2161 : 
; 2162 : 	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
; 2163 : 		{	// widen char
; 2164 : 		return (do_widen(_Byte));
; 2165 : 		}
; 2166 : 
; 2167 : 	const char *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
; 2168 : 		_Elem *_Dest) const
; 2169 : 		{	// widen chars in [_First, _Last)
; 2170 : 		return (do_widen(_First, _Last, _Dest));
; 2171 : 		}
; 2172 : 
; 2173 : 	char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
; 2174 : 		{	// narrow element to char
; 2175 : 		return (do_narrow(_Ch, _Dflt));
; 2176 : 		}
; 2177 : 
; 2178 : 	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
; 2179 : 		char _Dflt, char *_Dest) const
; 2180 : 		{	// narrow elements in [_First, _Last) to chars
; 2181 : 		return (do_narrow(_First, _Last, _Dflt, _Dest));
; 2182 : 		}
; 2183 : 
; 2184 : 	__PURE_APPDOMAIN_GLOBAL static locale::id id;
; 2185 : 
; 2186 : 	explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0)
; 2187 : 		: ctype_base(_Refs)
; 2188 : 		{	// construct from current locale
; 2189 : 		_BEGIN_LOCINFO(_Lobj)
; 2190 : 			_Init(_Lobj);
; 2191 : 		_END_LOCINFO()
; 2192 : 		}
; 2193 : 
; 2194 : 	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
; 2195 : 		: ctype_base(_Refs)
; 2196 : 		{	// construct from specified locale
; 2197 : 		_Init(_Lobj);
; 2198 : 		}
; 2199 : 
; 2200 : 	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0,
; 2201 : 		const locale *_Ploc = 0)
; 2202 : 		{	// return locale category mask and construct standard facet
; 2203 : 		if (_Ppf != 0 && *_Ppf == 0)
; 2204 : 			*_Ppf = _NEW_CRT ctype<_Elem>(
; 2205 : 				_Locinfo(_Ploc->c_str()));
; 2206 : 		return (_X_CTYPE);
; 2207 : 		}
; 2208 : 
; 2209 : protected:
; 2210 : 	virtual __CLR_OR_THIS_CALL ~ctype() _NOEXCEPT
; 2211 : 		{	// destroy the object
; 2212 : 		if (_Ctype._Delfl)
; 2213 : 			free((void *)_Ctype._Table);
; 2214 : 
; 2215 : 		free((void *)_Ctype._LocaleName);
; 2216 : 		}
; 2217 : 
; 2218 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 2219 : 		{	// initialize from _Lobj
; 2220 : 		_Ctype = _Lobj._Getctype();
; 2221 : 		_Cvt = _Lobj._Getcvt();
; 2222 : 		}
; 2223 : 
; 2224 : 	virtual bool __CLR_OR_THIS_CALL do_is(mask _Maskval, _Elem _Ch) const
; 2225 : 		{	// test if element fits any mask classifications
; 2226 : 		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
; 2227 : 			& _Maskval) != 0);
; 2228 : 		}
; 2229 : 
; 2230 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_is(const _Elem *_First, const _Elem *_Last,
; 2231 : 		mask *_Dest) const
; 2232 : 		{	// get mask sequence for elements in [_First, _Last)
; 2233 : 		_DEBUG_RANGE(_First, _Last);
; 2234 : 		_DEBUG_POINTER(_Dest);
; 2235 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2236 : 			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
; 2237 : 		return (_First);
; 2238 : 		}
; 2239 : 
; 2240 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_is(mask _Maskval,
; 2241 : 		const _Elem *_First, const _Elem *_Last) const
; 2242 : 		{	// find first in [_First, _Last) that fits mask classification
; 2243 : 		_DEBUG_RANGE(_First, _Last);
; 2244 : 		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
; 2245 : 			;
; 2246 : 		return (_First);
; 2247 : 		}
; 2248 : 
; 2249 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_not(mask _Maskval,
; 2250 : 		const _Elem *_First, const _Elem *_Last) const
; 2251 : 		{	// find first in [_First, _Last) not fitting mask classification
; 2252 : 		_DEBUG_RANGE(_First, _Last);
; 2253 : 		for (; _First != _Last && is(_Maskval, *_First); ++_First)
; 2254 : 			;
; 2255 : 		return (_First);
; 2256 : 		}
; 2257 : 
; 2258 : 	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
; 2259 : 		{	// convert element to lower case
; 2260 : 		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
; 2261 : 		if (_Byte == '\0')
; 2262 : 			return (_Ch);
; 2263 : 		else
; 2264 : 			return (widen((char)_Tolower(_Byte, &_Ctype)));
; 2265 : 		}
; 2266 : 
; 2267 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First,
; 2268 : 		const _Elem *_Last) const
; 2269 : 		{	// convert [_First, _Last) in place to lower case
; 2270 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2271 : 		for (; _First != _Last; ++_First)
; 2272 : 			{	// convert *_First to lower case
; 2273 : 			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
; 2274 : 			if (_Byte != '\0')
; 2275 : 				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
; 2276 : 			}
; 2277 : 		return ((const _Elem *)_First);
; 2278 : 		}
; 2279 : 
; 2280 : 	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
; 2281 : 		{	// convert element to upper case
; 2282 : 		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
; 2283 : 		if (_Byte == '\0')
; 2284 : 			return (_Ch);
; 2285 : 		else
; 2286 : 			return (widen((char)_Toupper(_Byte, &_Ctype)));
; 2287 : 		}
; 2288 : 
; 2289 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First,
; 2290 : 		const _Elem *_Last) const
; 2291 : 		{	// convert [_First, _Last) in place to upper case
; 2292 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2293 : 		for (; _First != _Last; ++_First)
; 2294 : 			{	// convert *_First to upper case
; 2295 : 			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
; 2296 : 			if (_Byte != '\0')
; 2297 : 				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
; 2298 : 			}
; 2299 : 		return ((const _Elem *)_First);
; 2300 : 		}
; 2301 : 
; 2302 : 	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
; 2303 : 		{	// widen char
; 2304 : 		return (_MAKLOCCHR(_Elem, _Byte, _Cvt));
; 2305 : 		}
; 2306 : 
; 2307 : 	virtual const char *__CLR_OR_THIS_CALL do_widen(const char *_First,
; 2308 : 		const char *_Last, _Elem *_Dest) const
; 2309 : 		{	// widen chars in [_First, _Last)
; 2310 : 		_DEBUG_RANGE(_First, _Last);
; 2311 : 		_DEBUG_POINTER(_Dest);
; 2312 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2313 : 			*_Dest = _MAKLOCCHR(_Elem, *_First, _Cvt);
; 2314 : 		return (_First);
; 2315 : 		}
; 2316 : 
; 2317 : 	char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const
; 2318 : 		{	// narrow element to char
; 2319 : 		char _Byte;
; 2320 : 		if (_Ch == (_Elem)0)
; 2321 : 			return ('\0');
; 2322 : 		else if ((_Byte = _MAKLOCBYTE(_Elem, _Ch, _Cvt)) == '\0')
; 2323 : 			return (_Dflt);
; 2324 : 		else
; 2325 : 			return (_Byte);
; 2326 : 		}
; 2327 : 
; 2328 : 	virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const
; 2329 : 		{	// narrow element to char
; 2330 : 		return (_Donarrow(_Ch, _Dflt));
; 2331 : 		}
; 2332 : 
; 2333 : 	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
; 2334 : 		const _Elem *_Last, char _Dflt, char *_Dest) const
; 2335 : 		{	// narrow elements in [_First, _Last) to chars
; 2336 : 		_DEBUG_RANGE(_First, _Last);
; 2337 : 		_DEBUG_POINTER(_Dest);
; 2338 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2339 : 			*_Dest = _Donarrow(*_First, _Dflt);
; 2340 : 		return (_First);
; 2341 : 		}
; 2342 : 
; 2343 : private:
; 2344 : 	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
; 2345 : 	_Locinfo::_Cvtvec _Cvt;		// conversion information
; 2346 : 	};
; 2347 : 
; 2348 : 		// STATIC ctype::id OBJECT
; 2349 : template<class _Elem>
; 2350 : 	locale::id ctype<_Elem>::id;
; 2351 : 
; 2352 : 		// CLASS ctype<char>
; 2353 : template<>
; 2354 : 	class _CRTIMP2_PURE ctype<char>
; 2355 : 	: public ctype_base
; 2356 : 	{	// facet for classifying char elements, converting cases
; 2357 : 	typedef ctype<char> _Myt;
; 2358 : 
; 2359 : public:
; 2360 : 	typedef char _Elem;
; 2361 : 	typedef _Elem char_type;
; 2362 : 
; 2363 : 	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
; 2364 : 		{	// test if element fits any mask classifications
; 2365 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
; 2366 : 		}
; 2367 : 
; 2368 : 	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First,
; 2369 : 		const _Elem *_Last, mask *_Dest) const
; 2370 : 		{	// get mask sequence for elements in [_First, _Last)
; 2371 : 		_DEBUG_RANGE(_First, _Last);
; 2372 : 		_DEBUG_POINTER(_Dest);
; 2373 : 		for (; _First != _Last; ++_First, ++_Dest)
; 2374 : 			*_Dest = _Ctype._Table[(unsigned char)*_First];
; 2375 : 		return (_First);
; 2376 : 		}
; 2377 : 
; 2378 : 	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval,
; 2379 : 		const _Elem *_First, const _Elem *_Last) const
; 2380 : 		{	// find first in [_First, _Last) that fits mask classification
; 2381 : 		_DEBUG_RANGE(_First, _Last);
; 2382 : 		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
; 2383 : 			;
; 2384 : 		return (_First);
; 2385 : 		}
; 2386 : 
; 2387 : 	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval,
; 2388 : 		const _Elem *_First, const _Elem *_Last) const
; 2389 : 		{	// find first in [_First, _Last) not fitting mask classification
; 2390 : 		_DEBUG_RANGE(_First, _Last);
; 2391 : 		for (; _First != _Last && is(_Maskval, *_First); ++_First)
; 2392 : 			;
; 2393 : 		return (_First);
; 2394 : 		}
; 2395 : 
; 2396 : 	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
; 2397 : 		{	// convert element to lower case
; 2398 : 		return (do_tolower(_Ch));
; 2399 : 		}
; 2400 : 
; 2401 : 	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
; 2402 : 		{	// convert [_First, _Last) in place to lower case
; 2403 : 		return (do_tolower(_First, _Last));
; 2404 : 		}
; 2405 : 
; 2406 : 	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
; 2407 : 		{	// convert element to upper case
; 2408 : 		return (do_toupper(_Ch));
; 2409 : 		}
; 2410 : 
; 2411 : 	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
; 2412 : 		{	// convert [_First, _Last) in place to upper case
; 2413 : 		return (do_toupper(_First, _Last));
; 2414 : 		}
; 2415 : 
; 2416 : 	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
; 2417 : 		{	// widen char
; 2418 : 		return (do_widen(_Byte));
; 2419 : 		}
; 2420 : 
; 2421 : 	const _Elem *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
; 2422 : 		_Elem *_Dest) const
; 2423 : 		{	// widen chars in [_First, _Last)
; 2424 : 		return (do_widen(_First, _Last, _Dest));

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR __Atoms$[ebp]
	push	ecx
	push	OFFSET ?_Src@?3??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB+14
	push	OFFSET ?_Src@?3??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld'::`4'::_Src
	mov	ecx, edi
	call	DWORD PTR [eax+28]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 774  : 		if (_First == _Last)

	test	al, al
	jne	SHORT $LN64@Getffld

; 775  : 			;	// empty field
; 776  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])

	mov	ecx, esi
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*

; 777  : 			*_Ptr++ = '+', ++_First;	// gather plus sign

	mov	ecx, esi
	cmp	al, BYTE PTR __Atoms$[ebp+11]
	jne	SHORT $LN66@Getffld
	mov	eax, DWORD PTR __Ac$GSCopy$1$[ebp]
	mov	BYTE PTR [eax], 43			; 0000002bH
	jmp	SHORT $LN1012@Getffld
$LN66@Getffld:

; 778  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	cmp	al, BYTE PTR __Atoms$[ebp+10]
	jne	SHORT $LN64@Getffld

; 779  : 			*_Ptr++ = '-', ++_First;	// gather minus sign

	mov	eax, DWORD PTR __Ac$GSCopy$1$[ebp]
	mov	ecx, esi
	mov	BYTE PTR [eax], 45			; 0000002dH
$LN1012@Getffld:
	lea	ebx, DWORD PTR [eax+1]
	mov	DWORD PTR __Ptr$1$[ebp], ebx
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN64@Getffld:

; 782  : 		int _Significant = 0;	// number of significant digits

	xor	edi, edi
	mov	BYTE PTR __Seendigit$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H
	lea	eax, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 782  : 		int _Significant = 0;	// number of significant digits

	mov	DWORD PTR __Significant$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmovae	eax, DWORD PTR __Grouping$[ebp]
	mov	DWORD PTR __Pg$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 783  : 		int _Pten = 0;	// power of 10 multiplier

	mov	DWORD PTR __Pten$1$[ebp], edi

; 784  : 		size_t _Idx;
; 785  : 
; 786  : 		const char *_Pg = &_Grouping[0];
; 787  : 		if (*_Pg == CHAR_MAX || *_Pg <= '\0')

	mov	al, BYTE PTR [eax]
	cmp	al, 127					; 0000007fH
	je	$LN62@Getffld
	test	al, al
	jle	$LN62@Getffld

; 799  : 					}
; 800  : 		else
; 801  : 			{	// grouping specified, gather digits and group sizes
; 802  : 			const _Elem _Kseparator = _Grouping.size() == 0
; 803  : 				? (_Elem)0 : _Punct_fac.thousands_sep();

	cmp	DWORD PTR __Grouping$[ebp+16], edi
	jne	SHORT $LN72@Getffld
	mov	BYTE PTR __Kseparator$1$[ebp], 0
	jmp	SHORT $LN73@Getffld
$LN72@Getffld:

; 85   : 		}
; 86   : 
; 87   : 	_Elem thousands_sep() const
; 88   : 		{	// return thousands separator
; 89   : 		return (do_thousands_sep());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 799  : 					}
; 800  : 		else
; 801  : 			{	// grouping specified, gather digits and group sizes
; 802  : 			const _Elem _Kseparator = _Grouping.size() == 0
; 803  : 				? (_Elem)0 : _Punct_fac.thousands_sep();

	mov	BYTE PTR __Kseparator$1$[ebp], al
$LN73@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Groups$4[ebp+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	WORD PTR __Groups$4[ebp], di
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Groups$4[ebp+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 804  : 			string _Groups((size_t)1, '\0');

	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 805  : 			size_t _Group = 0;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 807  : 			for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Groups$4[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 807  : 			for (; _First != _Last; ++_First)

	jne	$LL1004@Getffld
	npad	4
$LL53@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN316@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN314@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN320@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN320@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN321@Getffld
$LN320@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN321@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN314@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN313@Getffld
$LN314@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN313@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN316@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR __Atoms$[ebp]
	lea	eax, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	cl, cl
	je	SHORT $LN336@Getffld
$LL338@Getffld:
	cmp	cl, dl
	je	SHORT $LN336@Getffld
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL338@Getffld
$LN336@Getffld:

; 58   : 		;
; 59   : 	return ((size_t)(_Ptr - _Base));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	sub	eax, ecx

; 808  : 				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)

	cmp	eax, 10					; 0000000aH
	jae	SHORT $LN50@Getffld

; 809  : 					{	// got a digit, add to group size
; 810  : 					_Seendigit = true;
; 811  : 					if (_MAX_SIG_DIG <= _Significant)

	mov	ecx, DWORD PTR __Significant$1$[ebp]
	mov	BYTE PTR __Seendigit$1$[ebp], 1
	cmp	ecx, 36					; 00000024H
	jl	SHORT $LN49@Getffld

; 812  : 						++_Pten;	// just scale by 10

	inc	DWORD PTR __Pten$1$[ebp]
	jmp	SHORT $LN46@Getffld
$LN49@Getffld:

; 813  : 					else if (_Idx == 0 && _Significant == 0)

	test	eax, eax
	jne	SHORT $LN47@Getffld
	test	ecx, ecx
	je	SHORT $LN46@Getffld
$LN47@Getffld:

; 814  : 						;	// drop leading zeros
; 815  : 					else
; 816  : 						{	// save a significant digit
; 817  : 						*_Ptr++ = _Src[_Idx];

	mov	edx, DWORD PTR __Ptr$1$[ebp]
	mov	al, BYTE PTR ?_Src@?3??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [edx], al
	inc	edx

; 818  : 						++_Significant;

	inc	ecx
	mov	DWORD PTR __Ptr$1$[ebp], edx
	mov	DWORD PTR __Significant$1$[ebp], ecx
$LN46@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	mov	ecx, DWORD PTR __Groups$4[ebp+20]
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmp	ecx, 16					; 00000010H
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 820  : 					if (_Groups[_Group] != CHAR_MAX)

	cmp	BYTE PTR [eax+edi], 127			; 0000007fH
	je	SHORT $LN52@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	ecx, 16					; 00000010H
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 821  : 						++_Groups[_Group];

	inc	BYTE PTR [eax+edi]

; 822  : 					}
; 823  : 				else if (_Groups[_Group] == '\0'

	jmp	SHORT $LN1013@Getffld
$LN50@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	mov	edx, DWORD PTR __Groups$4[ebp+20]
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmp	edx, 16					; 00000010H
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 825  : 					|| *_First != _Kseparator)

	cmp	BYTE PTR [edi+eax], 0
	je	SHORT $LN920@Getffld
	cmp	BYTE PTR __Kseparator$1$[ebp], 0
	je	SHORT $LN920@Getffld
	mov	ecx, esi
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	cmp	al, BYTE PTR __Kseparator$1$[ebp]
	jne	SHORT $LN1003@Getffld

; 826  : 					break;	// not a group separator, done
; 827  : 				else
; 828  : 					{	// add a new group to _Groups string
; 829  : 					_Groups.append((size_t)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$4[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 830  : 					++_Group;

	inc	edi
$LN1013@Getffld:
	mov	ebx, DWORD PTR __Groups$4[ebp]
$LN52@Getffld:

; 807  : 			for (; _First != _Last; ++_First)

	mov	ecx, esi
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 807  : 			for (; _First != _Last; ++_First)

	je	$LL53@Getffld
$LN1003@Getffld:
	mov	edx, DWORD PTR __Groups$4[ebp+20]
$LN920@Getffld:

; 831  : 					}
; 832  : 			if (_Group == 0)

	test	edi, edi
	je	SHORT $LL1004@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	edx, 16					; 00000010H
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 834  : 			else if ('\0' < _Groups[_Group])

	cmp	BYTE PTR [eax+edi], 0
	jle	SHORT $LN38@Getffld

; 835  : 				++_Group;	// add trailing group to group count

	inc	edi
	npad	2
$LL1004@Getffld:
	mov	eax, DWORD PTR __Pg$1$[ebp]
$LN36@Getffld:

; 838  : 
; 839  : 			while (!_Bad && 0 < _Group)

	test	edi, edi
	je	SHORT $LN1001@Getffld

; 840  : 				if (*_Pg == CHAR_MAX)

	mov	cl, BYTE PTR [eax]
	cmp	cl, 127					; 0000007fH
	je	SHORT $LN1001@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	mov	edx, DWORD PTR __Groups$4[ebp+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 843  : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	dec	edi
	je	SHORT $LN30@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	edx, 16					; 00000010H
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 843  : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	cl, BYTE PTR [eax+edi]
	jne	SHORT $LN38@Getffld
$LN30@Getffld:
	test	edi, edi
	jne	SHORT $LN32@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	edx, 16					; 00000010H
	lea	eax, DWORD PTR __Groups$4[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 843  : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	cl, BYTE PTR [eax]
	jl	SHORT $LN38@Getffld
$LN32@Getffld:

; 838  : 
; 839  : 			while (!_Bad && 0 < _Group)

	mov	eax, DWORD PTR __Pg$1$[ebp]
	inc	eax

; 844  : 					_Bad = true;	// bad group size, fail
; 845  : 				else if ('\0' < _Pg[1])

	cmp	BYTE PTR [eax], 0
	jle	SHORT $LL1004@Getffld

; 846  : 					++_Pg;	// group size okay, advance to next test

	mov	DWORD PTR __Pg$1$[ebp], eax

; 838  : 
; 839  : 			while (!_Bad && 0 < _Group)

	jmp	SHORT $LN36@Getffld
$LN38@Getffld:

; 836  : 			else
; 837  : 				_Bad = true;	// trailing separator, fail

	mov	BYTE PTR __Bad$1$[ebp], 1

; 838  : 
; 839  : 			while (!_Bad && 0 < _Group)

	jmp	SHORT $LN921@Getffld
$LN1001@Getffld:
	mov	edx, DWORD PTR __Groups$4[ebp+20]
$LN921@Getffld:

; 847  : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	edx, 16					; 00000010H
	jb	SHORT $LN1005@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1005@Getffld:
	mov	edi, DWORD PTR __Significant$1$[ebp]
$LN59@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 849  : 		if (_Seendigit && _Significant == 0)

	cmp	BYTE PTR __Seendigit$1$[ebp], 0
	je	SHORT $LN27@Getffld
$LN954@Getffld:
	test	edi, edi
	jne	SHORT $LN27@Getffld

; 850  : 			*_Ptr++ = '0';	// save at least one leading digit

	mov	eax, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	inc	eax
	mov	DWORD PTR __Ptr$1$[ebp], eax
$LN27@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 852  : 		if (_First != _Last && *_First == _Punct_fac.decimal_point())

	jne	$LN1007@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	$LN431@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	$LN429@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN435@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	$LN435@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	$LN436@Getffld
$LN62@Getffld:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 790  : 					_Seendigit = true, ++_First)

	jne	SHORT $LN27@Getffld
$LL104@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN135@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN133@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN139@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN139@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN140@Getffld
$LN139@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN140@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN133@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN132@Getffld
$LN133@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN132@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN135@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR __Atoms$[ebp]
	lea	eax, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	cl, cl
	je	SHORT $LN155@Getffld
	npad	1
$LL157@Getffld:
	cmp	cl, dl
	je	SHORT $LN155@Getffld
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL157@Getffld
$LN155@Getffld:

; 58   : 		;
; 59   : 	return ((size_t)(_Ptr - _Base));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	sub	eax, ecx

; 790  : 					_Seendigit = true, ++_First)

	cmp	eax, 10					; 0000000aH
	jae	$LN59@Getffld

; 791  : 				if (_MAX_SIG_DIG <= _Significant)

	cmp	edi, 36					; 00000024H
	jl	SHORT $LN58@Getffld

; 792  : 					++_Pten;	// just scale by 10

	inc	DWORD PTR __Pten$1$[ebp]
	jmp	SHORT $LN60@Getffld
$LN58@Getffld:

; 793  : 				else if (_Idx == 0 && _Significant == 0)

	test	eax, eax
	jne	SHORT $LN56@Getffld
	test	edi, edi
	je	SHORT $LN60@Getffld
$LN56@Getffld:

; 794  : 					;	// drop leading zeros
; 795  : 				else
; 796  : 					{	// save a significant digit
; 797  : 					*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?3??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [ebx], al
	inc	ebx

; 798  : 					++_Significant;

	inc	edi
	mov	DWORD PTR __Ptr$1$[ebp], ebx
	mov	DWORD PTR __Significant$1$[ebp], edi
$LN60@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 790  : 					_Seendigit = true, ++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN105@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN111@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN111@Getffld

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN112@Getffld
$LN111@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN112@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN105@Getffld

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN925@Getffld
$LN105@Getffld:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN925@Getffld:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 790  : 					_Seendigit = true, ++_First)

	je	$LL104@Getffld

; 849  : 		if (_Seendigit && _Significant == 0)

	jmp	$LN954@Getffld
$LN435@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN436@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN429@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN428@Getffld
$LN429@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN428@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN431@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 84   : 		return (do_decimal_point());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	bl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 84   : 		return (do_decimal_point());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 852  : 		if (_First != _Last && *_First == _Punct_fac.decimal_point())

	cmp	bl, al
	jne	SHORT $LN1007@Getffld

; 853  : 			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	// add .

	call	_localeconv
	mov	ebx, DWORD PTR __Ptr$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ebx], al
	inc	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 853  : 			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	// add .

	mov	DWORD PTR __Ptr$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN456@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN462@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN462@Getffld

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN463@Getffld
$LN462@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN463@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN456@Getffld

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN455@Getffld
$LN456@Getffld:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
	jmp	SHORT $LN455@Getffld
$LN1007@Getffld:
	mov	ebx, DWORD PTR __Ptr$1$[ebp]
$LN455@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 855  : 		if (_Significant == 0)

	test	edi, edi
	jne	$LN21@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 858  : 				_Seendigit = true, ++_First)

	jne	$LN22@Getffld
	mov	ebx, DWORD PTR __Last$GSCopy$1$[ebp]
	mov	edi, DWORD PTR __Pten$1$[ebp]
	npad	2
$LL478@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN509@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN507@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN513@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN513@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN514@Getffld
$LN513@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN514@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN507@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN506@Getffld
$LN507@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN506@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN509@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 858  : 				_Seendigit = true, ++_First)

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	SHORT $LN996@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 859  : 				--_Pten;	// just count leading fraction zeros

	dec	edi
	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN479@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN485@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN485@Getffld

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN486@Getffld
$LN485@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN486@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN479@Getffld

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN926@Getffld
$LN479@Getffld:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN926@Getffld:

; 595  : 	return (_Left.equal(_Right));

	push	ebx
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 858  : 				_Seendigit = true, ++_First)

	je	$LL478@Getffld
$LN996@Getffld:
	mov	ebx, DWORD PTR __Ptr$1$[ebp]
	mov	DWORD PTR __Pten$1$[ebp], edi
	mov	edi, DWORD PTR __Significant$1$[ebp]
$LN22@Getffld:

; 860  : 			if (_Pten < 0)

	mov	eax, DWORD PTR __Pten$1$[ebp]
	test	eax, eax
	jns	SHORT $LN21@Getffld

; 861  : 				*_Ptr++ = '0', ++_Pten;	// put one back

	mov	BYTE PTR [ebx], 48			; 00000030H
	inc	ebx
	inc	eax
	mov	DWORD PTR __Pten$1$[ebp], eax
$LN21@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 866  : 				_Seendigit = true, ++_First)

	jne	$LN18@Getffld
$LL531@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN562@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN560@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN566@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN566@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN567@Getffld
$LN566@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN567@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN560@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN559@Getffld
$LN560@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN559@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN562@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR __Atoms$[ebp]
	lea	eax, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	cl, cl
	je	SHORT $LN582@Getffld
	npad	3
$LL584@Getffld:
	cmp	cl, dl
	je	SHORT $LN582@Getffld
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL584@Getffld
$LN582@Getffld:

; 58   : 		;
; 59   : 	return ((size_t)(_Ptr - _Base));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	sub	eax, ecx

; 866  : 				_Seendigit = true, ++_First)

	cmp	eax, 10					; 0000000aH
	jae	SHORT $LN18@Getffld

; 867  : 			if (_Significant < _MAX_SIG_DIG)

	cmp	edi, 36					; 00000024H
	jge	SHORT $LN19@Getffld

; 868  : 				{	// save a significant fraction digit
; 869  : 				*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?3??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [ebx], al
	inc	ebx
	inc	edi
$LN19@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 866  : 				_Seendigit = true, ++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN532@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN538@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN538@Getffld

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN539@Getffld
$LN538@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN539@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN532@Getffld

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN928@Getffld
$LN532@Getffld:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN928@Getffld:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 866  : 				_Seendigit = true, ++_First)

	je	$LL531@Getffld

; 875  : 				|| *_First == _Atoms[_NUMGET_EOFF]))

	jmp	SHORT $LN955@Getffld
$LN18@Getffld:
	mov	al, BYTE PTR __Seendigit$1$[ebp]
	test	al, al
	je	$LN4@Getffld
$LN955@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 875  : 				|| *_First == _Atoms[_NUMGET_EOFF]))

	jne	$LN1010@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	SHORT $LN597@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN595@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN601@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN601@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN602@Getffld
$LN601@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN602@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN595@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN594@Getffld
$LN595@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN594@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN597@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 875  : 				|| *_First == _Atoms[_NUMGET_EOFF]))

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp+13]
	je	SHORT $LN15@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN623@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN621@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN627@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN627@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN628@Getffld
$LN627@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN628@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN621@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN620@Getffld
$LN621@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN620@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN623@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 875  : 				|| *_First == _Atoms[_NUMGET_EOFF]))

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp+12]
	jne	$LN1010@Getffld
$LN15@Getffld:

; 876  : 			{	// 'e' or 'E', collect exponent
; 877  : 			*_Ptr++ = 'e', ++_First;

	mov	BYTE PTR [ebx], 101			; 00000065H
	inc	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN646@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN652@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN652@Getffld

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN653@Getffld
$LN652@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN653@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN646@Getffld

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN645@Getffld
$LN646@Getffld:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN645@Getffld:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 878  : 			_Seendigit = false, _Significant = 0;

	mov	BYTE PTR __Seendigit$1$[ebp], 0
	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 880  : 			if (_First == _Last)

	test	al, al
	jne	$LN917@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	SHORT $LN674@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN672@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN678@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN678@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN679@Getffld
$LN678@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN679@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN672@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN671@Getffld
$LN672@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], edi
$LN671@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN674@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 882  : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp+11]
	jne	SHORT $LN12@Getffld

; 883  : 				*_Ptr++ = '+', ++_First;	// gather plus sign

	mov	BYTE PTR [ebx], 43			; 0000002bH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN1016@Getffld
$LN12@Getffld:

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN723@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN721@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN727@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN727@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN728@Getffld
$LN727@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN728@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN721@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN720@Getffld
$LN721@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], edi
$LN720@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN723@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 884  : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp+10]
	jne	SHORT $LN917@Getffld

; 885  : 				*_Ptr++ = '-', ++_First;	// gather minus sign

	mov	BYTE PTR [ebx], 45			; 0000002dH
$LN1016@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 885  : 				*_Ptr++ = '-', ++_First;	// gather minus sign

	inc	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN746@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN752@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN752@Getffld

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN753@Getffld
$LN752@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN753@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN746@Getffld

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN917@Getffld
$LN746@Getffld:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	DWORD PTR [esi], edi
$LN917@Getffld:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 886  : 			for (; _First != _Last && *_First == _Atoms[0]; )

	jne	$LN7@Getffld
	npad	7
$LL9@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN776@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN774@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN780@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], edi
	jle	SHORT $LN780@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN781@Getffld
$LN780@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN781@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN774@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN773@Getffld
$LN774@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], edi
$LN773@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN776@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 886  : 			for (; _First != _Last && *_First == _Atoms[0]; )

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	SHORT $LN8@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 887  : 				_Seendigit = true, ++_First;	// strip leading zeros

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN799@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], edi
	je	SHORT $LN805@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN805@Getffld

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN806@Getffld
$LN805@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN806@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN799@Getffld

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN798@Getffld
$LN799@Getffld:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], edi
	mov	BYTE PTR [esi+4], 1
$LN798@Getffld:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 886  : 			for (; _First != _Last && *_First == _Atoms[0]; )

	je	$LL9@Getffld

; 888  : 			if (_Seendigit)

	jmp	SHORT $LN956@Getffld
$LN8@Getffld:
	cmp	BYTE PTR __Seendigit$1$[ebp], 0
	je	SHORT $LN7@Getffld
$LN956@Getffld:

; 889  : 				*_Ptr++ = '0';	// put one back

	mov	BYTE PTR [ebx], 48			; 00000030H
	inc	ebx
$LN7@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 892  : 				_Seendigit = true, ++_First)

	jne	$LN1010@Getffld
$LL821@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN852@Getffld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN850@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN856@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN856@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN857@Getffld
$LN856@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN857@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN850@Getffld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN849@Getffld
$LN850@Getffld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN849@Getffld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN852@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR __Atoms$[ebp]
	lea	eax, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	cl, cl
	je	SHORT $LN872@Getffld
$LL874@Getffld:
	cmp	cl, dl
	je	SHORT $LN872@Getffld
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL874@Getffld
$LN872@Getffld:

; 58   : 		;
; 59   : 	return ((size_t)(_Ptr - _Base));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	sub	eax, ecx

; 892  : 				_Seendigit = true, ++_First)

	cmp	eax, 10					; 0000000aH
	jae	SHORT $LN1010@Getffld

; 893  : 				if (_Significant < _MAX_EXP_DIG)

	cmp	edi, 8
	jge	SHORT $LN5@Getffld

; 894  : 					{	// save a significant exponent digit
; 895  : 					*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?3??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[eax]
	mov	BYTE PTR [ebx], al
	inc	ebx

; 896  : 					++_Significant;

	inc	edi
$LN5@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 892  : 				_Seendigit = true, ++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	test	ecx, ecx
	je	SHORT $LN822@Getffld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN828@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN828@Getffld

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN829@Getffld
$LN828@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN829@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN822@Getffld

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN930@Getffld
$LN822@Getffld:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN930@Getffld:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 892  : 				_Seendigit = true, ++_First)

	je	$LL821@Getffld
$LN1010@Getffld:
	mov	al, BYTE PTR __Seendigit$1$[ebp]
$LN4@Getffld:

; 897  : 					}
; 898  : 			}
; 899  : 
; 900  : 		if (_Bad || !_Seendigit)

	cmp	BYTE PTR __Bad$1$[ebp], 0
	jne	SHORT $LN1@Getffld
	test	al, al
	jne	SHORT $LN2@Getffld
$LN1@Getffld:

; 901  : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	ebx, DWORD PTR __Ac$GSCopy$1$[ebp]
$LN2@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 902  : 		*_Ptr = '\0';

	mov	BYTE PTR [ebx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN897@Getffld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Grouping$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN897@Getffld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 903  : 		return (_Pten);

	mov	eax, DWORD PTR __Pten$1$[ebp]
$LN70@Getffld:

; 904  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3:
	lea	ecx, DWORD PTR __Groups$4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
_TEXT	SEGMENT
__Dlen$1$ = -112					; size = 4
__Ac$GSCopy$1$ = -108					; size = 4
__Last$GSCopy$1$ = -104					; size = 4
__Ptr$1$ = -100						; size = 4
__Kseparator$1$ = -95					; size = 1
__Nonzero$1$ = -94					; size = 1
__Seendigit$1$ = -93					; size = 1
__Grouping$ = -92					; size = 24
__Groups$ = -68						; size = 24
__Atoms$ = -44						; size = 26
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Basefield$ = 24					; size = 4
__Loc$ = 28						; size = 4
?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld, COMDAT

; 656  : 		{	// get integer field from [_First, _Last) into _Ac

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ac$[ebp]
	mov	ebx, DWORD PTR __Loc$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Ac$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]

; 657  : 		const _Mypunct& _Punct_fac = _USE(_Loc, _Mypunct);

	push	ebx
	mov	DWORD PTR __Last$GSCopy$1$[ebp], eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	edi, eax

; 658  : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[ebp]
	mov	ecx, edi
	push	eax
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping

; 659  : 		const _Elem _Kseparator = _Grouping.size() == 0
; 660  : 			? (_Elem)0 : _Punct_fac.thousands_sep();

	cmp	DWORD PTR __Grouping$[ebp+16], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	jne	SHORT $LN41@Getifld
	mov	BYTE PTR __Kseparator$1$[ebp], 0
	jmp	SHORT $LN42@Getifld
$LN41@Getifld:

; 60   : 	}
; 61   : 
; 62   : inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
; 63   : 	{	// copy NTWCS to allocated storage
; 64   : 	size_t _Count = _CSTD wcslen(_Ptr) + 1;
; 65   : 	wchar_t *_Ptrdest = _NEW_CRT wchar_t[_Count];
; 66   : 	_CSTD wmemcpy(_Ptrdest, _Ptr, _Count);
; 67   : 	return (_Ptrdest);
; 68   : 	}
; 69   : 
; 70   : 		// TEMPLATE CLASS numpunct
; 71   : template<class _Elem>
; 72   : 	class numpunct
; 73   : 		: public locale::facet
; 74   : 	{	// facet for defining numeric punctuation text
; 75   : public:
; 76   : 	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
; 77   : 		string_type;
; 78   : 	typedef _Elem char_type;
; 79   : 
; 80   : 	__PURE_APPDOMAIN_GLOBAL _CRTIMP2_PURE static locale::id id;	// unique facet id
; 81   : 
; 82   : 	_Elem decimal_point() const
; 83   : 		{	// return decimal point
; 84   : 		return (do_decimal_point());
; 85   : 		}
; 86   : 
; 87   : 	_Elem thousands_sep() const
; 88   : 		{	// return thousands separator
; 89   : 		return (do_thousands_sep());

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 659  : 		const _Elem _Kseparator = _Grouping.size() == 0
; 660  : 			? (_Elem)0 : _Punct_fac.thousands_sep();

	mov	BYTE PTR __Kseparator$1$[ebp], al
$LN42@Getifld:

; 661  : 
; 662  : 		enum {
; 663  : 			_NUMGET_SIGNOFF = 22,
; 664  : 			_NUMGET_XOFF = 24};
; 665  : 		static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
; 666  : 		_Elem _Atoms[sizeof (_Src) - 1];
; 667  : 		const ctype<_Elem>& _Ctype_fac =
; 668  : 			_USE(_Loc, ctype<_Elem>);

	push	ebx
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2424 : 		return (do_widen(_First, _Last, _Dest));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB+26
	push	OFFSET ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld'::`2'::_Src
	mov	ecx, eax
	call	DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 671  : 		char *_Ptr = _Ac;

	mov	ebx, DWORD PTR __Ac$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 671  : 		char *_Ptr = _Ac;

	mov	DWORD PTR __Ptr$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 673  : 		if (_First == _Last)

	test	al, al
	jne	SHORT $LN34@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	SHORT $LN65@Getifld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN63@Getifld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN69@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN69@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN70@Getifld
$LN69@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN70@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN63@Getifld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN62@Getifld
$LN63@Getifld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN62@Getifld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN65@Getifld:

; 514  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 676  : 			*_Ptr++ = '+', ++_First;	// gather plus sign

	mov	ecx, esi
	cmp	al, BYTE PTR __Atoms$[ebp+23]
	jne	SHORT $LN36@Getifld
	mov	BYTE PTR [ebx], 43			; 0000002bH
	jmp	SHORT $LN488@Getifld
$LN36@Getifld:

; 677  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	cmp	al, BYTE PTR __Atoms$[ebp+22]
	jne	SHORT $LN34@Getifld

; 678  : 			*_Ptr++ = '-', ++_First;	// gather minus sign

	mov	BYTE PTR [ebx], 45			; 0000002dH
	mov	ecx, esi
$LN488@Getifld:
	lea	eax, DWORD PTR [ebx+1]
	mov	DWORD PTR __Ptr$1$[ebp], eax
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
$LN34@Getifld:

; 679  : 
; 680  : 		_Basefield &= ios_base::basefield;

	mov	ebx, DWORD PTR __Basefield$[ebp]
	and	ebx, 3584				; 00000e00H

; 683  : 			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

	cmp	ebx, 1024				; 00000400H
	jne	SHORT $LN45@Getifld
	mov	ebx, 8
	jmp	SHORT $LN489@Getifld
$LN45@Getifld:
	cmp	ebx, 2048				; 00000800H
	jne	SHORT $LN43@Getifld
	mov	ebx, 16					; 00000010H
	jmp	SHORT $LN489@Getifld
$LN43@Getifld:
	neg	ebx
	sbb	ebx, ebx
	and	ebx, 10					; 0000000aH
$LN489@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	edi
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 683  : 			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

	mov	DWORD PTR __Basefield$[ebp], ebx

; 684  : 
; 685  : 		bool _Seendigit = false;	// seen a digit in input

	mov	BYTE PTR __Seendigit$1$[ebp], 0

; 686  : 		bool _Nonzero = false;	// seen a nonzero digit in input

	mov	BYTE PTR __Nonzero$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 596  : 	}
; 597  : 
; 598  : template<class _Elem,
; 599  : 	class _Traits> inline
; 600  : 	bool __CLR_OR_THIS_CALL operator!=(
; 601  : 		const istreambuf_iterator<_Elem, _Traits>& _Left,
; 602  : 		const istreambuf_iterator<_Elem, _Traits>& _Right)
; 603  : 	{	// test for istreambuf_iterator inequality
; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 688  : 		if (_First != _Last && *_First == _Atoms[0])

	jne	$LN28@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	SHORT $LN95@Getifld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN93@Getifld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN99@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN99@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN100@Getifld
$LN99@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN100@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN93@Getifld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN92@Getifld
$LN93@Getifld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN92@Getifld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN95@Getifld:

; 514  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 688  : 		if (_First != _Last && *_First == _Atoms[0])

	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	SHORT $LN28@Getifld

; 689  : 			{	// leading zero, look for 0x, 0X
; 690  : 			_Seendigit = true, ++_First;

	mov	ecx, esi
	mov	BYTE PTR __Seendigit$1$[ebp], 1
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	edi
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 596  : 	}
; 597  : 
; 598  : template<class _Elem,
; 599  : 	class _Traits> inline
; 600  : 	bool __CLR_OR_THIS_CALL operator!=(
; 601  : 		const istreambuf_iterator<_Elem, _Traits>& _Left,
; 602  : 		const istreambuf_iterator<_Elem, _Traits>& _Right)
; 603  : 	{	// test for istreambuf_iterator inequality
; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 693  : 				&& (_Base == 0 || _Base == 16))

	jne	SHORT $LN32@Getifld
	mov	ecx, esi
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	cmp	al, BYTE PTR __Atoms$[ebp+25]
	je	SHORT $LN31@Getifld
	mov	ecx, esi
	call	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
	cmp	al, BYTE PTR __Atoms$[ebp+24]
	jne	SHORT $LN32@Getifld
$LN31@Getifld:
	test	ebx, ebx
	je	SHORT $LN30@Getifld
	cmp	ebx, 16					; 00000010H
	jne	SHORT $LN32@Getifld
$LN30@Getifld:

; 694  : 				_Base = 16, _Seendigit = false, ++_First;

	mov	ebx, 16					; 00000010H
	mov	BYTE PTR __Seendigit$1$[ebp], 0
	mov	ecx, esi
	mov	DWORD PTR __Basefield$[ebp], ebx
	call	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
	jmp	SHORT $LN480@Getifld
$LN32@Getifld:

; 695  : 			else if (_Base == 0)

	test	ebx, ebx
	jne	SHORT $LN479@Getifld

; 696  : 				_Base = 8;

	mov	ebx, 8
	mov	DWORD PTR __Basefield$[ebp], ebx

; 697  : 			}
; 698  : 
; 699  : 		size_t _Dlen = _Base == 0 || _Base == 10 ? 10
; 700  : 			: _Base == 8 ? 8 : 16 + 6;

	jmp	SHORT $LN480@Getifld
$LN28@Getifld:
	test	ebx, ebx
	je	SHORT $LN47@Getifld
$LN479@Getifld:
	cmp	ebx, 10					; 0000000aH
	je	SHORT $LN47@Getifld
$LN480@Getifld:
	mov	ecx, 8
	mov	eax, 22					; 00000016H
	cmp	ebx, ecx
	cmove	eax, ecx
	mov	DWORD PTR __Dlen$1$[ebp], eax
	jmp	SHORT $LN48@Getifld
$LN47@Getifld:
	mov	DWORD PTR __Dlen$1$[ebp], 10		; 0000000aH
$LN48@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	al, BYTE PTR __Seendigit$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ebx, 15					; 0000000fH
	mov	DWORD PTR __Groups$[ebp+20], ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR __Groups$[ebp], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Groups$[ebp+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR __Groups$[ebp+1], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 701  : 		string _Groups((size_t)1, (char)_Seendigit);

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 702  : 		size_t _Group = 0;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 596  : 	}
; 597  : 
; 598  : template<class _Elem,
; 599  : 	class _Traits> inline
; 600  : 	bool __CLR_OR_THIS_CALL operator!=(
; 601  : 		const istreambuf_iterator<_Elem, _Traits>& _Left,
; 602  : 		const istreambuf_iterator<_Elem, _Traits>& _Right)
; 603  : 	{	// test for istreambuf_iterator inequality
; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 705  : 			_First != _Last; ++_First)

	jne	$LN13@Getifld
	jmp	SHORT $LN263@Getifld
$LL485@Getifld:
	mov	ebx, DWORD PTR __Groups$[ebp+20]
$LN263@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN294@Getifld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN292@Getifld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN298@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN298@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN299@Getifld
$LN298@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN299@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN292@Getifld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN291@Getifld
$LN292@Getifld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN291@Getifld:

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN294@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR __Atoms$[ebp]
	lea	eax, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 514  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 57   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	cl, cl
	je	SHORT $LN314@Getifld
$LL316@Getifld:
	cmp	cl, dl
	je	SHORT $LN314@Getifld
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL316@Getifld
$LN314@Getifld:

; 58   : 		;
; 59   : 	return ((size_t)(_Ptr - _Base));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	sub	eax, ecx

; 706  : 			{	// look for digits and separators
; 707  : 			size_t _Idx = _Find_elem(_Atoms, *_First);
; 708  : 			if (_Idx < _Dlen)

	cmp	eax, DWORD PTR __Dlen$1$[ebp]
	jae	SHORT $LN24@Getifld

; 709  : 				{	// got a digit, characterize it and add to group size
; 710  : 				*_Ptr = _Src[_Idx];
; 711  : 				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)

	cmp	BYTE PTR __Nonzero$1$[ebp], 0
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	al, BYTE PTR ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB[eax]
	mov	BYTE PTR [ecx], al
	jne	SHORT $LN22@Getifld
	cmp	al, 48					; 00000030H
	je	SHORT $LN23@Getifld
$LN22@Getifld:
	mov	edx, DWORD PTR __Ac$GSCopy$1$[ebp]
	lea	eax, DWORD PTR [edx+31]
	cmp	ecx, eax
	jae	SHORT $LN23@Getifld

; 712  : 					++_Ptr, _Nonzero = true;

	inc	ecx
	mov	BYTE PTR __Nonzero$1$[ebp], 1
	mov	DWORD PTR __Ptr$1$[ebp], ecx
$LN23@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	ebx, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 713  : 				_Seendigit = true;

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	mov	ebx, DWORD PTR __Groups$[ebp]
	lea	eax, DWORD PTR __Groups$[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 714  : 				if (_Groups[_Group] != CHAR_MAX)

	cmp	BYTE PTR [eax+edi], 127			; 0000007fH
	je	$LN26@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groups$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR __Groups$[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 715  : 					++_Groups[_Group];

	inc	BYTE PTR [eax+edi]

; 716  : 				}
; 717  : 			else if (_Groups[_Group] == '\0'

	jmp	SHORT $LN490@Getifld
$LN24@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	ebx, 16					; 00000010H
	lea	eax, DWORD PTR __Groups$[ebp]
	mov	ebx, DWORD PTR __Groups$[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 719  : 				|| *_First != _Kseparator)

	cmp	BYTE PTR [eax+edi], 0
	je	$LN468@Getifld
	mov	al, BYTE PTR __Kseparator$1$[ebp]
	test	al, al
	je	$LN468@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 506  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN349@Getifld

; 568  : 				_Meta = _Strbuf->sgetc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN347@Getifld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN353@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN353@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LN354@Getifld
$LN353@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN354@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 568  : 				_Meta = _Strbuf->sgetc()))

	je	SHORT $LN347@Getifld

; 570  : 		else
; 571  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN346@Getifld
$LN347@Getifld:

; 569  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN346@Getifld:
	mov	al, BYTE PTR __Kseparator$1$[ebp]

; 572  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN349@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 719  : 				|| *_First != _Kseparator)

	cmp	BYTE PTR [esi+5], al
	jne	SHORT $LN468@Getifld

; 720  : 				break;	// not a group separator, done
; 721  : 			else
; 722  : 				{	// add a new group to _Groups string
; 723  : 				_Groups.append((string::size_type)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 724  : 				++_Group;

	inc	edi
$LN490@Getifld:
	mov	ebx, DWORD PTR __Groups$[ebp]
$LN26@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN264@Getifld

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN270@Getifld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN270@Getifld

; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN271@Getifld
$LN270@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN271@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 557  : 				_Strbuf->sbumpc()))

	je	SHORT $LN264@Getifld

; 559  : 		else
; 560  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN471@Getifld
$LN264@Getifld:

; 558  : 			_Strbuf = 0, _Got = true;

	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
$LN471@Getifld:

; 595  : 	return (_Left.equal(_Right));

	push	DWORD PTR __Last$GSCopy$1$[ebp]
	mov	ecx, esi
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal

; 596  : 	}
; 597  : 
; 598  : template<class _Elem,
; 599  : 	class _Traits> inline
; 600  : 	bool __CLR_OR_THIS_CALL operator!=(
; 601  : 		const istreambuf_iterator<_Elem, _Traits>& _Left,
; 602  : 		const istreambuf_iterator<_Elem, _Traits>& _Right)
; 603  : 	{	// test for istreambuf_iterator inequality
; 604  : 	return (!(_Left == _Right));

	test	al, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 705  : 			_First != _Last; ++_First)

	je	$LL485@Getifld
$LN468@Getifld:

; 725  : 				}
; 726  : 			}
; 727  : 
; 728  : 		if (_Group == 0)

	test	edi, edi
	je	SHORT $LN13@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groups$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR __Groups$[ebp]
	cmovae	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 730  : 		else if ('\0' < _Groups[_Group])

	cmp	BYTE PTR [eax+edi], 0
	jle	SHORT $LN14@Getifld

; 731  : 			++_Group;	// add trailing group to group count

	inc	edi

; 732  : 		else

	jmp	SHORT $LN13@Getifld
$LN14@Getifld:

; 733  : 			_Seendigit = false;	// trailing separator, fail

	mov	BYTE PTR __Seendigit$1$[ebp], 0
$LN13@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	mov	esi, DWORD PTR __Grouping$[ebp+20]
	lea	edx, DWORD PTR __Grouping$[ebp]
	mov	ebx, DWORD PTR __Grouping$[ebp]
	cmp	esi, 16					; 00000010H
	cmovae	edx, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 735  : 		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )

	cmp	BYTE PTR __Seendigit$1$[ebp], 0
	je	SHORT $LN478@Getifld
	npad	1
$LL12@Getifld:
	test	edi, edi
	je	SHORT $LN469@Getifld

; 736  : 			if (*_Pg == CHAR_MAX)

	mov	cl, BYTE PTR [edx]
	cmp	cl, 127					; 0000007fH
	je	SHORT $LN469@Getifld

; 739  : 				|| (0 == _Group && *_Pg < _Groups[_Group]))

	dec	edi
	je	SHORT $LN6@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groups$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR __Groups$[ebp]
	cmovae	eax, DWORD PTR __Groups$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 739  : 				|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	cl, BYTE PTR [eax+edi]
	jne	SHORT $LN478@Getifld
$LN6@Getifld:
	test	edi, edi
	jne	SHORT $LN8@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Groups$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR __Groups$[ebp]
	cmovae	eax, DWORD PTR __Groups$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 739  : 				|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	cl, BYTE PTR [eax]
	jl	SHORT $LN478@Getifld
$LN8@Getifld:

; 740  : 				_Seendigit = false;	// bad group size, fail
; 741  : 			else if ('\0' < _Pg[1])

	cmp	BYTE PTR [edx+1], 0
	jle	SHORT $LL12@Getifld

; 742  : 				++_Pg;	// group size okay, advance to next test

	inc	edx

; 735  : 		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )

	jmp	SHORT $LL12@Getifld
$LN469@Getifld:

; 743  : 
; 744  : 		if (_Seendigit && !_Nonzero)

	cmp	BYTE PTR __Nonzero$1$[ebp], 0

; 745  : 			*_Ptr++ = '0';	// zero field, replace stripped zero(s)

	mov	eax, DWORD PTR __Ptr$1$[ebp]
	jne	SHORT $LN1@Getifld
	mov	BYTE PTR [eax], 48			; 00000030H
	inc	eax
	jmp	SHORT $LN1@Getifld
$LN478@Getifld:

; 746  : 		else if (!_Seendigit)
; 747  : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	eax, DWORD PTR __Ac$GSCopy$1$[ebp]
$LN1@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR __Groups$[ebp+20], 16		; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 748  : 		*_Ptr = '\0';

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN421@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Groups$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	mov	esi, DWORD PTR __Grouping$[ebp+20]
	add	esp, 4
	mov	ebx, DWORD PTR __Grouping$[ebp]
$LN421@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	esi, 16					; 00000010H
	jb	SHORT $LN482@Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN482@Getifld:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 749  : 		return (_Base);

	mov	eax, DWORD PTR __Basefield$[ebp]

; 750  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$0:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$1:
	lea	ecx, DWORD PTR __Groups$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
_TEXT	SEGMENT
__Ans$ = -72						; size = 8
__Val$GSCopy$1$ = -64					; size = 4
$T2 = -60						; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 624  : 		{	// get void pointer from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax

; 631  : 			_Iosbase.getloc());	// gather field

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	DWORD PTR __Errno$[ebp], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	push	2048					; 00000800H
	lea	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	esi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 631  : 			_Iosbase.getloc());	// gather field

	add	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN13@do_get

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN13@do_get
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN13@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 635  : 				: _CSTD _Stoullx(_Ac, &_Ep, _Base, &_Errno);

	lea	eax, DWORD PTR __Errno$[ebp]
	push	eax
	push	esi
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stoulx
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Ans$[ebp+4], 0
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	ecx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 643  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN4@do_get

; 644  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [edi], 1
$LN4@do_get:

; 645  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN2@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN2@do_get

; 647  : 		else
; 648  : 			_Val = (void *)((char *)0 + _Ans);	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN1@do_get
$LN2@do_get:

; 646  : 			_State |= ios_base::failbit;

	or	DWORD PTR [edi], 2
$LN1@do_get:

; 649  : 		return (_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, ebx
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ebx+4], ecx

; 650  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
_TEXT	SEGMENT
__Ans$ = -84						; size = 8
__Ep$ = -76						; size = 4
__Hexexp$ = -72						; size = 4
__Errno$ = -68						; size = 4
__Ac$ = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 600  : 		{	// get long double from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR __Iosbase$[ebp]

; 601  : 		_DEBUG_RANGE(_First, _Last);
; 602  : 		char _Ac[_MAX_EXP_DIG + _MAX_SIG_DIG + 16], *_Ep;
; 603  : 		int _Errno = 0;
; 604  : 		int _Hexexp = 0;
; 605  : 		long double _Ans = _CSTD _Stoldx(_Ac, &_Ep,
; 606  : 			_Getffld(_Ac, _First, _Last,
; 607  : 				_Iosbase, &_Hexexp), &_Errno);	// gather field, convert

	lea	edx, DWORD PTR __Errno$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Val$[ebp]
	push	esi
	mov	esi, DWORD PTR __State$[ebp]
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	lea	edx, DWORD PTR __Hexexp$[ebp]
	mov	DWORD PTR __Errno$[ebp], 0
	push	edx
	push	eax
	lea	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Hexexp$[ebp], 0
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	ecx
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stoldx

; 608  : 
; 609  : 		if (_Hexexp != 0)

	mov	eax, DWORD PTR __Hexexp$[ebp]
	add	esp, 16					; 00000010H
	fstp	QWORD PTR __Ans$[ebp]
	test	eax, eax
	je	SHORT $LN5@do_get
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 896  :     return ldexp((double)_X, _Y);

	movsd	xmm0, QWORD PTR __Ans$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 610  : 			_Ans = _CSTD ldexpl(_Ans, 4 * _Hexexp);

	shl	eax, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 896  :     return ldexp((double)_X, _Y);

	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 610  : 			_Ans = _CSTD ldexpl(_Ans, 4 * _Hexexp);

	fstp	QWORD PTR __Ans$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 896  :     return ldexp((double)_X, _Y);

	add	esp, 12					; 0000000cH
$LN5@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 612  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN4@do_get

; 613  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [esi], 1
$LN4@do_get:

; 614  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN2@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN2@do_get

; 616  : 		else
; 617  : 			_Val = _Ans;	// deliver value

	movsd	xmm0, QWORD PTR __Ans$[ebp]
	movsd	QWORD PTR [ebx], xmm0
	jmp	SHORT $LN1@do_get
$LN2@do_get:

; 615  : 			_State |= ios_base::failbit;

	or	DWORD PTR [esi], 2
$LN1@do_get:

; 618  : 		return (_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, edi
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edi+4], ecx

; 619  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
_TEXT	SEGMENT
__Ans$ = -84						; size = 8
__Ep$ = -76						; size = 4
__Hexexp$ = -72						; size = 4
__Errno$ = -68						; size = 4
__Ac$ = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 576  : 		{	// get double from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR __Iosbase$[ebp]

; 577  : 		_DEBUG_RANGE(_First, _Last);
; 578  : 		char _Ac[_MAX_EXP_DIG + _MAX_SIG_DIG + 16], *_Ep;
; 579  : 		int _Errno = 0;
; 580  : 		int _Hexexp = 0;
; 581  : 		double _Ans = _CSTD _Stodx(_Ac, &_Ep,
; 582  : 			_Getffld(_Ac, _First, _Last,
; 583  : 				_Iosbase, &_Hexexp), &_Errno);	// gather field, convert

	lea	edx, DWORD PTR __Errno$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Val$[ebp]
	push	esi
	mov	esi, DWORD PTR __State$[ebp]
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	lea	edx, DWORD PTR __Hexexp$[ebp]
	mov	DWORD PTR __Errno$[ebp], 0
	push	edx
	push	eax
	lea	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Hexexp$[ebp], 0
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	ecx
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stodx

; 584  : 
; 585  : 		if (_Hexexp != 0)

	mov	eax, DWORD PTR __Hexexp$[ebp]
	add	esp, 16					; 00000010H
	fstp	QWORD PTR __Ans$[ebp]
	test	eax, eax
	je	SHORT $LN5@do_get

; 586  : 			_Ans = _CSTD ldexp(_Ans, 4 * _Hexexp);

	movsd	xmm0, QWORD PTR __Ans$[ebp]
	shl	eax, 2
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
	fstp	QWORD PTR __Ans$[ebp]
	add	esp, 12					; 0000000cH
$LN5@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 588  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN4@do_get

; 589  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [esi], 1
$LN4@do_get:

; 590  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN2@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN2@do_get

; 592  : 		else
; 593  : 			_Val = _Ans;	// deliver value

	movsd	xmm0, QWORD PTR __Ans$[ebp]
	movsd	QWORD PTR [ebx], xmm0
	jmp	SHORT $LN1@do_get
$LN2@do_get:

; 591  : 			_State |= ios_base::failbit;

	or	DWORD PTR [esi], 2
$LN1@do_get:

; 594  : 		return (_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, edi
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edi+4], ecx

; 595  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
_TEXT	SEGMENT
__Ep$ = -80						; size = 4
__Hexexp$ = -76						; size = 4
__Errno$ = -72						; size = 4
__Ans$ = -68						; size = 4
__Ac$ = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 552  : 		{	// get float from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR __Iosbase$[ebp]

; 553  : 		_DEBUG_RANGE(_First, _Last);
; 554  : 		char _Ac[_MAX_EXP_DIG + _MAX_SIG_DIG + 16], *_Ep;
; 555  : 		int _Errno = 0;
; 556  : 		int _Hexexp = 0;
; 557  : 		float _Ans = _CSTD _Stofx(_Ac, &_Ep,
; 558  : 			_Getffld(_Ac, _First, _Last,
; 559  : 				_Iosbase, &_Hexexp), &_Errno);	// gather field, convert

	lea	edx, DWORD PTR __Errno$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Val$[ebp]
	push	esi
	mov	esi, DWORD PTR __State$[ebp]
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	lea	edx, DWORD PTR __Hexexp$[ebp]
	mov	DWORD PTR __Errno$[ebp], 0
	push	edx
	push	eax
	lea	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Hexexp$[ebp], 0
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	ecx
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stofx

; 560  : 
; 561  : 		if (_Hexexp != 0)

	mov	eax, DWORD PTR __Hexexp$[ebp]
	add	esp, 16					; 00000010H
	fstp	DWORD PTR __Ans$[ebp]
	test	eax, eax
	je	SHORT $LN5@do_get

; 562  : 			_Ans = _CSTD ldexpf(_Ans, 4 * _Hexexp);

	movss	xmm0, DWORD PTR __Ans$[ebp]
	shl	eax, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 723  :     return (float)ldexp(_X, _Y);

	cvtps2pd xmm0, xmm0
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 562  : 			_Ans = _CSTD ldexpf(_Ans, 4 * _Hexexp);

	fstp	DWORD PTR __Ans$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 723  :     return (float)ldexp(_X, _Y);

	add	esp, 12					; 0000000cH
$LN5@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 564  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN4@do_get

; 565  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [esi], 1
$LN4@do_get:

; 566  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN2@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN2@do_get

; 568  : 		else
; 569  : 			_Val = _Ans;	// deliver value

	movss	xmm0, DWORD PTR __Ans$[ebp]
	movss	DWORD PTR [ebx], xmm0
	jmp	SHORT $LN1@do_get
$LN2@do_get:

; 567  : 			_State |= ios_base::failbit;

	or	DWORD PTR [esi], 2
$LN1@do_get:

; 570  : 		return (_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, edi
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edi+4], ecx

; 571  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
_TEXT	SEGMENT
$T2 = -68						; size = 4
__Val$GSCopy$1$ = -64					; size = 4
___$ReturnUdt$GSCopy$1$ = -60				; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 531  : 		{	// get unsigned long long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]

; 537  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	mov	ecx, esi
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	DWORD PTR __Errno$[ebp], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	lea	ecx, DWORD PTR __Errno$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ecx
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stoullx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 537  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	add	esp, 16					; 00000010H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, eax
	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN13@do_get

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN13@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN13@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 539  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN4@do_get

; 540  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN4@do_get:

; 541  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN2@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN2@do_get

; 543  : 		else
; 544  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN1@do_get
$LN2@do_get:

; 542  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN1@do_get:

; 545  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 546  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
_TEXT	SEGMENT
$T2 = -68						; size = 4
__Val$GSCopy$1$ = -64					; size = 4
___$ReturnUdt$GSCopy$1$ = -60				; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 511  : 		{	// get long long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]

; 517  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	mov	ecx, esi
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	DWORD PTR __Errno$[ebp], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	lea	ecx, DWORD PTR __Errno$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ecx
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stollx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 517  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	add	esp, 16					; 00000010H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, eax
	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN13@do_get

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN13@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN13@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 519  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN4@do_get

; 520  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN4@do_get:

; 521  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN2@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN2@do_get

; 523  : 		else
; 524  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	jmp	SHORT $LN1@do_get
$LN2@do_get:

; 522  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN1@do_get:

; 525  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 526  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
_TEXT	SEGMENT
$T2 = -68						; size = 4
__Val$GSCopy$1$ = -64					; size = 4
___$ReturnUdt$GSCopy$1$ = -60				; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 490  : 		{	// get unsigned long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]

; 496  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	mov	ecx, esi
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	DWORD PTR __Errno$[ebp], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	lea	ecx, DWORD PTR __Errno$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ecx
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stoulx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 496  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	add	esp, 16					; 00000010H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN13@do_get

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN13@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN13@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 498  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN4@do_get

; 499  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN4@do_get:

; 500  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN2@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN2@do_get

; 502  : 		else
; 503  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN1@do_get
$LN2@do_get:

; 501  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN1@do_get:

; 504  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 505  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
_TEXT	SEGMENT
$T2 = -68						; size = 4
__Val$GSCopy$1$ = -64					; size = 4
___$ReturnUdt$GSCopy$1$ = -60				; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 470  : 		{	// get long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]

; 476  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	mov	ecx, esi
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	DWORD PTR __Errno$[ebp], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	lea	ecx, DWORD PTR __Errno$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ecx
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stolx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 476  : 				_Iosbase.getloc()), &_Errno);	// gather field, convert

	add	esp, 16					; 00000010H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN13@do_get

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN13@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN13@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 478  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN4@do_get

; 479  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN4@do_get:

; 480  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN2@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN2@do_get

; 482  : 		else
; 483  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN1@do_get
$LN2@do_get:

; 481  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN1@do_get:

; 484  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 485  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
_TEXT	SEGMENT
$T2 = -68						; size = 4
__Val$GSCopy$1$ = -64					; size = 4
___$ReturnUdt$GSCopy$1$ = -60				; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 448  : 		{	// get unsigned int from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]

; 453  : 			_Iosbase.getloc());	// gather field into _Ac

	mov	ecx, esi
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	DWORD PTR __Errno$[ebp], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 453  : 			_Iosbase.getloc());	// gather field into _Ac

	add	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN17@do_get

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN17@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN17@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 454  : 		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	// point past any sign

	cmp	BYTE PTR __Ac$[ebp], 45			; 0000002dH
	lea	eax, DWORD PTR __Ac$[ebp]
	lea	edi, DWORD PTR __Ac$[ebp+1]
	cmovne	edi, eax

; 456  : 			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	lea	eax, DWORD PTR __Errno$[ebp]
	push	eax
	push	esi
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	push	edi
	call	__Stoulx
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	ecx, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 456  : 			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 458  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN4@do_get

; 459  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN4@do_get:

; 460  : 		if (_Ep == _Ptr || _Errno != 0 || UINT_MAX < _Ans)

	cmp	DWORD PTR __Ep$[ebp], edi
	je	SHORT $LN2@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN2@do_get
	cmp	esi, -1
	ja	SHORT $LN2@do_get

; 462  : 		else
; 463  : 			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	// deliver value

	cmp	BYTE PTR __Ac$[ebp], 45			; 0000002dH
	jne	SHORT $LN9@do_get
	neg	esi
$LN9@do_get:
	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN1@do_get
$LN2@do_get:

; 461  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN1@do_get:

; 464  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 465  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
_TEXT	SEGMENT
$T2 = -68						; size = 4
__Val$GSCopy$1$ = -64					; size = 4
___$ReturnUdt$GSCopy$1$ = -60				; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 425  : 		{	// get unsigned short from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]

; 430  : 			_Iosbase.getloc());	// gather field into _Ac

	mov	ecx, esi
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	DWORD PTR __Errno$[ebp], 0
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 430  : 			_Iosbase.getloc());	// gather field into _Ac

	add	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN17@do_get

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN17@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN17@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 431  : 		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	// point past any sign

	cmp	BYTE PTR __Ac$[ebp], 45			; 0000002dH
	lea	eax, DWORD PTR __Ac$[ebp]
	lea	edi, DWORD PTR __Ac$[ebp+1]
	cmovne	edi, eax

; 433  : 			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	lea	eax, DWORD PTR __Errno$[ebp]
	push	eax
	push	esi
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	push	edi
	call	__Stoulx
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	ecx, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 433  : 			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 435  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN4@do_get

; 436  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN4@do_get:

; 437  : 		if (_Ep == _Ptr || _Errno != 0 || USHRT_MAX < _Ans)

	cmp	DWORD PTR __Ep$[ebp], edi
	je	SHORT $LN2@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN2@do_get
	cmp	esi, 65535				; 0000ffffH
	ja	SHORT $LN2@do_get

; 439  : 		else
; 440  : 			_Val = (unsigned short)(_Ac[0] == '-'
; 441  : 				? 0 -_Ans : _Ans);	// deliver value

	cmp	BYTE PTR __Ac$[ebp], 45			; 0000002dH
	jne	SHORT $LN9@do_get
	neg	esi
$LN9@do_get:
	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	WORD PTR [eax], si
	jmp	SHORT $LN1@do_get
$LN2@do_get:

; 438  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN1@do_get:

; 442  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 443  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
_TEXT	SEGMENT
__Val$GSCopy$1$ = -120					; size = 4
$T2 = -116						; size = 4
_this$GSCopy$1$ = -112					; size = 4
__Ep$3 = -108						; size = 4
___$ReturnUdt$GSCopy$1$ = -104				; size = 4
__Errno$4 = -104					; size = 4
__Iosbase$GSCopy$1$ = -100				; size = 4
__Ulo$1$ = -100						; size = 4
$T5 = -100						; size = 4
$T6 = -96						; size = 24
$T7 = -96						; size = 24
__Str$8 = -72						; size = 24
__Ac$9 = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 388  : 		{	// get bool from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	eax, DWORD PTR __Iosbase$[ebp]

; 389  : 		_DEBUG_RANGE(_First, _Last);
; 390  : 		int _Ans = -1;	// negative answer indicates failure

	or	edi, -1
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]

; 391  : 
; 392  : 		if (_Iosbase.flags() & ios_base::boolalpha)

	test	DWORD PTR [eax+20], 16384		; 00004000H
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], esi
	mov	DWORD PTR __Iosbase$GSCopy$1$[ebp], eax
	mov	DWORD PTR __Val$GSCopy$1$[ebp], ecx
	je	$LN6@do_get

; 395  : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	ecx, eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 395  : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], edi
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN19@do_get

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN19@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN19@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$8[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	WORD PTR __Str$8[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$8[ebp+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 397  : 			_Str += _Punct_fac.falsename();

	lea	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	mov	ecx, esi
	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR __Str$8[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 397  : 			_Str += _Punct_fac.falsename();

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T7[ebp+20], 16		; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 397  : 			_Str += _Punct_fac.falsename();

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN187@do_get
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T7[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN187@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1034 : 		return (append((size_type)1, _Ch));

	push	0
	push	1
	lea	ecx, DWORD PTR __Str$8[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 399  : 			_Str += _Punct_fac.truename();	// construct "\0false\0true"

	lea	eax, DWORD PTR $T6[ebp]
	mov	ecx, esi
	push	eax
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR __Str$8[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 399  : 			_Str += _Punct_fac.truename();	// construct "\0false\0true"

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T6[ebp+20], 16		; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 399  : 			_Str += _Punct_fac.truename();	// construct "\0false\0true"

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN225@do_get
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T6[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN225@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR __Str$8[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR __Str$8[ebp]
	cmovae	eax, DWORD PTR __Str$8[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 400  : 			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());

	push	eax
	push	2
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
	add	esp, 16					; 00000010H

; 401  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR __Str$8[ebp+20], 16		; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 400  : 			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());

	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN286@do_get
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Str$8[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN286@do_get:
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
$LN4@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 595  : 	return (_Left.equal(_Right));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 413  : 		if (_First == _Last)

	test	al, al
	je	SHORT $LN3@do_get

; 414  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN3@do_get:

; 415  : 		if (_Ans < 0)

	test	edi, edi
	jns	$LN289@do_get

; 416  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2

; 417  : 		else

	jmp	$LN1@do_get
$LN6@do_get:

; 408  : 					_Iosbase.getloc()), &_Errno);

	lea	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR __Errno$4[ebp], 0
	push	ecx
	mov	ecx, eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	lea	ecx, DWORD PTR __Errno$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
	push	DWORD PTR [eax+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$9[ebp]
	push	eax
	push	DWORD PTR _this$GSCopy$1$[ebp]
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$3[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$9[ebp]
	push	eax
	call	__Stoulx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 408  : 					_Iosbase.getloc()), &_Errno);

	add	esp, 16					; 00000010H
	mov	DWORD PTR __Ulo$1$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN282@do_get

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN287@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN287@do_get:
	mov	eax, DWORD PTR __Ulo$1$[ebp]
$LN282@do_get:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 409  : 			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)

	lea	ecx, DWORD PTR __Ac$9[ebp]
	cmp	DWORD PTR __Ep$3[ebp], ecx
	je	$LN4@do_get
	cmp	DWORD PTR __Errno$4[ebp], 0
	jne	$LN4@do_get
	cmp	eax, 1
	cmovbe	edi, eax
	jmp	$LN4@do_get
$LN289@do_get:

; 418  : 			_Val = _Ans != 0;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	setne	cl
	mov	BYTE PTR [eax], cl
$LN1@do_get:

; 419  : 		return (_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, esi
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [esi+4], ecx

; 420  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1:
	lea	ecx, DWORD PTR __Str$8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get, COMDAT
; _this$ = ecx

; 359  : 		{	// get float from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp

; 360  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	push	DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __State$[ebp]
	push	DWORD PTR __Iosbase$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR [eax+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 361  : 		}

	pop	ebp
	ret	32					; 00000020H
?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 298  : 		{	// construct from specified locale

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	eax, DWORD PTR __Refs$[ebp]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 300  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	pop	ebp
	ret	8
??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 285  : 		}

	ret	4
?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 281  : 		}

	ret	0
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
;	COMDAT ?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 52
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 269  : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	edi, DWORD PTR __Ppf$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR $T3[ebp], ebx
	test	edi, edi
	je	SHORT $LN29@Getcat
	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN29@Getcat

; 272  : 				_Locinfo(_Ploc->c_str()));

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T4[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	test	esi, esi
	je	SHORT $LN4@Getcat
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	ecx, DWORD PTR __Ploc$[ebp]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jne	SHORT $LN12@Getcat
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN17@Getcat
$LN12@Getcat:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3398 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN17@Getcat
	lea	eax, DWORD PTR [ecx+28]
$LN17@Getcat:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 272  : 				_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	ebx, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 298  : 		{	// construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 272  : 				_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	esi, esi
$LN5@Getcat:
	mov	DWORD PTR [edi], esi
	test	bl, 1
	je	SHORT $LN29@Getcat
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN29@Getcat:

; 273  : 		return (_X_NUMERIC);

	mov	eax, 4

; 274  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 561  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 562  :  #if _NO_LOCALES
; 563  : 	static _Wrap_facet<_Facet> _Wfac;
; 564  : 	return (*(_Facet *)&_Wfac);
; 565  : 
; 566  :  #else /* _NO_LOCALES */
; 567  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 79   : 			if (_Id == 0)

	mov	edi, DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id

; 568  : 		const locale::facet *_Psave =
; 569  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __Psave$5[ebp], ebx

; 79   : 			if (_Id == 0)

	test	edi, edi
	jne	SHORT $LN11@use_facet

; 80   : 				{	// still zero, allocate stamp
; 81   : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 82   : 					if (_Id == 0)

	cmp	DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN10@use_facet

; 83   : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
$LN10@use_facet:

; 84   : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
$LN11@use_facet:

; 85   : 				}
; 86   : 			return (_Id);
; 87   : 			}
; 88   : 
; 89   : 	private:
; 90   : 		size_t _Id;	// the identifier stamp
; 91   : 
; 92   : 		__PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 93   : 
; 94   : 	public:
; 95   : 		__CLR_OR_THIS_CALL id(const id&) = delete;
; 96   : 		id& __CLR_OR_THIS_CALL operator=(const id&) = delete;
; 97   : 		};
; 98   : 
; 99   : 	class _Locimp;
; 100  : 
; 101  : 			// CLASS facet
; 102  : 	class _CRTIMP2_PURE facet
; 103  : 		: public _Facet_base
; 104  : 		{	// base class for all locale facets, performs reference counting
; 105  : 		friend class locale;
; 106  : 		friend class _Locimp;
; 107  : 
; 108  : 		template<class _Ty>
; 109  : 			friend void __CLRCALL_OR_CDECL _DebugHeapDelete(_Ty *_Ptr);
; 110  : 
; 111  : 	public:
; 112  : 		static size_t __CLRCALL_OR_CDECL _Getcat(const facet ** = 0,
; 113  : 			const locale * = 0)
; 114  : 			{	// get category value, or -1 if no corresponding C category
; 115  : 			return ((size_t)(-1));
; 116  : 			}
; 117  : 
; 118  :   #if defined(_DEBUG) && !defined(_M_X64)
; 119  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size)
; 120  : 			{	// replace operator new
; 121  : 			return (operator new(_Size, _DebugHeapTag_func(),
; 122  : 				__FILE__, __LINE__));
; 123  : 			}
; 124  : 
; 125  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size,
; 126  : 			const _DebugHeapTag_t& _Tag, char *_File, int _Line)
; 127  : 			{	// replace debugging operator new
; 128  : 			return (::operator new(_Size, _Tag, _File, _Line));
; 129  : 			}
; 130  : 
; 131  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr,
; 132  : 			const _DebugHeapTag_t&, char *, int)
; 133  : 			{	// replace debugging operator delete
; 134  : 			operator delete(_Ptr);
; 135  : 			}
; 136  : 
; 137  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr)
; 138  : 			{	// replace operator delete
; 139  : 			_DebugHeapDelete((facet *)_Ptr);
; 140  : 			}
; 141  :   #endif /* defined(_DEBUG) etc. */
; 142  : 
; 143  : 		virtual void __CLR_OR_THIS_CALL _Incref()
; 144  : 			{   // increment use count
; 145  : 			_MT_INCR(_Mtx, _Refs);
; 146  : 			}
; 147  : 
; 148  : 		virtual _Facet_base *__CLR_OR_THIS_CALL _Decref()
; 149  : 			{   // decrement use count
; 150  : 			if (_MT_DECR(_Mtx, _Refs) == 0)
; 151  : 				return (this);
; 152  : 			else
; 153  : 				return (0);
; 154  : 			}
; 155  : 
; 156  : 	private:
; 157  : 		_Atomic_counter_t _Refs;	// the reference count
; 158  : 
; 159  : 	protected:
; 160  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 161  : 			{	// construct with initial reference count
; 162  : 			_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
; 163  : 			}
; 164  : 
; 165  : 		virtual __CLR_OR_THIS_CALL ~facet() _NOEXCEPT
; 166  : 			{	// ensure that derived classes can be destroyed properly
; 167  : 			}
; 168  : 
; 169  : 	public:
; 170  : 		__CLR_OR_THIS_CALL facet(const facet&) = delete;
; 171  : 		facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 172  : 		};
; 173  : 
; 174  : 			// CLASS _Locimp
; 175  :  #pragma warning(push)
; 176  :  #pragma warning(disable: 4275)
; 177  : 
; 178  : 	class _CRTIMP2_PURE _Locimp
; 179  : 		: public facet
; 180  : 		{	// reference-counted actual implementation of a locale
; 181  : 	protected:
; 182  : 		__CLR_OR_THIS_CALL ~_Locimp() _NOEXCEPT
; 183  : 		{	// destroy the object
; 184  : 		_Locimp_dtor(this);
; 185  : 		}
; 186  : 
; 187  : 	private:
; 188  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 189  : 			_New_Locimp(bool _Transparent = false);
; 190  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 191  : 			_New_Locimp(const _Locimp& _Right);
; 192  : 
; 193  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 194  : 			_Locimp_dtor(_Locimp *);
; 195  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 196  : 			_Locimp_Addfac(_Locimp *, facet *, size_t);	// add a facet
; 197  : 		static void __CLRCALL_PURE_OR_CDECL
; 198  : 			_Locimp_ctor(_Locimp *, const _Locimp&);
; 199  : 
; 200  : 		friend class locale;
; 201  : 
; 202  : 		__CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 203  : 			: locale::facet(1), _Facetvec(0), _Facetcount(0),
; 204  : 				_Catmask(none), _Xparent(_Transparent),
; 205  : 					_Name("*")
; 206  : 			{	// construct an empty _Locimp
; 207  : 			}
; 208  : 
; 209  : 		__CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 210  : 			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
; 211  : 				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
; 212  : 					_Name(_Right._Name.c_str())
; 213  : 			{	// construct by copying
; 214  : 			_Locimp_ctor(this, _Right);
; 215  : 			}
; 216  : 
; 217  : 		void __CLR_OR_THIS_CALL _Addfac(facet *_Pfacet, size_t _Id)
; 218  : 			{	// add a facet
; 219  : 			_Locimp_Addfac(this, _Pfacet, _Id);
; 220  : 			}
; 221  : 
; 222  : 		static _Locimp *__CLRCALL_OR_CDECL _Makeloc(const _Locinfo&,
; 223  : 			category, _Locimp *, const locale *);	// make essential facets
; 224  : 
; 225  : 		static void __CLRCALL_OR_CDECL _Makewloc(const _Locinfo&,
; 226  : 			category, _Locimp *, const locale *);	// make wchar_t facets
; 227  : 
; 228  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 229  : 		static void __CLRCALL_OR_CDECL _Makeushloc(const _Locinfo&,
; 230  : 			category, _Locimp *, const locale *);	// make ushort facets
; 231  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 232  : 
; 233  : 		static void __CLRCALL_OR_CDECL _Makexloc(const _Locinfo&,
; 234  : 			category, _Locimp *, const locale *);	// make remaining facets
; 235  : 
; 236  : 		facet **_Facetvec;	// pointer to vector of facets
; 237  : 		size_t _Facetcount;	// size of vector of facets
; 238  : 		category _Catmask;	// mask describing implemented categories
; 239  : 		bool _Xparent;	// true if locale is transparent
; 240  : 		_Yarn<char> _Name;	// locale name, or "*" if not known
; 241  : 
; 242  : 		__PURE_APPDOMAIN_GLOBAL static _Locimp *_Clocptr;
; 243  : 
; 244  : public:
; 245  : 		_Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 246  : 		};
; 247  : 
; 248  :  #pragma warning(pop)
; 249  : 
; 250  : 	template<class _Elem,
; 251  : 		class _Traits,
; 252  : 		class _Alloc>
; 253  : 		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 254  : 			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
; 255  : 		{	// compare _Left and _Right strings using collate facet in locale
; 256  : 		const _STD collate<_Elem>& _Coll_fac =
; 257  : 			use_facet<_STD collate<_Elem> >(*this);
; 258  : 
; 259  : 		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
; 260  : 			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
; 261  : 		}
; 262  : 
; 263  : 	template<class _Facet>
; 264  : 		locale combine(const locale& _Loc) const
; 265  : 		{	// combine two locales
; 266  : 		_Facet *_Facptr;
; 267  : 
; 268  : 		_TRY_BEGIN
; 269  : 			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
; 270  : 		_CATCH_ALL
; 271  : 			_Xruntime_error("locale::combine facet missing");
; 272  : 		_CATCH_END
; 273  : 
; 274  : 		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
; 275  : 		_Newimp->_Addfac(_Facptr, _Facet::id);
; 276  : 		_Newimp->_Catmask = 0;
; 277  : 		_Newimp->_Name = "*";
; 278  : 		return (locale(_Newimp));
; 279  : 		}
; 280  : 
; 281  : 	template<class _Facet>
; 282  : 		locale(const locale& _Loc, const _Facet *_Facptr)
; 283  : 			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 284  : 		{	// construct from _Loc, replacing facet with *_Facptr
; 285  : 		if (_Facptr != 0)
; 286  : 			{	// replace facet
; 287  : 			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
; 288  : 			if (_Facet::_Getcat() != (size_t)(-1))
; 289  : 				{	// no C category
; 290  : 				_Ptr->_Catmask = 0;
; 291  : 				_Ptr->_Name = "*";
; 292  : 				}
; 293  : 			}
; 294  : 		}
; 295  : 
; 296  : 	locale(_Uninitialized)
; 297  : 		{	// defer construction
; 298  : 		}
; 299  : 
; 300  :  #if _NO_LOCALES
; 301  : 	locale(const locale& _Right) _THROW0()
; 302  : 		: _Ptr(0)
; 303  : 		{	// construct by copying
; 304  : 		}
; 305  : 
; 306  : 	locale() _THROW0()
; 307  : 		: _Ptr(0)
; 308  : 		{	// construct from current locale
; 309  : 		}
; 310  : 
; 311  : 	~locale() _NOEXCEPT
; 312  : 		{	// destroy the object
; 313  : 		}
; 314  : 
; 315  : 	locale& operator=(const locale& _Right) _THROW0()
; 316  : 		{	// assign a locale
; 317  : 		return (*this);
; 318  : 		}
; 319  : 
; 320  :  #else /* _NO_LOCALES */
; 321  : 	locale(const locale& _Right) _THROW0()
; 322  : 		: _Ptr(_Right._Ptr)
; 323  : 		{	// construct by copying
; 324  : 		_Ptr->_Incref();
; 325  : 		}
; 326  : 
; 327  : 	locale() _THROW0()
; 328  : 		: _Ptr(_Init(true))
; 329  : 		{	// construct from current locale
; 330  : 		}
; 331  : 
; 332  :  #if !defined(MRTDLL) || !defined(_CRTBLD)
; 333  : 	locale(const locale& _Loc, const locale& _Other,
; 334  : 		category _Cat)
; 335  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 336  : 		{	// construct a locale by copying named facets
; 337  : 		_TRY_BEGIN
; 338  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 339  : 			_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
; 340  : 				_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
; 341  : 		_END_LOCINFO()
; 342  : 		_CATCH_ALL
; 343  : 		_DELETE_CRT(_Ptr->_Decref());
; 344  : 		_RERAISE;
; 345  : 		_CATCH_END
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	void _Construct(const string &_Str,
; 350  : 		category _Cat)	// construct from named locale for category
; 351  : 		{	// construct a locale with named facets
; 352  : 		bool _Bad = false;
; 353  : 		_TRY_BEGIN
; 354  : 		_Init();
; 355  : 		_BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 356  : 			if (_Badname(_Lobj))
; 357  : 				_Bad = true;
; 358  : 			else
; 359  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 360  : 		_END_LOCINFO()
; 361  : 		_CATCH_ALL
; 362  : 		_DELETE_CRT(_Ptr->_Decref());
; 363  : 		_RERAISE;
; 364  : 		_CATCH_END
; 365  : 
; 366  : 		if (_Bad)
; 367  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 368  : 			_DELETE_CRT(_Ptr->_Decref());
; 369  : 			_Xruntime_error("bad locale name");
; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 	void _Construct(const locale& _Loc, const string &_Str,
; 374  : 		category _Cat)
; 375  : 		{	// construct a locale by copying, replacing named facets
; 376  : 		bool _Bad = false;
; 377  : 		_TRY_BEGIN
; 378  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 379  : 			bool _Hadname = !_Badname(_Lobj);
; 380  : 			_Lobj._Addcats(_Cat, _Str.c_str());
; 381  : 
; 382  : 			if (_Hadname && _Badname(_Lobj))
; 383  : 				_Bad = true;
; 384  : 			else
; 385  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 386  : 		_END_LOCINFO()
; 387  : 		_CATCH_ALL
; 388  : 		_DELETE_CRT(_Ptr->_Decref());
; 389  : 		_RERAISE;
; 390  : 		_CATCH_END
; 391  : 
; 392  : 		if (_Bad)
; 393  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 394  : 			_DELETE_CRT(_Ptr->_Decref());
; 395  : 			_Xruntime_error("bad locale name");
; 396  : 			}
; 397  : 		}
; 398  : 
; 399  : public:
; 400  : 	explicit locale(const char *_Locname,
; 401  : 		category _Cat = all)	// construct from named locale for category
; 402  : 		: _Ptr(_Locimp::_New_Locimp())
; 403  : 		{	// construct a locale with named facets
; 404  : 		// _Locname might have been returned from setlocale().
; 405  : 		// Therefore, _Construct() takes const string&.
; 406  : 		if (_Locname == 0)
; 407  : 			_Xruntime_error("bad locale name");
; 408  : 		_Construct(_Locname, _Cat);
; 409  : 		}
; 410  : 
; 411  : 	locale(const locale& _Loc, const char *_Locname,
; 412  : 		category _Cat)
; 413  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 414  : 		{	// construct a locale by copying, replacing named facets
; 415  : 		// _Locname might have been returned from setlocale().
; 416  : 		// Therefore, _Construct() takes const string&.
; 417  : 		if (_Locname == 0)
; 418  : 			_Xruntime_error("bad locale name");
; 419  : 		_Construct(_Loc, _Locname, _Cat);
; 420  : 		}
; 421  : 
; 422  : 	explicit locale(const string& _Str,
; 423  : 		category _Cat = all)	// construct from named locale for category
; 424  : 		: _Ptr(_Locimp::_New_Locimp())
; 425  : 		{	// construct a locale with named facets
; 426  : 		_Construct(_Str, _Cat);
; 427  : 		}
; 428  : 
; 429  : 	locale(const locale& _Loc, const string& _Str,
; 430  : 		category _Cat)
; 431  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 432  : 		{	// construct a locale by copying, replacing named facets
; 433  : 		_Construct(_Loc, _Str, _Cat);
; 434  : 		}
; 435  :  #endif /* !MRTDLL || !_CRTBLD */
; 436  : 
; 437  : 	~locale() _NOEXCEPT
; 438  : 		{	// destroy the object
; 439  : 		if (_Ptr != 0)
; 440  : 			_DELETE_CRT(_Ptr->_Decref());
; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	mov	ecx, DWORD PTR __Loc$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN20@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	SHORT $LN1@use_facet
	jmp	SHORT $LN24@use_facet
$LN20@use_facet:

; 85   : 				}
; 86   : 			return (_Id);
; 87   : 			}
; 88   : 
; 89   : 	private:
; 90   : 		size_t _Id;	// the identifier stamp
; 91   : 
; 92   : 		__PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 93   : 
; 94   : 	public:
; 95   : 		__CLR_OR_THIS_CALL id(const id&) = delete;
; 96   : 		id& __CLR_OR_THIS_CALL operator=(const id&) = delete;
; 97   : 		};
; 98   : 
; 99   : 	class _Locimp;
; 100  : 
; 101  : 			// CLASS facet
; 102  : 	class _CRTIMP2_PURE facet
; 103  : 		: public _Facet_base
; 104  : 		{	// base class for all locale facets, performs reference counting
; 105  : 		friend class locale;
; 106  : 		friend class _Locimp;
; 107  : 
; 108  : 		template<class _Ty>
; 109  : 			friend void __CLRCALL_OR_CDECL _DebugHeapDelete(_Ty *_Ptr);
; 110  : 
; 111  : 	public:
; 112  : 		static size_t __CLRCALL_OR_CDECL _Getcat(const facet ** = 0,
; 113  : 			const locale * = 0)
; 114  : 			{	// get category value, or -1 if no corresponding C category
; 115  : 			return ((size_t)(-1));
; 116  : 			}
; 117  : 
; 118  :   #if defined(_DEBUG) && !defined(_M_X64)
; 119  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size)
; 120  : 			{	// replace operator new
; 121  : 			return (operator new(_Size, _DebugHeapTag_func(),
; 122  : 				__FILE__, __LINE__));
; 123  : 			}
; 124  : 
; 125  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size,
; 126  : 			const _DebugHeapTag_t& _Tag, char *_File, int _Line)
; 127  : 			{	// replace debugging operator new
; 128  : 			return (::operator new(_Size, _Tag, _File, _Line));
; 129  : 			}
; 130  : 
; 131  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr,
; 132  : 			const _DebugHeapTag_t&, char *, int)
; 133  : 			{	// replace debugging operator delete
; 134  : 			operator delete(_Ptr);
; 135  : 			}
; 136  : 
; 137  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr)
; 138  : 			{	// replace operator delete
; 139  : 			_DebugHeapDelete((facet *)_Ptr);
; 140  : 			}
; 141  :   #endif /* defined(_DEBUG) etc. */
; 142  : 
; 143  : 		virtual void __CLR_OR_THIS_CALL _Incref()
; 144  : 			{   // increment use count
; 145  : 			_MT_INCR(_Mtx, _Refs);
; 146  : 			}
; 147  : 
; 148  : 		virtual _Facet_base *__CLR_OR_THIS_CALL _Decref()
; 149  : 			{   // decrement use count
; 150  : 			if (_MT_DECR(_Mtx, _Refs) == 0)
; 151  : 				return (this);
; 152  : 			else
; 153  : 				return (0);
; 154  : 			}
; 155  : 
; 156  : 	private:
; 157  : 		_Atomic_counter_t _Refs;	// the reference count
; 158  : 
; 159  : 	protected:
; 160  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 161  : 			{	// construct with initial reference count
; 162  : 			_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
; 163  : 			}
; 164  : 
; 165  : 		virtual __CLR_OR_THIS_CALL ~facet() _NOEXCEPT
; 166  : 			{	// ensure that derived classes can be destroyed properly
; 167  : 			}
; 168  : 
; 169  : 	public:
; 170  : 		__CLR_OR_THIS_CALL facet(const facet&) = delete;
; 171  : 		facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 172  : 		};
; 173  : 
; 174  : 			// CLASS _Locimp
; 175  :  #pragma warning(push)
; 176  :  #pragma warning(disable: 4275)
; 177  : 
; 178  : 	class _CRTIMP2_PURE _Locimp
; 179  : 		: public facet
; 180  : 		{	// reference-counted actual implementation of a locale
; 181  : 	protected:
; 182  : 		__CLR_OR_THIS_CALL ~_Locimp() _NOEXCEPT
; 183  : 		{	// destroy the object
; 184  : 		_Locimp_dtor(this);
; 185  : 		}
; 186  : 
; 187  : 	private:
; 188  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 189  : 			_New_Locimp(bool _Transparent = false);
; 190  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 191  : 			_New_Locimp(const _Locimp& _Right);
; 192  : 
; 193  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 194  : 			_Locimp_dtor(_Locimp *);
; 195  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 196  : 			_Locimp_Addfac(_Locimp *, facet *, size_t);	// add a facet
; 197  : 		static void __CLRCALL_PURE_OR_CDECL
; 198  : 			_Locimp_ctor(_Locimp *, const _Locimp&);
; 199  : 
; 200  : 		friend class locale;
; 201  : 
; 202  : 		__CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 203  : 			: locale::facet(1), _Facetvec(0), _Facetcount(0),
; 204  : 				_Catmask(none), _Xparent(_Transparent),
; 205  : 					_Name("*")
; 206  : 			{	// construct an empty _Locimp
; 207  : 			}
; 208  : 
; 209  : 		__CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 210  : 			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
; 211  : 				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
; 212  : 					_Name(_Right._Name.c_str())
; 213  : 			{	// construct by copying
; 214  : 			_Locimp_ctor(this, _Right);
; 215  : 			}
; 216  : 
; 217  : 		void __CLR_OR_THIS_CALL _Addfac(facet *_Pfacet, size_t _Id)
; 218  : 			{	// add a facet
; 219  : 			_Locimp_Addfac(this, _Pfacet, _Id);
; 220  : 			}
; 221  : 
; 222  : 		static _Locimp *__CLRCALL_OR_CDECL _Makeloc(const _Locinfo&,
; 223  : 			category, _Locimp *, const locale *);	// make essential facets
; 224  : 
; 225  : 		static void __CLRCALL_OR_CDECL _Makewloc(const _Locinfo&,
; 226  : 			category, _Locimp *, const locale *);	// make wchar_t facets
; 227  : 
; 228  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 229  : 		static void __CLRCALL_OR_CDECL _Makeushloc(const _Locinfo&,
; 230  : 			category, _Locimp *, const locale *);	// make ushort facets
; 231  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 232  : 
; 233  : 		static void __CLRCALL_OR_CDECL _Makexloc(const _Locinfo&,
; 234  : 			category, _Locimp *, const locale *);	// make remaining facets
; 235  : 
; 236  : 		facet **_Facetvec;	// pointer to vector of facets
; 237  : 		size_t _Facetcount;	// size of vector of facets
; 238  : 		category _Catmask;	// mask describing implemented categories
; 239  : 		bool _Xparent;	// true if locale is transparent
; 240  : 		_Yarn<char> _Name;	// locale name, or "*" if not known
; 241  : 
; 242  : 		__PURE_APPDOMAIN_GLOBAL static _Locimp *_Clocptr;
; 243  : 
; 244  : public:
; 245  : 		_Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 246  : 		};
; 247  : 
; 248  :  #pragma warning(pop)
; 249  : 
; 250  : 	template<class _Elem,
; 251  : 		class _Traits,
; 252  : 		class _Alloc>
; 253  : 		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 254  : 			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
; 255  : 		{	// compare _Left and _Right strings using collate facet in locale
; 256  : 		const _STD collate<_Elem>& _Coll_fac =
; 257  : 			use_facet<_STD collate<_Elem> >(*this);
; 258  : 
; 259  : 		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
; 260  : 			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
; 261  : 		}
; 262  : 
; 263  : 	template<class _Facet>
; 264  : 		locale combine(const locale& _Loc) const
; 265  : 		{	// combine two locales
; 266  : 		_Facet *_Facptr;
; 267  : 
; 268  : 		_TRY_BEGIN
; 269  : 			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
; 270  : 		_CATCH_ALL
; 271  : 			_Xruntime_error("locale::combine facet missing");
; 272  : 		_CATCH_END
; 273  : 
; 274  : 		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
; 275  : 		_Newimp->_Addfac(_Facptr, _Facet::id);
; 276  : 		_Newimp->_Catmask = 0;
; 277  : 		_Newimp->_Name = "*";
; 278  : 		return (locale(_Newimp));
; 279  : 		}
; 280  : 
; 281  : 	template<class _Facet>
; 282  : 		locale(const locale& _Loc, const _Facet *_Facptr)
; 283  : 			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 284  : 		{	// construct from _Loc, replacing facet with *_Facptr
; 285  : 		if (_Facptr != 0)
; 286  : 			{	// replace facet
; 287  : 			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
; 288  : 			if (_Facet::_Getcat() != (size_t)(-1))
; 289  : 				{	// no C category
; 290  : 				_Ptr->_Catmask = 0;
; 291  : 				_Ptr->_Name = "*";
; 292  : 				}
; 293  : 			}
; 294  : 		}
; 295  : 
; 296  : 	locale(_Uninitialized)
; 297  : 		{	// defer construction
; 298  : 		}
; 299  : 
; 300  :  #if _NO_LOCALES
; 301  : 	locale(const locale& _Right) _THROW0()
; 302  : 		: _Ptr(0)
; 303  : 		{	// construct by copying
; 304  : 		}
; 305  : 
; 306  : 	locale() _THROW0()
; 307  : 		: _Ptr(0)
; 308  : 		{	// construct from current locale
; 309  : 		}
; 310  : 
; 311  : 	~locale() _NOEXCEPT
; 312  : 		{	// destroy the object
; 313  : 		}
; 314  : 
; 315  : 	locale& operator=(const locale& _Right) _THROW0()
; 316  : 		{	// assign a locale
; 317  : 		return (*this);
; 318  : 		}
; 319  : 
; 320  :  #else /* _NO_LOCALES */
; 321  : 	locale(const locale& _Right) _THROW0()
; 322  : 		: _Ptr(_Right._Ptr)
; 323  : 		{	// construct by copying
; 324  : 		_Ptr->_Incref();
; 325  : 		}
; 326  : 
; 327  : 	locale() _THROW0()
; 328  : 		: _Ptr(_Init(true))
; 329  : 		{	// construct from current locale
; 330  : 		}
; 331  : 
; 332  :  #if !defined(MRTDLL) || !defined(_CRTBLD)
; 333  : 	locale(const locale& _Loc, const locale& _Other,
; 334  : 		category _Cat)
; 335  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 336  : 		{	// construct a locale by copying named facets
; 337  : 		_TRY_BEGIN
; 338  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 339  : 			_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
; 340  : 				_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
; 341  : 		_END_LOCINFO()
; 342  : 		_CATCH_ALL
; 343  : 		_DELETE_CRT(_Ptr->_Decref());
; 344  : 		_RERAISE;
; 345  : 		_CATCH_END
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	void _Construct(const string &_Str,
; 350  : 		category _Cat)	// construct from named locale for category
; 351  : 		{	// construct a locale with named facets
; 352  : 		bool _Bad = false;
; 353  : 		_TRY_BEGIN
; 354  : 		_Init();
; 355  : 		_BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 356  : 			if (_Badname(_Lobj))
; 357  : 				_Bad = true;
; 358  : 			else
; 359  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 360  : 		_END_LOCINFO()
; 361  : 		_CATCH_ALL
; 362  : 		_DELETE_CRT(_Ptr->_Decref());
; 363  : 		_RERAISE;
; 364  : 		_CATCH_END
; 365  : 
; 366  : 		if (_Bad)
; 367  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 368  : 			_DELETE_CRT(_Ptr->_Decref());
; 369  : 			_Xruntime_error("bad locale name");
; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 	void _Construct(const locale& _Loc, const string &_Str,
; 374  : 		category _Cat)
; 375  : 		{	// construct a locale by copying, replacing named facets
; 376  : 		bool _Bad = false;
; 377  : 		_TRY_BEGIN
; 378  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 379  : 			bool _Hadname = !_Badname(_Lobj);
; 380  : 			_Lobj._Addcats(_Cat, _Str.c_str());
; 381  : 
; 382  : 			if (_Hadname && _Badname(_Lobj))
; 383  : 				_Bad = true;
; 384  : 			else
; 385  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 386  : 		_END_LOCINFO()
; 387  : 		_CATCH_ALL
; 388  : 		_DELETE_CRT(_Ptr->_Decref());
; 389  : 		_RERAISE;
; 390  : 		_CATCH_END
; 391  : 
; 392  : 		if (_Bad)
; 393  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 394  : 			_DELETE_CRT(_Ptr->_Decref());
; 395  : 			_Xruntime_error("bad locale name");
; 396  : 			}
; 397  : 		}
; 398  : 
; 399  : public:
; 400  : 	explicit locale(const char *_Locname,
; 401  : 		category _Cat = all)	// construct from named locale for category
; 402  : 		: _Ptr(_Locimp::_New_Locimp())
; 403  : 		{	// construct a locale with named facets
; 404  : 		// _Locname might have been returned from setlocale().
; 405  : 		// Therefore, _Construct() takes const string&.
; 406  : 		if (_Locname == 0)
; 407  : 			_Xruntime_error("bad locale name");
; 408  : 		_Construct(_Locname, _Cat);
; 409  : 		}
; 410  : 
; 411  : 	locale(const locale& _Loc, const char *_Locname,
; 412  : 		category _Cat)
; 413  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 414  : 		{	// construct a locale by copying, replacing named facets
; 415  : 		// _Locname might have been returned from setlocale().
; 416  : 		// Therefore, _Construct() takes const string&.
; 417  : 		if (_Locname == 0)
; 418  : 			_Xruntime_error("bad locale name");
; 419  : 		_Construct(_Loc, _Locname, _Cat);
; 420  : 		}
; 421  : 
; 422  : 	explicit locale(const string& _Str,
; 423  : 		category _Cat = all)	// construct from named locale for category
; 424  : 		: _Ptr(_Locimp::_New_Locimp())
; 425  : 		{	// construct a locale with named facets
; 426  : 		_Construct(_Str, _Cat);
; 427  : 		}
; 428  : 
; 429  : 	locale(const locale& _Loc, const string& _Str,
; 430  : 		category _Cat)
; 431  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 432  : 		{	// construct a locale by copying, replacing named facets
; 433  : 		_Construct(_Loc, _Str, _Cat);
; 434  : 		}
; 435  :  #endif /* !MRTDLL || !_CRTBLD */
; 436  : 
; 437  : 	~locale() _NOEXCEPT
; 438  : 		{	// destroy the object
; 439  : 		if (_Ptr != 0)
; 440  : 			_DELETE_CRT(_Ptr->_Decref());
; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	xor	esi, esi
$LN24@use_facet:

; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN15@use_facet

; 470  : 			return (_Facptr);	// found facet or not transparent
; 471  : 		else
; 472  : 			{	// look in current locale
; 473  : 			locale::_Locimp *_Ptr = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 474  : 			return (_Id < _Ptr->_Facetcount
; 475  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 476  : 				: 0);	// no entry in current locale

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN25@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 570  : 
; 571  : 		size_t _Id = _Facet::id;
; 572  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 573  : 
; 574  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN1@use_facet
$LN25@use_facet:

; 575  : 			;	// got facet from locale
; 576  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet

; 577  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN1@use_facet
$LN4@use_facet:

; 578  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	push	DWORD PTR __Loc$[ebp]
	lea	eax, DWORD PTR __Psave$5[ebp]
	push	eax
	call	?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN2@use_facet

; 579  : 
; 580  :  #if _HAS_EXCEPTIONS
; 581  : 
; 582  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
$LN29@use_facet:
$LN2@use_facet:

; 583  : 
; 584  :  #else /* _HAS_EXCEPTIONS */
; 585  : 			abort();	// lazy disallowed
; 586  :  #endif /* _HAS_EXCEPTIONS */
; 587  : 
; 588  : 		else
; 589  : 			{	// queue up lazy facet for destruction
; 590  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$5[ebp]

; 591  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 592  : 
; 593  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 594  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+4]

; 595  : 
; 596  :  #if defined(_M_CEE)
; 597  : 			_Facet_Register_m(_Pfmod);
; 598  : 
; 599  :  #else /* defined(_M_CEE) */
; 600  : 			_Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4
$LN1@use_facet:

; 601  :  #endif /* defined(_M_CEE) */
; 602  : 			}
; 603  : 
; 604  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 605  : 	_END_LOCK()
; 606  :  #endif /* _NO_LOCALES */
; 607  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$3[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cquaternion.h
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCQuaternion@0@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 20
$T2 = -40						; size = 20
$T3 = -40						; size = 20
$T4 = -40						; size = 20
$T5 = -40						; size = 20
$T6 = -40						; size = 20
_z$ = -20						; size = 4
_y$ = -16						; size = 4
_x$ = -12						; size = 4
_w$ = -8						; size = 4
_c$ = -1						; size = 1
_s$ = 8							; size = 4
_v$ = 12						; size = 4
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCQuaternion@0@@Z PROC ; gen::operator>>, COMDAT

; 259  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 260  : 	TFloat32 w, x, y, z;
; 261  : 	char c = 0;
; 262  : 
; 263  : 	s >> c;

	mov	esi, DWORD PTR _s$[ebp]
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	push	esi
	mov	BYTE PTR _c$[ebp], 0
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 264  : 	if (c != '(') s.clear( ios_base::badbit ); // Subsequent >> operations will do nothing on error

	cmp	BYTE PTR _c$[ebp], 40			; 00000028H
	je	SHORT $LN13@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN13@operator

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T6[ebp]

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	jne	$LN232@operator

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN14@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN229@operator
$LN14@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	jmp	$LN229@operator
$LN13@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 265  : 	s >> w >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _w$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 266  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN56@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN56@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T5[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN230@operator
$LN59@operator:

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T4[ebp]

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN14@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN229@operator
$LN56@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 267  : 	s >> x >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 268  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN98@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN98@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN230@operator
$LN98@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 269  : 	s >> y >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 270  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN140@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN140@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN230@operator
$LN140@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 271  : 	s >> z >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 272  : 	if (c != ')') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 41			; 00000029H
	je	SHORT $LN182@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN182@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T1[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	SHORT $LN230@operator
$LN182@operator:

; 294  : 		}
; 295  : 
; 296  : 	void __CLR_OR_THIS_CALL clear(iostate _State = goodbit)
; 297  : 		{	// set state to argument
; 298  : 		clear(_State, false);
; 299  : 		}
; 300  : 
; 301  : 	void __CLR_OR_THIS_CALL clear(io_state _State)
; 302  : 		{	// set state to argument, old-style
; 303  : 		clear((iostate)_State);
; 304  : 		}
; 305  : 
; 306  : 	iostate __CLR_OR_THIS_CALL rdstate() const
; 307  : 		{	// return stream state
; 308  : 		return (_Mystate);
; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);
; 331  : 		}
; 332  : 
; 333  : 	bool __CLR_OR_THIS_CALL eof() const
; 334  : 		{	// test if eofbit is set in stream state
; 335  : 		return ((int)rdstate() & (int)eofbit);
; 336  : 		}
; 337  : 
; 338  : 	bool __CLR_OR_THIS_CALL fail() const
; 339  : 		{	// test if badbit or failbit is set in stream state
; 340  : 		return (((int)rdstate()
; 341  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	test	BYTE PTR [eax+esi+12], 6
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 274  : 	if (s) // Only set output if all input was successful

	jne	SHORT $LN226@operator
; File c:\users\simon\documents\github\post-processing\import\math\cquaternion.h

; 113  : 		w = setW;

	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR _w$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 114  : 		x = setX;

	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 115  : 		y = setY;

	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 116  : 		z = setZ;

	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
$LN226@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 278  : 	return s;

	mov	eax, esi
	pop	esi

; 279  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN232@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN229@operator:
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
$LN230@operator:
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T6[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T6[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN234@operator:
$LN228@operator:
	int	3
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCQuaternion@0@@Z ENDP ; gen::operator>>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCQuaternion@0@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_v$ = 12						; size = 4
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCQuaternion@0@@Z PROC ; gen::operator<<, COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp

; 255  : 	return s << '(' << v.w << "," << v.x << "," << v.y << "," << v.z << ')';

	mov	eax, DWORD PTR _v$[ebp]
	push	41					; 00000029H
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+8]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	push	DWORD PTR _s$[ebp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 256  : }

	pop	ebp
	ret	0
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCQuaternion@0@@Z ENDP ; gen::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix4x4@0@@Z
_TEXT	SEGMENT
$T1 = -88						; size = 20
$T2 = -88						; size = 20
$T3 = -88						; size = 20
$T4 = -88						; size = 20
$T5 = -88						; size = 20
$T6 = -88						; size = 20
$T7 = -88						; size = 20
$T8 = -88						; size = 20
$T9 = -88						; size = 20
$T10 = -88						; size = 20
$T11 = -88						; size = 20
$T12 = -88						; size = 20
$T13 = -88						; size = 20
$T14 = -88						; size = 20
$T15 = -88						; size = 20
$T16 = -88						; size = 20
$T17 = -88						; size = 20
$T18 = -88						; size = 20
_e00$ = -68						; size = 4
_e01$ = -64						; size = 4
_e02$ = -60						; size = 4
_e03$ = -56						; size = 4
_e10$ = -52						; size = 4
_e11$ = -48						; size = 4
_e12$ = -44						; size = 4
_e13$ = -40						; size = 4
_e20$ = -36						; size = 4
_e21$ = -32						; size = 4
_e22$ = -28						; size = 4
_e23$ = -24						; size = 4
_e30$ = -20						; size = 4
_e31$ = -16						; size = 4
_e32$ = -12						; size = 4
_e33$ = -8						; size = 4
_c$ = -1						; size = 1
_s$ = 8							; size = 4
_m$ = 12						; size = 4
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix4x4@0@@Z PROC ; gen::operator>>, COMDAT

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi

; 200  : 	TFloat32 e00, e01, e02, e03, e10, e11, e12, e13, e20, e21, e22, e23, e30, e31, e32, e33;
; 201  : 	char c = 0;
; 202  : 
; 203  : 	s >> c;

	mov	esi, DWORD PTR _s$[ebp]
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	push	esi
	mov	BYTE PTR _c$[ebp], 0
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 204  : 	if (c != '(') s.clear( ios_base::badbit ); // Subsequent >> operations will do nothing on error

	cmp	BYTE PTR _c$[ebp], 40			; 00000028H
	je	SHORT $LN25@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN25@operator

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T18[ebp]

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	jne	$LN746@operator

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN26@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN743@operator
$LN26@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	jmp	$LN743@operator
$LN25@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 205  : 	s >> e00 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e00$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 206  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN68@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN68@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T17[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN71@operator:

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T16[ebp]

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN26@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN743@operator
$LN68@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 207  : 	s >> e01 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e01$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 208  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN110@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN110@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T15[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN110@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 209  : 	s >> e02 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e02$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 210  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN152@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN152@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T14[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN152@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 211  : 	s >> e03 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e03$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 212  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN194@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN194@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T13[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN194@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 214  : 	s >> e10 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e10$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 215  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN236@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN236@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T12[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN236@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 216  : 	s >> e11 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e11$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 217  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN278@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN278@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T11[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN278@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 218  : 	s >> e12 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e12$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 219  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN320@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN320@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T10[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN320@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 220  : 	s >> e13 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e13$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 221  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN362@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN362@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T9[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN362@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 223  : 	s >> e20 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e20$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 224  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN404@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN404@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T8[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN404@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 225  : 	s >> e21 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e21$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 226  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN446@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN446@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T7[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN446@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 227  : 	s >> e22 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e22$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 228  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN488@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN488@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T6[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN488@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 229  : 	s >> e23 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e23$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 230  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN530@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN530@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T5[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN530@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 232  : 	s >> e30 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e30$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 233  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN572@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN572@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T4[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN572@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 234  : 	s >> e31 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e31$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 235  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN614@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN614@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN614@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 236  : 	s >> e32 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e32$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 237  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN656@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN656@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN656@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 238  : 	s >> e33 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e33$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 239  : 	if (c != ')') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 41			; 00000029H
	je	SHORT $LN698@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN698@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN71@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T1[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN744@operator
$LN698@operator:

; 294  : 		}
; 295  : 
; 296  : 	void __CLR_OR_THIS_CALL clear(iostate _State = goodbit)
; 297  : 		{	// set state to argument
; 298  : 		clear(_State, false);
; 299  : 		}
; 300  : 
; 301  : 	void __CLR_OR_THIS_CALL clear(io_state _State)
; 302  : 		{	// set state to argument, old-style
; 303  : 		clear((iostate)_State);
; 304  : 		}
; 305  : 
; 306  : 	iostate __CLR_OR_THIS_CALL rdstate() const
; 307  : 		{	// return stream state
; 308  : 		return (_Mystate);
; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);
; 331  : 		}
; 332  : 
; 333  : 	bool __CLR_OR_THIS_CALL eof() const
; 334  : 		{	// test if eofbit is set in stream state
; 335  : 		return ((int)rdstate() & (int)eofbit);
; 336  : 		}
; 337  : 
; 338  : 	bool __CLR_OR_THIS_CALL fail() const
; 339  : 		{	// test if badbit or failbit is set in stream state
; 340  : 		return (((int)rdstate()
; 341  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	test	BYTE PTR [eax+esi+12], 6
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 241  : 	if (s) // Only set output if all input was successful

	jne	$LN1@operator

; 242  : 	{
; 243  : 		m.Set( e00, e01, e02, e03, e10, e11, e12, e13, e20, e21, e22, e23, e30, e31, e32, e33 );

	movss	xmm0, DWORD PTR _e33$[ebp]
	sub	esp, 64					; 00000040H
	mov	ecx, DWORD PTR _m$[ebp]
	movss	DWORD PTR [esp+60], xmm0
	movss	xmm0, DWORD PTR _e32$[ebp]
	movss	DWORD PTR [esp+56], xmm0
	movss	xmm0, DWORD PTR _e31$[ebp]
	movss	DWORD PTR [esp+52], xmm0
	movss	xmm0, DWORD PTR _e30$[ebp]
	movss	DWORD PTR [esp+48], xmm0
	movss	xmm0, DWORD PTR _e23$[ebp]
	movss	DWORD PTR [esp+44], xmm0
	movss	xmm0, DWORD PTR _e22$[ebp]
	movss	DWORD PTR [esp+40], xmm0
	movss	xmm0, DWORD PTR _e21$[ebp]
	movss	DWORD PTR [esp+36], xmm0
	movss	xmm0, DWORD PTR _e20$[ebp]
	movss	DWORD PTR [esp+32], xmm0
	movss	xmm0, DWORD PTR _e13$[ebp]
	movss	DWORD PTR [esp+28], xmm0
	movss	xmm0, DWORD PTR _e12$[ebp]
	movss	DWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR _e11$[ebp]
	movss	DWORD PTR [esp+20], xmm0
	movss	xmm0, DWORD PTR _e10$[ebp]
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _e03$[ebp]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _e02$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _e01$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _e00$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?Set@CMatrix4x4@gen@@QAEXMMMMMMMMMMMMMMMM@Z ; gen::CMatrix4x4::Set
$LN1@operator:

; 244  : 	}
; 245  : 	return s;

	mov	eax, esi
	pop	esi

; 246  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN746@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN743@operator:
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
$LN744@operator:
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T18[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T18[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN748@operator:
$LN742@operator:
	int	3
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix4x4@0@@Z ENDP ; gen::operator>>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix3x3@0@@Z
_TEXT	SEGMENT
$T1 = -60						; size = 20
$T2 = -60						; size = 20
$T3 = -60						; size = 20
$T4 = -60						; size = 20
$T5 = -60						; size = 20
$T6 = -60						; size = 20
$T7 = -60						; size = 20
$T8 = -60						; size = 20
$T9 = -60						; size = 20
$T10 = -60						; size = 20
$T11 = -60						; size = 20
_e00$ = -40						; size = 4
_e01$ = -36						; size = 4
_e02$ = -32						; size = 4
_e10$ = -28						; size = 4
_e11$ = -24						; size = 4
_e12$ = -20						; size = 4
_e20$ = -16						; size = 4
_e21$ = -12						; size = 4
_e22$ = -8						; size = 4
_c$ = -1						; size = 1
_s$ = 8							; size = 4
_m$ = 12						; size = 4
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix3x3@0@@Z PROC ; gen::operator>>, COMDAT

; 164  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi

; 165  : 	TFloat32 e00, e01, e02, e10, e11, e12, e20, e21, e22;
; 166  : 	char c = 0;
; 167  : 
; 168  : 	s >> c;

	mov	esi, DWORD PTR _s$[ebp]
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	push	esi
	mov	BYTE PTR _c$[ebp], 0
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 169  : 	if (c != '(') s.clear( ios_base::badbit ); // Subsequent >> operations will do nothing on error

	cmp	BYTE PTR _c$[ebp], 40			; 00000028H
	je	SHORT $LN18@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN18@operator

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T11[ebp]

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	jne	$LN445@operator

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN19@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN442@operator
$LN19@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	jmp	$LN442@operator
$LN18@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 170  : 	s >> e00 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e00$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 171  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN61@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN61@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN64@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T10[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN443@operator
$LN64@operator:

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T9[ebp]

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN19@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN442@operator
$LN61@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 172  : 	s >> e01 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e01$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 173  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN103@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN103@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN64@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T8[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN443@operator
$LN103@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 174  : 	s >> e02 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e02$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 175  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN145@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN145@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN64@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T7[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN443@operator
$LN145@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 177  : 	s >> e10 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e10$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 178  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN187@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN187@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN64@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T6[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN443@operator
$LN187@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 179  : 	s >> e11 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e11$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 180  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN229@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN229@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN64@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T5[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN443@operator
$LN229@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 181  : 	s >> e12 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e12$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 182  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN271@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN271@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN64@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T4[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN443@operator
$LN271@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 184  : 	s >> e20 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e20$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 185  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN313@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN313@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN64@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN443@operator
$LN313@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 186  : 	s >> e21 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e21$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 187  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN355@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN355@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN64@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN443@operator
$LN355@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 188  : 	s >> e22 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e22$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 189  : 	if (c != ')') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 41			; 00000029H
	je	SHORT $LN397@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN397@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN64@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T1[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN443@operator
$LN397@operator:

; 294  : 		}
; 295  : 
; 296  : 	void __CLR_OR_THIS_CALL clear(iostate _State = goodbit)
; 297  : 		{	// set state to argument
; 298  : 		clear(_State, false);
; 299  : 		}
; 300  : 
; 301  : 	void __CLR_OR_THIS_CALL clear(io_state _State)
; 302  : 		{	// set state to argument, old-style
; 303  : 		clear((iostate)_State);
; 304  : 		}
; 305  : 
; 306  : 	iostate __CLR_OR_THIS_CALL rdstate() const
; 307  : 		{	// return stream state
; 308  : 		return (_Mystate);
; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);
; 331  : 		}
; 332  : 
; 333  : 	bool __CLR_OR_THIS_CALL eof() const
; 334  : 		{	// test if eofbit is set in stream state
; 335  : 		return ((int)rdstate() & (int)eofbit);
; 336  : 		}
; 337  : 
; 338  : 	bool __CLR_OR_THIS_CALL fail() const
; 339  : 		{	// test if badbit or failbit is set in stream state
; 340  : 		return (((int)rdstate()
; 341  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	test	BYTE PTR [eax+esi+12], 6
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 191  : 	if (s) // Only set output if all input was successful

	jne	SHORT $LN1@operator

; 192  : 	{
; 193  : 		m.Set( e00, e01, e02, e10, e11, e12, e20, e21, e22 );

	movss	xmm0, DWORD PTR _e22$[ebp]
	sub	esp, 36					; 00000024H
	mov	ecx, DWORD PTR _m$[ebp]
	movss	DWORD PTR [esp+32], xmm0
	movss	xmm0, DWORD PTR _e21$[ebp]
	movss	DWORD PTR [esp+28], xmm0
	movss	xmm0, DWORD PTR _e20$[ebp]
	movss	DWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR _e12$[ebp]
	movss	DWORD PTR [esp+20], xmm0
	movss	xmm0, DWORD PTR _e11$[ebp]
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _e10$[ebp]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _e02$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _e01$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _e00$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?Set@CMatrix3x3@gen@@QAEXMMMMMMMMM@Z	; gen::CMatrix3x3::Set
$LN1@operator:

; 194  : 	}
; 195  : 	return s;

	mov	eax, esi
	pop	esi

; 196  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN445@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN442@operator:
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
$LN443@operator:
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T11[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T11[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN447@operator:
$LN441@operator:
	int	3
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix3x3@0@@Z ENDP ; gen::operator>>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix2x2@0@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 20
$T2 = -40						; size = 20
$T3 = -40						; size = 20
$T4 = -40						; size = 20
$T5 = -40						; size = 20
$T6 = -40						; size = 20
_e00$ = -20						; size = 4
_e01$ = -16						; size = 4
_e10$ = -12						; size = 4
_e11$ = -8						; size = 4
_c$ = -1						; size = 1
_s$ = 8							; size = 4
_m$ = 12						; size = 4
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix2x2@0@@Z PROC ; gen::operator>>, COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 141  : 	TFloat32 e00, e01, e10, e11;
; 142  : 	char c = 0;
; 143  : 
; 144  : 	s >> c;

	mov	esi, DWORD PTR _s$[ebp]
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	push	esi
	mov	BYTE PTR _c$[ebp], 0
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 145  : 	if (c != '(') s.clear( ios_base::badbit ); // Subsequent >> operations will do nothing

	cmp	BYTE PTR _c$[ebp], 40			; 00000028H
	je	SHORT $LN13@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN13@operator

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T6[ebp]

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	jne	$LN230@operator

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN14@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN227@operator
$LN14@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	jmp	$LN227@operator
$LN13@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 146  : 	s >> e00 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e00$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 147  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN56@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN56@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T5[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN228@operator
$LN59@operator:

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T4[ebp]

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN14@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN227@operator
$LN56@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 148  : 	s >> e01 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e01$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 149  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN98@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN98@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN228@operator
$LN98@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 151  : 	s >> e10 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e10$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 152  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN140@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN140@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN228@operator
$LN140@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 153  : 	s >> e11 >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _e11$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 154  : 	if (c != ')') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 41			; 00000029H
	je	SHORT $LN182@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN182@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T1[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	SHORT $LN228@operator
$LN182@operator:

; 294  : 		}
; 295  : 
; 296  : 	void __CLR_OR_THIS_CALL clear(iostate _State = goodbit)
; 297  : 		{	// set state to argument
; 298  : 		clear(_State, false);
; 299  : 		}
; 300  : 
; 301  : 	void __CLR_OR_THIS_CALL clear(io_state _State)
; 302  : 		{	// set state to argument, old-style
; 303  : 		clear((iostate)_State);
; 304  : 		}
; 305  : 
; 306  : 	iostate __CLR_OR_THIS_CALL rdstate() const
; 307  : 		{	// return stream state
; 308  : 		return (_Mystate);
; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);
; 331  : 		}
; 332  : 
; 333  : 	bool __CLR_OR_THIS_CALL eof() const
; 334  : 		{	// test if eofbit is set in stream state
; 335  : 		return ((int)rdstate() & (int)eofbit);
; 336  : 		}
; 337  : 
; 338  : 	bool __CLR_OR_THIS_CALL fail() const
; 339  : 		{	// test if badbit or failbit is set in stream state
; 340  : 		return (((int)rdstate()
; 341  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	test	BYTE PTR [eax+esi+12], 6
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 156  : 	if (s) // Only set output if all input was successful

	jne	SHORT $LN1@operator

; 157  : 	{
; 158  : 		m.Set( e00, e01, e10, e11 );

	movss	xmm0, DWORD PTR _e11$[ebp]
	sub	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _m$[ebp]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _e10$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _e01$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _e00$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?Set@CMatrix2x2@gen@@QAEXMMMM@Z		; gen::CMatrix2x2::Set
$LN1@operator:

; 159  : 	}
; 160  : 	return s;

	mov	eax, esi
	pop	esi

; 161  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN230@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN227@operator:
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
$LN228@operator:
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T6[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T6[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN232@operator:
$LN226@operator:
	int	3
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCMatrix2x2@0@@Z ENDP ; gen::operator>>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix4x4@0@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_m$ = 12						; size = 4
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix4x4@0@@Z PROC ; gen::operator<<, COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp

; 132  : 	return s << '(' << m.e00 << "," << m.e01 << "," << m.e02 << "," << m.e03 << ",  "
; 133  : 	                << m.e10 << "," << m.e11 << "," << m.e12 << "," << m.e13 << ",  "
; 134  : 	                << m.e20 << "," << m.e21 << "," << m.e22 << "," << m.e23 << ",  "
; 135  : 	                << m.e30 << "," << m.e31 << "," << m.e32 << "," << m.e33 << ')';

	mov	eax, DWORD PTR _m$[ebp]
	push	41					; 00000029H
	push	ecx
	movss	xmm0, DWORD PTR [eax+60]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+56]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+52]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+48]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+44]
	push	OFFSET ??_C@_03JJJGFCCH@?0?5?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+40]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+36]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+32]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+28]
	push	OFFSET ??_C@_03JJJGFCCH@?0?5?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+24]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+20]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+16]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+12]
	push	OFFSET ??_C@_03JJJGFCCH@?0?5?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+8]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	push	DWORD PTR _s$[ebp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 136  : }

	pop	ebp
	ret	0
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix4x4@0@@Z ENDP ; gen::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix3x3@0@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_m$ = 12						; size = 4
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix3x3@0@@Z PROC ; gen::operator<<, COMDAT

; 124  : {

	push	ebp
	mov	ebp, esp

; 125  : 	return s << '(' << m.e00 << "," << m.e01 << "," << m.e02 << ",  "
; 126  : 	                << m.e10 << "," << m.e11 << "," << m.e12 << ",  "
; 127  : 	                << m.e20 << "," << m.e21 << "," << m.e22 << ')';

	mov	eax, DWORD PTR _m$[ebp]
	push	41					; 00000029H
	push	ecx
	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+28]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+24]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+20]
	push	OFFSET ??_C@_03JJJGFCCH@?0?5?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+16]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+12]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+8]
	push	OFFSET ??_C@_03JJJGFCCH@?0?5?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	push	DWORD PTR _s$[ebp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 128  : }

	pop	ebp
	ret	0
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix3x3@0@@Z ENDP ; gen::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix2x2@0@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_m$ = 12						; size = 4
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix2x2@0@@Z PROC ; gen::operator<<, COMDAT

; 118  : {

	push	ebp
	mov	ebp, esp

; 119  : 	return s << '(' << m.e00 << "," << m.e01 << ",  "
; 120  : 	                << m.e10 << "," << m.e11 << ')';

	mov	eax, DWORD PTR _m$[ebp]
	push	41					; 00000029H
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+8]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	push	OFFSET ??_C@_03JJJGFCCH@?0?5?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax]
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	push	DWORD PTR _s$[ebp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 121  : }

	pop	ebp
	ret	0
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCMatrix2x2@0@@Z ENDP ; gen::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector4.h
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector4@0@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 20
$T2 = -40						; size = 20
$T3 = -40						; size = 20
$T4 = -40						; size = 20
$T5 = -40						; size = 20
$T6 = -40						; size = 20
_w$ = -20						; size = 4
_z$ = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_c$ = -1						; size = 1
_s$ = 8							; size = 4
_v$ = 12						; size = 4
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector4@0@@Z PROC ; gen::operator>>, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 91   : 	TFloat32 x, y, z, w;
; 92   : 	char c = 0;
; 93   : 
; 94   : 	s >> c;

	mov	esi, DWORD PTR _s$[ebp]
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	push	esi
	mov	BYTE PTR _c$[ebp], 0
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 95   : 	if (c != '(') s.clear( ios_base::badbit ); // Subsequent >> operations will do nothing on error

	cmp	BYTE PTR _c$[ebp], 40			; 00000028H
	je	SHORT $LN13@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN13@operator

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T6[ebp]

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	jne	$LN232@operator

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN14@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN229@operator
$LN14@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	jmp	$LN229@operator
$LN13@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 96   : 	s >> x >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 97   : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN56@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN56@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T5[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN230@operator
$LN59@operator:

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T4[ebp]

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN14@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN229@operator
$LN56@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 98   : 	s >> y >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 99   : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN98@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN98@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN230@operator
$LN98@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 100  : 	s >> z >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 101  : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN140@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN140@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN230@operator
$LN140@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 102  : 	s >> w >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _w$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 103  : 	if (c != ')') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 41			; 00000029H
	je	SHORT $LN182@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN182@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN59@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T1[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	SHORT $LN230@operator
$LN182@operator:

; 294  : 		}
; 295  : 
; 296  : 	void __CLR_OR_THIS_CALL clear(iostate _State = goodbit)
; 297  : 		{	// set state to argument
; 298  : 		clear(_State, false);
; 299  : 		}
; 300  : 
; 301  : 	void __CLR_OR_THIS_CALL clear(io_state _State)
; 302  : 		{	// set state to argument, old-style
; 303  : 		clear((iostate)_State);
; 304  : 		}
; 305  : 
; 306  : 	iostate __CLR_OR_THIS_CALL rdstate() const
; 307  : 		{	// return stream state
; 308  : 		return (_Mystate);
; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);
; 331  : 		}
; 332  : 
; 333  : 	bool __CLR_OR_THIS_CALL eof() const
; 334  : 		{	// test if eofbit is set in stream state
; 335  : 		return ((int)rdstate() & (int)eofbit);
; 336  : 		}
; 337  : 
; 338  : 	bool __CLR_OR_THIS_CALL fail() const
; 339  : 		{	// test if badbit or failbit is set in stream state
; 340  : 		return (((int)rdstate()
; 341  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	test	BYTE PTR [eax+esi+12], 6
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 105  : 	if (s) // Only set output if all input was successful

	jne	SHORT $LN226@operator
; File c:\users\simon\documents\github\post-processing\import\math\cvector4.h

; 130  : 		x = xIn;

	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 131  : 		y = yIn;

	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 132  : 		z = zIn;

	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 133  : 		w = wIn;

	movss	xmm0, DWORD PTR _w$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
$LN226@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 109  : 	return s;

	mov	eax, esi
	pop	esi

; 110  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN232@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN229@operator:
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
$LN230@operator:
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T6[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T6[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN234@operator:
$LN228@operator:
	int	3
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector4@0@@Z ENDP ; gen::operator>>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector3@0@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 20
$T2 = -36						; size = 20
$T3 = -36						; size = 20
$T4 = -36						; size = 20
$T5 = -36						; size = 20
_z$ = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_c$ = -1						; size = 1
_s$ = 8							; size = 4
_v$ = 12						; size = 4
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector3@0@@Z PROC ; gen::operator>>, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi

; 70   : 	TFloat32 x, y, z;
; 71   : 	char c = 0;
; 72   : 
; 73   : 	s >> c;

	mov	esi, DWORD PTR _s$[ebp]
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	push	esi
	mov	BYTE PTR _c$[ebp], 0
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 74   : 	if (c != '(') s.clear( ios_base::badbit ); // Subsequent >> operations will do nothing on error

	cmp	BYTE PTR _c$[ebp], 40			; 00000028H
	je	SHORT $LN12@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN12@operator

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T5[ebp]

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	jne	$LN189@operator

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN13@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN186@operator
$LN13@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	jmp	$LN186@operator
$LN12@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 75   : 	s >> x >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 76   : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN55@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN55@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN58@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T4[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN187@operator
$LN58@operator:

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T3[ebp]

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN13@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN186@operator
$LN55@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 77   : 	s >> y >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 78   : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN97@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN97@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN58@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN187@operator
$LN97@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 79   : 	s >> z >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 80   : 	if (c != ')') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 41			; 00000029H
	je	SHORT $LN139@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN139@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	$LN58@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T1[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	SHORT $LN187@operator
$LN139@operator:

; 294  : 		}
; 295  : 
; 296  : 	void __CLR_OR_THIS_CALL clear(iostate _State = goodbit)
; 297  : 		{	// set state to argument
; 298  : 		clear(_State, false);
; 299  : 		}
; 300  : 
; 301  : 	void __CLR_OR_THIS_CALL clear(io_state _State)
; 302  : 		{	// set state to argument, old-style
; 303  : 		clear((iostate)_State);
; 304  : 		}
; 305  : 
; 306  : 	iostate __CLR_OR_THIS_CALL rdstate() const
; 307  : 		{	// return stream state
; 308  : 		return (_Mystate);
; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);
; 331  : 		}
; 332  : 
; 333  : 	bool __CLR_OR_THIS_CALL eof() const
; 334  : 		{	// test if eofbit is set in stream state
; 335  : 		return ((int)rdstate() & (int)eofbit);
; 336  : 		}
; 337  : 
; 338  : 	bool __CLR_OR_THIS_CALL fail() const
; 339  : 		{	// test if badbit or failbit is set in stream state
; 340  : 		return (((int)rdstate()
; 341  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	test	BYTE PTR [eax+esi+12], 6
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 82   : 	if (s) // Only set output if all input was successful

	jne	SHORT $LN183@operator
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 122  : 		x = xIn;

	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 123  : 		y = yIn;

	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 124  : 		z = zIn;

	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
$LN183@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 86   : 	return s;

	mov	eax, esi
	pop	esi

; 87   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN189@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN186@operator:
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
$LN187@operator:
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T5[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T5[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN191@operator:
$LN185@operator:
	int	3
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector3@0@@Z ENDP ; gen::operator>>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z
_TEXT	SEGMENT
$T2 = -88						; size = 20
$T3 = -68						; size = 20
$T4 = -48						; size = 20
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Ch$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z PROC ; std::operator>><char,std::char_traits<char> >, COMDAT

; 1049 : 	{	// extract a character

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 94   : 			{	// lock the stream buffer, if there

	mov	esi, DWORD PTR __Istr$[ebp]

; 1050 : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 1051 : 
; 1052 : 	typename _Myis::int_type _Meta;
; 1053 : 	ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi

; 94   : 			{	// lock the stream buffer, if there

	mov	DWORD PTR __Ok$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 95   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN15@operator

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN15@operator:

; 103  : 			}
; 104  : 
; 105  : 		_Myt& _Myistr;	// the input stream, for _Unlock call at destruction
; 106  : 
; 107  : 	private:
; 108  : 		_Sentry_base& operator=(const _Sentry_base&);
; 109  : 		};
; 110  : 
; 111  : 	class sentry
; 112  : 		: public _Sentry_base
; 113  : 		{	// stores thread lock and result of _Ipfx call
; 114  : 	public:
; 115  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Istr, bool _Noskip = false)
; 116  : 			: _Sentry_base(_Istr)
; 117  : 			{	// construct locking and calling _Ipfx
; 118  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	0
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	BYTE PTR __Ok$[ebp+4], al

; 1054 : 	const typename _Myis::sentry _Ok(_Istr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 1055 : 
; 1056 : 	if (_Ok)

	test	al, al
	je	SHORT $LN10@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 1058 : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN28@operator
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN28@operator

; 148  : 		}
; 149  : 
; 150  : 	int_type __CLR_OR_THIS_CALL sgetc()
; 151  : 		{	// get a character and don't point past it
; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());
; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	ecx, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN29@operator
$LN28@operator:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
	mov	ecx, eax
$LN29@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	ecx, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 1060 : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	jne	SHORT $LN2@operator

; 1061 : 			_State |= ios_base::eofbit | ios_base::failbit;	// end of file

	lea	edi, DWORD PTR [ecx+4]

; 1062 : 		else

	jmp	SHORT $LN1@operator
$LN2@operator:

; 1063 : 			_Ch = _Traits::to_char_type(_Meta);	// got a character

	mov	eax, DWORD PTR __Ch$[ebp]
	mov	BYTE PTR [eax], cl
$LN1@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN10@operator:

; 1065 : 		}
; 1066 : 
; 1067 : 	_Istr.setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 57   : 		if (_State != goodbit)

	test	edi, edi
	je	$LN102@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, edi

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN100@operator
	or	eax, 4
$LN100@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax
	je	$LN102@operator

; 288  : 		else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN105@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T4[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN152@operator:
__catch$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 1064 : 		_CATCH_IO_(_Istr)

	mov	ecx, DWORD PTR __Istr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 1064 : 		_CATCH_IO_(_Istr)

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN51@operator
	or	eax, 4
$LN51@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [edx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	test	DWORD PTR [edx+16], eax
	jne	SHORT $LN60@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 1064 : 		_CATCH_IO_(_Istr)

	mov	eax, $LN11@operator
	ret	0
$LN11@operator:
	mov	esi, DWORD PTR __Istr$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	$LN10@operator
$LN60@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 287  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN153@operator:
$LN105@operator:

; 290  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN103@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T3[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	eax
	call	__CxxThrowException@8
$LN154@operator:
$LN103@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	eax
	call	__CxxThrowException@8
$LN155@operator:
$LN102@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]

; 1068 : 	return (_Istr);

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN143@operator

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN143@operator:

; 1068 : 	return (_Istr);

	mov	eax, esi

; 1069 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN151@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ENDP ; std::operator>><char,std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector2@0@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 20
$T2 = -32						; size = 20
$T3 = -32						; size = 20
$T4 = -32						; size = 20
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_c$ = -1						; size = 1
_s$ = 8							; size = 4
_v$ = 12						; size = 4
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector2@0@@Z PROC ; gen::operator>>, COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 51   : 	TFloat32 x, y;
; 52   : 	char c = 0;
; 53   : 
; 54   : 	s >> c;

	mov	esi, DWORD PTR _s$[ebp]
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	push	esi
	mov	BYTE PTR _c$[ebp], 0
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 55   : 	if (c != '(') s.clear( ios_base::badbit ); // Subsequent >> operations will do nothing on error

	cmp	BYTE PTR _c$[ebp], 40			; 00000028H
	je	SHORT $LN11@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN11@operator

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T4[ebp]

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	jne	$LN146@operator

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN12@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	$LN143@operator
$LN12@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	jmp	$LN143@operator
$LN11@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 56   : 	s >> x >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 57   : 	if (c != ',') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 44			; 0000002cH
	je	SHORT $LN54@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN54@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN57@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	$LN144@operator
$LN57@operator:

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T2[ebp]

; 290  : 		else if (_Mystate & _Except & failbit)

	test	al, 2
	je	SHORT $LN12@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	jmp	SHORT $LN143@operator
$LN54@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 58   : 	s >> y >> c;

	lea	eax, DWORD PTR _c$[ebp]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
	push	eax
	call	??$?5DU?$char_traits@D@std@@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAD@Z ; std::operator>><char,std::char_traits<char> >
	add	esp, 8

; 59   : 	if (c != ')') s.clear( ios_base::badbit );

	cmp	BYTE PTR _c$[ebp], 41			; 00000029H
	je	SHORT $LN96@operator
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+esi+12], 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 4
	je	SHORT $LN96@operator

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	al, 4
	je	SHORT $LN57@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T1[ebp]

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	jmp	SHORT $LN144@operator
$LN96@operator:

; 294  : 		}
; 295  : 
; 296  : 	void __CLR_OR_THIS_CALL clear(iostate _State = goodbit)
; 297  : 		{	// set state to argument
; 298  : 		clear(_State, false);
; 299  : 		}
; 300  : 
; 301  : 	void __CLR_OR_THIS_CALL clear(io_state _State)
; 302  : 		{	// set state to argument, old-style
; 303  : 		clear((iostate)_State);
; 304  : 		}
; 305  : 
; 306  : 	iostate __CLR_OR_THIS_CALL rdstate() const
; 307  : 		{	// return stream state
; 308  : 		return (_Mystate);
; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);
; 331  : 		}
; 332  : 
; 333  : 	bool __CLR_OR_THIS_CALL eof() const
; 334  : 		{	// test if eofbit is set in stream state
; 335  : 		return ((int)rdstate() & (int)eofbit);
; 336  : 		}
; 337  : 
; 338  : 	bool __CLR_OR_THIS_CALL fail() const
; 339  : 		{	// test if badbit or failbit is set in stream state
; 340  : 		return (((int)rdstate()
; 341  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	test	BYTE PTR [eax+esi+12], 6
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 61   : 	if (s) // Only set output if all input was successful

	jne	SHORT $LN140@operator
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 113  : 		x = xIn;

	mov	ecx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 114  : 		y = yIn;

	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
$LN140@operator:
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp

; 65   : 	return s;

	mov	eax, esi
	pop	esi

; 66   : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN146@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
$LN143@operator:
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
$LN144@operator:
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T4[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN148@operator:
$LN142@operator:
	int	3
??5gen@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVCVector2@0@@Z ENDP ; gen::operator>>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector4@0@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_v$ = 12						; size = 4
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector4@0@@Z PROC ; gen::operator<<, COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp

; 45   : 	return s << '(' << v.x << ", " << v.y << ", " << v.z << ", " << v.w << ')';

	mov	eax, DWORD PTR _v$[ebp]
	push	41					; 00000029H
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+8]
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax]
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	push	DWORD PTR _s$[ebp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 46   : }

	pop	ebp
	ret	0
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector4@0@@Z ENDP ; gen::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector3@0@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_v$ = 12						; size = 4
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector3@0@@Z PROC ; gen::operator<<, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp

; 40   : 	return s << '(' << v.x << ", " << v.y << ", " << v.z << ')';

	mov	eax, DWORD PTR _v$[ebp]
	push	41					; 00000029H
	push	ecx
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax]
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	push	DWORD PTR _s$[ebp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 41   : }

	pop	ebp
	ret	0
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector3@0@@Z ENDP ; gen::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
$T2 = -104						; size = 20
$T3 = -84						; size = 20
$T4 = -64						; size = 20
__Pad$5 = -44						; size = 8
__Ok$ = -36						; size = 8
__State$ = -28						; size = 4
__Pad$1$ = -24						; size = 4
$T6 = -17						; size = 1
$T7 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 833  : 	{	// insert a char into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 100  : 			{	// lock the stream buffer, if there

	mov	ebx, DWORD PTR __Ostr$[ebp]

; 834  : 	typedef char _Elem;
; 835  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 836  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	esi, esi

; 100  : 			{	// lock the stream buffer, if there

	mov	edi, ebx

; 834  : 	typedef char _Elem;
; 835  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 836  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], esi

; 100  : 			{	// lock the stream buffer, if there

	mov	DWORD PTR __Ok$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ebx+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN26@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN26@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 123  : 			{	// construct locking and testing stream

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+4]

; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+ebx+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN22@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 76   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [eax+ebx+60]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN22@operator
	cmp	ecx, ebx
	je	SHORT $LN22@operator

; 125  : 				_Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+4]
	add	edx, ebx

; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [edx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al

; 837  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 838  : 
; 839  : 	if (_Ok)

	test	al, al
	je	$LN20@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 412  : 		return (_Wide);

	mov	ecx, DWORD PTR [edx+36]
	mov	edi, DWORD PTR [edx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 841  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	test	ecx, ecx
	jg	SHORT $LN15@operator
	jl	SHORT $LN239@operator
	cmp	edi, 1
	ja	SHORT $LN15@operator
$LN239@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$5[ebp], xmm0
	mov	ecx, DWORD PTR __Pad$5[ebp+4]
	mov	edi, DWORD PTR __Pad$5[ebp]
	jmp	SHORT $LN245@operator
$LN15@operator:
	sub	edi, 1
	sbb	ecx, 0
$LN245@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 367  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [edx+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 844  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	mov	DWORD PTR __Pad$1$[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	eax, 64					; 00000040H
	je	SHORT $LN237@operator
	npad	7
$LL9@operator:

; 846  : 				--_Pad)	// pad on left

	test	esi, esi
	jne	$LN2@operator
	test	ecx, ecx
	jl	SHORT $LN237@operator
	jg	SHORT $LN240@operator
	test	edi, edi
	je	SHORT $LN237@operator
$LN240@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 109  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [eax+ebx+64]
	mov	BYTE PTR $T7[ebp], cl

; 88   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ebx+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN61@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	test	eax, eax
	jle	SHORT $LN61@operator

; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);
; 278  : 		}
; 279  : 
; 280  : 	void __CLR_OR_THIS_CALL pbump(int _Off)
; 281  : 		{	// alter current position in write buffer by _Off
; 282  : 		*_IPcount -= _Off;
; 283  : 		*_IPnext += _Off;
; 284  : 		}
; 285  : 
; 286  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
; 287  : 		{	// set pointers for write buffer
; 288  : 		*_IPfirst = _First;
; 289  : 		*_IPnext = _First;
; 290  : 		*_IPcount = (int)(_Last - _First);
; 291  : 		}
; 292  : 
; 293  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 294  : 		{	// set pointers for write buffer, extended version
; 295  : 		*_IPfirst = _First;
; 296  : 		*_IPnext = _Next;
; 297  : 		*_IPcount = (int)(_Last - _Next);
; 298  : 		}
; 299  : 
; 300  : 	_Elem *__CLR_OR_THIS_CALL _Pninc()
; 301  : 		{	// increment current position in write buffer
; 302  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 303  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	al, BYTE PTR $T7[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	jmp	SHORT $LN62@operator
$LN61@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR $T7[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+12]
$LN62@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 846  : 				--_Pad)	// pad on left

	mov	ecx, DWORD PTR __Pad$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 848  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, 4
	cmove	esi, edx
	add	edi, -1
	mov	DWORD PTR __State$[ebp], esi
	adc	ecx, -1
	mov	DWORD PTR __Pad$1$[ebp], ecx
	jmp	SHORT $LL9@operator
$LN237@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ebx+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN81@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	test	eax, eax
	jle	SHORT $LN81@operator

; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);
; 278  : 		}
; 279  : 
; 280  : 	void __CLR_OR_THIS_CALL pbump(int _Off)
; 281  : 		{	// alter current position in write buffer by _Off
; 282  : 		*_IPcount -= _Off;
; 283  : 		*_IPnext += _Off;
; 284  : 		}
; 285  : 
; 286  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
; 287  : 		{	// set pointers for write buffer
; 288  : 		*_IPfirst = _First;
; 289  : 		*_IPnext = _First;
; 290  : 		*_IPcount = (int)(_Last - _First);
; 291  : 		}
; 292  : 
; 293  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 294  : 		{	// set pointers for write buffer, extended version
; 295  : 		*_IPfirst = _First;
; 296  : 		*_IPnext = _Next;
; 297  : 		*_IPcount = (int)(_Last - _Next);
; 298  : 		}
; 299  : 
; 300  : 	_Elem *__CLR_OR_THIS_CALL _Pninc()
; 301  : 		{	// increment current position in write buffer
; 302  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 303  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	jmp	SHORT $LN82@operator
$LN81@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	push	eax
	call	DWORD PTR [edx+12]
$LN82@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 853  : 				_Ostr.rdbuf()->sputc(_Ch)))

	mov	eax, 4
	cmove	esi, eax
	mov	eax, DWORD PTR __Pad$1$[ebp]
$LN246@operator:
	mov	DWORD PTR __State$[ebp], esi

; 854  : 			_State |= ios_base::badbit;
; 855  : 
; 856  : 		for (; _State == ios_base::goodbit && 0 < _Pad;
; 857  : 			--_Pad)	// pad on right

	test	esi, esi
	jne	SHORT $LN2@operator
	test	eax, eax
	jl	SHORT $LN2@operator
	jg	SHORT $LN241@operator
	test	edi, edi
	je	SHORT $LN2@operator
$LN241@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 109  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [eax+ebx+64]
	mov	BYTE PTR $T6[ebp], cl

; 88   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ebx+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN103@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	test	eax, eax
	jle	SHORT $LN103@operator

; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);
; 278  : 		}
; 279  : 
; 280  : 	void __CLR_OR_THIS_CALL pbump(int _Off)
; 281  : 		{	// alter current position in write buffer by _Off
; 282  : 		*_IPcount -= _Off;
; 283  : 		*_IPnext += _Off;
; 284  : 		}
; 285  : 
; 286  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
; 287  : 		{	// set pointers for write buffer
; 288  : 		*_IPfirst = _First;
; 289  : 		*_IPnext = _First;
; 290  : 		*_IPcount = (int)(_Last - _First);
; 291  : 		}
; 292  : 
; 293  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 294  : 		{	// set pointers for write buffer, extended version
; 295  : 		*_IPfirst = _First;
; 296  : 		*_IPnext = _Next;
; 297  : 		*_IPcount = (int)(_Last - _Next);
; 298  : 		}
; 299  : 
; 300  : 	_Elem *__CLR_OR_THIS_CALL _Pninc()
; 301  : 		{	// increment current position in write buffer
; 302  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 303  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	al, BYTE PTR $T6[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	jmp	SHORT $LN104@operator
$LN103@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+12]
$LN104@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 859  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, 4
	cmove	esi, eax
	mov	eax, DWORD PTR __Pad$1$[ebp]
	add	edi, -1
	adc	eax, -1
	mov	DWORD PTR __Pad$1$[ebp], eax
	jmp	SHORT $LN246@operator
$LN2@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN247@operator:
	mov	edi, DWORD PTR __Ok$[ebp]
$LN20@operator:

; 862  : 		}
; 863  : 
; 864  : 	_Ostr.width(0);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 418  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 865  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 57   : 		if (_State != goodbit)

	test	esi, esi
	je	$LN179@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, esi

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN177@operator
	or	eax, 4
$LN177@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax
	je	$LN179@operator

; 288  : 		else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN182@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T4[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN248@operator:
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 861  : 		_CATCH_IO_(_Ostr)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 861  : 		_CATCH_IO_(_Ostr)

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN126@operator
	or	eax, 4
$LN126@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [edx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	test	DWORD PTR [edx+16], eax
	jne	SHORT $LN135@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 861  : 		_CATCH_IO_(_Ostr)

	mov	eax, $LN21@operator
	ret	0
$LN21@operator:
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	esi, DWORD PTR __State$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	$LN247@operator
$LN135@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 287  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN249@operator:
$LN182@operator:

; 290  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN180@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T3[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	eax
	call	__CxxThrowException@8
$LN250@operator:
$LN180@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	eax
	call	__CxxThrowException@8
$LN251@operator:
$LN179@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 866  : 	return (_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 127  : 			}
; 128  : 
; 129  : 		__CLR_OR_THIS_CALL ~sentry() _NOEXCEPT
; 130  : 			{	// destroy the object
; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN218@operator

; 133  : 				this->_Myostr._Osfx();

	mov	ecx, edi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN218@operator:

; 103  : 			}
; 104  : 
; 105  : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 106  : 			{	// destroy after unlocking
; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edi+56]
	test	ecx, ecx
	je	SHORT $LN221@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN221@operator:

; 866  : 	return (_Ostr);

	mov	eax, ebx

; 867  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN244@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
$T2 = -96						; size = 20
$T3 = -76						; size = 20
$T4 = -56						; size = 20
__Ok$ = -36						; size = 8
__Pad$ = -36						; size = 8
__State$ = -28						; size = 4
__Count$2$ = -24					; size = 4
tv1207 = -24						; size = 4
$T5 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
$T6 = 15						; size = 1
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 787  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 790  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	esi, esi
	mov	DWORD PTR __State$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN26@operator
	xor	edx, edx
	jmp	SHORT $LN243@operator
$LN26@operator:
	mov	edx, eax
	lea	ecx, DWORD PTR [edx+1]
$LL229@operator:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL229@operator
	sub	edx, ecx
$LN243@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 412  : 		return (_Wide);

	mov	ecx, DWORD PTR __Ostr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	DWORD PTR __Count$2$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 412  : 		return (_Wide);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax+ecx+36]
	mov	edi, DWORD PTR [eax+ecx+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 793  : 		? 0 : _Ostr.width() - _Count;

	test	ebx, ebx
	jl	SHORT $LN17@operator
	jg	SHORT $LN231@operator
	test	edi, edi
	je	SHORT $LN17@operator
	test	ebx, ebx
	jl	SHORT $LN17@operator
	jg	SHORT $LN231@operator
	cmp	edi, edx
	jbe	SHORT $LN17@operator
$LN231@operator:
	sub	edi, edx
	sbb	ebx, esi
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	ebx, DWORD PTR __Pad$[ebp+4]
	mov	edi, DWORD PTR __Pad$[ebp]
$LN18@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	edx, DWORD PTR [eax+ecx+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 100  : 			{	// lock the stream buffer, if there

	mov	DWORD PTR __Ok$[ebp], ecx

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	edx, edx
	je	SHORT $LN38@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR __Ostr$[ebp]
$LN38@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 123  : 			{	// construct locking and testing stream

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+4]

; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+ecx+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN34@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 76   : 		return (_Tiestr);

	mov	eax, DWORD PTR [eax+ecx+60]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	eax, eax
	je	SHORT $LN34@operator
	cmp	eax, ecx
	je	SHORT $LN34@operator

; 125  : 				_Ostr.tie()->flush();

	mov	ecx, eax
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	ecx, DWORD PTR __Ostr$[ebp]
$LN34@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	add	edx, ecx

; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [edx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al

; 794  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 795  : 
; 796  : 	if (!_Ok)

	test	al, al
	jne	SHORT $LN14@operator

; 797  : 		_State |= ios_base::badbit;

	mov	esi, 4

; 798  : 	else

	jmp	$LN22@operator
$LN14@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 367  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [edx+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 801  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	cmp	eax, 64					; 00000040H
	je	SHORT $LN226@operator
	npad	6
$LL10@operator:

; 802  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	ebx, ebx
	jl	SHORT $LN8@operator
	jg	SHORT $LN232@operator
	test	edi, edi
	je	SHORT $LN8@operator
$LN232@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 109  : 		return (_Fillch);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	dl, BYTE PTR [eax+ecx+64]

; 88   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ecx+56]

; 109  : 		return (_Fillch);

	mov	BYTE PTR $T5[ebp], dl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN69@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	test	eax, eax
	jle	SHORT $LN239@operator

; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);
; 278  : 		}
; 279  : 
; 280  : 	void __CLR_OR_THIS_CALL pbump(int _Off)
; 281  : 		{	// alter current position in write buffer by _Off
; 282  : 		*_IPcount -= _Off;
; 283  : 		*_IPnext += _Off;
; 284  : 		}
; 285  : 
; 286  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
; 287  : 		{	// set pointers for write buffer
; 288  : 		*_IPfirst = _First;
; 289  : 		*_IPnext = _First;
; 290  : 		*_IPcount = (int)(_Last - _First);
; 291  : 		}
; 292  : 
; 293  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 294  : 		{	// set pointers for write buffer, extended version
; 295  : 		*_IPfirst = _First;
; 296  : 		*_IPnext = _Next;
; 297  : 		*_IPcount = (int)(_Last - _Next);
; 298  : 		}
; 299  : 
; 300  : 	_Elem *__CLR_OR_THIS_CALL _Pninc()
; 301  : 		{	// increment current position in write buffer
; 302  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 303  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	al, BYTE PTR $T5[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	jmp	SHORT $LN70@operator
$LN239@operator:
	mov	dl, BYTE PTR $T5[ebp]
$LN69@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, dl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+12]
$LN70@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 807  : 					break;

	mov	ecx, DWORD PTR __Ostr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 804  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	jne	SHORT $LN9@operator

; 805  : 					{	// insertion failed, quit
; 806  : 					_State |= ios_base::badbit;

	or	esi, 4
	mov	DWORD PTR __State$[ebp], esi
$LN8@operator:

; 811  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	test	esi, esi
	jne	$LN2@operator
$LN226@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 202  : 		return (xsputn(_Ptr, _Count));

	push	0
	push	DWORD PTR __Count$2$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 202  : 		return (xsputn(_Ptr, _Count));

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ecx+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 202  : 		return (xsputn(_Ptr, _Count));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+36]
	call	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 811  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	eax, DWORD PTR __Count$2$[ebp]
	jne	SHORT $LN233@operator
	test	edx, edx
	jne	SHORT $LN233@operator
$LL235@operator:

; 813  : 
; 814  : 		if (_State == ios_base::goodbit)
; 815  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	ebx, ebx
	jl	SHORT $LN238@operator
	jg	SHORT $LN234@operator
	test	edi, edi
	je	SHORT $LN238@operator
$LN234@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 109  : 		return (_Fillch);

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	dl, BYTE PTR [eax+ecx+64]

; 88   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ecx+56]

; 109  : 		return (_Fillch);

	mov	BYTE PTR $T6[ebp], dl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN95@operator
	mov	eax, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [eax]

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	test	eax, eax
	jle	SHORT $LN95@operator

; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);
; 278  : 		}
; 279  : 
; 280  : 	void __CLR_OR_THIS_CALL pbump(int _Off)
; 281  : 		{	// alter current position in write buffer by _Off
; 282  : 		*_IPcount -= _Off;
; 283  : 		*_IPnext += _Off;
; 284  : 		}
; 285  : 
; 286  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
; 287  : 		{	// set pointers for write buffer
; 288  : 		*_IPfirst = _First;
; 289  : 		*_IPnext = _First;
; 290  : 		*_IPcount = (int)(_Last - _First);
; 291  : 		}
; 292  : 
; 293  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 294  : 		{	// set pointers for write buffer, extended version
; 295  : 		*_IPfirst = _First;
; 296  : 		*_IPnext = _Next;
; 297  : 		*_IPcount = (int)(_Last - _Next);
; 298  : 		}
; 299  : 
; 300  : 	_Elem *__CLR_OR_THIS_CALL _Pninc()
; 301  : 		{	// increment current position in write buffer
; 302  : 		--*_IPcount;

	mov	edx, DWORD PTR [ecx+48]
	dec	eax
	mov	DWORD PTR [edx], eax

; 303  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	al, BYTE PTR $T6[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	jmp	SHORT $LN96@operator
$LN9@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 802  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	add	edi, -1
	adc	ebx, -1
	jmp	$LL10@operator
$LN95@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, dl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+12]
$LN96@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 817  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	jne	SHORT $LN3@operator

; 818  : 					{	// insertion failed, quit
; 819  : 					_State |= ios_base::badbit;

	or	esi, 4

; 820  : 					break;

	jmp	SHORT $LN238@operator
$LN3@operator:

; 813  : 
; 814  : 		if (_State == ios_base::goodbit)
; 815  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	add	edi, -1
	adc	ebx, -1
	jmp	SHORT $LL235@operator
$LN233@operator:

; 812  : 			_State |= ios_base::badbit;

	mov	esi, 4
$LN238@operator:
	mov	ecx, DWORD PTR __Ostr$[ebp]
$LN2@operator:

; 821  : 					}
; 822  : 		_Ostr.width(0);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 418  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ecx+32], 0
	mov	DWORD PTR [eax+ecx+36], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
	jmp	SHORT $LN246@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 823  : 		_CATCH_IO_(_Ostr)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 823  : 		_CATCH_IO_(_Ostr)

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN120@operator
	or	eax, 4
$LN120@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [edx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	test	DWORD PTR [edx+16], eax
	jne	$LN129@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 823  : 		_CATCH_IO_(_Ostr)

	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
	mov	esi, DWORD PTR __State$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
$LN246@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 824  : 		}
; 825  : 
; 826  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 57   : 		if (_State != goodbit)

	test	esi, esi
	je	$LN171@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, esi

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN169@operator
	or	eax, 4
$LN169@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [edx+16]
	and	eax, 23					; 00000017H
	mov	DWORD PTR [edx+12], eax
	and	ecx, eax
	je	$LN171@operator

; 288  : 		else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN174@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T4[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN247@operator:
$LN174@operator:

; 290  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN172@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T3[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	eax
	call	__CxxThrowException@8
$LN248@operator:
$LN172@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	eax
	call	__CxxThrowException@8
$LN249@operator:
$LN171@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 827  : 	return (_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 127  : 			}
; 128  : 
; 129  : 		__CLR_OR_THIS_CALL ~sentry() _NOEXCEPT
; 130  : 			{	// destroy the object
; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception

; 133  : 				this->_Myostr._Osfx();

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN210@operator
	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN210@operator:

; 103  : 			}
; 104  : 
; 105  : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 106  : 			{	// destroy after unlocking
; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN213@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
$LN213@operator:

; 827  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]

; 828  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN129@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 287  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN250@operator:
$LN242@operator:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\mathio.cpp
;	COMDAT ??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector2@0@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_v$ = 12						; size = 4
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector2@0@@Z PROC ; gen::operator<<, COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp

; 35   : 	return s << '(' << v.x << ", " << v.y << ')';

	mov	eax, DWORD PTR _v$[ebp]
	push	41					; 00000029H
	push	ecx
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR [eax]
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	40					; 00000028H
	push	DWORD PTR _s$[ebp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 36   : }

	pop	ebp
	ret	0
??6gen@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVCVector2@0@@Z ENDP ; gen::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cquaternion.h
;	COMDAT ?Set@CQuaternion@gen@@QAEXMMMM@Z
_TEXT	SEGMENT
_setW$ = 8						; size = 4
_setX$ = 12						; size = 4
_setY$ = 16						; size = 4
_setZ$ = 20						; size = 4
?Set@CQuaternion@gen@@QAEXMMMM@Z PROC			; gen::CQuaternion::Set, COMDAT
; _this$ = ecx

; 112  : 	{

	push	ebp
	mov	ebp, esp

; 113  : 		w = setW;

	movss	xmm0, DWORD PTR _setW$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 114  : 		x = setX;

	movss	xmm0, DWORD PTR _setX$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 115  : 		y = setY;

	movss	xmm0, DWORD PTR _setY$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 116  : 		z = setZ;

	movss	xmm0, DWORD PTR _setZ$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 117  : 	}

	pop	ebp
	ret	16					; 00000010H
?Set@CQuaternion@gen@@QAEXMMMM@Z ENDP			; gen::CQuaternion::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector4.h
;	COMDAT ?Set@CVector4@gen@@QAEXMMMM@Z
_TEXT	SEGMENT
_xIn$ = 8						; size = 4
_yIn$ = 12						; size = 4
_zIn$ = 16						; size = 4
_wIn$ = 20						; size = 4
?Set@CVector4@gen@@QAEXMMMM@Z PROC			; gen::CVector4::Set, COMDAT
; _this$ = ecx

; 129  : 	{

	push	ebp
	mov	ebp, esp

; 130  : 		x = xIn;

	movss	xmm0, DWORD PTR _xIn$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 131  : 		y = yIn;

	movss	xmm0, DWORD PTR _yIn$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 132  : 		z = zIn;

	movss	xmm0, DWORD PTR _zIn$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 133  : 		w = wIn;

	movss	xmm0, DWORD PTR _wIn$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 134  : 	}

	pop	ebp
	ret	16					; 00000010H
?Set@CVector4@gen@@QAEXMMMM@Z ENDP			; gen::CVector4::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
;	COMDAT ?Set@CVector3@gen@@QAEXMMM@Z
_TEXT	SEGMENT
_xIn$ = 8						; size = 4
_yIn$ = 12						; size = 4
_zIn$ = 16						; size = 4
?Set@CVector3@gen@@QAEXMMM@Z PROC			; gen::CVector3::Set, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp

; 122  : 		x = xIn;

	movss	xmm0, DWORD PTR _xIn$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 123  : 		y = yIn;

	movss	xmm0, DWORD PTR _yIn$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 124  : 		z = zIn;

	movss	xmm0, DWORD PTR _zIn$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 125  : 	}

	pop	ebp
	ret	12					; 0000000cH
?Set@CVector3@gen@@QAEXMMM@Z ENDP			; gen::CVector3::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
;	COMDAT ?Set@CVector2@gen@@QAEXMM@Z
_TEXT	SEGMENT
_xIn$ = 8						; size = 4
_yIn$ = 12						; size = 4
?Set@CVector2@gen@@QAEXMM@Z PROC			; gen::CVector2::Set, COMDAT
; _this$ = ecx

; 112  : 	{

	push	ebp
	mov	ebp, esp

; 113  : 		x = xIn;

	movss	xmm0, DWORD PTR _xIn$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 114  : 		y = yIn;

	movss	xmm0, DWORD PTR _yIn$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 115  : 	}

	pop	ebp
	ret	8
?Set@CVector2@gen@@QAEXMM@Z ENDP			; gen::CVector2::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??__FksNewline@gen@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__FksNewline@gen@@YAXXZ PROC				; gen::`dynamic atexit destructor for 'ksNewline'', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR _ksNewline+20, 16		; 00000010H
	jb	SHORT $LN23@dynamic
	push	esi

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	esi, DWORD PTR _ksNewline

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	push	OFFSET _ksNewline
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
$LN23@dynamic:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _ksNewline+20, 15		; 0000000fH

; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR _ksNewline+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR _ksNewline, 0
	mov	esp, ebp
	pop	ebp
	ret	0
??__FksNewline@gen@@YAXXZ ENDP				; gen::`dynamic atexit destructor for 'ksNewline''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
;	COMDAT ??__EksNewline@gen@@YAXXZ
text$di	SEGMENT
??__EksNewline@gen@@YAXXZ PROC				; gen::`dynamic initializer for 'ksNewline'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, OFFSET _ksNewline
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h

; 86   : const string ksNewline = "\n";

	push	OFFSET ??__FksNewline@gen@@YAXXZ	; gen::`dynamic atexit destructor for 'ksNewline''
	call	_atexit
	pop	ecx
	ret	0
??__EksNewline@gen@@YAXXZ ENDP				; gen::`dynamic initializer for 'ksNewline''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??__FksPathSeparator@gen@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__FksPathSeparator@gen@@YAXXZ PROC			; gen::`dynamic atexit destructor for 'ksPathSeparator'', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR _ksPathSeparator+20, 16	; 00000010H
	jb	SHORT $LN23@dynamic
	push	esi

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	esi, DWORD PTR _ksPathSeparator

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	push	OFFSET _ksPathSeparator
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
$LN23@dynamic:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _ksPathSeparator+20, 15	; 0000000fH

; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR _ksPathSeparator+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR _ksPathSeparator, 0
	mov	esp, ebp
	pop	ebp
	ret	0
??__FksPathSeparator@gen@@YAXXZ ENDP			; gen::`dynamic atexit destructor for 'ksPathSeparator''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
;	COMDAT ??__EksPathSeparator@gen@@YAXXZ
text$di	SEGMENT
??__EksPathSeparator@gen@@YAXXZ PROC			; gen::`dynamic initializer for 'ksPathSeparator'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01KICIPPFI@?2?$AA@
	mov	ecx, OFFSET _ksPathSeparator
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h

; 85   : const string ksPathSeparator = "\\";

	push	OFFSET ??__FksPathSeparator@gen@@YAXXZ	; gen::`dynamic atexit destructor for 'ksPathSeparator''
	call	_atexit
	pop	ecx
	ret	0
??__EksPathSeparator@gen@@YAXXZ ENDP			; gen::`dynamic initializer for 'ksPathSeparator''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??__FksCompiler@gen@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__FksCompiler@gen@@YAXXZ PROC				; gen::`dynamic atexit destructor for 'ksCompiler'', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR _ksCompiler+20, 16		; 00000010H
	jb	SHORT $LN23@dynamic
	push	esi

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	esi, DWORD PTR _ksCompiler

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	push	OFFSET _ksCompiler
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
$LN23@dynamic:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _ksCompiler+20, 15		; 0000000fH

; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR _ksCompiler+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR _ksCompiler, 0
	mov	esp, ebp
	pop	ebp
	ret	0
??__FksCompiler@gen@@YAXXZ ENDP				; gen::`dynamic atexit destructor for 'ksCompiler''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
;	COMDAT ??__EksCompiler@gen@@YAXXZ
text$di	SEGMENT
??__EksCompiler@gen@@YAXXZ PROC				; gen::`dynamic initializer for 'ksCompiler'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	32					; 00000020H
	push	OFFSET ??_C@_0CB@NBMGHEOM@Visual?5C?$CL?$CL?58?40?5?$CI2005?$CJ?5or?5greater@
	mov	ecx, OFFSET _ksCompiler
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h

; 80   : 	static const string ksCompiler = "Visual C++ 8.0 (2005) or greater";

	push	OFFSET ??__FksCompiler@gen@@YAXXZ	; gen::`dynamic atexit destructor for 'ksCompiler''
	call	_atexit
	pop	ecx
	ret	0
??__EksCompiler@gen@@YAXXZ ENDP				; gen::`dynamic initializer for 'ksCompiler''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
$T2 = -40						; size = 20
$T3 = -40						; size = 20
__Ok$4 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 581  : 		{	// flush output stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 582  : 		if (_Myios::rdbuf() != 0)

	cmp	DWORD PTR [eax+esi+56], 0
	je	$LN91@flush

; 583  : 			{	// buffer exists, flush it
; 584  : 			const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$4[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 586  : 			if (_Ok && _Myios::rdbuf()->pubsync() == -1)

	cmp	BYTE PTR __Ok$4[ebp+4], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	je	$LN48@flush
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 141  : 		return (sync());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+52]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 586  : 			if (_Ok && _Myios::rdbuf()->pubsync() == -1)

	cmp	eax, -1
	jne	$LN48@flush

; 587  : 				_Myios::setstate(ios_base::badbit);	// sync failed

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+esi+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 587  : 				_Myios::setstate(ios_base::badbit);	// sync failed

	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN46@flush
	or	eax, 4
$LN46@flush:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax
	je	SHORT $LN48@flush

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN51@flush

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T3[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN101@flush:
$LN51@flush:

; 290  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T2[ebp]

; 290  : 		else if (_Mystate & _Except & failbit)

	je	SHORT $LN49@flush

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
$LN100@flush:
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	eax
	call	__CxxThrowException@8
$LN102@flush:
$LN49@flush:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	jmp	SHORT $LN100@flush
$LN48@flush:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 588  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 109  : 			}
; 110  : 
; 111  : 		_Myt& _Myostr;	// the output stream, for _Unlock call at destruction
; 112  : 
; 113  : 	private:
; 114  : 		_Sentry_base& operator=(const _Sentry_base&);
; 115  : 		};
; 116  : 
; 117  : 	class sentry
; 118  : 		: public _Sentry_base
; 119  : 		{	// stores thread lock and state of stream
; 120  : 	public:
; 121  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Ostr)
; 122  : 			: _Sentry_base(_Ostr)
; 123  : 			{	// construct locking and testing stream
; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
; 125  : 				_Ostr.tie()->flush();
; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie
; 127  : 			}
; 128  : 
; 129  : 		__CLR_OR_THIS_CALL ~sentry() _NOEXCEPT
; 130  : 			{	// destroy the object
; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN88@flush

; 133  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR __Ok$4[ebp]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN88@flush:

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR __Ok$4[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN91@flush

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN91@flush:

; 589  : 		return (*this);

	mov	eax, esi

; 590  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN99@flush:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0:
	lea	ecx, DWORD PTR __Ok$4[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
_TEXT	SEGMENT
$T2 = -108						; size = 20
$T3 = -88						; size = 20
$T4 = -68						; size = 20
$T5 = -48						; size = 8
$T6 = -48						; size = 8
__Ok$ = -40						; size = 8
__State$ = -32						; size = 4
$T7 = -28						; size = 1
$T8 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 419  : 		{	// insert a float

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 420  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi

; 100  : 			{	// lock the stream buffer, if there

	mov	DWORD PTR __Ok$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN18@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN18@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 123  : 			{	// construct locking and testing stream

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	ecx, DWORD PTR [eax+4]

; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+esi+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN14@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 76   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [ecx+esi+60]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN14@operator
	cmp	ecx, esi
	je	SHORT $LN14@operator

; 125  : 				_Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN14@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi

; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al

; 421  : 		const sentry _Ok(*this);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 422  : 
; 423  : 		if (_Ok)

	test	al, al
	je	$LN12@operator

; 425  : 			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T8[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 425  : 			const _Nput& _Nput_fac = _USE(this->getloc(), _Nput);

	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN44@operator

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN44@operator
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN44@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 429  : 				_Myios::fill(), (double)_Val).failed())

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1161 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	sub	esp, 8
	movss	xmm0, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 429  : 				_Myios::fill(), (double)_Val).failed())

	cvtps2pd xmm0, xmm0
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	mov	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 109  : 		return (_Fillch);

	mov	al, BYTE PTR [ecx+esi+64]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 429  : 				_Myios::fill(), (double)_Val).failed())

	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 109  : 		return (_Fillch);

	mov	BYTE PTR $T7[ebp], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1161 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 622  : 		{	// construct from stream buffer _Sb

	mov	BYTE PTR $T6[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 1161 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR $T7[ebp]
	push	ecx
	push	DWORD PTR [ecx+56]
	lea	ecx, DWORD PTR $T5[ebp]
	push	DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, ebx
	call	DWORD PTR [eax+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 429  : 				_Myios::fill(), (double)_Val).failed())

	cmp	BYTE PTR $T5[ebp], 0
	mov	eax, 4
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	cmovne	edi, eax
$LN12@operator:

; 432  : 			}
; 433  : 
; 434  : 		_Myios::setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 57   : 		if (_State != goodbit)

	test	edi, edi
	je	$LN114@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, edi

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN112@operator
	or	eax, 4
$LN112@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax
	je	$LN114@operator

; 288  : 		else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN117@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T4[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN165@operator:
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 431  : 			_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 431  : 			_CATCH_IO_END

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN63@operator
	or	eax, 4
$LN63@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [edx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	test	DWORD PTR [edx+16], eax
	jne	SHORT $LN72@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 431  : 			_CATCH_IO_END

	mov	eax, $LN13@operator
	ret	0
$LN13@operator:
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	$LN12@operator
$LN72@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 287  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN166@operator:
$LN117@operator:

; 290  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN115@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T3[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	eax
	call	__CxxThrowException@8
$LN167@operator:
$LN115@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	eax
	call	__CxxThrowException@8
$LN168@operator:
$LN114@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 435  : 		return (*this);

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 127  : 			}
; 128  : 
; 129  : 		__CLR_OR_THIS_CALL ~sentry() _NOEXCEPT
; 130  : 			{	// destroy the object
; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN153@operator

; 133  : 				this->_Myostr._Osfx();

	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN153@operator:

; 103  : 			}
; 104  : 
; 105  : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 106  : 			{	// destroy after unlocking
; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN156@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN156@operator:

; 435  : 		return (*this);

	mov	eax, esi

; 436  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN164@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$4:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$3:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -76						; size = 20
$T3 = -56						; size = 20
$T4 = -36						; size = 20
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 166  : 		{	// perform any wrapup

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 167  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [eax+4]

; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+esi+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 168  : 		if (this->good() && this->flags() & ios_base::unitbuf)

	jne	$LN9@Osfx
	test	BYTE PTR [eax+esi+20], 2
	je	$LN9@Osfx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 141  : 		return (sync());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+52]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 169  : 			if (_Myios::rdbuf()->pubsync() == -1)	// flush stream as needed

	cmp	eax, -1
	jne	$LN9@Osfx

; 170  : 				_Myios::setstate(ios_base::badbit);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+esi+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 170  : 				_Myios::setstate(ios_base::badbit);

	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN27@Osfx
	or	eax, 4
$LN27@Osfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax
	je	$LN9@Osfx

; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN32@Osfx

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T4[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN71@Osfx:
$LN32@Osfx:

; 290  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN30@Osfx

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T3[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	eax
	call	__CxxThrowException@8
$LN72@Osfx:
$LN30@Osfx:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	eax
	call	__CxxThrowException@8
$LN73@Osfx:
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ostream

; 172  : 		_CATCH_END

	mov	eax, $LN9@Osfx
	ret	0
$LN9@Osfx:

; 173  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@Osfx:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Pnavail
	mov	eax, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [eax]
	cdq

; 309  : 		}

	ret	0
$LN3@Pnavail:

; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	xor	eax, eax
	cdq

; 309  : 		}

	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 302  : 		--*_IPcount;

	mov	eax, DWORD PTR [ecx+48]
	dec	DWORD PTR [eax]

; 303  : 		return ((*_IPnext)++);

	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx

; 304  : 		}

	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Gnavail
	mov	eax, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [eax]
	cdq

; 278  : 		}

	ret	0
$LN3@Gnavail:

; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	xor	eax, eax
	cdq

; 278  : 		}

	ret	0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 271  : 		--*_IGcount;

	mov	eax, DWORD PTR [ecx+44]
	dec	DWORD PTR [eax]

; 272  : 		return (++(*_IGnext));

	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [ecx]
	inc	eax
	mov	DWORD PTR [ecx], eax

; 273  : 		}

	ret	0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 265  : 		--*_IGcount;

	mov	eax, DWORD PTR [ecx+44]
	dec	DWORD PTR [eax]

; 266  : 		return ((*_IGnext)++);

	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx

; 267  : 		}

	ret	0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 221  : 		return (*_IGnext);

	mov	eax, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [eax]

; 222  : 		}

	ret	0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 201  : 		{	// put _Count characters from array beginning at _Ptr

	push	ebp
	mov	ebp, esp

; 202  : 		return (xsputn(_Ptr, _Count));

	push	DWORD PTR __Count$[ebp+4]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [eax+36]
	call	eax

; 203  : 		}

	pop	ebp
	ret	12					; 0000000cH
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 193  : 		{	// put a character

	push	ebp
	mov	ebp, esp

; 304  : 		}
; 305  : 
; 306  : 	streamsize __CLR_OR_THIS_CALL _Pnavail() const
; 307  : 		{	// count number of available positions in write buffer
; 308  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sputc
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	test	eax, eax
	jle	SHORT $LN3@sputc

; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);
; 278  : 		}
; 279  : 
; 280  : 	void __CLR_OR_THIS_CALL pbump(int _Off)
; 281  : 		{	// alter current position in write buffer by _Off
; 282  : 		*_IPcount -= _Off;
; 283  : 		*_IPnext += _Off;
; 284  : 		}
; 285  : 
; 286  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Last)
; 287  : 		{	// set pointers for write buffer
; 288  : 		*_IPfirst = _First;
; 289  : 		*_IPnext = _First;
; 290  : 		*_IPcount = (int)(_Last - _First);
; 291  : 		}
; 292  : 
; 293  : 	void __CLR_OR_THIS_CALL setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 294  : 		{	// set pointers for write buffer, extended version
; 295  : 		*_IPfirst = _First;
; 296  : 		*_IPnext = _Next;
; 297  : 		*_IPcount = (int)(_Last - _Next);
; 298  : 		}
; 299  : 
; 300  : 	_Elem *__CLR_OR_THIS_CALL _Pninc()
; 301  : 		{	// increment current position in write buffer
; 302  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 303  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 197  : 		}

	pop	ebp
	ret	4
$LN3@sputc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	DWORD PTR __Ch$[ebp], eax

; 197  : 		}

	pop	ebp

; 196  : 			: overflow(_Traits::to_int_type(_Ch)));

	jmp	DWORD PTR [edx+12]
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = ecx

; 163  : 		{	// point to next character and return it

	push	esi
	mov	esi, ecx

; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN17@snextc
	mov	ecx, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [ecx]

; 167  : 				? _Traits::eof() : sgetc());

	cmp	edx, 1
	jle	SHORT $LN5@snextc

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;

	lea	eax, DWORD PTR [edx-1]
	mov	DWORD PTR [ecx], eax

; 272  : 		return (++(*_IGnext));

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [eax]
	inc	ecx
	mov	DWORD PTR [eax], ecx
$LN47@snextc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [ecx]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 168  : 		}

	ret	0
$LN5@snextc:

; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	test	eax, eax
	je	SHORT $LN17@snextc
	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [ecx]

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN17@snextc

; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [ecx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	jmp	SHORT $LN18@snextc
$LN17@snextc:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+28]
$LN18@snextc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 167  : 				? _Traits::eof() : sgetc());

	jne	SHORT $LN3@snextc
	or	eax, eax
	pop	esi

; 168  : 		}

	ret	0
$LN3@snextc:

; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN35@snextc
	mov	eax, DWORD PTR [esi+44]

; 148  : 		}
; 149  : 
; 150  : 	int_type __CLR_OR_THIS_CALL sgetc()
; 151  : 		{	// get a character and don't point past it
; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN47@snextc
$LN35@snextc:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR [eax+24]
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;
; 266  : 		return ((*_IGnext)++);
; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN3@sgetc
	mov	eax, DWORD PTR [ecx+44]

; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN3@sgetc
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 154  : 		}

	ret	0
$LN3@sgetc:

; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+24]
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 267  : 		}
; 268  : 
; 269  : 	_Elem *__CLR_OR_THIS_CALL _Gnpreinc()
; 270  : 		{	// preincrement current position in read buffer
; 271  : 		--*_IGcount;
; 272  : 		return (++(*_IGnext));
; 273  : 		}
; 274  : 
; 275  : 	streamsize __CLR_OR_THIS_CALL _Gnavail() const
; 276  : 		{	// count number of available elements in read buffer
; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sbumpc
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 146  : 		return (0 < _Gnavail()
; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	test	eax, eax
	jle	SHORT $LN3@sbumpc

; 149  : 
; 150  : 	int_type __CLR_OR_THIS_CALL sgetc()
; 151  : 		{	// get a character and don't point past it
; 152  : 		return (0 < _Gnavail()
; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());
; 154  : 		}
; 155  : 
; 156  : 	streamsize __CLR_OR_THIS_CALL sgetn(_Elem *_Ptr,
; 157  : 		streamsize _Count)
; 158  : 		{	// get up to _Count characters into array beginning at _Ptr
; 159  : 		return (xsgetn(_Ptr, _Count));
; 160  : 		}
; 161  : 
; 162  : 	int_type __CLR_OR_THIS_CALL snextc()
; 163  : 		{	// point to next character and return it
; 164  : 		return (1 < _Gnavail()
; 165  : 			? _Traits::to_int_type(*_Gnpreinc())
; 166  : 			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
; 167  : 				? _Traits::eof() : sgetc());
; 168  : 		}
; 169  : 
; 170  : 	int_type __CLR_OR_THIS_CALL sputbackc(_Elem _Ch)
; 171  : 		{	// put back _Ch
; 172  : 		return (gptr() != 0 && eback() < gptr()
; 173  : 			&& _Traits::eq(_Ch, gptr()[-1])
; 174  : 			? _Traits::to_int_type(*_Gndec())
; 175  : 			: pbackfail(_Traits::to_int_type(_Ch)));
; 176  : 		}
; 177  : 
; 178  : 	void __CLR_OR_THIS_CALL stossc()
; 179  : 		{	// point past a character
; 180  : 		if (0 < _Gnavail())
; 181  : 			_Gninc();
; 182  : 		else
; 183  : 			uflow();
; 184  : 		}
; 185  : 
; 186  : 	int_type __CLR_OR_THIS_CALL sungetc()
; 187  : 		{	// back up one position
; 188  : 		return (gptr() != 0 && eback() < gptr()
; 189  : 			? _Traits::to_int_type(*_Gndec()) : pbackfail());
; 190  : 		}
; 191  : 
; 192  : 	int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch)
; 193  : 		{	// put a character
; 194  : 		return (0 < _Pnavail()
; 195  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 196  : 			: overflow(_Traits::to_int_type(_Ch)));
; 197  : 		}
; 198  : 
; 199  : 	streamsize __CLR_OR_THIS_CALL sputn(const _Elem *_Ptr,
; 200  : 		streamsize _Count)
; 201  : 		{	// put _Count characters from array beginning at _Ptr
; 202  : 		return (xsputn(_Ptr, _Count));
; 203  : 		}
; 204  : 
; 205  : 	virtual void __CLR_OR_THIS_CALL _Lock()
; 206  : 		{	// set the thread lock (overridden by basic_filebuf)
; 207  : 		}
; 208  : 
; 209  : 	virtual void __CLR_OR_THIS_CALL _Unlock()
; 210  : 		{	// clear the thread lock (overridden by basic_filebuf)
; 211  : 		}
; 212  : 
; 213  : protected:
; 214  : 	_Elem *__CLR_OR_THIS_CALL eback() const
; 215  : 		{	// return beginning of read buffer
; 216  : 		return (*_IGfirst);
; 217  : 		}
; 218  : 
; 219  : 	_Elem *__CLR_OR_THIS_CALL gptr() const
; 220  : 		{	// return current position in read buffer
; 221  : 		return (*_IGnext);
; 222  : 		}
; 223  : 
; 224  : 	_Elem *__CLR_OR_THIS_CALL pbase() const
; 225  : 		{	// return beginning of write buffer
; 226  : 		return (*_IPfirst);
; 227  : 		}
; 228  : 
; 229  : 	_Elem *__CLR_OR_THIS_CALL pptr() const
; 230  : 		{	// return current position in write buffer
; 231  : 		return (*_IPnext);
; 232  : 		}
; 233  : 
; 234  : 	_Elem *__CLR_OR_THIS_CALL egptr() const
; 235  : 		{	// return end of read buffer
; 236  : 		return (*_IGnext + *_IGcount);
; 237  : 		}
; 238  : 
; 239  : 	void __CLR_OR_THIS_CALL gbump(int _Off)
; 240  : 		{	// alter current position in read buffer by _Off
; 241  : 		*_IGcount -= _Off;
; 242  : 		*_IGnext += _Off;
; 243  : 		}
; 244  : 
; 245  : 	void __CLR_OR_THIS_CALL setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
; 246  : 		{	// set pointers for read buffer
; 247  : 		*_IGfirst = _First;
; 248  : 		*_IGnext = _Next;
; 249  : 		*_IGcount = (int)(_Last - _Next);
; 250  : 		}
; 251  : 
; 252  : 	_Elem *__CLR_OR_THIS_CALL epptr() const
; 253  : 		{	// return end of write buffer
; 254  : 		return (*_IPnext + *_IPcount);
; 255  : 		}
; 256  : 
; 257  : 	_Elem *__CLR_OR_THIS_CALL _Gndec()
; 258  : 		{	// decrement current position in read buffer
; 259  : 		++*_IGcount;
; 260  : 		return (--*_IGnext);
; 261  : 		}
; 262  : 
; 263  : 	_Elem *__CLR_OR_THIS_CALL _Gninc()
; 264  : 		{	// increment current position in read buffer
; 265  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 266  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 148  : 		}

	ret	0
$LN3@sbumpc:

; 146  : 		return (0 < _Gnavail()
; 147  : 			? _Traits::to_int_type(*_Gninc()) : uflow());

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+28]
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 141  : 		return (sync());

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+52]
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN3@sentry

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+8]
$LN3@sentry:
	ret	0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 123  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 124  : 			}

	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 117  : 			{	// construct locking and calling _Ipfx

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 94   : 			{	// lock the stream buffer, if there

	mov	edx, DWORD PTR __Istr$[ebp]
	mov	DWORD PTR [esi], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 95   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN4@sentry

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN4@sentry:

; 118  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	DWORD PTR __Noskip$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	BYTE PTR [esi+4], al

; 119  : 			}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN1@Sentry_bas

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+8]
$LN1@Sentry_bas:

; 103  : 			}

	ret	0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 94   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR __Istr$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 95   : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 97   : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z
_TEXT	SEGMENT
$T2 = -112						; size = 20
$T3 = -92						; size = 20
$T4 = -72						; size = 20
$T5 = -52						; size = 8
$T6 = -52						; size = 8
$T7 = -44						; size = 8
__Ok$ = -36						; size = 8
$T8 = -28						; size = 4
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z PROC ; std::basic_istream<char,std::char_traits<char> >::operator>>, COMDAT
; _this$ = ecx

; 412  : 		{	// extract a float

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 413  : 		ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 94   : 			{	// lock the stream buffer, if there

	mov	DWORD PTR __Ok$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 95   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN16@operator

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN16@operator:

; 103  : 			}
; 104  : 
; 105  : 		_Myt& _Myistr;	// the input stream, for _Unlock call at destruction
; 106  : 
; 107  : 	private:
; 108  : 		_Sentry_base& operator=(const _Sentry_base&);
; 109  : 		};
; 110  : 
; 111  : 	class sentry
; 112  : 		: public _Sentry_base
; 113  : 		{	// stores thread lock and result of _Ipfx call
; 114  : 	public:
; 115  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Istr, bool _Noskip = false)
; 116  : 			: _Sentry_base(_Istr)
; 117  : 			{	// construct locking and calling _Ipfx
; 118  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	0
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	BYTE PTR __Ok$[ebp+4], al

; 414  : 		const sentry _Ok(*this);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 415  : 
; 416  : 		if (_Ok)

	test	al, al
	je	SHORT $LN11@operator

; 418  : 			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T8[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 418  : 			const _Nget& _Nget_fac = _USE(this->getloc(), _Nget);

	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN28@operator

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN28@operator
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN28@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 360  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 422  : 				*this, _State, _Val);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 360  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	lea	ebx, DWORD PTR __State$[ebp]
	mov	edx, DWORD PTR [edi]
	push	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 496  : 		{	// construct from stream buffer _Sb

	mov	BYTE PTR $T7[ebp+4], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 422  : 				*this, _State, _Val);

	mov	eax, DWORD PTR [eax+4]
	add	eax, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 360  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	push	eax
	push	DWORD PTR $T7[ebp+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 496  : 		{	// construct from stream buffer _Sb

	test	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 360  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	push	0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 496  : 		{	// construct from stream buffer _Sb

	sete	BYTE PTR $T6[ebp+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocnum

; 360  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	lea	eax, DWORD PTR $T5[ebp]
	push	DWORD PTR $T6[ebp+4]
	push	ecx
	push	eax
	mov	ecx, edi
	call	DWORD PTR [edx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN11@operator:

; 426  : 		_Myios::setstate(_State);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 57   : 		if (_State != goodbit)

	mov	edx, DWORD PTR __State$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 426  : 		_Myios::setstate(_State);

	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 57   : 		if (_State != goodbit)

	test	edx, edx
	je	$LN96@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, edx

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN94@operator
	or	eax, 4
$LN94@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax
	je	$LN96@operator

; 288  : 		else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN99@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T4[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN146@operator:
__catch$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 423  : 			_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 423  : 			_CATCH_IO_END

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN45@operator
	or	eax, 4
$LN45@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [edx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	test	DWORD PTR [edx+16], eax
	jne	SHORT $LN54@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 423  : 			_CATCH_IO_END

	mov	eax, $LN12@operator
	ret	0
$LN12@operator:
	mov	esi, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	$LN11@operator
$LN54@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 287  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN147@operator:
$LN99@operator:

; 290  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN97@operator

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T3[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	eax
	call	__CxxThrowException@8
$LN148@operator:
$LN97@operator:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	eax
	call	__CxxThrowException@8
$LN149@operator:
$LN96@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]

; 427  : 		return (*this);

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN137@operator

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN137@operator:

; 427  : 		return (*this);

	mov	eax, esi

; 428  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN145@operator:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z$4:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z$3:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAM@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::operator>>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
$T2 = -140						; size = 20
$T3 = -120						; size = 20
$T4 = -100						; size = 20
$T5 = -80						; size = 20
$T6 = -60						; size = 20
$T7 = -40						; size = 20
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T8 = 8							; size = 4
__Noskip$ = 8						; size = 1
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = ecx

; 135  : 		{	// test stream state and skip whitespace as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi

; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 136  : 		if (this->good())

	jne	$LN1@Ipfx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 76   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [ecx+60]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 138  : 			if (_Myios::tie() != 0)

	test	ecx, ecx
	je	SHORT $LN10@Ipfx

; 139  : 				_Myios::tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$LN10@Ipfx:

; 141  : 			if (!_Noskip && this->flags() & ios_base::skipws)

	cmp	BYTE PTR __Noskip$[ebp], 0
	jne	$LN17@Ipfx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 367  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 141  : 			if (!_Noskip && this->flags() & ios_base::skipws)

	test	BYTE PTR [ecx+20], 1
	je	$LN17@Ipfx

; 143  : 				const _Ctype& _Ctype_fac = _USE(this->getloc(), _Ctype);

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T8[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 143  : 				const _Ctype& _Ctype_fac = _USE(this->getloc(), _Ctype);

	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 439  : 		if (_Ptr != 0)

	test	ecx, ecx
	je	SHORT $LN32@Ipfx

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN32@Ipfx
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN32@Ipfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 145  : 				_TRY_IO_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 277  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN38@Ipfx
	mov	eax, DWORD PTR [ecx+44]

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN38@Ipfx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 588  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\streambuf

; 153  : 			? _Traits::to_int_type(*gptr()) : underflow());

	jmp	SHORT $LL214@Ipfx
$LN38@Ipfx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LL214@Ipfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 594  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 149  : 					if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	jne	$LN4@Ipfx

; 151  : 						_Myios::setstate(ios_base::eofbit);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+esi+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 151  : 						_Myios::setstate(ios_base::eofbit);

	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 1

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN61@Ipfx
	or	eax, 4
$LN61@Ipfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax
	je	$LN5@Ipfx

; 288  : 		else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN66@Ipfx

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T7[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T7[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T7[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN218@Ipfx:
$LN66@Ipfx:

; 290  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN64@Ipfx

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T6[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T6[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	eax
	call	__CxxThrowException@8
$LN219@Ipfx:
$LN64@Ipfx:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T5[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T5[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	eax
	call	__CxxThrowException@8
$LN220@Ipfx:
$LN4@Ipfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2365 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

	movzx	ecx, al
	mov	eax, DWORD PTR [edi+12]
	test	BYTE PTR [eax+ecx*2], 72		; 00000048H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 155  : 						_Traits::to_char_type(_Meta)))

	jne	SHORT $LN6@Ipfx
$LN5@Ipfx:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN17@Ipfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi

; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 160  : 			if (this->good())

	jne	SHORT $LN1@Ipfx

; 161  : 				return (true);

	mov	al, 1

; 165  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@Ipfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 148  : 				for (; ; _Meta = _Myios::rdbuf()->snextc())

	mov	ecx, DWORD PTR [eax+esi+56]
	call	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
	jmp	$LL214@Ipfx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0:

; 157  : 				_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 157  : 				_CATCH_IO_END

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN114@Ipfx
	or	eax, 4
$LN114@Ipfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [edx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	test	DWORD PTR [edx+16], eax
	jne	SHORT $LN123@Ipfx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 157  : 				_CATCH_IO_END

	mov	eax, $LN18@Ipfx
	ret	0
$LN18@Ipfx:
	mov	esi, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN17@Ipfx
$LN123@Ipfx:

; 287  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN221@Ipfx:
$LN1@Ipfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	mov	eax, DWORD PTR [ecx+12]
	or	eax, 2

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN166@Ipfx
	or	eax, 4
$LN166@Ipfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax
	jne	SHORT $LN175@Ipfx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\istream

; 164  : 		return (false);

	xor	al, al

; 165  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN175@Ipfx:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 288  : 		else if (_Mystate & _Except & badbit)

	test	cl, 4
	je	SHORT $LN171@Ipfx

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T4[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T4[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN222@Ipfx:
$LN171@Ipfx:

; 290  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN169@Ipfx

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T3[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T3[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	eax
	call	__CxxThrowException@8
$LN223@Ipfx:
$LN169@Ipfx:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	push	eax
	call	__CxxThrowException@8
$LN224@Ipfx:
$LN217@Ipfx:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 109  : 		return (_Fillch);

	mov	al, BYTE PTR [ecx+64]

; 110  : 		}

	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 88   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx+56]

; 89   : 		}

	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 76   : 		return (_Tiestr);

	mov	eax, DWORD PTR [ecx+60]

; 77   : 		}

	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 56   : 		{	// merge _State into state, possibly reraise exception

	push	ebp
	mov	ebp, esp

; 57   : 		if (_State != goodbit)

	mov	edx, DWORD PTR __State$[ebp]
	test	edx, edx
	je	SHORT $LN6@setstate

; 58   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	mov	eax, DWORD PTR [ecx+12]
	or	eax, edx

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN8@setstate
	or	eax, 4
$LN8@setstate:
	mov	DWORD PTR __State$[ebp], eax

; 59   : 		}

	pop	ebp

; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	jmp	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN6@setstate:

; 59   : 		}

	pop	ebp
	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 44   : 		{	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp

; 45   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	cmp	DWORD PTR [ecx+56], 0
	mov	eax, DWORD PTR __State$[ebp]
	jne	SHORT $LN4@clear
	or	eax, 4
$LN4@clear:
	mov	DWORD PTR __State$[ebp], eax

; 47   : 		}

	pop	ebp

; 45   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 46   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);

	jmp	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 423  : 		{	// get locale

	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 323  : 		{	// construct by copying

	mov	eax, DWORD PTR [ecx+48]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx

; 324  : 		_Ptr->_Incref();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase

; 424  : 		return (*_Ploc);

	mov	eax, esi
	pop	esi

; 425  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 416  : 		{	// set width to argument

	push	ebp
	mov	ebp, esp

; 417  : 		streamsize _Oldwidth = _Wide;

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]
	push	esi

; 418  : 		_Wide = _Newwidth;

	mov	esi, DWORD PTR __Newwidth$[ebp]
	mov	DWORD PTR [ecx+32], esi
	mov	esi, DWORD PTR __Newwidth$[ebp+4]
	mov	DWORD PTR [ecx+36], esi
	pop	esi

; 419  : 		return (_Oldwidth);
; 420  : 		}

	pop	ebp
	ret	8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 412  : 		return (_Wide);

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]

; 413  : 		}

	ret	0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?precision@ios_base@std@@QBE_JXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 400  : 		return (_Prec);

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]

; 401  : 		}

	ret	0
?precision@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 367  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+20]

; 368  : 		}

	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?fail@ios_base@std@@QBE_NXZ PROC			; std::ios_base::fail, COMDAT
; _this$ = ecx

; 340  : 		return (((int)rdstate()
; 341  : 			& ((int)badbit | (int)failbit)) != 0);

	test	BYTE PTR [ecx+12], 6
	mov	eax, 0
	setne	al

; 342  : 		}

	ret	0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 330  : 		return (rdstate() == goodbit);

	xor	eax, eax
	cmp	DWORD PTR [ecx+12], eax
	sete	al

; 331  : 		}

	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 308  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+12]

; 309  : 		}

	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -20						; size = 20
$T2 = -20						; size = 20
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 282  : 		{	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp

; 283  : 		_Mystate = (iostate)(_State & _Statmask);

	mov	eax, DWORD PTR __State$[ebp]
	sub	esp, 20					; 00000014H
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax

; 284  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax
	je	SHORT $LN1@clear

; 285  : 			;
; 286  : 		else if (_Reraise)

	cmp	BYTE PTR __Reraise$[ebp], 0
	jne	SHORT $LN40@clear

; 288  : 		else if (_Mystate & _Except & badbit)

	test	cl, 4
	jne	SHORT $LN42@clear

; 290  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2

; 233  : 			{	// construct with message

	lea	ecx, DWORD PTR $T1[ebp]

; 290  : 		else if (_Mystate & _Except & failbit)

	jne	SHORT $LN43@clear

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@

; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");

	jmp	SHORT $LN39@clear
$LN1@clear:

; 294  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN40@clear:

; 287  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN44@clear:
$LN42@clear:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T2[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");

	push	eax
	call	__CxxThrowException@8
$LN45@clear:
$LN43@clear:

; 233  : 			{	// construct with message

	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
$LN39@clear:
	push	OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	push	1
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T1[ebp]

; 233  : 			{	// construct with message

	mov	DWORD PTR $T1[ebp], OFFSET ??_7failure@ios_base@std@@6B@

; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");

	push	eax
	call	__CxxThrowException@8
$LN46@clear:
$LN38@clear:
	int	3
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ??Bios_base@std@@QBE_NXZ
_TEXT	SEGMENT
??Bios_base@std@@QBE_NXZ PROC				; std::ios_base::operator bool, COMDAT
; _this$ = ecx

; 275  : 
; 276  : 	bool __CLR_OR_THIS_CALL operator!() const
; 277  : 		{	// test if any stream operation has failed
; 278  : 		return (fail());
; 279  : 		}
; 280  : 
; 281  : 	void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise)
; 282  : 		{	// set state, possibly reraise exception
; 283  : 		_Mystate = (iostate)(_State & _Statmask);
; 284  : 		if ((_Mystate & _Except) == 0)
; 285  : 			;
; 286  : 		else if (_Reraise)
; 287  : 			_RERAISE;
; 288  : 		else if (_Mystate & _Except & badbit)
; 289  : 			_THROW_NCEE(failure, "ios_base::badbit set");
; 290  : 		else if (_Mystate & _Except & failbit)
; 291  : 			_THROW_NCEE(failure, "ios_base::failbit set");
; 292  : 		else
; 293  : 			_THROW_NCEE(failure, "ios_base::eofbit set");
; 294  : 		}
; 295  : 
; 296  : 	void __CLR_OR_THIS_CALL clear(iostate _State = goodbit)
; 297  : 		{	// set state to argument
; 298  : 		clear(_State, false);
; 299  : 		}
; 300  : 
; 301  : 	void __CLR_OR_THIS_CALL clear(io_state _State)
; 302  : 		{	// set state to argument, old-style
; 303  : 		clear((iostate)_State);
; 304  : 		}
; 305  : 
; 306  : 	iostate __CLR_OR_THIS_CALL rdstate() const
; 307  : 		{	// return stream state
; 308  : 		return (_Mystate);
; 309  : 		}
; 310  : 
; 311  : 	void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Exreraise)
; 312  : 		{	// merge in state argument, possibly reraise exception
; 313  : 		if (_State != goodbit)
; 314  : 			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
; 315  : 		}
; 316  : 
; 317  : 	void __CLR_OR_THIS_CALL setstate(iostate _State)
; 318  : 		{	// merge in state argument
; 319  : 		if (_State != goodbit)
; 320  : 			clear((iostate)((int)rdstate() | (int)_State), false);
; 321  : 		}
; 322  : 
; 323  : 	void __CLR_OR_THIS_CALL setstate(io_state _State)
; 324  : 		{	// merge in state argument, old style
; 325  : 		setstate((iostate)_State);
; 326  : 		}
; 327  : 
; 328  : 	bool __CLR_OR_THIS_CALL good() const
; 329  : 		{	// test if no state bits are set
; 330  : 		return (rdstate() == goodbit);
; 331  : 		}
; 332  : 
; 333  : 	bool __CLR_OR_THIS_CALL eof() const
; 334  : 		{	// test if eofbit is set in stream state
; 335  : 		return ((int)rdstate() & (int)eofbit);
; 336  : 		}
; 337  : 
; 338  : 	bool __CLR_OR_THIS_CALL fail() const
; 339  : 		{	// test if badbit or failbit is set in stream state
; 340  : 		return (((int)rdstate()
; 341  : 			& ((int)badbit | (int)failbit)) != 0);

	test	BYTE PTR [ecx+12], 6

; 273  : 		return (!fail());

	mov	eax, 0
	sete	al

; 274  : 		}

	ret	0
??Bios_base@std@@QBE_NXZ ENDP				; std::ios_base::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN12@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	push	edi
	push	esi
	mov	edi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	mov	DWORD PTR [edi], OFFSET ??_7failure@ios_base@std@@6B@
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 233  : 			{	// construct with message

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Errcode$[ebp]
	push	esi
	push	DWORD PTR __Message$[ebp]
	mov	esi, ecx
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
	mov	DWORD PTR [esi], OFFSET ??_7failure@ios_base@std@@6B@

; 234  : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 614  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	esi

; 615  : 		if (_Syserror_map(_Errval))

	mov	esi, DWORD PTR __Errval$[ebp]
	push	esi
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax

; 299  : 		{	// construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi

; 615  : 		if (_Syserror_map(_Errval))

	je	SHORT $LN2@default_er

; 299  : 		{	// construct from error code and category

	mov	DWORD PTR [eax+4], OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	pop	esi

; 616  : 			return (error_condition(_Errval, generic_category()));
; 617  : 		else
; 618  : 			return (error_condition(_Errval, system_category()));
; 619  : 		}

	pop	ebp
	ret	8
$LN2@default_er:

; 299  : 		{	// construct from error code and category

	mov	DWORD PTR [eax+4], OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	pop	esi

; 616  : 			return (error_condition(_Errval, generic_category()));
; 617  : 		else
; 618  : 			return (error_condition(_Errval, system_category()));
; 619  : 		}

	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 607  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	push	DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	add	esp, 4

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	test	eax, eax
	mov	edx, OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
	cmovne	edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN47@message
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 610  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN47@message:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL49@message:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL49@message
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 610  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 603  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 604  : 		}

	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 597  : 	_System_error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7_System_error_category@std@@6B@

; 598  : 		{	// default constructor
; 599  : 		}

	mov	eax, ecx
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 584  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	push	ecx

; 585  : 		if (_Errcode == (int)io_errc::stream)

	mov	eax, DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 585  : 		if (_Errcode == (int)io_errc::stream)

	cmp	eax, 1
	jne	SHORT $LN2@message
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	21					; 00000015H

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 588  : 			return (_Generic_error_category::message(_Errcode));

	mov	eax, esi
	pop	esi

; 589  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@message:

; 588  : 			return (_Generic_error_category::message(_Errcode));

	push	eax
	push	esi
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, esi
	pop	esi

; 589  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 580  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 581  : 		}

	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 574  : 	_Iostream_error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@

; 575  : 		{	// default constructor
; 576  : 		}

	mov	eax, ecx
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN8@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 563  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	push	DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	add	esp, 4

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	test	eax, eax
	mov	edx, OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
	cmovne	edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN47@message
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 566  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN47@message:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL49@message:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL49@message
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 566  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 559  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 560  : 		}

	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 553  : 	_Generic_error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7_Generic_error_category@std@@6B@

; 554  : 		{	// default constructor
; 555  : 		}

	mov	eax, ecx
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	push	edi
	push	esi
	mov	edi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	mov	DWORD PTR [edi], OFFSET ??_7system_error@std@@6B@
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 509  : 		{	// construct from error code and message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	edx, DWORD PTR __Message$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN47@system_err
	xor	ecx, ecx
	jmp	SHORT $LN48@system_err
$LN47@system_err:
	mov	ecx, edx
	lea	edi, DWORD PTR [ecx+1]
	npad	1
$LL81@system_err:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL81@system_err
	sub	ecx, edi
$LN48@system_err:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T2[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 509  : 		{	// construct from error code and message string

	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	push	DWORD PTR __Errcode$[ebp+4]
	mov	ecx, esi
	push	DWORD PTR __Errcode$[ebp]
	call	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T2[ebp+20], 16		; 00000010H
	jb	SHORT $LN82@system_err
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T2[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN82@system_err:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 510  : 		}

	mov	eax, esi

; 509  : 		{	// construct from error code and message string

	mov	DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@

; 510  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Ogtp
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN8@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	push	edi
	push	esi
	mov	edi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T2 = -44						; size = 4
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 484  : 		{	// construct from error code and message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	eax, DWORD PTR __Message$[ebp]
	sub	esp, 24					; 00000018H
	mov	ecx, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 726  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 484  : 		{	// construct from error code and message string

	push	DWORD PTR __Errcode$[ebp+4]
	lea	eax, DWORD PTR $T3[ebp]
	push	DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
	add	esp, 36					; 00000024H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 484  : 		{	// construct from error code and message string

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	jb	SHORT $LN56@System_err
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [eax]
$LN56@System_err:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept

; 173  : 		{	// construct from message string

	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, esi
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T3[ebp+20], 16		; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept

; 173  : 		{	// construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	jb	SHORT $LN79@System_err
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T3[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN79@System_err:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 484  : 		{	// construct from error code and message string

	mov	ecx, DWORD PTR __Errcode$[ebp]

; 485  : 		}

	mov	eax, esi
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR __Errcode$[ebp+4]
	mov	DWORD PTR [esi], OFFSET ??_7_System_error@std@@6B@
	mov	DWORD PTR [esi+16], ecx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T2 = -44						; size = 4
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 24
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 474  : 		{	// compose error message

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1793 : 		return (this->_Mysize == 0);

	cmp	DWORD PTR __Message$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 474  : 		{	// compose error message

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 475  : 		if (!_Message.empty())

	je	SHORT $LN10@Makestr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
	lea	ecx, DWORD PTR __Message$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN10@Makestr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 477  : 		_Message.append(_Errcode.message());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR __Errcode$[ebp]
	call	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR __Message$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 477  : 		_Message.append(_Errcode.message());

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1039 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR $T3[ebp+20], 16		; 00000010H
	jb	SHORT $LN38@Makestr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR $T3[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN38@Makestr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	edx, DWORD PTR __Message$[ebp+20]
	cmp	edx, 16					; 00000010H
	jae	SHORT $LN91@Makestr

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	eax, DWORD PTR __Message$[ebp+16]
	inc	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN90@Makestr
	push	eax
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	push	esi
	call	_memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	mov	edx, DWORD PTR __Message$[ebp+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	jmp	SHORT $LN90@Makestr
$LN91@Makestr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Message$[ebp]
	mov	DWORD PTR [esi], ecx
$LN90@Makestr:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 944  : 		this->_Mysize = _Right._Mysize;

	mov	ecx, DWORD PTR __Message$[ebp+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 478  : 		return (_Message);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 944  : 		this->_Mysize = _Right._Mysize;

	mov	DWORD PTR [esi+16], ecx

; 945  : 		this->_Myres = _Right._Myres;

	mov	DWORD PTR [esi+20], edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 479  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0:
	lea	ecx, DWORD PTR __Message$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 352  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp

; 177  : 		return (this == &_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	mov	al, 1

; 355  : 		}

	pop	ebp
	ret	4
$LN3@operator:

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	xor	al, al

; 355  : 		}

	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 338  : 		return (*_Mycat);

	mov	eax, DWORD PTR [ecx+4]

; 339  : 		}

	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 333  : 		return (_Myval);

	mov	eax, DWORD PTR [ecx]

; 334  : 		}

	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 299  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 300  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 253  : 		{	// get name of error code

	push	ebp
	mov	ebp, esp
	push	ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR [ecx+4]

; 254  : 		return (category().message(value()));

	push	DWORD PTR [ecx]
	mov	ecx, eax
	mov	DWORD PTR $T1[ebp], 0
	push	DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 255  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR [ecx+4]

; 248  : 		}

	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 242  : 		return (_Myval);

	mov	eax, DWORD PTR [ecx]

; 243  : 		}

	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 208  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 209  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 176  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp

; 177  : 		return (this == &_Right);

	xor	eax, eax
	cmp	ecx, DWORD PTR __Right$[ebp]
	sete	al

; 178  : 		}

	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 391  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp

; 177  : 		return (this == &_Right);

	mov	eax, DWORD PTR __Code$[ebp]
	cmp	ecx, DWORD PTR [eax+4]

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	jne	SHORT $LN3@equivalent
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	al, 1

; 393  : 	}

	pop	ebp
	ret	8
$LN3@equivalent:

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	xor	al, al

; 393  : 	}

	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 384  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T1[ebp]
	sub	esp, 8
	push	DWORD PTR __Errval$[ebp]
	push	edx
	call	DWORD PTR [eax+12]

; 177  : 		return (this == &_Right);

	mov	edx, DWORD PTR __Cond$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edx+4]

; 178  : 		}
; 179  : 
; 180  : 	bool operator!=(const error_category& _Right) const _NOEXCEPT
; 181  : 		{	// compare categories for inequality
; 182  : 		return (!(*this == _Right));
; 183  : 		}
; 184  : 
; 185  : 	bool operator<(const error_category& _Right) const _NOEXCEPT
; 186  : 		{	// compare categories for order
; 187  : 		return (this < &_Right);
; 188  : 		}
; 189  : 
; 190  : 	error_category(const error_category&) = delete;
; 191  : 	error_category& operator=(const error_category&) = delete;
; 192  : 	};
; 193  : 
; 194  : 		// CLASS error_code
; 195  : class error_code
; 196  : 	{	// store an implementation-specific error code and category
; 197  : public:
; 198  : 	typedef error_code _Myt;
; 199  : 
; 200  : 	error_code()
; 201  : 		: _Myval(0),
; 202  : 			_Mycat(&system_category())
; 203  : 		{	// construct non-error
; 204  : 		}
; 205  : 
; 206  : 	error_code(int _Val, const error_category& _Cat)
; 207  : 		: _Myval(_Val), _Mycat(&_Cat)
; 208  : 		{	// construct from error code and category
; 209  : 		}
; 210  : 
; 211  : 	template<class _Enum,
; 212  : 		class = typename enable_if<is_error_code_enum<_Enum>::value,
; 213  : 			void>::type>
; 214  : 		error_code(_Enum _Errcode)
; 215  : 		: _Myval(0), _Mycat(0)
; 216  : 		{	// construct from enumerated error code
; 217  : 		*this = make_error_code(_Errcode);	// using ADL
; 218  : 		}
; 219  : 
; 220  : 	void assign(int _Val, const error_category& _Cat)
; 221  : 		{	// assign error code and category
; 222  : 		_Myval = _Val;
; 223  : 		_Mycat = &_Cat;
; 224  : 		}
; 225  : 
; 226  : 	template<class _Enum>
; 227  : 		typename enable_if<is_error_code_enum<_Enum>::value,
; 228  : 			error_code>::type& operator=(_Enum _Errcode)
; 229  : 		{	// assign enumerated error code
; 230  : 		*this = make_error_code(_Errcode);	// using ADL
; 231  : 		return (*this);
; 232  : 		}
; 233  : 
; 234  : 	void clear() _NOEXCEPT
; 235  : 		{	// assign non-error
; 236  : 		_Myval = 0;
; 237  : 		_Mycat = &system_category();
; 238  : 		}
; 239  : 
; 240  : 	int value() const
; 241  : 		{	// get error code
; 242  : 		return (_Myval);
; 243  : 		}
; 244  : 
; 245  : 	const error_category& category() const
; 246  : 		{	// get category
; 247  : 		return (*_Mycat);
; 248  : 		}
; 249  : 
; 250  : 	error_condition default_error_condition() const;
; 251  : 
; 252  : 	string message() const
; 253  : 		{	// get name of error code
; 254  : 		return (category().message(value()));
; 255  : 		}
; 256  : 
; 257  : 	explicit operator bool() const _NOEXCEPT
; 258  : 		{	// test for actual error
; 259  : 		return (value() != 0);
; 260  : 		}
; 261  : 
; 262  : 	bool operator==(const error_code& _Right) const _NOEXCEPT
; 263  : 		{	// test if *this == _Right
; 264  : 		return (category() == _Right.category()
; 265  : 			&& value() == _Right.value());
; 266  : 		}
; 267  : 
; 268  : 	bool operator!=(const error_code& _Right) const _NOEXCEPT
; 269  : 		{	// test if *this != _Right
; 270  : 		return (!(*this == _Right));
; 271  : 		}
; 272  : 
; 273  : 	bool operator<(const error_code& _Right) const _NOEXCEPT
; 274  : 		{	// test if *this == _Right
; 275  : 		return (category() < _Right.category()
; 276  : 			|| (category() == _Right.category()
; 277  : 				&& value() < _Right.value()));
; 278  : 		}
; 279  : 
; 280  : private:
; 281  : 	int _Myval;	// the stored error number
; 282  : 	const error_category *_Mycat;	// pointer to error category
; 283  : 	};
; 284  : 
; 285  : 		// CLASS error_condition
; 286  : class error_condition
; 287  : 	{	// store an abstract error code and category
; 288  : public:
; 289  : 	typedef error_condition _Myt;
; 290  : 
; 291  : 	error_condition() _NOEXCEPT
; 292  : 		: _Myval(0),
; 293  : 			_Mycat(&generic_category())
; 294  : 		{	// construct non-error
; 295  : 		}
; 296  : 
; 297  : 	error_condition(int _Val, const error_category& _Cat) _NOEXCEPT
; 298  : 		: _Myval(_Val), _Mycat(&_Cat)
; 299  : 		{	// construct from error code and category
; 300  : 		}
; 301  : 
; 302  : 	template<class _Enum,
; 303  : 		class = typename enable_if<is_error_condition_enum<_Enum>::value,
; 304  : 			void>::type>
; 305  : 		error_condition(_Enum _Errcode) _NOEXCEPT
; 306  : 		: _Myval(0), _Mycat(0)
; 307  : 		{	// construct from enumerated error code
; 308  : 		*this = make_error_condition(_Errcode);	// using ADL
; 309  : 		}
; 310  : 
; 311  : 	void assign(int _Val, const error_category& _Cat) _NOEXCEPT
; 312  : 		{	// assign error code and category
; 313  : 		_Myval = _Val;
; 314  : 		_Mycat = &_Cat;
; 315  : 		}
; 316  : 
; 317  : 	template<class _Enum>
; 318  : 		typename enable_if<is_error_condition_enum<_Enum>::value,
; 319  : 			error_condition>::type& operator=(_Enum _Errcode) _NOEXCEPT
; 320  : 		{	// assign enumerated error code
; 321  : 		*this = make_error_condition(_Errcode);	// using ADL
; 322  : 		return (*this);
; 323  : 		}
; 324  : 
; 325  : 	void clear() _NOEXCEPT
; 326  : 		{	// assign non-error
; 327  : 		_Myval = 0;
; 328  : 		_Mycat = &generic_category();
; 329  : 		}
; 330  : 
; 331  : 	int value() const _NOEXCEPT
; 332  : 		{	// get error code
; 333  : 		return (_Myval);
; 334  : 		}
; 335  : 
; 336  : 	const error_category& category() const _NOEXCEPT
; 337  : 		{	// get category
; 338  : 		return (*_Mycat);
; 339  : 		}
; 340  : 
; 341  : 	string message() const
; 342  : 		{	// get name of error code
; 343  : 		return (category().message(value()));
; 344  : 		}
; 345  : 
; 346  : 	explicit operator bool() const _NOEXCEPT
; 347  : 		{	// test for actual error
; 348  : 		return (value() != 0);
; 349  : 		}
; 350  : 
; 351  : 	bool operator==(const error_condition& _Right) const _NOEXCEPT
; 352  : 		{	// test if *this == _Right
; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	jne	SHORT $LN5@equivalent
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN5@equivalent

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	al, 1

; 386  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN5@equivalent:

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	xor	al, al

; 386  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 377  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp

; 299  : 		{	// construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Errval$[ebp]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 378  : 	return (error_condition(_Errval, *this));
; 379  : 	}

	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 160  : 		}

	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 154  : 	error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 155  : 		{	// default constructor
; 156  : 		}

	mov	eax, ecx
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 653  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 654  : 	}

	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 648  : 	return (_Error_objects<int>::_Iostream_object);

	mov	eax, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object

; 649  : 	}

	ret	0
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 643  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 644  : 	}

	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 440  : 	{	// make an error_code

	push	ebp
	mov	ebp, esp

; 208  : 		{	// construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Errno$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object

; 441  : 	return (error_code((int)_Errno, iostream_category()));
; 442  : 	}

	pop	ebp
	ret	0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
__Lock$3 = -24						; size = 4
__Lock$4 = -20						; size = 4
__Psave$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 561  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 562  :  #if _NO_LOCALES
; 563  : 	static _Wrap_facet<_Facet> _Wfac;
; 564  : 	return (*(_Facet *)&_Wfac);
; 565  : 
; 566  :  #else /* _NO_LOCALES */
; 567  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 79   : 			if (_Id == 0)

	mov	edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id

; 568  : 		const locale::facet *_Psave =
; 569  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __Psave$5[ebp], ebx

; 79   : 			if (_Id == 0)

	test	edi, edi
	jne	SHORT $LN11@use_facet

; 80   : 				{	// still zero, allocate stamp
; 81   : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 82   : 					if (_Id == 0)

	cmp	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, edi ; std::ctype<char>::id
	jne	SHORT $LN10@use_facet

; 83   : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN10@use_facet:

; 84   : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
$LN11@use_facet:

; 85   : 				}
; 86   : 			return (_Id);
; 87   : 			}
; 88   : 
; 89   : 	private:
; 90   : 		size_t _Id;	// the identifier stamp
; 91   : 
; 92   : 		__PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 93   : 
; 94   : 	public:
; 95   : 		__CLR_OR_THIS_CALL id(const id&) = delete;
; 96   : 		id& __CLR_OR_THIS_CALL operator=(const id&) = delete;
; 97   : 		};
; 98   : 
; 99   : 	class _Locimp;
; 100  : 
; 101  : 			// CLASS facet
; 102  : 	class _CRTIMP2_PURE facet
; 103  : 		: public _Facet_base
; 104  : 		{	// base class for all locale facets, performs reference counting
; 105  : 		friend class locale;
; 106  : 		friend class _Locimp;
; 107  : 
; 108  : 		template<class _Ty>
; 109  : 			friend void __CLRCALL_OR_CDECL _DebugHeapDelete(_Ty *_Ptr);
; 110  : 
; 111  : 	public:
; 112  : 		static size_t __CLRCALL_OR_CDECL _Getcat(const facet ** = 0,
; 113  : 			const locale * = 0)
; 114  : 			{	// get category value, or -1 if no corresponding C category
; 115  : 			return ((size_t)(-1));
; 116  : 			}
; 117  : 
; 118  :   #if defined(_DEBUG) && !defined(_M_X64)
; 119  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size)
; 120  : 			{	// replace operator new
; 121  : 			return (operator new(_Size, _DebugHeapTag_func(),
; 122  : 				__FILE__, __LINE__));
; 123  : 			}
; 124  : 
; 125  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size,
; 126  : 			const _DebugHeapTag_t& _Tag, char *_File, int _Line)
; 127  : 			{	// replace debugging operator new
; 128  : 			return (::operator new(_Size, _Tag, _File, _Line));
; 129  : 			}
; 130  : 
; 131  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr,
; 132  : 			const _DebugHeapTag_t&, char *, int)
; 133  : 			{	// replace debugging operator delete
; 134  : 			operator delete(_Ptr);
; 135  : 			}
; 136  : 
; 137  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr)
; 138  : 			{	// replace operator delete
; 139  : 			_DebugHeapDelete((facet *)_Ptr);
; 140  : 			}
; 141  :   #endif /* defined(_DEBUG) etc. */
; 142  : 
; 143  : 		virtual void __CLR_OR_THIS_CALL _Incref()
; 144  : 			{   // increment use count
; 145  : 			_MT_INCR(_Mtx, _Refs);
; 146  : 			}
; 147  : 
; 148  : 		virtual _Facet_base *__CLR_OR_THIS_CALL _Decref()
; 149  : 			{   // decrement use count
; 150  : 			if (_MT_DECR(_Mtx, _Refs) == 0)
; 151  : 				return (this);
; 152  : 			else
; 153  : 				return (0);
; 154  : 			}
; 155  : 
; 156  : 	private:
; 157  : 		_Atomic_counter_t _Refs;	// the reference count
; 158  : 
; 159  : 	protected:
; 160  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 161  : 			{	// construct with initial reference count
; 162  : 			_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
; 163  : 			}
; 164  : 
; 165  : 		virtual __CLR_OR_THIS_CALL ~facet() _NOEXCEPT
; 166  : 			{	// ensure that derived classes can be destroyed properly
; 167  : 			}
; 168  : 
; 169  : 	public:
; 170  : 		__CLR_OR_THIS_CALL facet(const facet&) = delete;
; 171  : 		facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 172  : 		};
; 173  : 
; 174  : 			// CLASS _Locimp
; 175  :  #pragma warning(push)
; 176  :  #pragma warning(disable: 4275)
; 177  : 
; 178  : 	class _CRTIMP2_PURE _Locimp
; 179  : 		: public facet
; 180  : 		{	// reference-counted actual implementation of a locale
; 181  : 	protected:
; 182  : 		__CLR_OR_THIS_CALL ~_Locimp() _NOEXCEPT
; 183  : 		{	// destroy the object
; 184  : 		_Locimp_dtor(this);
; 185  : 		}
; 186  : 
; 187  : 	private:
; 188  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 189  : 			_New_Locimp(bool _Transparent = false);
; 190  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 191  : 			_New_Locimp(const _Locimp& _Right);
; 192  : 
; 193  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 194  : 			_Locimp_dtor(_Locimp *);
; 195  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 196  : 			_Locimp_Addfac(_Locimp *, facet *, size_t);	// add a facet
; 197  : 		static void __CLRCALL_PURE_OR_CDECL
; 198  : 			_Locimp_ctor(_Locimp *, const _Locimp&);
; 199  : 
; 200  : 		friend class locale;
; 201  : 
; 202  : 		__CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 203  : 			: locale::facet(1), _Facetvec(0), _Facetcount(0),
; 204  : 				_Catmask(none), _Xparent(_Transparent),
; 205  : 					_Name("*")
; 206  : 			{	// construct an empty _Locimp
; 207  : 			}
; 208  : 
; 209  : 		__CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 210  : 			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
; 211  : 				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
; 212  : 					_Name(_Right._Name.c_str())
; 213  : 			{	// construct by copying
; 214  : 			_Locimp_ctor(this, _Right);
; 215  : 			}
; 216  : 
; 217  : 		void __CLR_OR_THIS_CALL _Addfac(facet *_Pfacet, size_t _Id)
; 218  : 			{	// add a facet
; 219  : 			_Locimp_Addfac(this, _Pfacet, _Id);
; 220  : 			}
; 221  : 
; 222  : 		static _Locimp *__CLRCALL_OR_CDECL _Makeloc(const _Locinfo&,
; 223  : 			category, _Locimp *, const locale *);	// make essential facets
; 224  : 
; 225  : 		static void __CLRCALL_OR_CDECL _Makewloc(const _Locinfo&,
; 226  : 			category, _Locimp *, const locale *);	// make wchar_t facets
; 227  : 
; 228  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 229  : 		static void __CLRCALL_OR_CDECL _Makeushloc(const _Locinfo&,
; 230  : 			category, _Locimp *, const locale *);	// make ushort facets
; 231  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 232  : 
; 233  : 		static void __CLRCALL_OR_CDECL _Makexloc(const _Locinfo&,
; 234  : 			category, _Locimp *, const locale *);	// make remaining facets
; 235  : 
; 236  : 		facet **_Facetvec;	// pointer to vector of facets
; 237  : 		size_t _Facetcount;	// size of vector of facets
; 238  : 		category _Catmask;	// mask describing implemented categories
; 239  : 		bool _Xparent;	// true if locale is transparent
; 240  : 		_Yarn<char> _Name;	// locale name, or "*" if not known
; 241  : 
; 242  : 		__PURE_APPDOMAIN_GLOBAL static _Locimp *_Clocptr;
; 243  : 
; 244  : public:
; 245  : 		_Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 246  : 		};
; 247  : 
; 248  :  #pragma warning(pop)
; 249  : 
; 250  : 	template<class _Elem,
; 251  : 		class _Traits,
; 252  : 		class _Alloc>
; 253  : 		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 254  : 			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
; 255  : 		{	// compare _Left and _Right strings using collate facet in locale
; 256  : 		const _STD collate<_Elem>& _Coll_fac =
; 257  : 			use_facet<_STD collate<_Elem> >(*this);
; 258  : 
; 259  : 		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
; 260  : 			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
; 261  : 		}
; 262  : 
; 263  : 	template<class _Facet>
; 264  : 		locale combine(const locale& _Loc) const
; 265  : 		{	// combine two locales
; 266  : 		_Facet *_Facptr;
; 267  : 
; 268  : 		_TRY_BEGIN
; 269  : 			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
; 270  : 		_CATCH_ALL
; 271  : 			_Xruntime_error("locale::combine facet missing");
; 272  : 		_CATCH_END
; 273  : 
; 274  : 		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
; 275  : 		_Newimp->_Addfac(_Facptr, _Facet::id);
; 276  : 		_Newimp->_Catmask = 0;
; 277  : 		_Newimp->_Name = "*";
; 278  : 		return (locale(_Newimp));
; 279  : 		}
; 280  : 
; 281  : 	template<class _Facet>
; 282  : 		locale(const locale& _Loc, const _Facet *_Facptr)
; 283  : 			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 284  : 		{	// construct from _Loc, replacing facet with *_Facptr
; 285  : 		if (_Facptr != 0)
; 286  : 			{	// replace facet
; 287  : 			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
; 288  : 			if (_Facet::_Getcat() != (size_t)(-1))
; 289  : 				{	// no C category
; 290  : 				_Ptr->_Catmask = 0;
; 291  : 				_Ptr->_Name = "*";
; 292  : 				}
; 293  : 			}
; 294  : 		}
; 295  : 
; 296  : 	locale(_Uninitialized)
; 297  : 		{	// defer construction
; 298  : 		}
; 299  : 
; 300  :  #if _NO_LOCALES
; 301  : 	locale(const locale& _Right) _THROW0()
; 302  : 		: _Ptr(0)
; 303  : 		{	// construct by copying
; 304  : 		}
; 305  : 
; 306  : 	locale() _THROW0()
; 307  : 		: _Ptr(0)
; 308  : 		{	// construct from current locale
; 309  : 		}
; 310  : 
; 311  : 	~locale() _NOEXCEPT
; 312  : 		{	// destroy the object
; 313  : 		}
; 314  : 
; 315  : 	locale& operator=(const locale& _Right) _THROW0()
; 316  : 		{	// assign a locale
; 317  : 		return (*this);
; 318  : 		}
; 319  : 
; 320  :  #else /* _NO_LOCALES */
; 321  : 	locale(const locale& _Right) _THROW0()
; 322  : 		: _Ptr(_Right._Ptr)
; 323  : 		{	// construct by copying
; 324  : 		_Ptr->_Incref();
; 325  : 		}
; 326  : 
; 327  : 	locale() _THROW0()
; 328  : 		: _Ptr(_Init(true))
; 329  : 		{	// construct from current locale
; 330  : 		}
; 331  : 
; 332  :  #if !defined(MRTDLL) || !defined(_CRTBLD)
; 333  : 	locale(const locale& _Loc, const locale& _Other,
; 334  : 		category _Cat)
; 335  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 336  : 		{	// construct a locale by copying named facets
; 337  : 		_TRY_BEGIN
; 338  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 339  : 			_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
; 340  : 				_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
; 341  : 		_END_LOCINFO()
; 342  : 		_CATCH_ALL
; 343  : 		_DELETE_CRT(_Ptr->_Decref());
; 344  : 		_RERAISE;
; 345  : 		_CATCH_END
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	void _Construct(const string &_Str,
; 350  : 		category _Cat)	// construct from named locale for category
; 351  : 		{	// construct a locale with named facets
; 352  : 		bool _Bad = false;
; 353  : 		_TRY_BEGIN
; 354  : 		_Init();
; 355  : 		_BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 356  : 			if (_Badname(_Lobj))
; 357  : 				_Bad = true;
; 358  : 			else
; 359  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 360  : 		_END_LOCINFO()
; 361  : 		_CATCH_ALL
; 362  : 		_DELETE_CRT(_Ptr->_Decref());
; 363  : 		_RERAISE;
; 364  : 		_CATCH_END
; 365  : 
; 366  : 		if (_Bad)
; 367  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 368  : 			_DELETE_CRT(_Ptr->_Decref());
; 369  : 			_Xruntime_error("bad locale name");
; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 	void _Construct(const locale& _Loc, const string &_Str,
; 374  : 		category _Cat)
; 375  : 		{	// construct a locale by copying, replacing named facets
; 376  : 		bool _Bad = false;
; 377  : 		_TRY_BEGIN
; 378  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 379  : 			bool _Hadname = !_Badname(_Lobj);
; 380  : 			_Lobj._Addcats(_Cat, _Str.c_str());
; 381  : 
; 382  : 			if (_Hadname && _Badname(_Lobj))
; 383  : 				_Bad = true;
; 384  : 			else
; 385  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 386  : 		_END_LOCINFO()
; 387  : 		_CATCH_ALL
; 388  : 		_DELETE_CRT(_Ptr->_Decref());
; 389  : 		_RERAISE;
; 390  : 		_CATCH_END
; 391  : 
; 392  : 		if (_Bad)
; 393  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 394  : 			_DELETE_CRT(_Ptr->_Decref());
; 395  : 			_Xruntime_error("bad locale name");
; 396  : 			}
; 397  : 		}
; 398  : 
; 399  : public:
; 400  : 	explicit locale(const char *_Locname,
; 401  : 		category _Cat = all)	// construct from named locale for category
; 402  : 		: _Ptr(_Locimp::_New_Locimp())
; 403  : 		{	// construct a locale with named facets
; 404  : 		// _Locname might have been returned from setlocale().
; 405  : 		// Therefore, _Construct() takes const string&.
; 406  : 		if (_Locname == 0)
; 407  : 			_Xruntime_error("bad locale name");
; 408  : 		_Construct(_Locname, _Cat);
; 409  : 		}
; 410  : 
; 411  : 	locale(const locale& _Loc, const char *_Locname,
; 412  : 		category _Cat)
; 413  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 414  : 		{	// construct a locale by copying, replacing named facets
; 415  : 		// _Locname might have been returned from setlocale().
; 416  : 		// Therefore, _Construct() takes const string&.
; 417  : 		if (_Locname == 0)
; 418  : 			_Xruntime_error("bad locale name");
; 419  : 		_Construct(_Loc, _Locname, _Cat);
; 420  : 		}
; 421  : 
; 422  : 	explicit locale(const string& _Str,
; 423  : 		category _Cat = all)	// construct from named locale for category
; 424  : 		: _Ptr(_Locimp::_New_Locimp())
; 425  : 		{	// construct a locale with named facets
; 426  : 		_Construct(_Str, _Cat);
; 427  : 		}
; 428  : 
; 429  : 	locale(const locale& _Loc, const string& _Str,
; 430  : 		category _Cat)
; 431  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 432  : 		{	// construct a locale by copying, replacing named facets
; 433  : 		_Construct(_Loc, _Str, _Cat);
; 434  : 		}
; 435  :  #endif /* !MRTDLL || !_CRTBLD */
; 436  : 
; 437  : 	~locale() _NOEXCEPT
; 438  : 		{	// destroy the object
; 439  : 		if (_Ptr != 0)
; 440  : 			_DELETE_CRT(_Ptr->_Decref());
; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	mov	ecx, DWORD PTR __Loc$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN20@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	SHORT $LN1@use_facet
	jmp	SHORT $LN24@use_facet
$LN20@use_facet:

; 85   : 				}
; 86   : 			return (_Id);
; 87   : 			}
; 88   : 
; 89   : 	private:
; 90   : 		size_t _Id;	// the identifier stamp
; 91   : 
; 92   : 		__PURE_APPDOMAIN_GLOBAL static int _Id_cnt;
; 93   : 
; 94   : 	public:
; 95   : 		__CLR_OR_THIS_CALL id(const id&) = delete;
; 96   : 		id& __CLR_OR_THIS_CALL operator=(const id&) = delete;
; 97   : 		};
; 98   : 
; 99   : 	class _Locimp;
; 100  : 
; 101  : 			// CLASS facet
; 102  : 	class _CRTIMP2_PURE facet
; 103  : 		: public _Facet_base
; 104  : 		{	// base class for all locale facets, performs reference counting
; 105  : 		friend class locale;
; 106  : 		friend class _Locimp;
; 107  : 
; 108  : 		template<class _Ty>
; 109  : 			friend void __CLRCALL_OR_CDECL _DebugHeapDelete(_Ty *_Ptr);
; 110  : 
; 111  : 	public:
; 112  : 		static size_t __CLRCALL_OR_CDECL _Getcat(const facet ** = 0,
; 113  : 			const locale * = 0)
; 114  : 			{	// get category value, or -1 if no corresponding C category
; 115  : 			return ((size_t)(-1));
; 116  : 			}
; 117  : 
; 118  :   #if defined(_DEBUG) && !defined(_M_X64)
; 119  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size)
; 120  : 			{	// replace operator new
; 121  : 			return (operator new(_Size, _DebugHeapTag_func(),
; 122  : 				__FILE__, __LINE__));
; 123  : 			}
; 124  : 
; 125  : 		void *__CLRCALL_OR_CDECL operator new(size_t _Size,
; 126  : 			const _DebugHeapTag_t& _Tag, char *_File, int _Line)
; 127  : 			{	// replace debugging operator new
; 128  : 			return (::operator new(_Size, _Tag, _File, _Line));
; 129  : 			}
; 130  : 
; 131  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr,
; 132  : 			const _DebugHeapTag_t&, char *, int)
; 133  : 			{	// replace debugging operator delete
; 134  : 			operator delete(_Ptr);
; 135  : 			}
; 136  : 
; 137  : 		void __CLRCALL_OR_CDECL operator delete(void *_Ptr)
; 138  : 			{	// replace operator delete
; 139  : 			_DebugHeapDelete((facet *)_Ptr);
; 140  : 			}
; 141  :   #endif /* defined(_DEBUG) etc. */
; 142  : 
; 143  : 		virtual void __CLR_OR_THIS_CALL _Incref()
; 144  : 			{   // increment use count
; 145  : 			_MT_INCR(_Mtx, _Refs);
; 146  : 			}
; 147  : 
; 148  : 		virtual _Facet_base *__CLR_OR_THIS_CALL _Decref()
; 149  : 			{   // decrement use count
; 150  : 			if (_MT_DECR(_Mtx, _Refs) == 0)
; 151  : 				return (this);
; 152  : 			else
; 153  : 				return (0);
; 154  : 			}
; 155  : 
; 156  : 	private:
; 157  : 		_Atomic_counter_t _Refs;	// the reference count
; 158  : 
; 159  : 	protected:
; 160  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
; 161  : 			{	// construct with initial reference count
; 162  : 			_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
; 163  : 			}
; 164  : 
; 165  : 		virtual __CLR_OR_THIS_CALL ~facet() _NOEXCEPT
; 166  : 			{	// ensure that derived classes can be destroyed properly
; 167  : 			}
; 168  : 
; 169  : 	public:
; 170  : 		__CLR_OR_THIS_CALL facet(const facet&) = delete;
; 171  : 		facet& __CLR_OR_THIS_CALL operator=(const facet&) = delete;
; 172  : 		};
; 173  : 
; 174  : 			// CLASS _Locimp
; 175  :  #pragma warning(push)
; 176  :  #pragma warning(disable: 4275)
; 177  : 
; 178  : 	class _CRTIMP2_PURE _Locimp
; 179  : 		: public facet
; 180  : 		{	// reference-counted actual implementation of a locale
; 181  : 	protected:
; 182  : 		__CLR_OR_THIS_CALL ~_Locimp() _NOEXCEPT
; 183  : 		{	// destroy the object
; 184  : 		_Locimp_dtor(this);
; 185  : 		}
; 186  : 
; 187  : 	private:
; 188  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 189  : 			_New_Locimp(bool _Transparent = false);
; 190  : 		static _MRTIMP2_PURE_NPURE _Locimp *__CLRCALL_PURE_OR_CDECL
; 191  : 			_New_Locimp(const _Locimp& _Right);
; 192  : 
; 193  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 194  : 			_Locimp_dtor(_Locimp *);
; 195  : 		static _MRTIMP2_PURE_NPURE void __CLRCALL_PURE_OR_CDECL
; 196  : 			_Locimp_Addfac(_Locimp *, facet *, size_t);	// add a facet
; 197  : 		static void __CLRCALL_PURE_OR_CDECL
; 198  : 			_Locimp_ctor(_Locimp *, const _Locimp&);
; 199  : 
; 200  : 		friend class locale;
; 201  : 
; 202  : 		__CLR_OR_THIS_CALL _Locimp(bool _Transparent)
; 203  : 			: locale::facet(1), _Facetvec(0), _Facetcount(0),
; 204  : 				_Catmask(none), _Xparent(_Transparent),
; 205  : 					_Name("*")
; 206  : 			{	// construct an empty _Locimp
; 207  : 			}
; 208  : 
; 209  : 		__CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
; 210  : 			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
; 211  : 				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
; 212  : 					_Name(_Right._Name.c_str())
; 213  : 			{	// construct by copying
; 214  : 			_Locimp_ctor(this, _Right);
; 215  : 			}
; 216  : 
; 217  : 		void __CLR_OR_THIS_CALL _Addfac(facet *_Pfacet, size_t _Id)
; 218  : 			{	// add a facet
; 219  : 			_Locimp_Addfac(this, _Pfacet, _Id);
; 220  : 			}
; 221  : 
; 222  : 		static _Locimp *__CLRCALL_OR_CDECL _Makeloc(const _Locinfo&,
; 223  : 			category, _Locimp *, const locale *);	// make essential facets
; 224  : 
; 225  : 		static void __CLRCALL_OR_CDECL _Makewloc(const _Locinfo&,
; 226  : 			category, _Locimp *, const locale *);	// make wchar_t facets
; 227  : 
; 228  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 229  : 		static void __CLRCALL_OR_CDECL _Makeushloc(const _Locinfo&,
; 230  : 			category, _Locimp *, const locale *);	// make ushort facets
; 231  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 232  : 
; 233  : 		static void __CLRCALL_OR_CDECL _Makexloc(const _Locinfo&,
; 234  : 			category, _Locimp *, const locale *);	// make remaining facets
; 235  : 
; 236  : 		facet **_Facetvec;	// pointer to vector of facets
; 237  : 		size_t _Facetcount;	// size of vector of facets
; 238  : 		category _Catmask;	// mask describing implemented categories
; 239  : 		bool _Xparent;	// true if locale is transparent
; 240  : 		_Yarn<char> _Name;	// locale name, or "*" if not known
; 241  : 
; 242  : 		__PURE_APPDOMAIN_GLOBAL static _Locimp *_Clocptr;
; 243  : 
; 244  : public:
; 245  : 		_Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&) = delete;
; 246  : 		};
; 247  : 
; 248  :  #pragma warning(pop)
; 249  : 
; 250  : 	template<class _Elem,
; 251  : 		class _Traits,
; 252  : 		class _Alloc>
; 253  : 		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 254  : 			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
; 255  : 		{	// compare _Left and _Right strings using collate facet in locale
; 256  : 		const _STD collate<_Elem>& _Coll_fac =
; 257  : 			use_facet<_STD collate<_Elem> >(*this);
; 258  : 
; 259  : 		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
; 260  : 			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
; 261  : 		}
; 262  : 
; 263  : 	template<class _Facet>
; 264  : 		locale combine(const locale& _Loc) const
; 265  : 		{	// combine two locales
; 266  : 		_Facet *_Facptr;
; 267  : 
; 268  : 		_TRY_BEGIN
; 269  : 			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
; 270  : 		_CATCH_ALL
; 271  : 			_Xruntime_error("locale::combine facet missing");
; 272  : 		_CATCH_END
; 273  : 
; 274  : 		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
; 275  : 		_Newimp->_Addfac(_Facptr, _Facet::id);
; 276  : 		_Newimp->_Catmask = 0;
; 277  : 		_Newimp->_Name = "*";
; 278  : 		return (locale(_Newimp));
; 279  : 		}
; 280  : 
; 281  : 	template<class _Facet>
; 282  : 		locale(const locale& _Loc, const _Facet *_Facptr)
; 283  : 			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 284  : 		{	// construct from _Loc, replacing facet with *_Facptr
; 285  : 		if (_Facptr != 0)
; 286  : 			{	// replace facet
; 287  : 			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
; 288  : 			if (_Facet::_Getcat() != (size_t)(-1))
; 289  : 				{	// no C category
; 290  : 				_Ptr->_Catmask = 0;
; 291  : 				_Ptr->_Name = "*";
; 292  : 				}
; 293  : 			}
; 294  : 		}
; 295  : 
; 296  : 	locale(_Uninitialized)
; 297  : 		{	// defer construction
; 298  : 		}
; 299  : 
; 300  :  #if _NO_LOCALES
; 301  : 	locale(const locale& _Right) _THROW0()
; 302  : 		: _Ptr(0)
; 303  : 		{	// construct by copying
; 304  : 		}
; 305  : 
; 306  : 	locale() _THROW0()
; 307  : 		: _Ptr(0)
; 308  : 		{	// construct from current locale
; 309  : 		}
; 310  : 
; 311  : 	~locale() _NOEXCEPT
; 312  : 		{	// destroy the object
; 313  : 		}
; 314  : 
; 315  : 	locale& operator=(const locale& _Right) _THROW0()
; 316  : 		{	// assign a locale
; 317  : 		return (*this);
; 318  : 		}
; 319  : 
; 320  :  #else /* _NO_LOCALES */
; 321  : 	locale(const locale& _Right) _THROW0()
; 322  : 		: _Ptr(_Right._Ptr)
; 323  : 		{	// construct by copying
; 324  : 		_Ptr->_Incref();
; 325  : 		}
; 326  : 
; 327  : 	locale() _THROW0()
; 328  : 		: _Ptr(_Init(true))
; 329  : 		{	// construct from current locale
; 330  : 		}
; 331  : 
; 332  :  #if !defined(MRTDLL) || !defined(_CRTBLD)
; 333  : 	locale(const locale& _Loc, const locale& _Other,
; 334  : 		category _Cat)
; 335  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 336  : 		{	// construct a locale by copying named facets
; 337  : 		_TRY_BEGIN
; 338  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 339  : 			_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
; 340  : 				_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
; 341  : 		_END_LOCINFO()
; 342  : 		_CATCH_ALL
; 343  : 		_DELETE_CRT(_Ptr->_Decref());
; 344  : 		_RERAISE;
; 345  : 		_CATCH_END
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	void _Construct(const string &_Str,
; 350  : 		category _Cat)	// construct from named locale for category
; 351  : 		{	// construct a locale with named facets
; 352  : 		bool _Bad = false;
; 353  : 		_TRY_BEGIN
; 354  : 		_Init();
; 355  : 		_BEGIN_LOCINFO(_Lobj(_Cat, _Str.c_str()))
; 356  : 			if (_Badname(_Lobj))
; 357  : 				_Bad = true;
; 358  : 			else
; 359  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 360  : 		_END_LOCINFO()
; 361  : 		_CATCH_ALL
; 362  : 		_DELETE_CRT(_Ptr->_Decref());
; 363  : 		_RERAISE;
; 364  : 		_CATCH_END
; 365  : 
; 366  : 		if (_Bad)
; 367  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 368  : 			_DELETE_CRT(_Ptr->_Decref());
; 369  : 			_Xruntime_error("bad locale name");
; 370  : 			}
; 371  : 		}
; 372  : 
; 373  : 	void _Construct(const locale& _Loc, const string &_Str,
; 374  : 		category _Cat)
; 375  : 		{	// construct a locale by copying, replacing named facets
; 376  : 		bool _Bad = false;
; 377  : 		_TRY_BEGIN
; 378  : 		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
; 379  : 			bool _Hadname = !_Badname(_Lobj);
; 380  : 			_Lobj._Addcats(_Cat, _Str.c_str());
; 381  : 
; 382  : 			if (_Hadname && _Badname(_Lobj))
; 383  : 				_Bad = true;
; 384  : 			else
; 385  : 				_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
; 386  : 		_END_LOCINFO()
; 387  : 		_CATCH_ALL
; 388  : 		_DELETE_CRT(_Ptr->_Decref());
; 389  : 		_RERAISE;
; 390  : 		_CATCH_END
; 391  : 
; 392  : 		if (_Bad)
; 393  : 			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
; 394  : 			_DELETE_CRT(_Ptr->_Decref());
; 395  : 			_Xruntime_error("bad locale name");
; 396  : 			}
; 397  : 		}
; 398  : 
; 399  : public:
; 400  : 	explicit locale(const char *_Locname,
; 401  : 		category _Cat = all)	// construct from named locale for category
; 402  : 		: _Ptr(_Locimp::_New_Locimp())
; 403  : 		{	// construct a locale with named facets
; 404  : 		// _Locname might have been returned from setlocale().
; 405  : 		// Therefore, _Construct() takes const string&.
; 406  : 		if (_Locname == 0)
; 407  : 			_Xruntime_error("bad locale name");
; 408  : 		_Construct(_Locname, _Cat);
; 409  : 		}
; 410  : 
; 411  : 	locale(const locale& _Loc, const char *_Locname,
; 412  : 		category _Cat)
; 413  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 414  : 		{	// construct a locale by copying, replacing named facets
; 415  : 		// _Locname might have been returned from setlocale().
; 416  : 		// Therefore, _Construct() takes const string&.
; 417  : 		if (_Locname == 0)
; 418  : 			_Xruntime_error("bad locale name");
; 419  : 		_Construct(_Loc, _Locname, _Cat);
; 420  : 		}
; 421  : 
; 422  : 	explicit locale(const string& _Str,
; 423  : 		category _Cat = all)	// construct from named locale for category
; 424  : 		: _Ptr(_Locimp::_New_Locimp())
; 425  : 		{	// construct a locale with named facets
; 426  : 		_Construct(_Str, _Cat);
; 427  : 		}
; 428  : 
; 429  : 	locale(const locale& _Loc, const string& _Str,
; 430  : 		category _Cat)
; 431  : 		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
; 432  : 		{	// construct a locale by copying, replacing named facets
; 433  : 		_Construct(_Loc, _Str, _Cat);
; 434  : 		}
; 435  :  #endif /* !MRTDLL || !_CRTBLD */
; 436  : 
; 437  : 	~locale() _NOEXCEPT
; 438  : 		{	// destroy the object
; 439  : 		if (_Ptr != 0)
; 440  : 			_DELETE_CRT(_Ptr->_Decref());
; 441  : 		}
; 442  : 
; 443  : 	locale& operator=(const locale& _Right) _THROW0()
; 444  : 		{	// assign a locale
; 445  : 		if (_Ptr != _Right._Ptr)
; 446  : 			{	// different implementation, point at new one
; 447  : 			_DELETE_CRT(_Ptr->_Decref());
; 448  : 			_Ptr = _Right._Ptr;
; 449  : 			_Ptr->_Incref();
; 450  : 			}
; 451  : 		return (*this);
; 452  : 		}
; 453  :  #endif /* _NO_LOCALES */
; 454  : 
; 455  : 	string name() const
; 456  : 		{	// return locale name
; 457  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 458  : 		}
; 459  : 
; 460  : 	const char *c_str() const
; 461  : 		{	// return locale name as NTBS
; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 463  : 		}
; 464  : 
; 465  : 	const facet *_Getfacet(size_t _Id) const
; 466  : 		{	// look up a facet in locale object
; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	xor	esi, esi
$LN24@use_facet:

; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN15@use_facet

; 470  : 			return (_Facptr);	// found facet or not transparent
; 471  : 		else
; 472  : 			{	// look in current locale
; 473  : 			locale::_Locimp *_Ptr = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 474  : 			return (_Id < _Ptr->_Facetcount
; 475  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 476  : 				: 0);	// no entry in current locale

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN25@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN15@use_facet:

; 570  : 
; 571  : 		size_t _Id = _Facet::id;
; 572  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 573  : 
; 574  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN1@use_facet
$LN25@use_facet:

; 575  : 			;	// got facet from locale
; 576  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet

; 577  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx
	jmp	SHORT $LN1@use_facet
$LN4@use_facet:

; 578  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	push	DWORD PTR __Loc$[ebp]
	lea	eax, DWORD PTR __Psave$5[ebp]
	push	eax
	call	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN2@use_facet

; 579  : 
; 580  :  #if _HAS_EXCEPTIONS
; 581  : 
; 582  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0bad_cast@std@@QAE@PBD@Z		; std::bad_cast::bad_cast
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
$LN29@use_facet:
$LN2@use_facet:

; 583  : 
; 584  :  #else /* _HAS_EXCEPTIONS */
; 585  : 			abort();	// lazy disallowed
; 586  :  #endif /* _HAS_EXCEPTIONS */
; 587  : 
; 588  : 		else
; 589  : 			{	// queue up lazy facet for destruction
; 590  : 			_Pf = _Psave;

	mov	esi, DWORD PTR __Psave$5[ebp]

; 591  : 			_Facetptr<_Facet>::_Psave = _Psave;
; 592  : 
; 593  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 594  : 			_Pfmod->_Incref();

	mov	ecx, esi
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+4]

; 595  : 
; 596  :  #if defined(_M_CEE)
; 597  : 			_Facet_Register_m(_Pfmod);
; 598  : 
; 599  :  #else /* defined(_M_CEE) */
; 600  : 			_Facet_Register(_Pfmod);

	push	esi
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
	add	esp, 4
$LN1@use_facet:

; 601  :  #endif /* defined(_M_CEE) */
; 602  : 			}
; 603  : 
; 604  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$3[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 605  : 	_END_LOCK()
; 606  :  #endif /* _NO_LOCALES */
; 607  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$3[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2504 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR [esi+16]

; 2493 : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2504 : 		if (0 < _Ctype._Delfl)

	test	eax, eax
	jle	SHORT $LN18@scalar

; 2505 : 			free((void *)_Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free
	jmp	SHORT $LN19@scalar
$LN18@scalar:

; 2506 : 		else if (_Ctype._Delfl < 0)

	jns	SHORT $LN6@scalar

; 2507 : 			delete[] (void *)_Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]
$LN19@scalar:
	add	esp, 4
$LN6@scalar:

; 2508 : 
; 2509 : 		free((void *)_Ctype._LocaleName);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN17@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2561 : 		{	// narrow elements in [_First, _Last) to chars

	push	ebp
	mov	ebp, esp

; 2562 : 		_DEBUG_RANGE(_First, _Last);
; 2563 : 		_DEBUG_POINTER(_Dest);
; 2564 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, edx
	push	ecx
	push	edx
	push	DWORD PTR __Dest$[ebp]
	call	_memcpy

; 2565 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]
	add	esp, 12					; 0000000cH

; 2566 : 		}

	pop	ebp
	ret	16					; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2555 : 		{	// narrow char

	push	ebp
	mov	ebp, esp

; 2556 : 		return (_Ch);

	mov	al, BYTE PTR __Ch$[ebp]

; 2557 : 		}

	pop	ebp
	ret	8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2547 : 		{	// widen chars in [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2548 : 		_DEBUG_RANGE(_First, _Last);
; 2549 : 		_DEBUG_POINTER(_Dest);
; 2550 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, edx
	push	ecx
	push	edx
	push	DWORD PTR __Dest$[ebp]
	call	_memcpy

; 2551 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]
	add	esp, 12					; 0000000cH

; 2552 : 		}

	pop	ebp
	ret	12					; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2541 : 		{	// widen char

	push	ebp
	mov	ebp, esp

; 2542 : 		return (_Byte);

	mov	al, BYTE PTR __Byte$[ebp]

; 2543 : 		}

	pop	ebp
	ret	4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv135 = 12						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2533 : 		{	// convert [_First, _Last) in place to upper case

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR __Last$[ebp]
	xor	edx, edx
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	sub	ebx, esi
	push	edi
	xor	edi, edi
	cmp	esi, DWORD PTR __Last$[ebp]
	cmova	ebx, edx

; 2534 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2535 : 		for (; _First != _Last; ++_First)

	test	ebx, ebx
	je	SHORT $LN10@do_toupper
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv135[ebp], eax
$LL3@do_toupper:

; 2536 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

	push	eax
	movzx	eax, BYTE PTR [esi]
	push	eax
	call	__Toupper
	mov	BYTE PTR [esi], al
	inc	edi
	mov	eax, DWORD PTR tv135[ebp]
	add	esp, 8
	inc	esi
	cmp	edi, ebx
	jne	SHORT $LL3@do_toupper
$LN10@do_toupper:
	pop	edi

; 2537 : 		return ((const _Elem *)_First);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2538 : 		}

	pop	ebp
	ret	8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2527 : 		{	// convert element to upper case

	push	ebp
	mov	ebp, esp

; 2528 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

	lea	eax, DWORD PTR [ecx+8]
	push	eax
	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, al
	push	eax
	call	__Toupper
	add	esp, 8

; 2529 : 		}

	pop	ebp
	ret	4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv135 = 12						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2519 : 		{	// convert [_First, _Last) in place to lower case

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR __Last$[ebp]
	xor	edx, edx
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	sub	ebx, esi
	push	edi
	xor	edi, edi
	cmp	esi, DWORD PTR __Last$[ebp]
	cmova	ebx, edx

; 2520 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2521 : 		for (; _First != _Last; ++_First)

	test	ebx, ebx
	je	SHORT $LN10@do_tolower
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv135[ebp], eax
$LL3@do_tolower:

; 2522 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

	push	eax
	movzx	eax, BYTE PTR [esi]
	push	eax
	call	__Tolower
	mov	BYTE PTR [esi], al
	inc	edi
	mov	eax, DWORD PTR tv135[ebp]
	add	esp, 8
	inc	esi
	cmp	edi, ebx
	jne	SHORT $LL3@do_tolower
$LN10@do_tolower:
	pop	edi

; 2523 : 		return ((const _Elem *)_First);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2524 : 		}

	pop	ebp
	ret	8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2513 : 		{	// convert element to lower case

	push	ebp
	mov	ebp, esp

; 2514 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

	lea	eax, DWORD PTR [ecx+8]
	push	eax
	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, al
	push	eax
	call	__Tolower
	add	esp, 8

; 2515 : 		}

	pop	ebp
	ret	4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2503 : 		{	// free any allocated storage

	push	esi
	mov	esi, ecx

; 2504 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	jle	SHORT $LN6@Tidy

; 2505 : 			free((void *)_Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free

; 2507 : 			delete[] (void *)_Ctype._Table;

	add	esp, 4

; 2508 : 
; 2509 : 		free((void *)_Ctype._LocaleName);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
	pop	esi

; 2510 : 		}

	ret	0
$LN6@Tidy:

; 2506 : 		else if (_Ctype._Delfl < 0)

	jns	SHORT $LN1@Tidy

; 2507 : 			delete[] (void *)_Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@Tidy:

; 2508 : 
; 2509 : 		free((void *)_Ctype._LocaleName);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
	pop	esi

; 2510 : 		}

	ret	0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2498 : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 117  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T1[ebp]
	push	esi
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2498 : 		{	// initialize from _Lobj

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 117  : 		return (::_Getctype());

	call	__Getctype
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2499 : 		_Ctype = _Lobj._Getctype();

	movdqu	xmm0, XMMWORD PTR [eax]
	movdqu	XMMWORD PTR [esi+8], xmm0
	pop	esi

; 2500 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2493 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 2496 : 
; 2497 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 2498 : 		{	// initialize from _Lobj
; 2499 : 		_Ctype = _Lobj._Getctype();
; 2500 : 		}
; 2501 : 
; 2502 : 	void __CLR_OR_THIS_CALL _Tidy()
; 2503 : 		{	// free any allocated storage
; 2504 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR [esi+16]

; 2493 : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2496 : 
; 2497 : 	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
; 2498 : 		{	// initialize from _Lobj
; 2499 : 		_Ctype = _Lobj._Getctype();
; 2500 : 		}
; 2501 : 
; 2502 : 	void __CLR_OR_THIS_CALL _Tidy()
; 2503 : 		{	// free any allocated storage
; 2504 : 		if (0 < _Ctype._Delfl)

	test	eax, eax
	jle	SHORT $LN14@ctype

; 2505 : 			free((void *)_Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free
	jmp	SHORT $LN15@ctype
$LN14@ctype:

; 2506 : 		else if (_Ctype._Delfl < 0)

	jns	SHORT $LN3@ctype

; 2507 : 			delete[] (void *)_Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]
$LN15@ctype:
	add	esp, 4
$LN3@ctype:

; 2508 : 
; 2509 : 		free((void *)_Ctype._LocaleName);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2495 : 		}

	ret	0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -84						; size = 52
$T3 = -32						; size = 16
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T5 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2470 : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2471 : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	edi, DWORD PTR __Ppf$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR $T4[ebp], ebx
	test	edi, edi
	je	SHORT $LN33@Getcat
	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN33@Getcat

; 2473 : 				_Locinfo(_Ploc->c_str()));

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T5[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	test	esi, esi
	je	SHORT $LN4@Getcat

; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR __Ploc$[ebp]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN12@Getcat
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN17@Getcat
$LN12@Getcat:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3398 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN17@Getcat
	lea	eax, DWORD PTR [ecx+28]
$LN17@Getcat:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2473 : 				_Locinfo(_Ploc->c_str()));

	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 117  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 117  : 		return (::_Getctype());

	push	eax
	mov	ebx, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2464 : 		{	// construct from current locale

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 117  : 		return (::_Getctype());

	call	__Getctype
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2499 : 		_Ctype = _Lobj._Getctype();

	movdqu	xmm0, XMMWORD PTR [eax]
	movdqu	XMMWORD PTR [esi+8], xmm0

; 2473 : 				_Locinfo(_Ploc->c_str()));

	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	xor	esi, esi
$LN5@Getcat:
	mov	DWORD PTR [edi], esi
	test	bl, 1
	je	SHORT $LN33@Getcat
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN33@Getcat:

; 2474 : 		return (_X_CTYPE);

	mov	eax, 2

; 2475 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2464 : 		{	// construct from current locale

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	eax, DWORD PTR __Refs$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2464 : 		{	// construct from current locale

	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	DWORD PTR [esi+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 117  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2464 : 		{	// construct from current locale

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 117  : 		return (::_Getctype());

	call	__Getctype
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2499 : 		_Ctype = _Lobj._Getctype();

	movdqu	xmm0, XMMWORD PTR [eax]

; 2465 : 		_Init(_Lobj);
; 2466 : 		}

	mov	eax, esi

; 2499 : 		_Ctype = _Lobj._Getctype();

	movdqu	XMMWORD PTR [esi+8], xmm0
	pop	esi

; 2465 : 		_Init(_Lobj);
; 2466 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z PROC		; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2423 : 		{	// widen chars in [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2424 : 		return (do_widen(_First, _Last, _Dest));

	mov	eax, DWORD PTR [ecx]

; 2425 : 		}

	pop	ebp

; 2424 : 		return (do_widen(_First, _Last, _Dest));

	jmp	DWORD PTR [eax+28]
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2417 : 		{	// widen char

	push	ebp
	mov	ebp, esp

; 2418 : 		return (do_widen(_Byte));

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+32]

; 2419 : 		}

	pop	ebp

; 2418 : 		return (do_widen(_Byte));

	jmp	eax
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 1
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx

; 2364 : 		{	// test if element fits any mask classifications

	push	ebp
	mov	ebp, esp

; 2365 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

	mov	eax, DWORD PTR __Ch$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	movzx	edx, al
	mov	ax, WORD PTR __Maskval$[ebp]
	test	WORD PTR [ecx+edx*2], ax
	mov	eax, 0
	setne	al

; 2366 : 		}

	pop	ebp
	ret	8
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2106 : 		}

	ret	0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2101 : 		{	// default constructor

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	eax, DWORD PTR __Refs$[ebp]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 2102 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
	pop	ebp
	ret	4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 466  : 		{	// look up a facet in locale object

	push	ebp
	mov	ebp, esp

; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	mov	ecx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR __Id$[ebp]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	eax, eax
	jne	SHORT $LN1@Getfacet
	jmp	SHORT $LN10@Getfacet
$LN6@Getfacet:

; 467  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount
; 468  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end

	xor	eax, eax
$LN10@Getfacet:

; 469  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN1@Getfacet

; 470  : 			return (_Facptr);	// found facet or not transparent
; 471  : 		else
; 472  : 			{	// look in current locale
; 473  : 			locale::_Locimp *_Ptr = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 474  : 			return (_Id < _Ptr->_Facetcount
; 475  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 476  : 				: 0);	// no entry in current locale

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 477  : 			}
; 478  : 		}

	pop	ebp
	ret	4
$LN8@Getfacet:

; 474  : 			return (_Id < _Ptr->_Facetcount
; 475  : 				? _Ptr->_Facetvec[_Id]	// get from current locale
; 476  : 				: 0);	// no entry in current locale

	xor	eax, eax
$LN1@Getfacet:
	pop	esi

; 477  : 			}
; 478  : 		}

	pop	ebp
	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN3@c_str
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 463  : 		}

	ret	0
$LN3@c_str:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3398 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN7@c_str
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 462  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, ecx

; 463  : 		}

	ret	0
$LN7@c_str:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3398 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	add	eax, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 463  : 		}

	ret	0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 439  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@locale

; 440  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN4@locale
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN4@locale:

; 441  : 		}

	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx

; 324  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]

; 325  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN8@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 167  : 			}

	ret	0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 160  : 		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h

; 97   : 	_Counter = _Value;

	mov	eax, DWORD PTR __Initrefs$[ebp]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale

; 163  : 			}

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
	pop	ebp
	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 150  : 			if (_MT_DECR(_Mtx, _Refs) == 0)

	lea	eax, DWORD PTR [ecx+4]
	or	edx, -1
	lock	 xadd	 DWORD PTR [eax], edx
	mov	eax, 0
	cmove	eax, ecx

; 151  : 				return (this);
; 152  : 			else
; 153  : 				return (0);
; 154  : 			}

	ret	0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 145  : 			_MT_INCR(_Mtx, _Refs);

	add	ecx, 4
	mov	eax, 1
	lock	 xadd	 DWORD PTR [ecx], eax

; 146  : 			}

	ret	0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 78   : 			{	// get stamp, with lazy allocation

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 79   : 			if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN6@operator

; 80   : 				{	// still zero, allocate stamp
; 81   : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$1[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 82   : 					if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN1@operator

; 83   : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR [esi], eax
$LN1@operator:

; 84   : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$1[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN6@operator:

; 85   : 				}
; 86   : 			return (_Id);

	mov	eax, DWORD PTR [esi]
	pop	esi

; 87   : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 75   : 			}

	mov	eax, ecx
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
	mov	eax, ecx
	ret	0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 24   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@

; 25   : 		}

	ret	0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 3413 : 		{	// discard any string

	push	esi
	mov	esi, ecx

; 3414 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 3415 : 
; 3416 :  #ifdef _DEBUG
; 3417 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3418 : 
; 3419 :  #else /* _DEBUG */
; 3420 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN4@Tidy:

; 3421 :  #endif /* _DEBUG */
; 3422 : 
; 3423 : 		_Myptr = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 3424 : 		}

	ret	0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3387 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 3390 : 
; 3391 : 	bool __CLR_OR_THIS_CALL empty() const
; 3392 : 		{	// test if empty string
; 3393 : 		return (_Myptr == 0);
; 3394 : 		}
; 3395 : 
; 3396 : 	const _Elem *__CLR_OR_THIS_CALL c_str() const
; 3397 : 		{	// return NTBS
; 3398 : 		return (_Myptr != 0 ? _Myptr : &_Nul);
; 3399 : 		}
; 3400 : 
; 3401 : 	bool __CLR_OR_THIS_CALL _Empty() const
; 3402 : 		{	// test if empty string
; 3403 : 		return (_Myptr == 0);
; 3404 : 		}
; 3405 : 
; 3406 : 	const _Elem *__CLR_OR_THIS_CALL _C_str() const
; 3407 : 		{	// return NTBS
; 3408 : 		return (_Myptr != 0 ? _Myptr : &_Nul);
; 3409 : 		}
; 3410 : 
; 3411 : private:
; 3412 : 	void __CLR_OR_THIS_CALL _Tidy()
; 3413 : 		{	// discard any string
; 3414 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Yarn

; 3415 : 
; 3416 :  #ifdef _DEBUG
; 3417 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3418 : 
; 3419 :  #else /* _DEBUG */
; 3420 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Yarn:

; 3421 :  #endif /* _DEBUG */
; 3422 : 
; 3423 : 		_Myptr = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 3388 : 		_Tidy();
; 3389 : 		}

	ret	0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 3338 : 		{	// default construct

	xor	eax, eax
	mov	DWORD PTR [ecx], 0
	mov	WORD PTR [ecx+4], ax

; 3339 : 		}

	mov	eax, ecx
	ret	0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 3413 : 		{	// discard any string

	push	esi
	mov	esi, ecx

; 3414 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 3415 : 
; 3416 :  #ifdef _DEBUG
; 3417 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3418 : 
; 3419 :  #else /* _DEBUG */
; 3420 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN4@Tidy:

; 3421 :  #endif /* _DEBUG */
; 3422 : 
; 3423 : 		_Myptr = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 3424 : 		}

	ret	0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 3398 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN4@c_str
	lea	eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 3399 : 		}

	ret	0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 3387 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 3390 : 
; 3391 : 	bool __CLR_OR_THIS_CALL empty() const
; 3392 : 		{	// test if empty string
; 3393 : 		return (_Myptr == 0);
; 3394 : 		}
; 3395 : 
; 3396 : 	const _Elem *__CLR_OR_THIS_CALL c_str() const
; 3397 : 		{	// return NTBS
; 3398 : 		return (_Myptr != 0 ? _Myptr : &_Nul);
; 3399 : 		}
; 3400 : 
; 3401 : 	bool __CLR_OR_THIS_CALL _Empty() const
; 3402 : 		{	// test if empty string
; 3403 : 		return (_Myptr == 0);
; 3404 : 		}
; 3405 : 
; 3406 : 	const _Elem *__CLR_OR_THIS_CALL _C_str() const
; 3407 : 		{	// return NTBS
; 3408 : 		return (_Myptr != 0 ? _Myptr : &_Nul);
; 3409 : 		}
; 3410 : 
; 3411 : private:
; 3412 : 	void __CLR_OR_THIS_CALL _Tidy()
; 3413 : 		{	// discard any string
; 3414 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Yarn

; 3415 : 
; 3416 :  #ifdef _DEBUG
; 3417 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3418 : 
; 3419 :  #else /* _DEBUG */
; 3420 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Yarn:

; 3421 :  #endif /* _DEBUG */
; 3422 : 
; 3423 : 		_Myptr = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 3388 : 		_Tidy();
; 3389 : 		}

	ret	0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 3338 : 		{	// default construct

	mov	DWORD PTR [ecx], 0

; 3339 : 		}

	mov	eax, ecx
	mov	BYTE PTR [ecx+4], 0
	ret	0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 172  : 		return ("true");

	mov	eax, OFFSET ??_C@_04LOAJBDKD@true?$AA@

; 173  : 		}

	ret	0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 167  : 		return ("false");

	mov	eax, OFFSET ??_C@_05LAPONLG@false?$AA@

; 168  : 		}

	ret	0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 127  : 		return (localeconv());

	jmp	_localeconv
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = -44						; size = 44
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 121  : 		{	// return codecvt stuff

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 122  : 		return (::_Getcvt());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__Getcvt
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	add	esp, 4
	movdqu	xmm0, XMMWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+40]
	movdqu	XMMWORD PTR [edx], xmm0
	movdqu	xmm0, XMMWORD PTR [eax+16]
	movdqu	XMMWORD PTR [edx+16], xmm0
	movq	xmm0, QWORD PTR [eax+32]
	mov	eax, edx
	movq	QWORD PTR [edx+32], xmm0
	mov	DWORD PTR [edx+40], ecx

; 123  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 116  : 		{	// return ctype stuff

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 117  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__Getctype
	add	esp, 4
	movdqu	xmm0, XMMWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movdqu	XMMWORD PTR [eax], xmm0

; 118  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 95   : 		_Locinfo_dtor(this);

	push	esi
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3414 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+44]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 95   : 		_Locinfo_dtor(this);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3414 : 		if (_Myptr != 0)

	test	eax, eax
	je	SHORT $LN5@Locinfo

; 3415 : 
; 3416 :  #ifdef _DEBUG
; 3417 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3418 : 
; 3419 :  #else /* _DEBUG */
; 3420 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN5@Locinfo:

; 3421 :  #endif /* _DEBUG */
; 3422 : 
; 3423 : 		_Myptr = 0;

	mov	DWORD PTR [esi+44], 0

; 3414 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN10@Locinfo

; 3415 : 
; 3416 :  #ifdef _DEBUG
; 3417 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3418 : 
; 3419 :  #else /* _DEBUG */
; 3420 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN10@Locinfo:

; 3421 :  #endif /* _DEBUG */
; 3422 : 
; 3423 : 		_Myptr = 0;

	mov	DWORD PTR [esi+36], 0

; 3414 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN15@Locinfo

; 3415 : 
; 3416 :  #ifdef _DEBUG
; 3417 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3418 : 
; 3419 :  #else /* _DEBUG */
; 3420 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN15@Locinfo:

; 3421 :  #endif /* _DEBUG */
; 3422 : 
; 3423 : 		_Myptr = 0;

	mov	DWORD PTR [esi+28], 0

; 3414 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN20@Locinfo

; 3415 : 
; 3416 :  #ifdef _DEBUG
; 3417 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3418 : 
; 3419 :  #else /* _DEBUG */
; 3420 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN20@Locinfo:

; 3421 :  #endif /* _DEBUG */
; 3422 : 
; 3423 : 		_Myptr = 0;

	mov	DWORD PTR [esi+20], 0

; 3414 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN25@Locinfo

; 3415 : 
; 3416 :  #ifdef _DEBUG
; 3417 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3418 : 
; 3419 :  #else /* _DEBUG */
; 3420 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN25@Locinfo:

; 3421 :  #endif /* _DEBUG */
; 3422 : 
; 3423 : 		_Myptr = 0;

	mov	DWORD PTR [esi+12], 0

; 3414 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN30@Locinfo

; 3415 : 
; 3416 :  #ifdef _DEBUG
; 3417 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 3418 : 
; 3419 :  #else /* _DEBUG */
; 3420 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN30@Locinfo:

; 3421 :  #endif /* _DEBUG */
; 3422 : 
; 3423 : 		_Myptr = 0;

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 96   : 		}

	mov	ecx, esi
	pop	esi
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 76   : 		{	// construct from NTBS

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Locinfo@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	push	0
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3338 : 		{	// default construct

	mov	DWORD PTR [esi+4], 0
	mov	BYTE PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	BYTE PTR [esi+16], 0
	xor	eax, eax
	mov	DWORD PTR [esi+20], 0
	mov	WORD PTR [esi+24], ax
	mov	DWORD PTR [esi+28], eax
	mov	WORD PTR [esi+32], ax
	mov	DWORD PTR [esi+36], eax
	mov	BYTE PTR [esi+40], al
	mov	DWORD PTR [esi+44], eax
	mov	BYTE PTR [esi+48], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 77   : 		if (_Pch == 0)

	mov	eax, DWORD PTR __Pch$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	test	eax, eax
	jne	SHORT $LN1@Locinfo
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept

; 178  : 		{	// construct from message string

	lea	eax, DWORD PTR __Message$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 78   : 			_THROW_NCEE(runtime_error, "bad locale name");

	mov	DWORD PTR __Message$[ebp], OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept

; 178  : 		{	// construct from message string

	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 78   : 			_THROW_NCEE(runtime_error, "bad locale name");

	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept

; 178  : 		{	// construct from message string

	mov	DWORD PTR $T2[ebp], OFFSET ??_7runtime_error@std@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocinfo

; 78   : 			_THROW_NCEE(runtime_error, "bad locale name");

	push	eax
	call	__CxxThrowException@8
$LN28@Locinfo:
$LN1@Locinfo:

; 79   : 		_Locinfo_ctor(this, _Pch);

	push	eax
	push	esi
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
	add	esp, 8

; 80   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN27@Locinfo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Ogtp
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR ___that$[ebp]
	mov	esi, ecx
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 178  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	esi
	lea	eax, DWORD PTR __Message$[ebp]
	mov	esi, ecx
	push	eax
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 179  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 173  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR __Message$[ebp]
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept

; 173  : 		{	// construct from message string

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN8@runtime_er
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [eax]
$LN8@runtime_er:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\stdexcept

; 173  : 		{	// construct from message string

	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 174  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 2273 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	je	SHORT $LN19@Tidy

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN19@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN14@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Tidy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebx
$LN19@Tidy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2286 : 		}

	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	esi
	test	edx, edx
	je	SHORT $LN2@Inside

; 513  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN8@Inside
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	esi, ecx
$LN9@Inside:

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	edx, esi
	jb	SHORT $LN2@Inside

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN14@Inside
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN15@Inside
$LN14@Inside:
	mov	esi, ecx
$LN15@Inside:

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	eax, DWORD PTR [ecx+16]
	add	eax, esi
	cmp	eax, edx
	jbe	SHORT $LN2@Inside

; 2260 : 		else
; 2261 : 			return (true);

	mov	al, 1
	pop	esi

; 2262 : 		}

	pop	ebp
	ret	4
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2262 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ptr$1$ = 12						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2243 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	cmp	edi, -2					; fffffffeH
	ja	$LN67@Grow

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	DWORD PTR [esi+16]
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, edi
	pop	edi
	sbb	eax, eax
	neg	eax
	pop	esi

; 2253 : 		}

	pop	ebp
	ret	8
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	cmp	BYTE PTR __Trim$[ebp], 0
	je	SHORT $LN3@Grow
	cmp	edi, 16					; 00000010H
	jae	SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	push	ebx
	mov	ebx, DWORD PTR [esi+16]
	cmp	edi, ebx
	cmovb	ebx, edi

; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN44@Grow

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __Ptr$1$[ebp], eax

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)

	test	ebx, ebx
	je	SHORT $LN39@Grow
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	eax
	push	esi
	call	_memcpy
	mov	eax, DWORD PTR __Ptr$1$[ebp]
	add	esp, 12					; 0000000cH
$LN39@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN44@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);
; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	eax, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ebx+esi], 0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	sbb	eax, eax
	pop	edi
	neg	eax
	pop	esi

; 2253 : 		}

	pop	ebp
	ret	8
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN64@Grow

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);
; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN60@Grow
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, DWORD PTR [esi]
$LN60@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
$LN64@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, edi
	pop	edi
	sbb	eax, eax
	neg	eax
	pop	esi

; 2253 : 		}

	pop	ebp
	ret	8
$LN67@Grow:

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN69@Grow:
$LN66@Grow:
	int	3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN5@Eos
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2238 : 		}

	pop	ebp
	ret	4
$LN5@Eos:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2238 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$1$ = -20						; size = 4
__Newres$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
$T2 = 11						; size = 1
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, eax
	or	edi, 15					; 0000000fH

; 2203 : 		if (max_size() < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax
	jmp	SHORT $LN47@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	ebx, DWORD PTR [esi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN47@Copy

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, -2					; fffffffeH

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN47@Copy

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);
; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	edi, -2					; fffffffeH
$LN47@Copy:

; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

	xor	eax, eax
	mov	DWORD PTR __Ptr$1$[ebp], eax

; 24   : 
; 25   : 	if (_Count == 0)

	test	ecx, ecx
	je	SHORT $LN19@Copy

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	ecx, -1
	ja	SHORT $LN62@Copy
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN19@Copy
$LN62@Copy:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN174@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END

	mov	eax, $LN171@Copy
	ret	0
$LN171@Copy:

; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	edi, DWORD PTR __Newres$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], eax
$LN19@Copy:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	je	SHORT $LN112@Copy

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN105@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN106@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN91@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN91@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2222 : 			_RERAISE;

	push	0

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 2222 : 			_RERAISE;

	push	0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2222 : 			_RERAISE;

	call	__CxxThrowException@8
$LN175@Copy:
$LN105@Copy:

; 513  : 			: this->_Bx._Buf);

	mov	ecx, esi
$LN106@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	ebx, ebx
	je	SHORT $LN112@Copy
	push	ebx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN112@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN131@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN131@Copy:

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2231 : 		this->_Myres = _Newres;

	mov	DWORD PTR [esi+20], edi

; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 513  : 			: this->_Bx._Buf);

	cmp	edi, 16					; 00000010H
	jb	SHORT $LN166@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, eax
$LN166@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2233 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN173@Copy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off

	push	ebp
	mov	ebp, esp

; 2194 : 		if (_Count == 1)

	mov	eax, DWORD PTR __Count$[ebp]
	mov	edx, ecx
	cmp	eax, 1
	jne	SHORT $LN2@Chassign

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN8@Chassign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [edx]
$LN8@Chassign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Off$[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [edx+eax], cl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2198 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Chassign:

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN16@Chassign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [edx]
$LN16@Chassign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 559  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	mov	eax, DWORD PTR __Ch$[ebp]
	movsx	eax, al
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 559  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2198 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 2188 : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp

; 2189 : 		return (this->_Getal());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2190 : 		}

	pop	ebp
	ret	4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1793 : 		return (this->_Mysize == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+16], eax
	sete	al

; 1794 : 		}

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1761 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR [ecx+16]

; 1755 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN5@c_str

; 1739 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 1740 : 		}

	ret	0
$LN5@c_str:

; 1739 : 		return (this->_Myptr());

	mov	eax, ecx

; 1740 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1695 : 		{	// subscript nonmutable sequence

	push	ebp
	mov	ebp, esp

; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1704 : 		return (this->_Myptr()[_Off]);

	mov	eax, DWORD PTR __Off$[ebp]

; 520  : 			: this->_Bx._Buf);

	jb	SHORT $LN5@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR [ecx]
$LN5@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1704 : 		return (this->_Myptr()[_Off]);

	add	eax, ecx

; 1705 : 		}

	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1682 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1691 : 		return (this->_Myptr()[_Off]);

	mov	eax, DWORD PTR __Off$[ebp]

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN5@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR [ecx]
$LN5@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1691 : 		return (this->_Myptr()[_Off]);

	add	eax, ecx

; 1692 : 		}

	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1343 : 		if (this->_Mysize < _Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	edi, ecx
	jb	SHORT $LN41@erase

; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, ecx
	cmp	eax, edx
	ja	SHORT $LN3@erase

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN14@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1354 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1355 : 		}

	pop	ebp
	ret	8
$LN14@erase:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1355 : 		}

	pop	ebp
	ret	8
$LN3@erase:

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)

	test	edx, edx
	je	SHORT $LN38@erase

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN22@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN23@erase
$LN22@erase:
	mov	eax, esi
$LN23@erase:

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

	sub	edi, edx
	push	ebx
	lea	ebx, DWORD PTR [eax+ecx]

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN29@erase
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ebx+edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH
$LN29@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi
	pop	ebx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN34@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1354 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1355 : 		}

	pop	ebp
	ret	8
$LN34@erase:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN38@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1354 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1355 : 		}

	pop	ebp
	ret	8
$LN41@erase:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN43@erase:
$LN40@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp

; 1335 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN18@erase

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN11@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1338 : 		return (*this);

	mov	eax, ecx

; 1339 : 		}

	pop	ebp
	ret	4
$LN11@erase:

; 513  : 			: this->_Bx._Buf);

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1338 : 		return (*this);

	mov	eax, ecx

; 1339 : 		}

	pop	ebp
	ret	4
$LN18@erase:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN20@erase:
$LN17@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
__Num$1$ = 8						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1271 : 		{	// insert _Count * _Ch at _Off

	push	ebp
	mov	ebp, esp
	push	ebx

; 1272 : 		if (this->_Mysize < _Off)

	mov	ebx, DWORD PTR __Off$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, ebx
	jb	$LN38@insert

; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)

	mov	edi, DWORD PTR __Count$[ebp]
	or	eax, -1
	sub	eax, ecx
	cmp	eax, edi
	jbe	$LN40@insert

; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	test	edi, edi
	je	SHORT $LN35@insert
	lea	eax, DWORD PTR [ecx+edi]
	mov	ecx, esi
	push	0
	push	eax
	mov	DWORD PTR __Num$1$[ebp], eax
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN35@insert

; 513  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	edx, esi
$LN14@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN19@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN20@insert
$LN19@insert:
	mov	ecx, esi
$LN20@insert:

; 1281 : 				this->_Mysize - _Off);	// empty out hole

	mov	eax, DWORD PTR [esi+16]
	sub	eax, ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN26@insert
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1281 : 				this->_Mysize - _Off);	// empty out hole

	lea	eax, DWORD PTR [edx+ebx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1281 : 				this->_Mysize - _Off);	// empty out hole

	lea	eax, DWORD PTR [ecx+ebx]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$LN26@insert:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, esi
	push	edi
	push	ebx
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	ecx, DWORD PTR __Num$1$[ebp]
	mov	DWORD PTR [esi+16], ecx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN31@insert
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1285 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1286 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN31@insert:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
$LN35@insert:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1285 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1286 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN38@insert:

; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN41@insert:
$LN40@insert:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN42@insert:
$LN37@insert:
	int	3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1173 : 		{	// assign _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1174 : 		if (_Count == npos)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	esi, ecx
	cmp	edi, -1
	je	$LN106@assign

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	$LN108@assign

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN12@assign

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	DWORD PTR [esi+16]
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))

	je	SHORT $LN101@assign
$LN105@assign:

; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)

	cmp	edi, 1
	jne	SHORT $LN74@assign

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN79@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2196 : 		else

	jmp	SHORT $LN91@assign
$LN12@assign:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN105@assign

; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN67@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1182 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	8
$LN67@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1183 : 		}

	pop	ebp
	ret	8
$LN79@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2196 : 		else

	jmp	SHORT $LN91@assign
$LN74@assign:

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN87@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN88@assign
$LN87@assign:
	mov	ecx, esi
$LN88@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 559  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	mov	eax, DWORD PTR __Ch$[ebp]
	push	edi
	movsx	eax, al
	push	eax
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN91@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN97@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1182 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	8
$LN97@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN101@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1182 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	8
$LN106@assign:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN109@assign:
$LN108@assign:
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN110@assign:
$LN103@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@assign
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1170 : 		}

	pop	ebp
	ret	4
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@assign:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@assign
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1170 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@assign

; 513  : 			: this->_Bx._Buf);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN13@assign
$LN12@assign:
	mov	eax, esi
$LN13@assign:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@assign

; 513  : 			: this->_Bx._Buf);

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN18@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN19@assign
$LN18@assign:
	mov	edx, esi
$LN19@assign:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@assign

; 513  : 			: this->_Bx._Buf);

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN24@assign

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN24@assign:

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	edi

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Count$[ebp]
	cmp	edi, -2					; fffffffeH
	ja	SHORT $LN118@assign

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN32@assign

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1157 : 
; 1158 : 		if (_Grow(_Count))

	je	SHORT $LN112@assign
$LN117@assign:

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN96@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN97@assign
$LN32@assign:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN117@assign

; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN87@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1163 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN87@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1164 : 		}

	pop	ebp
	ret	8
$LN96@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
$LN97@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	edi, edi
	je	SHORT $LN103@assign
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN103@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN108@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1163 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN108@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN112@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1163 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN118@assign:

; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN120@assign:
$LN115@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 1130 : 		if (_Right.size() < _Roff)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Roff$[ebp]
	mov	edi, DWORD PTR [ebx+16]
	cmp	edi, ecx
	jb	$LN125@assign

; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;

	sub	edi, ecx

; 1133 : 		if (_Count < _Num)

	cmp	DWORD PTR __Count$[ebp], edi
	cmovb	edi, DWORD PTR __Count$[ebp]

; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	lea	eax, DWORD PTR [edi+ecx]

; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)

	cmp	DWORD PTR [esi+16], eax
	jb	$LN127@assign

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN25@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN25@assign:

; 513  : 			: this->_Bx._Buf);

	mov	edx, esi

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN3@assign:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	$LN128@assign

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN35@assign

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Roff$[ebp]

; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1138 : 		else if (_Grow(_Num))

	je	SHORT $LN120@assign
$LN124@assign:

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN98@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ebx, DWORD PTR [ebx]
$LN98@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN104@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN105@assign
$LN35@assign:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN124@assign

; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN90@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN90@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN104@assign:

; 513  : 			: this->_Bx._Buf);

	mov	edx, esi
$LN105@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	edi, edi
	je	SHORT $LN111@assign
	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1141 : 				_Right._Myptr() + _Roff, _Num);

	lea	eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN111@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN116@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1144 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN116@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN120@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN125@assign:

; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN129@assign:
$LN127@assign:
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN130@assign:
$LN128@assign:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN131@assign:
$LN122@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp

; 1124 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1125 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1091 : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	ebx

; 1092 : 		if (npos - this->_Mysize <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	or	eax, -1
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, ecx
	cmp	eax, ebx
	jbe	SHORT $LN87@append

; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	test	ebx, ebx
	je	SHORT $LN81@append
	push	edi
	lea	edi, DWORD PTR [ecx+ebx]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	SHORT $LN89@append

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN12@append

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	je	SHORT $LN83@append
$LN86@append:

; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, esi
	push	ebx
	push	DWORD PTR [esi+16]
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN77@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN12@append:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN86@append

; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN67@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN67@append:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1102 : 		}

	pop	ebp
	ret	8
$LN77@append:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN83@append:
	pop	edi
$LN81@append:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN87@append:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN90@append:
$LN89@append:
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN91@append:
$LN84@append:
	int	3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1085 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@append
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1088 : 		}

	pop	ebp
	ret	4
$LN5@append:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@append:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@append
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1088 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
tv279 = 8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1063 : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	edi, DWORD PTR __Ptr$[ebp]

; 1063 : 		{	// append [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	test	edi, edi
	je	SHORT $LN3@append

; 513  : 			: this->_Bx._Buf);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN13@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN14@append
$LN13@append:
	mov	eax, esi
$LN14@append:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	edi, eax
	jb	SHORT $LN3@append

; 513  : 			: this->_Bx._Buf);

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN19@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN20@append
$LN19@append:
	mov	edx, esi
$LN20@append:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, edi
	jbe	SHORT $LN3@append

; 513  : 			: this->_Bx._Buf);

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN25@append

; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	edi, eax
	push	edi
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi

; 1082 : 		}

	pop	ebp
	ret	8
$LN25@append:

; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi

; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	edi, eax
	push	edi
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi

; 1082 : 		}

	pop	ebp
	ret	8
$LN3@append:

; 1072 : 		if (npos - this->_Mysize <= _Count)

	mov	ecx, DWORD PTR [esi+16]
	or	eax, -1
	push	ebx
	mov	ebx, DWORD PTR __Count$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv279[ebp], ecx
	cmp	eax, ebx
	jbe	SHORT $LN54@append

; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	test	ebx, ebx
	je	SHORT $LN50@append
	lea	eax, DWORD PTR [ecx+ebx]
	mov	ecx, esi
	push	0
	push	eax
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN50@append

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN34@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN35@append
$LN34@append:
	mov	ecx, esi
$LN35@append:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	ebx, ebx
	je	SHORT $LN41@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);

	mov	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);

	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN41@append:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	ecx, DWORD PTR tv279[ebp]
	add	ecx, ebx

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN46@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	ebx
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1081 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1082 : 		}

	pop	ebp
	ret	8
$LN46@append:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
$LN50@append:
	pop	ebx
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1081 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1082 : 		}

	pop	ebp
	ret	8
$LN54@append:

; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN56@append:
$LN53@append:
	int	3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
tv280 = 8						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 1045 : 		if (_Right.size() < _Roff)

	mov	edi, DWORD PTR __Right$[ebp]
	mov	esi, ecx
	mov	ecx, DWORD PTR __Roff$[ebp]
	mov	eax, DWORD PTR [edi+16]
	cmp	eax, ecx
	jb	$LN43@append

; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	sub	eax, ecx

; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)

	mov	ecx, DWORD PTR [esi+16]
	cmp	eax, ebx
	mov	DWORD PTR tv280[ebp], ecx
	cmovb	ebx, eax
	or	eax, -1
	sub	eax, ecx
	cmp	eax, ebx
	jbe	SHORT $LN45@append

; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))

	test	ebx, ebx
	je	SHORT $LN40@append
	lea	eax, DWORD PTR [ecx+ebx]
	mov	ecx, esi
	push	0
	push	eax
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN40@append

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN18@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edi, DWORD PTR [edi]
$LN18@append:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN24@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN25@append
$LN24@append:
	mov	ecx, esi
$LN25@append:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	ebx, ebx
	je	SHORT $LN31@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1056 : 				_Right._Myptr() + _Roff, _Count);

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1056 : 				_Right._Myptr() + _Roff, _Count);

	mov	eax, DWORD PTR [esi+16]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN31@append:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	ecx, DWORD PTR tv280[ebp]
	add	ecx, ebx

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN36@append
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1059 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1060 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN36@append:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
$LN40@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1059 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1060 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN43@append:

; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN46@append:
$LN45@append:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN47@append:
$LN42@append:
	int	3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1038 : 		{	// append _Right

	push	ebp
	mov	ebp, esp

; 1039 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1040 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1033 : 		{	// append 1 * _Ch

	push	ebp
	mov	ebp, esp

; 1034 : 		return (append((size_type)1, _Ch));

	push	DWORD PTR __Ch$[ebp]
	push	1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1035 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1023 : 		{	// append _Right

	push	ebp
	mov	ebp, esp

; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1024 : 		return (append(_Right));
; 1025 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 997  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp

; 998  : 		if (this != &_Right)

	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, ecx
	cmp	esi, eax
	je	SHORT $LN55@operator

; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN55@operator:

; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1010 : 		}

	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 990  : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN21@basic_stri
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@basic_stri:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 992  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 935  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi
	mov	edi, ecx
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jae	SHORT $LN2@Assign_rv

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	eax, DWORD PTR [esi+16]
	inc	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN1@Assign_rv
	push	eax
	push	esi
	push	edi
	call	_memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	jmp	SHORT $LN1@Assign_rv
$LN2@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edi, edi
	je	SHORT $LN21@Assign_rv
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
$LN21@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 942  : 			_Right._Bx._Ptr = pointer();

	mov	DWORD PTR [esi], 0
$LN1@Assign_rv:

; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax

; 945  : 		this->_Myres = _Right._Myres;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 947  : 		}

	pop	ebp
	ret	4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 920  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 921  : 		if (this == &_Right)

	mov	edi, DWORD PTR __Right$[ebp]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN165@assign

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN95@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN95@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jae	SHORT $LN110@assign

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	eax, DWORD PTR [edi+16]
	inc	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN109@assign
	push	eax
	push	edi
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	jmp	SHORT $LN109@assign
$LN110@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 942  : 			_Right._Bx._Ptr = pointer();

	mov	DWORD PTR [edi], 0
$LN109@assign:

; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], eax

; 945  : 		this->_Myres = _Right._Myres;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR [esi+20], eax

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
$LN165@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 931  : 		return (*this);

	mov	eax, esi
	pop	esi

; 932  : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 887  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi

; 887  : 		{	// construct by moving _Right

	mov	edi, ecx

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 936  : 		if (_Right._Myres < this->_BUF_SIZE)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jae	SHORT $LN42@basic_stri

; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);

	mov	eax, DWORD PTR [esi+16]
	inc	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN41@basic_stri
	push	eax
	push	esi
	push	edi
	call	_memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 939  : 		else

	jmp	SHORT $LN41@basic_stri
$LN42@basic_stri:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 942  : 			_Right._Bx._Ptr = pointer();

	mov	DWORD PTR [esi], 0
$LN41@basic_stri:

; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax

; 945  : 		this->_Myres = _Right._Myres;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax

; 890  : 		}

	mov	eax, edi

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 890  : 		}

	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 794  : 		{	// construct from _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	esi

; 796  : 		assign(_Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	esi, ecx
	push	DWORD PTR __Count$[ebp]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 796  : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 797  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN43@basic_stri
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
$LN43@basic_stri:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edx, ecx
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL45@basic_stri:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL45@basic_stri
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 740  : 		}

	mov	eax, ecx

; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 740  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 724  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 726  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 727  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp

; 684  : 		return (_Alty());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc, COMDAT
; _this$ = ecx

; 636  : 		}

	ret	4
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 494  : 		_Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

	mov	eax, ecx

; 495  : 		_Myres = 0;

	mov	DWORD PTR [ecx+20], 0

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 521  : 		}

	ret	0
$LN3@Myptr:

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	mov	eax, ecx

; 521  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 514  : 		}

	ret	0
$LN3@Myptr:

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	mov	eax, ecx

; 514  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 495  : 		_Myres = 0;
; 496  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 25   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN14@allocate
	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 848  : 		}

	pop	ebp
	ret	4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
	int	3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 807  : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 802  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 741  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

	or	eax, -1

; 736  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 613  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 25   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN11@allocate
	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, ecx

; 579  : 		}

	pop	ebp
	ret	4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ PROC ; std::allocator<char>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp

; 533  : 		return (*this);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ENDP ; std::allocator<char>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xatomic0.h
;	COMDAT ?_Init_atomic_counter@std@@YAXAAKK@Z
_TEXT	SEGMENT
__Counter$ = 8						; size = 4
__Value$ = 12						; size = 4
?_Init_atomic_counter@std@@YAXAAKK@Z PROC		; std::_Init_atomic_counter, COMDAT

; 96   : 	{	// non-atomically initialize counter

	push	ebp
	mov	ebp, esp

; 97   : 	_Counter = _Value;

	mov	eax, DWORD PTR __Counter$[ebp]
	mov	ecx, DWORD PTR __Value$[ebp]
	mov	DWORD PTR [eax], ecx

; 98   : 	}

	pop	ebp
	ret	0
?_Init_atomic_counter@std@@YAXAAKK@Z ENDP		; std::_Init_atomic_counter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 605  : 		return (EOF);

	or	eax, -1

; 606  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 593  : 		{	// test for metacharacter equality

	push	ebp
	mov	ebp, esp

; 594  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 595  : 		}

	pop	ebp
	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 587  : 		{	// convert character to metacharacter

	push	ebp
	mov	ebp, esp

; 588  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, BYTE PTR [eax]

; 589  : 		}

	pop	ebp
	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 581  : 		{	// convert metacharacter to character

	push	ebp
	mov	ebp, esp

; 582  : 		return ((_Elem)_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	al, BYTE PTR [eax]

; 583  : 		}

	pop	ebp
	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 558  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 559  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ch$[ebp]
	movsx	eax, al
	push	eax
	push	DWORD PTR __First$[ebp]
	call	_memset
	add	esp, 12					; 0000000cH

; 560  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]

; 554  : 		}

	pop	ebp
	ret	0
$LN3@move:

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	mov	DWORD PTR __Count$[ebp], eax

; 554  : 		}

	pop	ebp

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	jmp	_memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]

; 531  : 		}

	pop	ebp
	ret	0
$LN3@copy:

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	mov	DWORD PTR __Count$[ebp], eax

; 531  : 		}

	pop	ebp

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 524  : 		}

	pop	ebp
	ret	0
$LN3@length:

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	lea	edx, DWORD PTR [eax+1]
$LL5@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@length
	sub	eax, edx

; 524  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _ldexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_ldexpl	PROC						; COMDAT

; 895  : {

	push	ebp
	mov	ebp, esp

; 896  :     return ldexp((double)_X, _Y);

	push	DWORD PTR __Y$[ebp]
	movsd	xmm0, QWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
	add	esp, 12					; 0000000cH

; 897  : }

	pop	ebp
	ret	0
_ldexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _ldexpf
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_ldexpf	PROC						; COMDAT

; 722  : {

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 723  :     return (float)ldexp(_X, _Y);

	push	DWORD PTR __Y$[ebp]
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	add	esp, 12					; 0000000cH

; 724  : }

	pop	ebp
	ret	0
_ldexpf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _hypot
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 8
_hypot	PROC						; COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp

; 557  :     return _hypot(_X, _Y);

	movsd	xmm0, QWORD PTR __Y$[ebp]
	sub	esp, 16					; 00000010H
	movsd	QWORD PTR [esp+8], xmm0
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	__hypot
	add	esp, 16					; 00000010H

; 558  : }

	pop	ebp
	ret	0
_hypot	ENDP
_TEXT	ENDS
END
