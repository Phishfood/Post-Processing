; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	C:\Users\Simon\Documents\GitHub\Post-Processing\Import\Math\CMatrix3x3.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?value@?$integral_constant@I$07@std@@2IB	; std::integral_constant<unsigned int,8>::value
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?value@?$integral_constant@I$03@std@@2IB	; std::integral_constant<unsigned int,4>::value
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@I$01@std@@2IB	; std::integral_constant<unsigned int,2>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$integral_constant@I$00@std@@2IB	; std::integral_constant<unsigned int,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Maximum@$S@std@@2IB			; std::_Maximum<>::value
;	COMDAT ?value@?$_Maximum@$S@std@@2IB
CONST	SEGMENT
?value@?$_Maximum@$S@std@@2IB DD 00H			; std::_Maximum<>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$00@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$00@std@@2IB DD 01H		; std::integral_constant<unsigned int,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$01@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$01@std@@2IB DD 02H		; std::integral_constant<unsigned int,2>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$03@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$03@std@@2IB DD 04H		; std::integral_constant<unsigned int,4>::value
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$07@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$07@std@@2IB DD 08H		; std::integral_constant<unsigned int,8>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
CONST	SEGMENT
_kfPi	DD	040490fdbr			; 3.14159
_kfEpsilon DD	0350637bdr			; 5e-007
_kfPi64	DQ	0400921fb54442d18r		; 3.14159
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
PUBLIC	_hypot
PUBLIC	_acosf
PUBLIC	_atan2f
PUBLIC	_cosf
PUBLIC	_fabsf
PUBLIC	_sinf
PUBLIC	_sqrtf
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ; std::allocator<char>::select_on_container_copy_construction
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?ObjectName@gen@@YAPBDXZ			; gen::ObjectName
PUBLIC	??0CFatalException@gen@@QAE@PBD0H@Z		; gen::CFatalException::CFatalException
PUBLIC	??0CFatalException@gen@@QAE@PBD00@Z		; gen::CFatalException::CFatalException
PUBLIC	??1CFatalException@gen@@QAE@XZ			; gen::CFatalException::~CFatalException
PUBLIC	??0CFatalException@gen@@QAE@ABV01@@Z		; gen::CFatalException::CFatalException
PUBLIC	?Abs@gen@@YAIH@Z				; gen::Abs
PUBLIC	?Abs@gen@@YAMM@Z				; gen::Abs
PUBLIC	?Sqrt@gen@@YAMM@Z				; gen::Sqrt
PUBLIC	?Sin@gen@@YAMM@Z				; gen::Sin
PUBLIC	?Cos@gen@@YAMM@Z				; gen::Cos
PUBLIC	?ACos@gen@@YAMM@Z				; gen::ACos
PUBLIC	?ATan@gen@@YAMMM@Z				; gen::ATan
PUBLIC	?InvSqrt@gen@@YAMM@Z				; gen::InvSqrt
PUBLIC	?SinCos@gen@@YAXMPAM0@Z				; gen::SinCos
PUBLIC	?IsZero@gen@@YA_NMM@Z				; gen::IsZero
PUBLIC	?AreEqual@gen@@YA_NMMI@Z			; gen::AreEqual
PUBLIC	??0CVector2@gen@@QAE@XZ				; gen::CVector2::CVector2
PUBLIC	??0CVector2@gen@@QAE@MM@Z			; gen::CVector2::CVector2
PUBLIC	??0CVector2@gen@@QAE@ABV01@@Z			; gen::CVector2::CVector2
PUBLIC	?IsZero@CVector2@gen@@QBE_NXZ			; gen::CVector2::IsZero
PUBLIC	??Ggen@@YA?AVCVector2@0@ABV10@0@Z		; gen::operator-
PUBLIC	??0CVector3@gen@@QAE@XZ				; gen::CVector3::CVector3
PUBLIC	??0CVector3@gen@@QAE@MMM@Z			; gen::CVector3::CVector3
PUBLIC	??0CVector3@gen@@QAE@PBM@Z			; gen::CVector3::CVector3
PUBLIC	??0CVector3@gen@@QAE@ABV01@@Z			; gen::CVector3::CVector3
PUBLIC	??4CVector3@gen@@QAEAAV01@ABV01@@Z		; gen::CVector3::operator=
PUBLIC	?Set@CVector3@gen@@QAEXMMM@Z			; gen::CVector3::Set
PUBLIC	?IsZero@CVector3@gen@@QBE_NXZ			; gen::CVector3::IsZero
PUBLIC	??Ggen@@YA?AVCVector3@0@ABV10@@Z		; gen::operator-
PUBLIC	?Cross@gen@@YA?AVCVector3@1@ABV21@0@Z		; gen::Cross
PUBLIC	??0CMatrix3x3@gen@@QAE@XZ			; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@MMMMMMMMM@Z		; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@PBM_N@Z			; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@ABVCVector3@1@00_N@Z	; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@ABVCVector2@1@00_N@Z	; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@ABVCVector3@1@W4ERotationOrder@1@0@Z ; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@ABVCQuaternion@1@ABVCVector3@1@@Z ; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@ABVCVector3@1@M0@Z	; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@ABVCVector2@1@@Z		; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@ABVCVector2@1@M0@Z	; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@ABVCMatrix2x2@1@ABVCVector2@1@@Z ; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??0CMatrix3x3@gen@@QAE@ABV01@@Z			; gen::CMatrix3x3::CMatrix3x3
PUBLIC	??4CMatrix3x3@gen@@QAEAAV01@ABV01@@Z		; gen::CMatrix3x3::operator=
PUBLIC	?Set@CMatrix3x3@gen@@QAEXMMMMMMMMM@Z		; gen::CMatrix3x3::Set
PUBLIC	?Set@CMatrix3x3@gen@@QAEXPBM_N@Z		; gen::CMatrix3x3::Set
PUBLIC	?GetRow@CMatrix3x3@gen@@QBE?AVCVector3@2@I@Z	; gen::CMatrix3x3::GetRow
PUBLIC	?GetColumn@CMatrix3x3@gen@@QBE?AVCVector3@2@I@Z	; gen::CMatrix3x3::GetColumn
PUBLIC	?SetRow@CMatrix3x3@gen@@QAEXIABVCVector3@2@@Z	; gen::CMatrix3x3::SetRow
PUBLIC	?SetRow@CMatrix3x3@gen@@QAEXIABVCVector2@2@@Z	; gen::CMatrix3x3::SetRow
PUBLIC	?SetColumn@CMatrix3x3@gen@@QAEXIABVCVector3@2@@Z ; gen::CMatrix3x3::SetColumn
PUBLIC	?SetColumn@CMatrix3x3@gen@@QAEXIABVCVector2@2@@Z ; gen::CMatrix3x3::SetColumn
PUBLIC	?SetRows@CMatrix3x3@gen@@QAEXABVCVector3@2@00@Z	; gen::CMatrix3x3::SetRows
PUBLIC	?SetRows@CMatrix3x3@gen@@QAEXABVCVector2@2@00@Z	; gen::CMatrix3x3::SetRows
PUBLIC	?SetColumns@CMatrix3x3@gen@@QAEXABVCVector3@2@00@Z ; gen::CMatrix3x3::SetColumns
PUBLIC	?SetColumns@CMatrix3x3@gen@@QAEXABVCVector2@2@00@Z ; gen::CMatrix3x3::SetColumns
PUBLIC	?MakeTransformEuler@CMatrix3x3@gen@@QAEXABVCVector3@2@W4ERotationOrder@2@0@Z ; gen::CMatrix3x3::MakeTransformEuler
PUBLIC	?MakeTransformQuaternion@CMatrix3x3@gen@@QAEXABVCQuaternion@2@ABVCVector3@2@@Z ; gen::CMatrix3x3::MakeTransformQuaternion
PUBLIC	?MakeTransformAxisAngle@CMatrix3x3@gen@@QAEXABVCVector3@2@M0@Z ; gen::CMatrix3x3::MakeTransformAxisAngle
PUBLIC	?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z ; gen::CMatrix3x3::DecomposeTransformEuler
PUBLIC	?DecomposeTransformQuaternion@CMatrix3x3@gen@@QBEXPAVCQuaternion@2@PAVCVector3@2@@Z ; gen::CMatrix3x3::DecomposeTransformQuaternion
PUBLIC	?DecomposeTransformAxisAngle@CMatrix3x3@gen@@QBEXPAVCVector3@2@PAM0@Z ; gen::CMatrix3x3::DecomposeTransformAxisAngle
PUBLIC	?MakeAffine2D@CMatrix3x3@gen@@QAEXABVCVector2@2@M0@Z ; gen::CMatrix3x3::MakeAffine2D
PUBLIC	?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z ; gen::CMatrix3x3::DecomposeAffine2D
PUBLIC	?GetScale@CMatrix3x3@gen@@QBE?AVCVector3@2@XZ	; gen::CMatrix3x3::GetScale
PUBLIC	?SetScaleX@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::SetScaleX
PUBLIC	?SetScaleY@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::SetScaleY
PUBLIC	?SetScaleZ@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::SetScaleZ
PUBLIC	?SetScale@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z	; gen::CMatrix3x3::SetScale
PUBLIC	?SetScale@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::SetScale
PUBLIC	?GetPosition2D@CMatrix3x3@gen@@QBE?AVCVector2@2@XZ ; gen::CMatrix3x3::GetPosition2D
PUBLIC	?GetScale2D@CMatrix3x3@gen@@QBE?AVCVector2@2@XZ	; gen::CMatrix3x3::GetScale2D
PUBLIC	?SetScaleX2D@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::SetScaleX2D
PUBLIC	?SetScaleY2D@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::SetScaleY2D
PUBLIC	?SetScale2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z ; gen::CMatrix3x3::SetScale2D
PUBLIC	?SetScale2D@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::SetScale2D
PUBLIC	?IsIdentity@CMatrix3x3@gen@@QBE_NXZ		; gen::CMatrix3x3::IsIdentity
PUBLIC	?IsOrthogonal@CMatrix3x3@gen@@QBE_NXZ		; gen::CMatrix3x3::IsOrthogonal
PUBLIC	?IsOrthonormal@CMatrix3x3@gen@@QBE_NXZ		; gen::CMatrix3x3::IsOrthonormal
PUBLIC	?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z ; gen::CMatrix3x3::Orthogonalise
PUBLIC	?IsOrthogonal2x2@CMatrix3x3@gen@@QBE_NXZ	; gen::CMatrix3x3::IsOrthogonal2x2
PUBLIC	?IsOrthonormal2x2@CMatrix3x3@gen@@QBE_NXZ	; gen::CMatrix3x3::IsOrthonormal2x2
PUBLIC	?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z ; gen::CMatrix3x3::Orthogonalise2x2
PUBLIC	?Transpose@CMatrix3x3@gen@@QAEXXZ		; gen::CMatrix3x3::Transpose
PUBLIC	?InvertRotScale@CMatrix3x3@gen@@QAEXXZ		; gen::CMatrix3x3::InvertRotScale
PUBLIC	?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ		; gen::CMatrix3x3::InvertAffine2D
PUBLIC	?Invert@CMatrix3x3@gen@@QAEXXZ			; gen::CMatrix3x3::Invert
PUBLIC	?MakeIdentity@CMatrix3x3@gen@@QAEXXZ		; gen::CMatrix3x3::MakeIdentity
PUBLIC	?MakeRotationX@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::MakeRotationX
PUBLIC	?MakeRotationY@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::MakeRotationY
PUBLIC	?MakeRotationZ@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::MakeRotationZ
PUBLIC	?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z ; gen::CMatrix3x3::MakeRotation
PUBLIC	?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z ; gen::CMatrix3x3::MakeRotation
PUBLIC	?MakeScaling@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z ; gen::CMatrix3x3::MakeScaling
PUBLIC	?MakeScaling@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::MakeScaling
PUBLIC	?MakeTranslation2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z ; gen::CMatrix3x3::MakeTranslation2D
PUBLIC	?MakeRotation2D@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::MakeRotation2D
PUBLIC	?MakeScaling2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z ; gen::CMatrix3x3::MakeScaling2D
PUBLIC	?MakeScaling2D@CMatrix3x3@gen@@QAEXM@Z		; gen::CMatrix3x3::MakeScaling2D
PUBLIC	?FaceDirection@CMatrix3x3@gen@@QAEXABVCVector3@2@0_N@Z ; gen::CMatrix3x3::FaceDirection
PUBLIC	?FaceTarget2D@CMatrix3x3@gen@@QAEXABVCVector2@2@_N1@Z ; gen::CMatrix3x3::FaceTarget2D
PUBLIC	?FaceDirection2D@CMatrix3x3@gen@@QAEXABVCVector2@2@_N1@Z ; gen::CMatrix3x3::FaceDirection2D
PUBLIC	??XCMatrix3x3@gen@@QAEAAV01@M@Z			; gen::CMatrix3x3::operator*=
PUBLIC	??_0CMatrix3x3@gen@@QAEAAV01@M@Z		; gen::CMatrix3x3::operator/=
PUBLIC	?Transform@CMatrix3x3@gen@@QBE?AVCVector3@2@ABV32@@Z ; gen::CMatrix3x3::Transform
PUBLIC	?TransformVector2D@CMatrix3x3@gen@@QBE?AVCVector2@2@ABV32@@Z ; gen::CMatrix3x3::TransformVector2D
PUBLIC	?TransformPoint2D@CMatrix3x3@gen@@QBE?AVCVector2@2@ABV32@@Z ; gen::CMatrix3x3::TransformPoint2D
PUBLIC	??XCMatrix3x3@gen@@QAEAAV01@ABV01@@Z		; gen::CMatrix3x3::operator*=
PUBLIC	?MultiplyAffine2D@CMatrix3x3@gen@@QAEAAV12@ABV12@@Z ; gen::CMatrix3x3::MultiplyAffine2D
PUBLIC	??8gen@@YA_NABVCMatrix3x3@0@0@Z			; gen::operator==
PUBLIC	??9gen@@YA_NABVCMatrix3x3@0@0@Z			; gen::operator!=
PUBLIC	??Dgen@@YA?AVCMatrix3x3@0@MABV10@@Z		; gen::operator*
PUBLIC	??Dgen@@YA?AVCMatrix3x3@0@ABV10@M@Z		; gen::operator*
PUBLIC	??Kgen@@YA?AVCMatrix3x3@0@ABV10@M@Z		; gen::operator/
PUBLIC	??Dgen@@YA?AVCVector3@0@ABV10@ABVCMatrix3x3@0@@Z ; gen::operator*
PUBLIC	??Dgen@@YA?AVCVector3@0@ABVCMatrix3x3@0@ABV10@@Z ; gen::operator*
PUBLIC	??Dgen@@YA?AVCMatrix3x3@0@ABV10@0@Z		; gen::operator*
PUBLIC	?MultiplyAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@0@Z ; gen::MultiplyAffine2D
PUBLIC	?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z ; gen::Orthogonalise
PUBLIC	?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z ; gen::Orthogonalise2x2
PUBLIC	?Transpose@gen@@YA?AVCMatrix3x3@1@ABV21@@Z	; gen::Transpose
PUBLIC	?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z ; gen::InverseRotScale
PUBLIC	?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z ; gen::InverseAffine2D
PUBLIC	?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z	; gen::Inverse
PUBLIC	?Matrix3x3Identity@gen@@YA?AVCMatrix3x3@1@XZ	; gen::Matrix3x3Identity
PUBLIC	?Matrix3x3RotationX@gen@@YA?AVCMatrix3x3@1@M@Z	; gen::Matrix3x3RotationX
PUBLIC	?Matrix3x3RotationY@gen@@YA?AVCMatrix3x3@1@M@Z	; gen::Matrix3x3RotationY
PUBLIC	?Matrix3x3RotationZ@gen@@YA?AVCMatrix3x3@1@M@Z	; gen::Matrix3x3RotationZ
PUBLIC	?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z ; gen::Matrix3x3Rotation
PUBLIC	?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z ; gen::Matrix3x3Rotation
PUBLIC	?Matrix3x3Scaling@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@@Z ; gen::Matrix3x3Scaling
PUBLIC	?Matrix3x3Scaling@gen@@YA?AVCMatrix3x3@1@M@Z	; gen::Matrix3x3Scaling
PUBLIC	?MatrixTranslation2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@@Z ; gen::MatrixTranslation2D
PUBLIC	?MatrixRotation2D@gen@@YA?AVCMatrix3x3@1@M@Z	; gen::MatrixRotation2D
PUBLIC	?MatrixScaling2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@@Z ; gen::MatrixScaling2D
PUBLIC	?MatrixScaling2D@gen@@YA?AVCMatrix3x3@1@M@Z	; gen::MatrixScaling2D
PUBLIC	?MatrixFaceDirection@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@0_N@Z ; gen::MatrixFaceDirection
PUBLIC	?MatrixFaceTarget2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@0_N1@Z ; gen::MatrixFaceTarget2D
PUBLIC	?MatrixFaceDirection2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@0_N1@Z ; gen::MatrixFaceDirection2D
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_0CB@NBMGHEOM@Visual?5C?$CL?$CL?58?40?5?$CI2005?$CJ?5or?5greater@ ; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BE@HBKCGNOA@Unhandled?5Exception?$AA@	; `string'
PUBLIC	?kIdentity@CMatrix3x3@gen@@2V12@B		; gen::CMatrix3x3::kIdentity
PUBLIC	__TI1?AVCFatalException@gen@@
PUBLIC	__CTA1?AVCFatalException@gen@@
PUBLIC	??_R0?AVCFatalException@gen@@@8			; gen::CFatalException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCFatalException@gen@@@8??0CFatalException@gen@@QAE@ABV01@@Z76
PUBLIC	??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@	; `string'
PUBLIC	??_C@_0BC@DBAKKFEN@Invalid?5parameter?$AA@	; `string'
PUBLIC	??_C@_0CJ@DHMHJNHL@gen?3?3CMatrix3x3?3?3DecomposeTransf@ ; `string'
PUBLIC	??_C@_0CD@GODDIFLH@gen?3?3CMatrix3x3?3?3DecomposeAffine@ ; `string'
PUBLIC	??_C@_0BP@PMPEPEBF@gen?3?3CMatrix3x3?3?3Orthogonalise?$AA@ ; `string'
PUBLIC	??_C@_0BD@MGLNMEBA@gen?3?3Orthogonalise?$AA@	; `string'
PUBLIC	??_C@_0CC@DNFNCOGI@gen?3?3CMatrix3x3?3?3Orthogonalise2x@ ; `string'
PUBLIC	??_C@_0BG@OLNACDHO@gen?3?3Orthogonalise2x2?$AA@	; `string'
PUBLIC	??_C@_0CA@CAHBGMPM@gen?3?3CMatrix3x3?3?3InvertRotScale?$AA@ ; `string'
PUBLIC	??_C@_0BF@CDKPJIKO@gen?3?3InverseRotScale?$AA@	; `string'
PUBLIC	??_C@_0CA@GCJMOFPA@gen?3?3CMatrix3x3?3?3InvertAffine2D?$AA@ ; `string'
PUBLIC	??_C@_0BF@GBECBBKC@gen?3?3InverseAffine2D?$AA@	; `string'
PUBLIC	??_C@_0N@BLGPECID@gen?3?3Inverse?$AA@		; `string'
PUBLIC	??_C@_0BO@FPKFHDMJ@gen?3?3CMatrix3x3?3?3MakeRotation?$AA@ ; `string'
PUBLIC	??_C@_0BB@OPALDBID@Zero?5length?5axis?$AA@	; `string'
PUBLIC	??_C@_0BH@KCOELIJE@gen?3?3Matrix3x3Rotation?$AA@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@350637bd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40490fdb
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__hypot:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z:PROC ; gen::CFatalException::AppendToCallStack
EXTRN	?Normalise@gen@@YA?AVCVector2@1@ABV21@@Z:PROC	; gen::Normalise
EXTRN	?Normalise@CVector3@gen@@QAEXXZ:PROC		; gen::CVector3::Normalise
EXTRN	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z:PROC	; gen::Normalise
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIatan2:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_acos_precise:PROC
EXTRN	__libm_sse2_cos_precise:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_memcpy:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?kZAxis@CVector3@gen@@2V12@B:BYTE		; gen::CVector3::kZAxis
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_ksCompiler$initializer$ DD FLAT:??__EksCompiler@gen@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@350637bd
CONST	SEGMENT
__real@350637bd DD 0350637bdr			; 5e-007
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KCOELIJE@gen?3?3Matrix3x3Rotation?$AA@
CONST	SEGMENT
??_C@_0BH@KCOELIJE@gen?3?3Matrix3x3Rotation?$AA@ DB 'gen::Matrix3x3Rotati'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OPALDBID@Zero?5length?5axis?$AA@
CONST	SEGMENT
??_C@_0BB@OPALDBID@Zero?5length?5axis?$AA@ DB 'Zero length axis', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FPKFHDMJ@gen?3?3CMatrix3x3?3?3MakeRotation?$AA@
CONST	SEGMENT
??_C@_0BO@FPKFHDMJ@gen?3?3CMatrix3x3?3?3MakeRotation?$AA@ DB 'gen::CMatri'
	DB	'x3x3::MakeRotation', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BLGPECID@gen?3?3Inverse?$AA@
CONST	SEGMENT
??_C@_0N@BLGPECID@gen?3?3Inverse?$AA@ DB 'gen::Inverse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GBECBBKC@gen?3?3InverseAffine2D?$AA@
CONST	SEGMENT
??_C@_0BF@GBECBBKC@gen?3?3InverseAffine2D?$AA@ DB 'gen::InverseAffine2D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GCJMOFPA@gen?3?3CMatrix3x3?3?3InvertAffine2D?$AA@
CONST	SEGMENT
??_C@_0CA@GCJMOFPA@gen?3?3CMatrix3x3?3?3InvertAffine2D?$AA@ DB 'gen::CMat'
	DB	'rix3x3::InvertAffine2D', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CDKPJIKO@gen?3?3InverseRotScale?$AA@
CONST	SEGMENT
??_C@_0BF@CDKPJIKO@gen?3?3InverseRotScale?$AA@ DB 'gen::InverseRotScale', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CAHBGMPM@gen?3?3CMatrix3x3?3?3InvertRotScale?$AA@
CONST	SEGMENT
??_C@_0CA@CAHBGMPM@gen?3?3CMatrix3x3?3?3InvertRotScale?$AA@ DB 'gen::CMat'
	DB	'rix3x3::InvertRotScale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OLNACDHO@gen?3?3Orthogonalise2x2?$AA@
CONST	SEGMENT
??_C@_0BG@OLNACDHO@gen?3?3Orthogonalise2x2?$AA@ DB 'gen::Orthogonalise2x2'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DNFNCOGI@gen?3?3CMatrix3x3?3?3Orthogonalise2x@
CONST	SEGMENT
??_C@_0CC@DNFNCOGI@gen?3?3CMatrix3x3?3?3Orthogonalise2x@ DB 'gen::CMatrix'
	DB	'3x3::Orthogonalise2x2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MGLNMEBA@gen?3?3Orthogonalise?$AA@
CONST	SEGMENT
??_C@_0BD@MGLNMEBA@gen?3?3Orthogonalise?$AA@ DB 'gen::Orthogonalise', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PMPEPEBF@gen?3?3CMatrix3x3?3?3Orthogonalise?$AA@
CONST	SEGMENT
??_C@_0BP@PMPEPEBF@gen?3?3CMatrix3x3?3?3Orthogonalise?$AA@ DB 'gen::CMatr'
	DB	'ix3x3::Orthogonalise', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GODDIFLH@gen?3?3CMatrix3x3?3?3DecomposeAffine@
CONST	SEGMENT
??_C@_0CD@GODDIFLH@gen?3?3CMatrix3x3?3?3DecomposeAffine@ DB 'gen::CMatrix'
	DB	'3x3::DecomposeAffine2D', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DHMHJNHL@gen?3?3CMatrix3x3?3?3DecomposeTransf@
CONST	SEGMENT
??_C@_0CJ@DHMHJNHL@gen?3?3CMatrix3x3?3?3DecomposeTransf@ DB 'gen::CMatrix'
	DB	'3x3::DecomposeTransformEuler', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DBAKKFEN@Invalid?5parameter?$AA@
CONST	SEGMENT
??_C@_0BC@DBAKKFEN@Invalid?5parameter?$AA@ DB 'Invalid parameter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
CONST	SEGMENT
??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@ DB 'Singular matrix', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
CONST	SEGMENT
??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@ DB 'Import\Math\CMa'
	DB	'trix3x3.cpp', 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVCFatalException@gen@@@8??0CFatalException@gen@@QAE@ABV01@@Z76
xdata$x	SEGMENT
__CT??_R0?AVCFatalException@gen@@@8??0CFatalException@gen@@QAE@ABV01@@Z76 DD 00H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04cH
	DD	FLAT:??0CFatalException@gen@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVCFatalException@gen@@@8
data$r	SEGMENT
??_R0?AVCFatalException@gen@@@8 DD FLAT:??_7type_info@@6B@ ; gen::CFatalException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFatalException@gen@@', 00H
data$r	ENDS
;	COMDAT __CTA1?AVCFatalException@gen@@
xdata$x	SEGMENT
__CTA1?AVCFatalException@gen@@ DD 01H
	DD	FLAT:__CT??_R0?AVCFatalException@gen@@@8??0CFatalException@gen@@QAE@ABV01@@Z76
xdata$x	ENDS
;	COMDAT __TI1?AVCFatalException@gen@@
xdata$x	SEGMENT
__TI1?AVCFatalException@gen@@ DD 00H
	DD	FLAT:??1CFatalException@gen@@QAE@XZ
	DD	00H
	DD	FLAT:__CTA1?AVCFatalException@gen@@
xdata$x	ENDS
;	COMDAT ??_C@_0BE@HBKCGNOA@Unhandled?5Exception?$AA@
CONST	SEGMENT
??_C@_0BE@HBKCGNOA@Unhandled?5Exception?$AA@ DB 'Unhandled Exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NBMGHEOM@Visual?5C?$CL?$CL?58?40?5?$CI2005?$CJ?5or?5greater@
CONST	SEGMENT
??_C@_0CB@NBMGHEOM@Visual?5C?$CL?$CL?58?40?5?$CI2005?$CJ?5or?5greater@ DB 'V'
	DB	'isual C++ 8.0 (2005) or greater', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
_ksCompiler DB	00H
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
_ksPathSeparator DB 00H
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
_ksNewline DB	00H
	DB	15 DUP(00H)
	DD	00H
	DD	0fH
?kIdentity@CMatrix3x3@gen@@2V12@B DD 03f800000r	; 1	; gen::CMatrix3x3::kIdentity
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_DATA	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD FLAT:??_7_System_error_category@std@@6B@ ; std::_Error_objects<int>::_System_object
_DATA	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_DATA	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD FLAT:??_7_Iostream_error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object
_DATA	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_DATA	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD FLAT:??_7_Generic_error_category@std@@6B@ ; std::_Error_objects<int>::_Generic_object
_DATA	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z$3
__catchsym$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffeecH
	DD	FLAT:__catch$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z$1
__ehfuncinfo$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z$3
__catchsym$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffef0H
	DD	FLAT:__catch$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z$1
__ehfuncinfo$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$3
__catchsym$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0ffffff00H
	DD	FLAT:__catch$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$1
__ehfuncinfo$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$3
__catchsym$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0ffffff04H
	DD	FLAT:__catch$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$1
__ehfuncinfo$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$3
__catchsym$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0ffffff04H
	DD	FLAT:__catch$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$1
__ehfuncinfo$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z$3
__catchsym$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffee8H
	DD	FLAT:__catch$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z$1
__ehfuncinfo$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z$3
__catchsym$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffe94H
	DD	FLAT:__catch$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z$1
__ehfuncinfo$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z$3
__catchsym$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffeecH
	DD	FLAT:__catch$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z$1
__ehfuncinfo$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z
	DD	01H
	DD	FLAT:__tryblocktable$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z$3
__catchsym$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffef0H
	DD	FLAT:__catch$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z$1
__ehfuncinfo$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ$3
__catchsym$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0ffffff04H
	DD	FLAT:__catch$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ$1
__ehfuncinfo$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ$3
__catchsym$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffef4H
	DD	FLAT:__catch$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ$1
__ehfuncinfo$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z$3
__catchsym$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffeecH
	DD	FLAT:__catch$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z$1
__ehfuncinfo$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z$3
__catchsym$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffe84H
	DD	FLAT:__catch$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z$1
__ehfuncinfo$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z$3
__catchsym$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffed4H
	DD	FLAT:__catch$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z$1
__ehfuncinfo$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z$3
__catchsym$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z$3 DD 08H
	DD	FLAT:??_R0?AVCFatalException@gen@@@8
	DD	0fffffe60H
	DD	FLAT:__catch$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z$1
__ehfuncinfo$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CFatalException@gen@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFatalException@gen@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CFatalException@gen@@QAE@ABV01@@Z$1
__ehfuncinfo$??0CFatalException@gen@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CFatalException@gen@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CFatalException@gen@@QAE@PBD00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFatalException@gen@@QAE@PBD00@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CFatalException@gen@@QAE@PBD00@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CFatalException@gen@@QAE@PBD00@Z$2
__ehfuncinfo$??0CFatalException@gen@@QAE@PBD00@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CFatalException@gen@@QAE@PBD00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CFatalException@gen@@QAE@PBD0H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFatalException@gen@@QAE@PBD0H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CFatalException@gen@@QAE@PBD0H@Z$1
__ehfuncinfo$??0CFatalException@gen@@QAE@PBD0H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CFatalException@gen@@QAE@PBD0H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_ksPathSeparator$initializer$ DD FLAT:??__EksPathSeparator@gen@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_ksNewline$initializer$ DD FLAT:??__EksNewline@gen@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 601  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);
; 731  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN7@construct:

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 724  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT

; 159  : 		{	// destroy the object

	mov	DWORD PTR ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_System_object
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	pop	ecx
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 159  : 		{	// destroy the object

	mov	DWORD PTR ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	pop	ecx
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 159  : 		{	// destroy the object

	mov	DWORD PTR ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A, OFFSET ??_7error_category@std@@6B@ ; std::_Error_objects<int>::_Generic_object
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$di	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 611  : 		{	// estimate maximum array size

	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	pop	ecx
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN1@Allocate
	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	jne	SHORT $LN2@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	jmp	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, ecx

; 32   : 	}

	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN11@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MatrixFaceDirection2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@0_N1@Z
_TEXT	SEGMENT
_axis$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
_position$ = 12						; size = 4
_direction$ = 16					; size = 4
_bUseYAxis$ = 20					; size = 1
_bLH$ = 24						; size = 1
?MatrixFaceDirection2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@0_N1@Z PROC ; gen::MatrixFaceDirection2D, COMDAT

; 2840 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2843 : 	CVector2 axis = Normalise( direction );

	push	DWORD PTR _direction$[ebp]
	lea	eax, DWORD PTR _axis$[ebp]
	push	eax
	call	?Normalise@gen@@YA?AVCVector2@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 168  : 		return gen::IsZero( x*x + y*y );

	movss	xmm3, DWORD PTR _axis$[ebp+4]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2843 : 	CVector2 axis = Normalise( direction );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 168  : 		return gen::IsZero( x*x + y*y );

	movss	xmm4, DWORD PTR _axis$[ebp]
	movaps	xmm1, xmm3
	movaps	xmm0, xmm4
	mulss	xmm1, xmm3
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2844 : 	if (axis.IsZero()) return CMatrix3x3( position );

	jbe	SHORT $LN7@MatrixFace

; 269  : 	e00 = 1.0f;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 270  : 	e01 = 0.0f;
; 271  : 	e02 = 0.0f;
; 272  : 
; 273  : 	e10 = 0.0f;
; 274  : 	e11 = 1.0f;
; 275  : 	e12 = 0.0f;
; 276  : 
; 277  : 	// Put position (translation) in bottom row
; 278  : 	e20 = position.x;

	mov	edx, DWORD PTR _position$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax+24], ecx

; 279  : 	e21 = position.y;

	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 1065353216		; 3f800000H
	mov	DWORD PTR [eax+28], ecx

; 2844 : 	if (axis.IsZero()) return CMatrix3x3( position );

	jmp	SHORT $LN24@MatrixFace
$LN7@MatrixFace:

; 2845 : 	if (bUseYAxis)

	cmp	BYTE PTR _bUseYAxis$[ebp], 0
	je	SHORT $LN6@MatrixFace

; 2846 : 	{
; 2847 : 		m.e10 = axis.x;
; 2848 : 		m.e11 = axis.y;
; 2849 : 		m.e12 = 0.0f;
; 2850 : 		if (bLH)

	cmp	BYTE PTR _bLH$[ebp], 0
	movaps	xmm5, xmm3

; 2851 : 		{
; 2852 : 			m.e00 = m.e11;

	movaps	xmm0, xmm3

; 2853 : 			m.e01 = -m.e10;

	movaps	xmm3, xmm4
	je	SHORT $LN5@MatrixFace
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000

; 2854 : 		}
; 2855 : 		else

	jmp	SHORT $LN1@MatrixFace
$LN5@MatrixFace:

; 2856 : 		{
; 2857 : 			m.e00 = -m.e11;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000

; 2858 : 			m.e01 = m.e10;
; 2859 : 		}
; 2860 : 		m.e02 = 0.0f;
; 2861 : 	}
; 2862 : 	else

	jmp	SHORT $LN1@MatrixFace
$LN6@MatrixFace:

; 2863 : 	{
; 2864 : 		m.e00 = axis.x;
; 2865 : 		m.e01 = axis.y;
; 2866 : 		m.e02 = 0.0f;
; 2867 : 		if (bLH)

	cmp	BYTE PTR _bLH$[ebp], 0
	movaps	xmm0, xmm4

; 2868 : 		{
; 2869 : 			m.e11 = -m.e00;

	movaps	xmm5, xmm4

; 2870 : 			m.e10 = m.e01;

	movaps	xmm4, xmm3
	je	SHORT $LN2@MatrixFace

; 2868 : 		{
; 2869 : 			m.e11 = -m.e00;

	xorps	xmm5, DWORD PTR __xmm@80000000800000008000000080000000

; 2871 : 		}
; 2872 : 		else

	jmp	SHORT $LN1@MatrixFace
$LN2@MatrixFace:

; 2873 : 		{
; 2874 : 			m.e11 = m.e00;
; 2875 : 			m.e10 = -m.e01;

	xorps	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
$LN1@MatrixFace:

; 2876 : 		}
; 2877 : 		m.e12 = 0.0f;
; 2878 : 	}
; 2879 : 
; 2880 : 	m.e20 = position.x;

	mov	eax, DWORD PTR _position$[ebp]
	movss	xmm1, DWORD PTR [eax]

; 2881 : 	m.e21 = position.y;

	movss	xmm2, DWORD PTR [eax+4]

; 280  : 	e22 = 1.0f;
; 281  : }
; 282  : 
; 283  : // Construct 2D affine transformation from position, rotation angle and optional scaling, with 
; 284  : // remaining elements taken from the identity matrix. Matrix is effectively built in this
; 285  : // order: M = Scale*Rotation*Translation
; 286  : CMatrix3x3::CMatrix3x3
; 287  : (
; 288  : 	const CVector2& position,
; 289  : 	const TFloat32  fAngle,
; 290  : 	const CVector2& scale /*= CVector2::kOne*/
; 291  : )
; 292  : {
; 293  : 	TFloat32 s, c;
; 294  : 	SinCos( fAngle, &s, &c );
; 295  : 
; 296  : 	e00 = c * scale.x;
; 297  : 	e01 = s * scale.x;
; 298  : 	e02 = 0.0f;
; 299  : 
; 300  : 	e10 = -s * scale.y;
; 301  : 	e11 = c * scale.y;
; 302  : 	e12 = 0.0f;
; 303  : 
; 304  : 	e20 = position.x;
; 305  : 	e21 = position.y;
; 306  : 	e22 = 1.0f;
; 307  : }
; 308  : 
; 309  : 
; 310  : // Construct from a CMatrix2x2 and optional 2D position, with remaining elements taken from
; 311  : // the identity matrix
; 312  : CMatrix3x3::CMatrix3x3
; 313  : (
; 314  : 	const CMatrix2x2& m,
; 315  : 	const CVector2&   position /*= CVector2::kOrigin*/
; 316  : )
; 317  : {
; 318  : 	// Copy 2x2 elements, adding extra identity elements
; 319  : 	e00 = m.e00;
; 320  : 	e01 = m.e01;
; 321  : 	e02 = 0.0f;
; 322  : 
; 323  : 	e10 = m.e10;
; 324  : 	e11 = m.e11;
; 325  : 	e12 = 0.0f;
; 326  : 
; 327  : 	// Put position (translation) in bottom row
; 328  : 	e20 = position.x;
; 329  : 	e21 = position.y;
; 330  : 	e22 = 1.0f;
; 331  : }
; 332  : 
; 333  : 
; 334  : // Copy constructor
; 335  : CMatrix3x3::CMatrix3x3( const CMatrix3x3& m )
; 336  : {
; 337  : 	e00 = m.e00;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	DWORD PTR [eax], xmm0

; 338  : 	e01 = m.e01;

	movss	DWORD PTR [eax+4], xmm3

; 339  : 	e02 = m.e02;
; 340  : 
; 341  : 	e10 = m.e10;

	movss	DWORD PTR [eax+12], xmm4

; 342  : 	e11 = m.e11;

	movss	DWORD PTR [eax+16], xmm5

; 343  : 	e12 = m.e12;
; 344  : 
; 345  : 	e20 = m.e20;

	movss	DWORD PTR [eax+24], xmm1

; 346  : 	e21 = m.e21;

	movss	DWORD PTR [eax+28], xmm2
$LN24@MatrixFace:

; 347  : 	e22 = m.e22;

	mov	DWORD PTR [eax+32], 1065353216		; 3f800000H
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+8], 0

; 2882 : 	m.e22 = 1.0f;
; 2883 : 
; 2884 : 	return m;
; 2885 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MatrixFaceDirection2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@0_N1@Z ENDP ; gen::MatrixFaceDirection2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MatrixFaceTarget2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@0_N1@Z
_TEXT	SEGMENT
_axis$ = -16						; size = 8
$T1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
_position$ = 12						; size = 4
_target$ = 16						; size = 4
_bUseYAxis$ = 20					; size = 1
_bLH$ = 24						; size = 1
?MatrixFaceTarget2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@0_N1@Z PROC ; gen::MatrixFaceTarget2D, COMDAT

; 2739 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 366  : 	return CVector2(v1.x - v2.x, v1.y - v2.y);

	mov	eax, DWORD PTR _target$[ebp]
	push	esi
	mov	esi, DWORD PTR _position$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [esi]

; 50   : 	{}

	movss	DWORD PTR $T1[ebp], xmm0

; 366  : 	return CVector2(v1.x - v2.x, v1.y - v2.y);

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2742 : 	CVector2 axis = Normalise(target - position);

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 366  : 	return CVector2(v1.x - v2.x, v1.y - v2.y);

	subss	xmm0, DWORD PTR [esi+4]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2742 : 	CVector2 axis = Normalise(target - position);

	push	eax
	lea	eax, DWORD PTR _axis$[ebp]
	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 50   : 	{}

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2742 : 	CVector2 axis = Normalise(target - position);

	call	?Normalise@gen@@YA?AVCVector2@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 168  : 		return gen::IsZero( x*x + y*y );

	movss	xmm3, DWORD PTR _axis$[ebp+4]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2742 : 	CVector2 axis = Normalise(target - position);

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 168  : 		return gen::IsZero( x*x + y*y );

	movss	xmm4, DWORD PTR _axis$[ebp]
	movaps	xmm1, xmm3
	movaps	xmm0, xmm4
	mulss	xmm1, xmm3
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2743 : 	if (axis.IsZero()) return CMatrix3x3( position );

	jbe	SHORT $LN7@MatrixFace

; 269  : 	e00 = 1.0f;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 270  : 	e01 = 0.0f;
; 271  : 	e02 = 0.0f;
; 272  : 
; 273  : 	e10 = 0.0f;
; 274  : 	e11 = 1.0f;
; 275  : 	e12 = 0.0f;
; 276  : 
; 277  : 	// Put position (translation) in bottom row
; 278  : 	e20 = position.x;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+24], ecx

; 279  : 	e21 = position.y;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 1065353216		; 3f800000H
	mov	DWORD PTR [eax+28], ecx

; 2743 : 	if (axis.IsZero()) return CMatrix3x3( position );

	jmp	SHORT $LN28@MatrixFace
$LN7@MatrixFace:

; 2744 : 	if (bUseYAxis)

	cmp	BYTE PTR _bUseYAxis$[ebp], 0
	je	SHORT $LN6@MatrixFace

; 2745 : 	{
; 2746 : 		m.e10 = axis.x;
; 2747 : 		m.e11 = axis.y;
; 2748 : 		m.e12 = 0.0f;
; 2749 : 		if (bLH)

	cmp	BYTE PTR _bLH$[ebp], 0
	movaps	xmm5, xmm3

; 2750 : 		{
; 2751 : 			m.e00 = m.e11;

	movaps	xmm0, xmm3

; 2752 : 			m.e01 = -m.e10;

	movaps	xmm3, xmm4
	je	SHORT $LN5@MatrixFace
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000

; 2753 : 		}
; 2754 : 		else

	jmp	SHORT $LN1@MatrixFace
$LN5@MatrixFace:

; 2755 : 		{
; 2756 : 			m.e00 = -m.e11;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000

; 2757 : 			m.e01 = m.e10;
; 2758 : 		}
; 2759 : 		m.e02 = 0.0f;
; 2760 : 	}
; 2761 : 	else

	jmp	SHORT $LN1@MatrixFace
$LN6@MatrixFace:

; 2762 : 	{
; 2763 : 		m.e00 = axis.x;
; 2764 : 		m.e01 = axis.y;
; 2765 : 		m.e02 = 0.0f;
; 2766 : 		if (bLH)

	cmp	BYTE PTR _bLH$[ebp], 0
	movaps	xmm0, xmm4

; 2767 : 		{
; 2768 : 			m.e11 = -m.e00;

	movaps	xmm5, xmm4

; 2769 : 			m.e10 = m.e01;

	movaps	xmm4, xmm3
	je	SHORT $LN2@MatrixFace

; 2767 : 		{
; 2768 : 			m.e11 = -m.e00;

	xorps	xmm5, DWORD PTR __xmm@80000000800000008000000080000000

; 2770 : 		}
; 2771 : 		else

	jmp	SHORT $LN1@MatrixFace
$LN2@MatrixFace:

; 2772 : 		{
; 2773 : 			m.e11 = m.e00;
; 2774 : 			m.e10 = -m.e01;

	xorps	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
$LN1@MatrixFace:

; 280  : 	e22 = 1.0f;
; 281  : }
; 282  : 
; 283  : // Construct 2D affine transformation from position, rotation angle and optional scaling, with 
; 284  : // remaining elements taken from the identity matrix. Matrix is effectively built in this
; 285  : // order: M = Scale*Rotation*Translation
; 286  : CMatrix3x3::CMatrix3x3
; 287  : (
; 288  : 	const CVector2& position,
; 289  : 	const TFloat32  fAngle,
; 290  : 	const CVector2& scale /*= CVector2::kOne*/
; 291  : )
; 292  : {
; 293  : 	TFloat32 s, c;
; 294  : 	SinCos( fAngle, &s, &c );
; 295  : 
; 296  : 	e00 = c * scale.x;
; 297  : 	e01 = s * scale.x;
; 298  : 	e02 = 0.0f;
; 299  : 
; 300  : 	e10 = -s * scale.y;
; 301  : 	e11 = c * scale.y;
; 302  : 	e12 = 0.0f;
; 303  : 
; 304  : 	e20 = position.x;
; 305  : 	e21 = position.y;
; 306  : 	e22 = 1.0f;
; 307  : }
; 308  : 
; 309  : 
; 310  : // Construct from a CMatrix2x2 and optional 2D position, with remaining elements taken from
; 311  : // the identity matrix
; 312  : CMatrix3x3::CMatrix3x3
; 313  : (
; 314  : 	const CMatrix2x2& m,
; 315  : 	const CVector2&   position /*= CVector2::kOrigin*/
; 316  : )
; 317  : {
; 318  : 	// Copy 2x2 elements, adding extra identity elements
; 319  : 	e00 = m.e00;
; 320  : 	e01 = m.e01;
; 321  : 	e02 = 0.0f;
; 322  : 
; 323  : 	e10 = m.e10;
; 324  : 	e11 = m.e11;
; 325  : 	e12 = 0.0f;
; 326  : 
; 327  : 	// Put position (translation) in bottom row
; 328  : 	e20 = position.x;
; 329  : 	e21 = position.y;
; 330  : 	e22 = 1.0f;
; 331  : }
; 332  : 
; 333  : 
; 334  : // Copy constructor
; 335  : CMatrix3x3::CMatrix3x3( const CMatrix3x3& m )
; 336  : {
; 337  : 	e00 = m.e00;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2775 : 		}
; 2776 : 		m.e12 = 0.0f;
; 2777 : 	}
; 2778 : 
; 2779 : 	m.e20 = position.x;

	movss	xmm1, DWORD PTR [esi]

; 2780 : 	m.e21 = position.y;

	movss	xmm2, DWORD PTR [esi+4]

; 280  : 	e22 = 1.0f;
; 281  : }
; 282  : 
; 283  : // Construct 2D affine transformation from position, rotation angle and optional scaling, with 
; 284  : // remaining elements taken from the identity matrix. Matrix is effectively built in this
; 285  : // order: M = Scale*Rotation*Translation
; 286  : CMatrix3x3::CMatrix3x3
; 287  : (
; 288  : 	const CVector2& position,
; 289  : 	const TFloat32  fAngle,
; 290  : 	const CVector2& scale /*= CVector2::kOne*/
; 291  : )
; 292  : {
; 293  : 	TFloat32 s, c;
; 294  : 	SinCos( fAngle, &s, &c );
; 295  : 
; 296  : 	e00 = c * scale.x;
; 297  : 	e01 = s * scale.x;
; 298  : 	e02 = 0.0f;
; 299  : 
; 300  : 	e10 = -s * scale.y;
; 301  : 	e11 = c * scale.y;
; 302  : 	e12 = 0.0f;
; 303  : 
; 304  : 	e20 = position.x;
; 305  : 	e21 = position.y;
; 306  : 	e22 = 1.0f;
; 307  : }
; 308  : 
; 309  : 
; 310  : // Construct from a CMatrix2x2 and optional 2D position, with remaining elements taken from
; 311  : // the identity matrix
; 312  : CMatrix3x3::CMatrix3x3
; 313  : (
; 314  : 	const CMatrix2x2& m,
; 315  : 	const CVector2&   position /*= CVector2::kOrigin*/
; 316  : )
; 317  : {
; 318  : 	// Copy 2x2 elements, adding extra identity elements
; 319  : 	e00 = m.e00;
; 320  : 	e01 = m.e01;
; 321  : 	e02 = 0.0f;
; 322  : 
; 323  : 	e10 = m.e10;
; 324  : 	e11 = m.e11;
; 325  : 	e12 = 0.0f;
; 326  : 
; 327  : 	// Put position (translation) in bottom row
; 328  : 	e20 = position.x;
; 329  : 	e21 = position.y;
; 330  : 	e22 = 1.0f;
; 331  : }
; 332  : 
; 333  : 
; 334  : // Copy constructor
; 335  : CMatrix3x3::CMatrix3x3( const CMatrix3x3& m )
; 336  : {
; 337  : 	e00 = m.e00;

	movss	DWORD PTR [eax], xmm0

; 338  : 	e01 = m.e01;

	movss	DWORD PTR [eax+4], xmm3

; 339  : 	e02 = m.e02;
; 340  : 
; 341  : 	e10 = m.e10;

	movss	DWORD PTR [eax+12], xmm4

; 342  : 	e11 = m.e11;

	movss	DWORD PTR [eax+16], xmm5

; 343  : 	e12 = m.e12;
; 344  : 
; 345  : 	e20 = m.e20;

	movss	DWORD PTR [eax+24], xmm1

; 346  : 	e21 = m.e21;

	movss	DWORD PTR [eax+28], xmm2
$LN28@MatrixFace:

; 347  : 	e22 = m.e22;

	mov	DWORD PTR [eax+32], 1065353216		; 3f800000H
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+8], 0
	pop	esi

; 2781 : 	m.e22 = 1.0f;
; 2782 : 
; 2783 : 	return m;
; 2784 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MatrixFaceTarget2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@0_N1@Z ENDP ; gen::MatrixFaceTarget2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MatrixFaceDirection@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@0_N@Z
_TEXT	SEGMENT
$T1 = -56						; size = 12
$T2 = -56						; size = 12
$T3 = -56						; size = 12
$T4 = -44						; size = 12
$T5 = -44						; size = 12
$T6 = -44						; size = 12
$T7 = -44						; size = 12
_axisX$ = -32						; size = 12
_axisZ$ = -20						; size = 12
_axisY$3$ = -8						; size = 4
_axisZ$1$ = -8						; size = 4
_axisY$2$ = -4						; size = 4
_axisZ$2$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_direction$ = 12					; size = 4
_up$ = 16						; size = 4
_axisZ$3$ = 20						; size = 4
_bLH$ = 20						; size = 1
?MatrixFaceDirection@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@0_N@Z PROC ; gen::MatrixFaceDirection, COMDAT

; 2663 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2664 : 	CVector3 axisX, axisY, axisZ;
; 2665 : 	if (bLH)

	cmp	BYTE PTR _bLH$[ebp], 0
	je	$LN6@MatrixFace

; 2667 : 		axisZ = Normalise( direction );

	push	DWORD PTR _direction$[ebp]
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	lea	ecx, DWORD PTR _axisZ$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2667 : 		axisZ = Normalise( direction );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	cmp	ecx, eax
	je	SHORT $LN97@MatrixFace

; 101  : 		{
; 102  : 			x = v.x;

	movss	xmm4, DWORD PTR [eax]

; 103  : 			y = v.y;

	movss	xmm5, DWORD PTR [eax+4]

; 104  : 			z = v.z;

	movss	xmm6, DWORD PTR [eax+8]
	jmp	SHORT $LN101@MatrixFace
$LN97@MatrixFace:
	movss	xmm6, DWORD PTR _axisZ$[ebp+8]
	movss	xmm5, DWORD PTR _axisZ$[ebp+4]
	movss	xmm4, DWORD PTR _axisZ$[ebp]
$LN101@MatrixFace:

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm1, xmm5

; 104  : 			z = v.z;

	movss	DWORD PTR _axisZ$1$[ebp], xmm4

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm0, xmm4
	mulss	xmm1, xmm5
	mulss	xmm0, xmm4

; 104  : 			z = v.z;

	movss	DWORD PTR _axisZ$2$[ebp], xmm5
	movss	DWORD PTR _axisZ$3$[ebp], xmm6

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2668 : 		if (axisZ.IsZero()) return CMatrix3x3::kIdentity;

	jbe	SHORT $LN5@MatrixFace
$LN104@MatrixFace:

; 117  : 	}
; 118  : 	else
; 119  : 	{
; 120  : 		e00 = v0.x;
; 121  : 		e10 = v0.y;
; 122  : 		e20 = v0.z;
; 123  : 
; 124  : 		e01 = v1.x;
; 125  : 		e11 = v1.y;
; 126  : 		e21 = v1.z;
; 127  : 
; 128  : 		e02 = v2.x;
; 129  : 		e12 = v2.y;
; 130  : 		e22 = v2.z;
; 131  : 	}
; 132  : }
; 133  : 
; 134  : // Construct by row or column using CVector2's, remaining elements taken from identity matrix
; 135  : // May specify if setting rows or columns
; 136  : CMatrix3x3::CMatrix3x3
; 137  : (
; 138  : 	const CVector2& v0,
; 139  : 	const CVector2& v1,
; 140  : 	const CVector2& v2,
; 141  : 	const bool      bRows /*= true*/
; 142  : )
; 143  : {
; 144  : 	if (bRows)
; 145  : 	{
; 146  : 		e00 = v0.x;
; 147  : 		e01 = v0.y;
; 148  : 		e02 = 0.0f;
; 149  : 
; 150  : 		e10 = v1.x;
; 151  : 		e11 = v1.y;
; 152  : 		e12 = 0.0f;
; 153  : 
; 154  : 		e20 = v2.x;
; 155  : 		e21 = v2.y;
; 156  : 		e22 = 0.0f;
; 157  : 	}
; 158  : 	else
; 159  : 	{
; 160  : 		e00 = v0.x;
; 161  : 		e10 = v0.y;
; 162  : 
; 163  : 		e01 = v1.x;
; 164  : 		e11 = v1.y;
; 165  : 
; 166  : 		e02 = v2.x;
; 167  : 		e12 = v2.y;
; 168  : 
; 169  : 		e20 = 0.0f;
; 170  : 		e21 = 0.0f;
; 171  : 		e22 = 1.0f;
; 172  : 	}
; 173  : }
; 174  :  
; 175  : 
; 176  : // Construct matrix transformation from euler angles and optional scaling. Matrix is effectively
; 177  : // built in this order: M = Scale*Rotation
; 178  : CMatrix3x3::CMatrix3x3
; 179  : (
; 180  : 	const CVector3&      angles,
; 181  : 	const ERotationOrder eRotOrder /*= kZXY*/,
; 182  : 	const CVector3&      scale /*= CVector3::kOne*/
; 183  : )
; 184  : {
; 185  : 	// First build rotation matrix
; 186  : 	MakeRotation( angles, eRotOrder );
; 187  : 
; 188  : 	// Scale matrix
; 189  : 	e00 *= scale.x;
; 190  : 	e01 *= scale.x;
; 191  : 	e02 *= scale.x;
; 192  : 
; 193  : 	e10 *= scale.y;
; 194  : 	e11 *= scale.y;
; 195  : 	e12 *= scale.y;
; 196  : 
; 197  : 	e20 *= scale.z;
; 198  : 	e21 *= scale.z;
; 199  : 	e22 *= scale.z;
; 200  : }
; 201  : 
; 202  : // Construct matrix transformation from quaternion and optional scaling. Matrix is effectively
; 203  : // built in this order: M = Scale*Rotation
; 204  : CMatrix3x3::CMatrix3x3
; 205  : (
; 206  : 	const CQuaternion& quat,
; 207  : 	const CVector3&    scale /*= CVector3::kOne*/
; 208  : )
; 209  : {
; 210  : 	// Efficiently precalculate some values from the quaternion
; 211  : 	TFloat32 xx = 2*quat.x;
; 212  : 	TFloat32 yy = 2*quat.y;
; 213  : 	TFloat32 zz = 2*quat.z;
; 214  : 	TFloat32 xy = xx*quat.y;
; 215  : 	TFloat32 yz = yy*quat.z;
; 216  : 	TFloat32 zx = zz*quat.x;
; 217  : 	TFloat32 wx = quat.w*xx;
; 218  : 	TFloat32 wy = quat.w*yy;
; 219  : 	TFloat32 wz = quat.w*zz;
; 220  : 	xx *= quat.x;
; 221  : 	yy *= quat.y;
; 222  : 	zz *= quat.z;
; 223  : 
; 224  : 	// Fill upper 3x3 matrix, combining scaling with rotation values from the quaternion
; 225  : 	e00 = scale.x * (1 - yy - zz);
; 226  : 	e01 = scale.x * (xy + wz);
; 227  : 	e02 = scale.x * (zx - wy);
; 228  : 
; 229  : 	e10 = scale.y * (xy - wz);
; 230  : 	e11 = scale.y * (1 - xx - zz);
; 231  : 	e12 = scale.y * (yz + wx);
; 232  : 
; 233  : 	e20 = scale.z * (zx + wy);
; 234  : 	e21 = scale.z * (yz - wx);
; 235  : 	e22 = scale.z * (1 - xx - yy);
; 236  : }
; 237  : 
; 238  : // Construct matrix transformation from axis/angle of rotation and optional scaling. Matrix is
; 239  : // effectively built in this order: M = Scale*Rotation
; 240  : CMatrix3x3::CMatrix3x3
; 241  : (
; 242  : 	const CVector3& axis,
; 243  : 	const TFloat32  fAngle,
; 244  : 	const CVector3& scale /*= CVector3::kOne*/
; 245  : )
; 246  : {
; 247  : 	// First build rotation matrix
; 248  : 	MakeRotation( axis, fAngle );
; 249  : 
; 250  : 	// Scale matrix
; 251  : 	e00 *= scale.x;
; 252  : 	e01 *= scale.x;
; 253  : 	e02 *= scale.x;
; 254  : 
; 255  : 	e10 *= scale.y;
; 256  : 	e11 *= scale.y;
; 257  : 	e12 *= scale.y;
; 258  : 
; 259  : 	e20 *= scale.z;
; 260  : 	e21 *= scale.z;
; 261  : 	e22 *= scale.z;
; 262  : }
; 263  : 
; 264  : 
; 265  : // Construct 2D affine transformation from position (translation) only
; 266  : CMatrix3x3::CMatrix3x3( const CVector2& position )
; 267  : {
; 268  : 	// Take most elements from identity
; 269  : 	e00 = 1.0f;
; 270  : 	e01 = 0.0f;
; 271  : 	e02 = 0.0f;
; 272  : 
; 273  : 	e10 = 0.0f;
; 274  : 	e11 = 1.0f;
; 275  : 	e12 = 0.0f;
; 276  : 
; 277  : 	// Put position (translation) in bottom row
; 278  : 	e20 = position.x;
; 279  : 	e21 = position.y;
; 280  : 	e22 = 1.0f;
; 281  : }
; 282  : 
; 283  : // Construct 2D affine transformation from position, rotation angle and optional scaling, with 
; 284  : // remaining elements taken from the identity matrix. Matrix is effectively built in this
; 285  : // order: M = Scale*Rotation*Translation
; 286  : CMatrix3x3::CMatrix3x3
; 287  : (
; 288  : 	const CVector2& position,
; 289  : 	const TFloat32  fAngle,
; 290  : 	const CVector2& scale /*= CVector2::kOne*/
; 291  : )
; 292  : {
; 293  : 	TFloat32 s, c;
; 294  : 	SinCos( fAngle, &s, &c );
; 295  : 
; 296  : 	e00 = c * scale.x;
; 297  : 	e01 = s * scale.x;
; 298  : 	e02 = 0.0f;
; 299  : 
; 300  : 	e10 = -s * scale.y;
; 301  : 	e11 = c * scale.y;
; 302  : 	e12 = 0.0f;
; 303  : 
; 304  : 	e20 = position.x;
; 305  : 	e21 = position.y;
; 306  : 	e22 = 1.0f;
; 307  : }
; 308  : 
; 309  : 
; 310  : // Construct from a CMatrix2x2 and optional 2D position, with remaining elements taken from
; 311  : // the identity matrix
; 312  : CMatrix3x3::CMatrix3x3
; 313  : (
; 314  : 	const CMatrix2x2& m,
; 315  : 	const CVector2&   position /*= CVector2::kOrigin*/
; 316  : )
; 317  : {
; 318  : 	// Copy 2x2 elements, adding extra identity elements
; 319  : 	e00 = m.e00;
; 320  : 	e01 = m.e01;
; 321  : 	e02 = 0.0f;
; 322  : 
; 323  : 	e10 = m.e10;
; 324  : 	e11 = m.e11;
; 325  : 	e12 = 0.0f;
; 326  : 
; 327  : 	// Put position (translation) in bottom row
; 328  : 	e20 = position.x;
; 329  : 	e21 = position.y;
; 330  : 	e22 = 1.0f;
; 331  : }
; 332  : 
; 333  : 
; 334  : // Copy constructor
; 335  : CMatrix3x3::CMatrix3x3( const CMatrix3x3& m )
; 336  : {
; 337  : 	e00 = m.e00;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movups	xmm0, XMMWORD PTR ?kIdentity@CMatrix3x3@gen@@2V12@B
	movups	XMMWORD PTR [eax], xmm0

; 338  : 	e01 = m.e01;
; 339  : 	e02 = m.e02;
; 340  : 
; 341  : 	e10 = m.e10;
; 342  : 	e11 = m.e11;

	movups	xmm0, XMMWORD PTR ?kIdentity@CMatrix3x3@gen@@2V12@B+16
	movups	XMMWORD PTR [eax+16], xmm0

; 343  : 	e12 = m.e12;
; 344  : 
; 345  : 	e20 = m.e20;
; 346  : 	e21 = m.e21;
; 347  : 	e22 = m.e22;

	movss	xmm0, DWORD PTR ?kIdentity@CMatrix3x3@gen@@2V12@B+32
	movss	DWORD PTR [eax+32], xmm0

; 2679 : 		axisY = Cross( axisX, axisZ ); // Will already be normalised
; 2680 : 	}
; 2681 : 	
; 2682 : 	return CMatrix3x3( axisX, axisY, axisZ );
; 2683 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@MatrixFace:
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	mov	eax, DWORD PTR _up$[ebp]
	movss	xmm3, DWORD PTR [eax+4]
	movss	xmm2, DWORD PTR [eax+8]
	movaps	xmm1, xmm3
	movaps	xmm0, xmm2
	mulss	xmm1, xmm6
	mulss	xmm0, xmm5
	mulss	xmm2, xmm4
	subss	xmm1, xmm0
	mulss	xmm3, xmm4

; 51   : 	{}

	movss	DWORD PTR $T6[ebp], xmm1

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	xmm1, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2669 : 		axisX = Normalise( Cross( up, axisZ ) );

	lea	eax, DWORD PTR $T6[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movaps	xmm0, xmm1
	mulss	xmm1, xmm5
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2669 : 		axisX = Normalise( Cross( up, axisZ ) );

	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	mulss	xmm0, xmm6
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2669 : 		axisX = Normalise( Cross( up, axisZ ) );

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	subss	xmm1, xmm3
	subss	xmm2, xmm0

; 51   : 	{}

	movss	DWORD PTR $T6[ebp+8], xmm1
	movss	DWORD PTR $T6[ebp+4], xmm2
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2669 : 		axisX = Normalise( Cross( up, axisZ ) );

	call	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	lea	ecx, DWORD PTR _axisX$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2669 : 		axisX = Normalise( Cross( up, axisZ ) );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	cmp	ecx, eax
	je	SHORT $LN98@MatrixFace

; 101  : 		{
; 102  : 			x = v.x;

	movss	xmm4, DWORD PTR [eax]

; 103  : 			y = v.y;

	movss	xmm5, DWORD PTR [eax+4]

; 104  : 			z = v.z;

	movss	xmm6, DWORD PTR [eax+8]
	jmp	SHORT $LN32@MatrixFace
$LN98@MatrixFace:
	movss	xmm6, DWORD PTR _axisX$[ebp+8]
	movss	xmm5, DWORD PTR _axisX$[ebp+4]
	movss	xmm4, DWORD PTR _axisX$[ebp]
$LN32@MatrixFace:

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm1, xmm5
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2670 : 		if (axisX.IsZero()) return CMatrix3x3::kIdentity;

	ja	$LN104@MatrixFace
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	xmm2, DWORD PTR _axisZ$2$[ebp]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _axisZ$3$[ebp]
	movaps	xmm7, xmm6
	movss	xmm1, DWORD PTR _axisZ$1$[ebp]
	mulss	xmm7, xmm2
	subss	xmm7, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _axisZ$3$[ebp]
	movss	DWORD PTR _axisY$2$[ebp], xmm0
	movaps	xmm0, xmm6
	movss	xmm3, DWORD PTR _axisY$2$[ebp]
	mulss	xmm0, xmm1
	subss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm2
	movss	DWORD PTR _axisY$2$[ebp], xmm3
	movaps	xmm3, xmm5
	mulss	xmm3, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2673 : 	else

	jmp	$LN102@MatrixFace
$LN6@MatrixFace:
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	mov	eax, DWORD PTR _direction$[ebp]
	movss	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm0, DWORD PTR [eax]
	xorps	xmm0, xmm1

; 51   : 	{}

	movss	DWORD PTR $T5[ebp], xmm0

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	movss	xmm0, DWORD PTR [eax+4]
	xorps	xmm0, xmm1

; 51   : 	{}

	movss	DWORD PTR $T5[ebp+4], xmm0

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	movss	xmm0, DWORD PTR [eax+8]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2675 : 		axisZ = Normalise( -direction );

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	xorps	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2675 : 		axisZ = Normalise( -direction );

	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 51   : 	{}

	movss	DWORD PTR $T5[ebp+8], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2675 : 		axisZ = Normalise( -direction );

	call	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	lea	ecx, DWORD PTR _axisZ$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2675 : 		axisZ = Normalise( -direction );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	cmp	ecx, eax
	je	SHORT $LN99@MatrixFace

; 101  : 		{
; 102  : 			x = v.x;

	movss	xmm4, DWORD PTR [eax]

; 103  : 			y = v.y;

	movss	xmm5, DWORD PTR [eax+4]

; 104  : 			z = v.z;

	movss	xmm6, DWORD PTR [eax+8]
	jmp	SHORT $LN103@MatrixFace
$LN99@MatrixFace:
	movss	xmm6, DWORD PTR _axisZ$[ebp+8]
	movss	xmm5, DWORD PTR _axisZ$[ebp+4]
	movss	xmm4, DWORD PTR _axisZ$[ebp]
$LN103@MatrixFace:

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm1, xmm5

; 104  : 			z = v.z;

	movss	DWORD PTR _axisZ$1$[ebp], xmm4

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm0, xmm4
	mulss	xmm1, xmm5
	mulss	xmm0, xmm4

; 104  : 			z = v.z;

	movss	DWORD PTR _axisZ$2$[ebp], xmm5
	movss	DWORD PTR _axisZ$3$[ebp], xmm6

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2676 : 		if (axisZ.IsZero()) return CMatrix3x3::kIdentity;

	ja	$LN104@MatrixFace
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	mov	eax, DWORD PTR _up$[ebp]
	movss	xmm2, DWORD PTR [eax+8]
	movss	xmm3, DWORD PTR [eax+4]
	movaps	xmm1, xmm2
	movaps	xmm0, xmm3
	mulss	xmm1, xmm5
	mulss	xmm0, xmm6
	mulss	xmm2, xmm4
	subss	xmm1, xmm0
	mulss	xmm3, xmm4

; 51   : 	{}

	movss	DWORD PTR $T4[ebp], xmm1

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	xmm1, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2677 : 		axisX = Normalise( Cross( axisZ, up ) );

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movaps	xmm0, xmm1
	mulss	xmm1, xmm5
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2677 : 		axisX = Normalise( Cross( axisZ, up ) );

	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	mulss	xmm0, xmm6
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2677 : 		axisX = Normalise( Cross( axisZ, up ) );

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	subss	xmm3, xmm1
	subss	xmm0, xmm2

; 51   : 	{}

	movss	DWORD PTR $T4[ebp+8], xmm3
	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2677 : 		axisX = Normalise( Cross( axisZ, up ) );

	call	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	lea	ecx, DWORD PTR _axisX$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2677 : 		axisX = Normalise( Cross( axisZ, up ) );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	cmp	ecx, eax
	je	SHORT $LN100@MatrixFace

; 101  : 		{
; 102  : 			x = v.x;

	movss	xmm4, DWORD PTR [eax]

; 103  : 			y = v.y;

	movss	xmm5, DWORD PTR [eax+4]

; 104  : 			z = v.z;

	movss	xmm6, DWORD PTR [eax+8]
	jmp	SHORT $LN73@MatrixFace
$LN100@MatrixFace:
	movss	xmm6, DWORD PTR _axisX$[ebp+8]
	movss	xmm5, DWORD PTR _axisX$[ebp+4]
	movss	xmm4, DWORD PTR _axisX$[ebp]
$LN73@MatrixFace:

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm1, xmm5
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2678 : 		if (axisX.IsZero()) return CMatrix3x3::kIdentity;

	ja	$LN104@MatrixFace
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	xmm2, DWORD PTR _axisZ$2$[ebp]
	movaps	xmm0, xmm6
	movss	xmm1, DWORD PTR _axisZ$1$[ebp]
	movaps	xmm7, xmm5
	mulss	xmm7, DWORD PTR _axisZ$3$[ebp]
	mulss	xmm0, xmm2
	subss	xmm7, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm1
	movss	DWORD PTR _axisY$2$[ebp], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _axisZ$3$[ebp]
	movss	xmm3, DWORD PTR _axisY$2$[ebp]
	subss	xmm3, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm1
	movss	DWORD PTR _axisY$2$[ebp], xmm3
	movaps	xmm3, xmm4
	mulss	xmm3, xmm2
$LN102@MatrixFace:
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 106  : 		e00 = v0.x;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	subss	xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 111  : 		e11 = v1.y;

	movss	xmm0, DWORD PTR _axisY$2$[ebp]
	movss	DWORD PTR [eax+16], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	DWORD PTR _axisY$3$[ebp], xmm3
	movss	xmm3, DWORD PTR _axisZ$3$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 112  : 		e12 = v1.z;

	movss	xmm0, DWORD PTR _axisY$3$[ebp]
	movss	DWORD PTR [eax], xmm4
	movss	DWORD PTR [eax+4], xmm5
	movss	DWORD PTR [eax+8], xmm6
	movss	DWORD PTR [eax+12], xmm7
	movss	DWORD PTR [eax+20], xmm0

; 113  : 
; 114  : 		e20 = v2.x;

	movss	DWORD PTR [eax+24], xmm1

; 115  : 		e21 = v2.y;

	movss	DWORD PTR [eax+28], xmm2

; 116  : 		e22 = v2.z;

	movss	DWORD PTR [eax+32], xmm3

; 2679 : 		axisY = Cross( axisX, axisZ ); // Will already be normalised
; 2680 : 	}
; 2681 : 	
; 2682 : 	return CMatrix3x3( axisX, axisY, axisZ );
; 2683 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MatrixFaceDirection@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@0_N@Z ENDP ; gen::MatrixFaceDirection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MatrixScaling2D@gen@@YA?AVCMatrix3x3@1@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_fScale$ = 12						; size = 4
?MatrixScaling2D@gen@@YA?AVCMatrix3x3@1@M@Z PROC	; gen::MatrixScaling2D, COMDAT

; 2600 : {

	push	ebp
	mov	ebp, esp

; 2601 : 	CMatrix3x3 m;
; 2602 : 
; 2603 : 	m.e00 = fScale;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	xmm1, DWORD PTR _fScale$[ebp]
	movss	DWORD PTR [eax], xmm1

; 2604 : 	m.e01 = 0.0f;

	mov	DWORD PTR [eax+4], 0

; 2605 : 	m.e02 = 0.0f;

	mov	DWORD PTR [eax+8], 0

; 2606 : 
; 2607 : 	m.e10 = 0.0f;

	mov	DWORD PTR [eax+12], 0

; 2608 : 	m.e11 = fScale;

	movss	DWORD PTR [eax+16], xmm1

; 2609 : 	m.e12 = 0.0f;

	mov	DWORD PTR [eax+20], 0

; 2610 : 
; 2611 : 	m.e20 = 0.0f;

	mov	DWORD PTR [eax+24], 0

; 2612 : 	m.e21 = 0.0f;

	mov	DWORD PTR [eax+28], 0

; 2613 : 	m.e22 = 1.0f;

	mov	DWORD PTR [eax+32], 1065353216		; 3f800000H

; 2614 : 
; 2615 : 	return m;
; 2616 : }

	pop	ebp
	ret	0
?MatrixScaling2D@gen@@YA?AVCMatrix3x3@1@M@Z ENDP	; gen::MatrixScaling2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MatrixScaling2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_scale$ = 12						; size = 4
?MatrixScaling2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@@Z PROC ; gen::MatrixScaling2D, COMDAT

; 2580 : {

	push	ebp
	mov	ebp, esp

; 2581 : 	CMatrix3x3 m;
; 2582 : 
; 2583 : 	m.e00 = scale.x;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _scale$[ebp]

; 2584 : 	m.e01 = 0.0f;

	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR [ecx]

; 2585 : 	m.e02 = 0.0f;
; 2586 : 
; 2587 : 	m.e10 = 0.0f;
; 2588 : 	m.e11 = scale.y;

	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 2589 : 	m.e12 = 0.0f;
; 2590 : 
; 2591 : 	m.e20 = 0.0f;
; 2592 : 	m.e21 = 0.0f;
; 2593 : 	m.e22 = 1.0f;
; 2594 : 
; 2595 : 	return m;

	mov	eax, edx
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], ecx
	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+24], 0
	mov	DWORD PTR [edx+28], 0
	mov	DWORD PTR [edx+32], 1065353216		; 3f800000H

; 2596 : }

	pop	ebp
	ret	0
?MatrixScaling2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@@Z ENDP ; gen::MatrixScaling2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MatrixRotation2D@gen@@YA?AVCMatrix3x3@1@M@Z
_TEXT	SEGMENT
_s$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fAngle$ = 12						; size = 4
?MatrixRotation2D@gen@@YA?AVCMatrix3x3@1@M@Z PROC	; gen::MatrixRotation2D, COMDAT

; 2556 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _fAngle$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _s$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _fAngle$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2562 : 	m.e00 = c;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm1, xmm1

; 2563 : 	m.e01 = s;

	movss	xmm2, DWORD PTR _s$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2564 : 	m.e02 = 0.0f;

	mov	DWORD PTR [eax+8], 0

; 2565 : 
; 2566 : 	m.e10 = -s;
; 2567 : 	m.e11 = c;
; 2568 : 	m.e12 = 0.0f;

	mov	DWORD PTR [eax+20], 0

; 2569 : 
; 2570 : 	m.e20 = 0.0f;

	mov	DWORD PTR [eax+24], 0
	movss	DWORD PTR [eax+4], xmm2
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [eax], xmm1
	movss	DWORD PTR [eax+12], xmm2
	movss	DWORD PTR [eax+16], xmm1

; 2571 : 	m.e21 = 0.0f;

	mov	DWORD PTR [eax+28], 0

; 2572 : 	m.e22 = 1.0f;

	mov	DWORD PTR [eax+32], 1065353216		; 3f800000H

; 2573 : 
; 2574 : 	return m;
; 2575 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MatrixRotation2D@gen@@YA?AVCMatrix3x3@1@M@Z ENDP	; gen::MatrixRotation2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MatrixTranslation2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_translate$ = 12					; size = 4
?MatrixTranslation2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@@Z PROC ; gen::MatrixTranslation2D, COMDAT

; 2535 : {

	push	ebp
	mov	ebp, esp

; 2536 : 	CMatrix3x3 m;
; 2537 : 
; 2538 : 	m.e00 = 1.0f;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2539 : 	m.e01 = 0.0f;
; 2540 : 	m.e02 = 0.0f;
; 2541 : 
; 2542 : 	m.e10 = 0.0f;
; 2543 : 	m.e11 = 1.0f;
; 2544 : 	m.e12 = 0.0f;
; 2545 : 
; 2546 : 	m.e20 = translate.x;

	mov	edx, DWORD PTR _translate$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax+24], ecx

; 2547 : 	m.e21 = translate.y;

	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+16], 1065353216		; 3f800000H
	mov	DWORD PTR [eax+20], 0
	mov	DWORD PTR [eax+28], ecx

; 2548 : 	m.e22 = 1.0f;

	mov	DWORD PTR [eax+32], 1065353216		; 3f800000H

; 2549 : 
; 2550 : 	return m;
; 2551 : }

	pop	ebp
	ret	0
?MatrixTranslation2D@gen@@YA?AVCMatrix3x3@1@ABVCVector2@1@@Z ENDP ; gen::MatrixTranslation2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Matrix3x3Scaling@gen@@YA?AVCMatrix3x3@1@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_fScale$ = 12						; size = 4
?Matrix3x3Scaling@gen@@YA?AVCMatrix3x3@1@M@Z PROC	; gen::Matrix3x3Scaling, COMDAT

; 2435 : {

	push	ebp
	mov	ebp, esp

; 2436 : 	CMatrix3x3 m;
; 2437 : 
; 2438 : 	m.e00 = fScale;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	xmm1, DWORD PTR _fScale$[ebp]
	movss	DWORD PTR [eax], xmm1

; 2439 : 	m.e01 = 0.0f;

	mov	DWORD PTR [eax+4], 0

; 2440 : 	m.e02 = 0.0f;

	mov	DWORD PTR [eax+8], 0

; 2441 : 
; 2442 : 	m.e10 = 0.0f;

	mov	DWORD PTR [eax+12], 0

; 2443 : 	m.e11 = fScale;

	movss	DWORD PTR [eax+16], xmm1

; 2444 : 	m.e12 = 0.0f;

	mov	DWORD PTR [eax+20], 0

; 2445 : 
; 2446 : 	m.e20 = 0.0f;

	mov	DWORD PTR [eax+24], 0

; 2447 : 	m.e21 = 0.0f;

	mov	DWORD PTR [eax+28], 0

; 2448 : 	m.e22 = fScale;

	movss	DWORD PTR [eax+32], xmm1

; 2449 : 
; 2450 : 	return m;
; 2451 : }

	pop	ebp
	ret	0
?Matrix3x3Scaling@gen@@YA?AVCMatrix3x3@1@M@Z ENDP	; gen::Matrix3x3Scaling
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Matrix3x3Scaling@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_scale$ = 12						; size = 4
?Matrix3x3Scaling@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@@Z PROC ; gen::Matrix3x3Scaling, COMDAT

; 2415 : {

	push	ebp
	mov	ebp, esp

; 2416 : 	CMatrix3x3 m;
; 2417 : 
; 2418 : 	m.e00 = scale.x;

	mov	edx, DWORD PTR _scale$[ebp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 2419 : 	m.e01 = 0.0f;
; 2420 : 	m.e02 = 0.0f;
; 2421 : 
; 2422 : 	m.e10 = 0.0f;
; 2423 : 	m.e11 = scale.y;

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+16], ecx

; 2424 : 	m.e12 = 0.0f;
; 2425 : 
; 2426 : 	m.e20 = 0.0f;
; 2427 : 	m.e21 = 0.0f;
; 2428 : 	m.e22 = scale.z;

	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [esi], eax

; 2429 : 
; 2430 : 	return m;

	mov	eax, esi
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], ecx
	pop	esi

; 2431 : }

	pop	ebp
	ret	0
?Matrix3x3Scaling@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@@Z ENDP ; gen::Matrix3x3Scaling
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z
_TEXT	SEGMENT
_e$2 = -276						; size = 4
_t$1$ = -272						; size = 4
_axisNorm$3 = -268					; size = 12
_c$1$ = -256						; size = 4
_sx$1$ = -252						; size = 4
_s$1$ = -252						; size = 4
$T4 = -248						; size = 76
$T5 = -172						; size = 76
$T6 = -96						; size = 76
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_axis$ = 12						; size = 4
_fAngle$ = 16						; size = 4
?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z PROC ; gen::Matrix3x3Rotation, COMDAT

; 2372 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	movss	xmm0, DWORD PTR _fAngle$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edi, DWORD PTR _axis$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2373 : 	GEN_GUARD;

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _s$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _fAngle$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	xorps	xmm1, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2381 : 	CVector3 axisNorm = Normalise( axis );

	lea	eax, DWORD PTR _axisNorm$3[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2381 : 	CVector3 axisNorm = Normalise( axis );

	push	edi
	push	eax
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	movss	DWORD PTR _c$1$[ebp], xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2379 : 	TFloat32 t = 1.0f - c;

	movss	DWORD PTR _t$1$[ebp], xmm0

; 2381 : 	CVector3 axisNorm = Normalise( axis );

	call	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movss	xmm2, DWORD PTR _axisNorm$3[ebp+4]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2381 : 	CVector3 axisNorm = Normalise( axis );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movss	xmm4, DWORD PTR _axisNorm$3[ebp]
	movaps	xmm1, xmm2
	movss	xmm6, DWORD PTR _axisNorm$3[ebp+8]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2382 : 	GEN_ASSERT( !axisNorm.IsZero(), "Zero length axis" );

	jbe	SHORT $LN1@Matrix3x3R
	push	2382					; 0000094eH
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BB@OPALDBID@Zero?5length?5axis?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN38@Matrix3x3R:
$LN1@Matrix3x3R:

; 2383 : 
; 2384 : 	TFloat32 sx = s * axisNorm.x;

	movss	xmm1, DWORD PTR _s$1$[ebp]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm1

; 2385 : 	TFloat32 sy = s * axisNorm.y;

	movaps	xmm7, xmm2

; 2386 : 	TFloat32 sz = s * axisNorm.z;
; 2387 : 	TFloat32 tx = t * axisNorm.x;  
; 2388 : 	TFloat32 ty = t * axisNorm.y;
; 2389 : 	TFloat32 tz = t * axisNorm.z;
; 2390 : 	TFloat32 txy = ty * axisNorm.x;
; 2391 : 	TFloat32 tyz = tz * axisNorm.y;
; 2392 : 	TFloat32 tzx = tx * axisNorm.z;
; 2393 : 
; 2394 : 	m.e00 = tx * axisNorm.x + c;
; 2395 : 	m.e01 = txy + sz;
; 2396 : 	m.e02 = tzx - sy;
; 2397 : 
; 2398 : 	m.e10 = txy - sz; 
; 2399 : 	m.e11 = ty * axisNorm.y + c;
; 2400 : 	m.e12 = tyz + sx;
; 2401 : 
; 2402 : 	m.e20 = tzx + sy;
; 2403 : 	m.e21 = tyz - sx;
; 2404 : 	m.e22 = tz * axisNorm.z + c;
; 2405 : 
; 2406 : 	return m;

	mov	eax, esi
	mulss	xmm7, xmm1
	movaps	xmm5, xmm6
	mulss	xmm5, xmm1
	movaps	xmm3, xmm2
	movss	xmm1, DWORD PTR _t$1$[ebp]
	movss	DWORD PTR _sx$1$[ebp], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm1
	mulss	xmm3, xmm1
	mulss	xmm6, xmm1
	movaps	xmm1, xmm3
	mulss	xmm3, DWORD PTR _axisNorm$3[ebp+4]
	mulss	xmm1, xmm4
	movaps	xmm4, xmm6
	mulss	xmm4, xmm2
	movaps	xmm2, xmm0
	mulss	xmm0, DWORD PTR _axisNorm$3[ebp]
	mulss	xmm2, DWORD PTR _axisNorm$3[ebp+8]
	addss	xmm0, DWORD PTR _c$1$[ebp]
	mulss	xmm6, DWORD PTR _axisNorm$3[ebp+8]
	addss	xmm3, DWORD PTR _c$1$[ebp]
	addss	xmm6, DWORD PTR _c$1$[ebp]
	movss	DWORD PTR [esi], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, xmm5
	subss	xmm1, xmm5
	movss	DWORD PTR [esi+16], xmm3
	movss	DWORD PTR [esi+32], xmm6
	movss	DWORD PTR [esi+4], xmm0
	movaps	xmm0, xmm2
	subss	xmm0, xmm7
	movss	DWORD PTR [esi+12], xmm1
	addss	xmm2, xmm7
	movss	DWORD PTR [esi+8], xmm0
	movaps	xmm0, xmm4
	addss	xmm0, DWORD PTR _sx$1$[ebp]
	subss	xmm4, DWORD PTR _sx$1$[ebp]
	movss	DWORD PTR [esi+24], xmm2
	movss	DWORD PTR [esi+20], xmm0
	movss	DWORD PTR [esi+28], xmm4

; 2409 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z$0:

; 2407 : 
; 2408 : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BH@KCOELIJE@gen?3?3Matrix3x3Rotation?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	__CxxThrowException@8
$LN39@Matrix3x3R:
__catch$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z$1:
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BH@KCOELIJE@gen?3?3Matrix3x3Rotation?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN40@Matrix3x3R:
$LN37@Matrix3x3R:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@ABVCVector3@1@M@Z ENDP ; gen::Matrix3x3Rotation
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z
_TEXT	SEGMENT
_e$2 = -272						; size = 4
_sZ$1$ = -268						; size = 4
_cY$1$ = -264						; size = 4
_sY$1$ = -260						; size = 4
_sX$1$ = -256						; size = 4
_cX$1$ = -252						; size = 4
$T3 = -248						; size = 76
$T4 = -172						; size = 76
$T5 = -96						; size = 76
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_angles$ = 12						; size = 12
_eRotOrder$ = 24					; size = 4
?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z PROC ; gen::Matrix3x3Rotation, COMDAT

; 2253 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	movss	xmm0, DWORD PTR _angles$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2254 : 	GEN_GUARD;

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sX$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _angles$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cX$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _angles$[ebp+4]

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sY$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _angles$[ebp+4]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cY$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _angles$[ebp+8]

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sZ$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _angles$[ebp+8]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2263 : 	switch (eRotOrder)

	mov	eax, DWORD PTR _eRotOrder$[ebp]
	xorps	xmm6, xmm6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm6, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2263 : 	switch (eRotOrder)

	cmp	eax, 5
	ja	$LN1@Matrix3x3R
	jmp	DWORD PTR $LN61@Matrix3x3R[eax*4]
$LN7@Matrix3x3R:

; 2264 : 	{
; 2265 : 		case kZYX:
; 2266 : 		{
; 2267 : 			m.e00 = cZ * cY;

	movss	xmm4, DWORD PTR _cY$1$[ebp]
	movaps	xmm0, xmm6

; 2268 : 			m.e01 = sZ * cX + cZ * sY * sX;

	movss	xmm5, DWORD PTR _sY$1$[ebp]
	movaps	xmm2, xmm6
	movss	xmm3, DWORD PTR _sZ$1$[ebp]
	movss	xmm7, DWORD PTR _sX$1$[ebp]
	mulss	xmm0, xmm4
	mulss	xmm2, xmm5
	movss	DWORD PTR [esi], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	movaps	xmm1, xmm2

; 2269 : 			m.e02 = sZ * sX + -cZ * sY * cX;
; 2270 : 
; 2271 : 			m.e10 = -sZ * cY;
; 2272 : 			m.e11 = cZ * cX + -sZ * sY * sX;
; 2273 : 			m.e12 = cZ * sX + sZ * sY * cX;
; 2274 : 
; 2275 : 			m.e20 = sY;

	movss	DWORD PTR [esi+24], xmm5
	mulss	xmm2, DWORD PTR _cX$1$[ebp]
	mulss	xmm1, xmm7
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm7
	subss	xmm0, xmm2
	movss	DWORD PTR [esi+4], xmm1
	movaps	xmm1, xmm6
	mulss	xmm6, xmm7
	mulss	xmm1, DWORD PTR _cX$1$[ebp]
	movss	DWORD PTR [esi+8], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm4
	mulss	xmm3, xmm5
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR _cX$1$[ebp]
	mulss	xmm0, xmm7
	addss	xmm3, xmm6
	subss	xmm1, xmm0

; 2276 : 			m.e21 = -cY * sX;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm7
	movss	DWORD PTR [esi+20], xmm3
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+16], xmm1
	movss	DWORD PTR [esi+28], xmm0

; 2277 : 			m.e22 = cY * cX;
; 2278 : 			break;

	jmp	$LN58@Matrix3x3R
$LN6@Matrix3x3R:

; 2279 : 		}
; 2280 : 		case kYZX:
; 2281 : 		{
; 2282 : 			m.e00 = cY * cZ;

	movss	xmm4, DWORD PTR _cY$1$[ebp]
	movaps	xmm0, xmm6

; 2283 : 			m.e01 = cY * sZ * cX + sY * sX;

	movss	xmm3, DWORD PTR _sZ$1$[ebp]
	movss	xmm5, DWORD PTR _sY$1$[ebp]
	movaps	xmm2, xmm3
	movss	xmm7, DWORD PTR _sX$1$[ebp]
	mulss	xmm0, xmm4
	mulss	xmm2, xmm4
	movss	DWORD PTR [esi], xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm7
	movaps	xmm1, xmm2

; 2284 : 			m.e02 = cY * sZ * sX + -sY * cX;

	mulss	xmm2, xmm7
	mulss	xmm1, DWORD PTR _cX$1$[ebp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	subss	xmm2, xmm0
	movss	DWORD PTR [esi+4], xmm1

; 2285 : 
; 2286 : 			m.e10 = -sZ;

	movaps	xmm0, xmm3

; 2287 : 			m.e11 = cZ * cX;
; 2288 : 			m.e12 = cZ * sX;
; 2289 : 
; 2290 : 			m.e20 = sY * cZ;
; 2291 : 			m.e21 = sY * sZ * cX + -cY * sX;

	mulss	xmm3, xmm5
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movaps	xmm0, xmm6
	movss	DWORD PTR [esi+8], xmm2
	movaps	xmm1, xmm3
	movss	xmm2, DWORD PTR _cX$1$[ebp]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	movss	DWORD PTR [esi+16], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm7

; 2292 : 			m.e22 = sY * sZ * sX + cY * cX;

	mulss	xmm3, xmm7
	movss	DWORD PTR [esi+20], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm7
	mulss	xmm4, xmm2
	subss	xmm1, xmm0
	mulss	xmm6, xmm5
	addss	xmm3, xmm4
	movss	DWORD PTR [esi+24], xmm6
	movss	DWORD PTR [esi+28], xmm1
	movss	DWORD PTR [esi+32], xmm3

; 2293 : 			break;

	jmp	$LN8@Matrix3x3R
$LN5@Matrix3x3R:

; 2294 : 		}
; 2295 : 		case kXZY:
; 2296 : 		{
; 2297 : 			m.e00 = cZ * cY;

	movss	xmm5, DWORD PTR _cY$1$[ebp]
	movaps	xmm0, xmm6

; 2298 : 			m.e01 = sZ;
; 2299 : 			m.e02 = -cZ * sY;

	movss	xmm7, DWORD PTR _sY$1$[ebp]
	movss	xmm4, DWORD PTR _sZ$1$[ebp]

; 2300 : 
; 2301 : 			m.e10 = -cX * sZ * cY + sX * sY;

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR _sX$1$[ebp]
	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR _cX$1$[ebp]
	mulss	xmm0, xmm5
	movss	DWORD PTR [esi+4], xmm4

; 2302 : 			m.e11 = cX * cZ;
; 2303 : 			m.e12 = cX * sZ * sY + sX * cY;
; 2304 : 
; 2305 : 			m.e20 = sX * sZ * cY + cX * sY;

	mulss	xmm4, DWORD PTR _sX$1$[ebp]
	movss	DWORD PTR [esi], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm7
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+8], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm5
	mulss	xmm2, xmm7
	subss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR _cX$1$[ebp]

; 2306 : 			m.e21 = -sX * cZ;

	mulss	xmm6, DWORD PTR _sX$1$[ebp]
	movss	DWORD PTR [esi+16], xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _sX$1$[ebp]
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm1
	movaps	xmm1, xmm4
	addss	xmm2, xmm0
	mulss	xmm1, xmm5

; 2307 : 			m.e22 = -sX * sZ * sY + cX * cY;

	mulss	xmm5, DWORD PTR _cX$1$[ebp]
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	mulss	xmm4, xmm7
	addss	xmm1, xmm0
	movss	DWORD PTR [esi+20], xmm2
	movss	DWORD PTR [esi+28], xmm6
	subss	xmm5, xmm4
	movss	DWORD PTR [esi+24], xmm1
	movss	DWORD PTR [esi+32], xmm5

; 2308 : 			break;

	jmp	$LN8@Matrix3x3R
$LN4@Matrix3x3R:

; 2309 : 		}
; 2310 : 		case kZXY:
; 2311 : 		{
; 2312 : 			m.e00 = cZ * cY + sZ * sX * sY;

	movss	xmm3, DWORD PTR _sZ$1$[ebp]
	movaps	xmm0, xmm6
	movss	xmm7, DWORD PTR _sX$1$[ebp]
	movaps	xmm2, xmm3
	movss	xmm5, DWORD PTR _sY$1$[ebp]
	movss	xmm4, DWORD PTR _cY$1$[ebp]
	mulss	xmm2, xmm7
	mulss	xmm0, xmm4
	movaps	xmm1, xmm2

; 2313 : 			m.e01 = sZ * cX;
; 2314 : 			m.e02 = -cZ * sY + sZ * sX * cY;

	mulss	xmm2, xmm4
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	movss	DWORD PTR [esi+4], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm5
	movss	DWORD PTR [esi], xmm1
	subss	xmm2, xmm0

; 2315 : 
; 2316 : 			m.e10 = -sZ * cY + cZ * sX * sY;

	movaps	xmm0, xmm3
	mulss	xmm0, xmm4

; 2317 : 			m.e11 = cZ * cX;
; 2318 : 			m.e12 = sZ * sY + cZ * sX * cY;

	mulss	xmm3, xmm5
	movss	DWORD PTR [esi+8], xmm2
	movaps	xmm2, xmm6
	mulss	xmm2, xmm7

; 2319 : 
; 2320 : 			m.e20 = cX * sY;
; 2321 : 			m.e21 = -sX;

	xorps	xmm7, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+28], xmm7
	movaps	xmm1, xmm2
	mulss	xmm2, xmm4
	mulss	xmm1, xmm5
	addss	xmm2, xmm3
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR _cX$1$[ebp]
	mulss	xmm6, xmm0
	mulss	xmm5, xmm0
	movss	DWORD PTR [esi+12], xmm1
	movss	DWORD PTR [esi+16], xmm6
	movss	DWORD PTR [esi+20], xmm2
	movss	DWORD PTR [esi+24], xmm5

; 2322 : 			m.e22 = cX * cY;

	mulss	xmm4, xmm0

; 2323 : 			break;

	jmp	$LN59@Matrix3x3R
$LN3@Matrix3x3R:

; 2324 : 		}
; 2325 : 		case kYXZ:
; 2326 : 		{
; 2327 : 			m.e00 = cY * cZ + -sY * sX * sZ;

	movss	xmm5, DWORD PTR _sY$1$[ebp]
	movaps	xmm1, xmm6
	movss	xmm7, DWORD PTR _sX$1$[ebp]
	movaps	xmm2, xmm5
	movss	xmm3, DWORD PTR _sZ$1$[ebp]
	movss	xmm4, DWORD PTR _cY$1$[ebp]
	mulss	xmm2, xmm7
	mulss	xmm1, xmm4
	movaps	xmm0, xmm2

; 2328 : 			m.e01 = cY * sZ + sY * sX * cZ;
; 2329 : 			m.e02 = -sY * cX;
; 2330 : 
; 2331 : 			m.e10 = -cX * sZ;
; 2332 : 			m.e11 = cX * cZ;
; 2333 : 			m.e12 = sX;

	movss	DWORD PTR [esi+20], xmm7
	mulss	xmm0, xmm3
	mulss	xmm2, xmm6
	subss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm4
	addss	xmm2, xmm0
	movss	DWORD PTR [esi], xmm1
	movaps	xmm0, xmm5
	movss	DWORD PTR [esi+4], xmm2
	movss	xmm2, DWORD PTR _cX$1$[ebp]
	mulss	xmm0, xmm2
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+8], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm2
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm2

; 2334 : 
; 2335 : 			m.e20 = sY * cZ + cY * sX * sZ;

	movaps	xmm2, xmm4
	mulss	xmm2, xmm7
	movss	DWORD PTR [esi+16], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm5
	movaps	xmm1, xmm2

; 2336 : 			m.e21 = sY * sZ + -cY * sX * cZ;

	mulss	xmm2, xmm6
	mulss	xmm1, xmm3
	mulss	xmm3, xmm5
	subss	xmm3, xmm2
	movss	DWORD PTR [esi+28], xmm3

; 2337 : 			m.e22 = cY * cX;
; 2338 : 			break;

	jmp	$LN60@Matrix3x3R
$LN2@Matrix3x3R:

; 2339 : 		}
; 2340 : 		case kXYZ:
; 2341 : 		{
; 2342 : 			m.e00 = cY * cZ;

	movss	xmm4, DWORD PTR _cY$1$[ebp]
	movaps	xmm0, xmm6

; 2343 : 			m.e01 = cY * sZ;

	movss	xmm3, DWORD PTR _sZ$1$[ebp]

; 2344 : 			m.e02 = -sY;

	movss	xmm5, DWORD PTR _sY$1$[ebp]

; 2345 : 
; 2346 : 			m.e10 = sX * sY * cZ + -cX * sZ;

	movss	xmm7, DWORD PTR _sX$1$[ebp]
	movaps	xmm2, xmm5
	mulss	xmm0, xmm4
	mulss	xmm2, xmm7
	movss	DWORD PTR [esi], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm4
	movaps	xmm1, xmm2

; 2347 : 			m.e11 = sX * sY * sZ + cX * cZ;

	mulss	xmm2, xmm3
	movss	DWORD PTR [esi+4], xmm0
	movaps	xmm0, xmm5
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000

; 2348 : 			m.e12 = sX * cY;
; 2349 : 
; 2350 : 			m.e20 = cX * sY * cZ + sX * sZ;

	mulss	xmm5, DWORD PTR _cX$1$[ebp]
	movss	DWORD PTR [esi+8], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	mulss	xmm1, xmm6
	subss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	movss	DWORD PTR [esi+12], xmm1
	addss	xmm2, xmm0
	movaps	xmm1, xmm5
	movaps	xmm0, xmm4
	mulss	xmm1, xmm6

; 2351 : 			m.e21 = cX * sY * sZ + -sX * cZ;

	mulss	xmm5, xmm3
	mulss	xmm6, xmm7
	mulss	xmm0, xmm7
	subss	xmm5, xmm6
	movss	DWORD PTR [esi+16], xmm2
	movss	DWORD PTR [esi+20], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm7
	movss	DWORD PTR [esi+28], xmm5
$LN60@Matrix3x3R:

; 2348 : 			m.e12 = sX * cY;
; 2349 : 
; 2350 : 			m.e20 = cX * sY * cZ + sX * sZ;

	addss	xmm1, xmm0
	movss	DWORD PTR [esi+24], xmm1
$LN58@Matrix3x3R:

; 2352 : 			m.e22 = cX * cY;

	mulss	xmm4, DWORD PTR _cX$1$[ebp]
$LN59@Matrix3x3R:
	movss	DWORD PTR [esi+32], xmm4
$LN8@Matrix3x3R:

; 2358 : 	}
; 2359 : 
; 2360 : 	return m;

	mov	eax, esi

; 2363 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@Matrix3x3R:

; 2353 : 			break;
; 2354 : 		}
; 2355 : 
; 2356 : 		default:
; 2357 : 			GEN_ERROR( "Invalid parameter" );

	push	2357					; 00000935H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BC@DBAKKFEN@Invalid?5parameter?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN62@Matrix3x3R:
__catch$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z$0:

; 2361 : 
; 2362 : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BH@KCOELIJE@gen?3?3Matrix3x3Rotation?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN63@Matrix3x3R:
__catch$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z$1:
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BH@KCOELIJE@gen?3?3Matrix3x3Rotation?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN64@Matrix3x3R:
$LN57@Matrix3x3R:
	npad	1
$LN61@Matrix3x3R:

; 2363 : }

	DD	$LN2@Matrix3x3R
	DD	$LN5@Matrix3x3R
	DD	$LN6@Matrix3x3R
	DD	$LN3@Matrix3x3R
	DD	$LN4@Matrix3x3R
	DD	$LN7@Matrix3x3R
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Matrix3x3Rotation@gen@@YA?AVCMatrix3x3@1@VCVector3@1@W4ERotationOrder@1@@Z ENDP ; gen::Matrix3x3Rotation
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Matrix3x3RotationZ@gen@@YA?AVCMatrix3x3@1@M@Z
_TEXT	SEGMENT
_sZ$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_z$ = 12						; size = 4
?Matrix3x3RotationZ@gen@@YA?AVCMatrix3x3@1@M@Z PROC	; gen::Matrix3x3RotationZ, COMDAT

; 2225 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sZ$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _z$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2231 : 	m.e00 = cZ;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm1, xmm1

; 2232 : 	m.e01 = sZ;

	movss	xmm2, DWORD PTR _sZ$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2233 : 	m.e02 = 0.0f;

	mov	DWORD PTR [eax+8], 0

; 2234 : 
; 2235 : 	m.e10 = -sZ;
; 2236 : 	m.e11 = cZ;
; 2237 : 	m.e12 = 0.0f;

	mov	DWORD PTR [eax+20], 0

; 2238 : 
; 2239 : 	m.e20 = 0.0f;

	mov	DWORD PTR [eax+24], 0
	movss	DWORD PTR [eax+4], xmm2
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [eax], xmm1
	movss	DWORD PTR [eax+12], xmm2
	movss	DWORD PTR [eax+16], xmm1

; 2240 : 	m.e21 = 0.0f;

	mov	DWORD PTR [eax+28], 0

; 2241 : 	m.e22 = 1.0f;

	mov	DWORD PTR [eax+32], 1065353216		; 3f800000H

; 2242 : 
; 2243 : 	return m;
; 2244 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Matrix3x3RotationZ@gen@@YA?AVCMatrix3x3@1@M@Z ENDP	; gen::Matrix3x3RotationZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Matrix3x3RotationY@gen@@YA?AVCMatrix3x3@1@M@Z
_TEXT	SEGMENT
_sY$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_y$ = 12						; size = 4
?Matrix3x3RotationY@gen@@YA?AVCMatrix3x3@1@M@Z PROC	; gen::Matrix3x3RotationY, COMDAT

; 2202 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sY$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2208 : 	m.e00 = cY;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm1, xmm1

; 2210 : 	m.e02 = -sY;

	movss	xmm2, DWORD PTR _sY$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2209 : 	m.e01 = 0.0f;

	mov	DWORD PTR [eax+4], 0

; 2211 : 
; 2212 : 	m.e10 = 0.0f;

	mov	DWORD PTR [eax+12], 0

; 2213 : 	m.e11 = 1.0f;

	mov	DWORD PTR [eax+16], 1065353216		; 3f800000H
	movaps	xmm0, xmm2

; 2214 : 	m.e12 = 0.0f;

	mov	DWORD PTR [eax+20], 0
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [eax], xmm1
	movss	DWORD PTR [eax+8], xmm0

; 2215 : 
; 2216 : 	m.e20 = sY;

	movss	DWORD PTR [eax+24], xmm2

; 2217 : 	m.e21 = 0.0f;

	mov	DWORD PTR [eax+28], 0

; 2218 : 	m.e22 = cY;

	movss	DWORD PTR [eax+32], xmm1

; 2219 : 
; 2220 : 	return m;
; 2221 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Matrix3x3RotationY@gen@@YA?AVCMatrix3x3@1@M@Z ENDP	; gen::Matrix3x3RotationY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Matrix3x3RotationX@gen@@YA?AVCMatrix3x3@1@M@Z
_TEXT	SEGMENT
_sX$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
?Matrix3x3RotationX@gen@@YA?AVCMatrix3x3@1@M@Z PROC	; gen::Matrix3x3RotationX, COMDAT

; 2179 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sX$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2185 : 	m.e00 = 1.0f;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2185 : 	m.e00 = 1.0f;

	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 2186 : 	m.e01 = 0.0f;

	mov	DWORD PTR [eax+4], 0

; 2187 : 	m.e02 = 0.0f;
; 2188 : 
; 2189 : 	m.e10 = 0.0f;
; 2190 : 	m.e11 = cX;
; 2191 : 	m.e12 = sX;

	movss	xmm0, DWORD PTR _sX$1$[ebp]
	movss	DWORD PTR [eax+20], xmm0

; 2192 : 
; 2193 : 	m.e20 = 0.0f;
; 2194 : 	m.e21 = -sX;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	movss	DWORD PTR [eax+16], xmm1
	mov	DWORD PTR [eax+24], 0
	movss	DWORD PTR [eax+28], xmm0

; 2195 : 	m.e22 = cX;

	movss	DWORD PTR [eax+32], xmm1

; 2196 : 
; 2197 : 	return m;
; 2198 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Matrix3x3RotationX@gen@@YA?AVCMatrix3x3@1@M@Z ENDP	; gen::Matrix3x3RotationX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Matrix3x3Identity@gen@@YA?AVCMatrix3x3@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?Matrix3x3Identity@gen@@YA?AVCMatrix3x3@1@XZ PROC	; gen::Matrix3x3Identity, COMDAT

; 2158 : {

	push	ebp
	mov	ebp, esp

; 2159 : 	CMatrix3x3 m;
; 2160 : 
; 2161 : 	m.e00 = 1.0f;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 2162 : 	m.e01 = 0.0f;

	mov	DWORD PTR [eax+4], 0

; 2163 : 	m.e02 = 0.0f; 

	mov	DWORD PTR [eax+8], 0

; 2164 : 
; 2165 : 	m.e10 = 0.0f;

	mov	DWORD PTR [eax+12], 0

; 2166 : 	m.e11 = 1.0f;

	mov	DWORD PTR [eax+16], 1065353216		; 3f800000H

; 2167 : 	m.e12 = 0.0f;

	mov	DWORD PTR [eax+20], 0

; 2168 : 
; 2169 : 	m.e20 = 0.0f;

	mov	DWORD PTR [eax+24], 0

; 2170 : 	m.e21 = 0.0f;

	mov	DWORD PTR [eax+28], 0

; 2171 : 	m.e22 = 1.0f;

	mov	DWORD PTR [eax+32], 1065353216		; 3f800000H

; 2172 : 
; 2173 : 	return m;
; 2174 : }

	pop	ebp
	ret	0
?Matrix3x3Identity@gen@@YA?AVCMatrix3x3@1@XZ ENDP	; gen::Matrix3x3Identity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
_TEXT	SEGMENT
_e$2 = -256						; size = 4
_det1$1$ = -252						; size = 4
$T3 = -248						; size = 76
$T4 = -172						; size = 76
$T5 = -96						; size = 76
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z PROC		; gen::Inverse, COMDAT

; 1850 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1851 : 	GEN_GUARD;
; 1852 : 
; 1853 : 	CMatrix3x3 mOut;
; 1854 : 
; 1855 : 	// Calculate determinant of upper left 3x3
; 1856 : 	TFloat32 det0 = m.e11*m.e22 - m.e21*m.e12;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, DWORD PTR [eax+28]
	movss	xmm7, DWORD PTR [eax+16]
	mulss	xmm7, DWORD PTR [eax+32]

; 1857 : 	TFloat32 det1 = m.e12*m.e20 - m.e22*m.e10;

	movss	xmm2, DWORD PTR [eax+24]
	movss	xmm6, DWORD PTR [eax+12]

; 1858 : 	TFloat32 det2 = m.e10*m.e21 - m.e20*m.e11;
; 1859 : 	TFloat32 det = m.e00*det0 +m.e01*det1 + m.e02*det2;

	movss	xmm3, DWORD PTR [eax+4]
	subss	xmm7, xmm0
	movaps	xmm0, xmm2
	mulss	xmm2, DWORD PTR [eax+16]
	mulss	xmm0, DWORD PTR [eax+20]
	movss	DWORD PTR _det1$1$[ebp], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax+32]
	movss	xmm4, DWORD PTR _det1$1$[ebp]
	mulss	xmm6, DWORD PTR [eax+28]
	subss	xmm4, xmm0
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm7
	subss	xmm6, xmm2
	mulss	xmm3, xmm4
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, xmm6
	addss	xmm3, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm3
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1860 : 	GEN_ASSERT( !IsZero(det), "Singular matrix" );

	jbe	$LN1@Inverse
	push	1860					; 00000744H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN26@Inverse:
__catch$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$0:

; 1877 : 
; 1878 : 	GEN_ENDGUARD;

	mov	ecx, DWORD PTR _e$2[ebp]
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0N@BLGPECID@gen?3?3Inverse?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN27@Inverse:
__catch$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$1:
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0N@BLGPECID@gen?3?3Inverse?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN28@Inverse:
$LN1@Inverse:

; 1861 : 
; 1862 : 	// Calculate inverse of upper left 3x3
; 1863 : 	TFloat32 invDet = 1.0f / det;

	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm3

; 1864 : 	mOut.e00 = invDet * det0;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm7
	movss	DWORD PTR [ecx], xmm0

; 1865 : 	mOut.e10 = invDet * det1;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm4
	movss	DWORD PTR [ecx+12], xmm0

; 1866 : 	mOut.e20 = invDet * det2;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm6
	movss	DWORD PTR [ecx+24], xmm0

; 1867 : 		  
; 1868 : 	mOut.e01 = invDet * (m.e21*m.e02 - m.e01*m.e22);

	movss	xmm1, DWORD PTR [eax+28]
	mulss	xmm1, DWORD PTR [eax+8]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [eax+32]
	subss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [ecx+4], xmm1

; 1869 : 	mOut.e11 = invDet * (m.e22*m.e00 - m.e02*m.e20);

	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+32]
	movss	xmm0, DWORD PTR [eax+24]
	mulss	xmm0, DWORD PTR [eax+8]
	subss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [ecx+16], xmm1

; 1870 : 	mOut.e21 = invDet * (m.e20*m.e01 - m.e00*m.e21);

	movss	xmm1, DWORD PTR [eax+24]
	mulss	xmm1, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [eax+28]
	mulss	xmm0, DWORD PTR [eax]
	subss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [ecx+28], xmm1

; 1871 : 		  
; 1872 : 	mOut.e02 = invDet * (m.e01*m.e12 - m.e11*m.e02);

	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [eax+20]
	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [eax+16]
	subss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [ecx+8], xmm1

; 1873 : 	mOut.e12 = invDet * (m.e02*m.e10 - m.e12*m.e00);

	movss	xmm1, DWORD PTR [eax+12]
	mulss	xmm1, DWORD PTR [eax+8]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [eax+20]
	subss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [ecx+20], xmm1

; 1874 : 	mOut.e22 = invDet * (m.e00*m.e11 - m.e10*m.e01);

	movss	xmm1, DWORD PTR [eax+16]
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm1, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [eax+4]

; 1875 : 
; 1876 : 	return mOut;

	mov	eax, ecx
	subss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [ecx+32], xmm1

; 1879 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@Inverse:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z ENDP		; gen::Inverse
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
_TEXT	SEGMENT
_e$2 = -252						; size = 4
$T3 = -248						; size = 76
$T4 = -172						; size = 76
$T5 = -96						; size = 76
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z PROC	; gen::InverseAffine2D, COMDAT

; 1812 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1813 : 	GEN_GUARD;
; 1814 : 
; 1815 : 	CMatrix3x3 mOut;
; 1816 : 
; 1817 : 	// Calculate determinant of upper left 2x2
; 1818 : 	TFloat32 det = m.e00*m.e11 - m.e01*m.e10;

	mov	eax, DWORD PTR _m$[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [eax+12]
	movss	xmm3, DWORD PTR [eax+16]
	movss	xmm2, DWORD PTR [eax]
	mulss	xmm2, xmm3
	subss	xmm2, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1819 : 	GEN_ASSERT( !IsZero(det), "Singular matrix" );

	jbe	$LN1@InverseAff
	push	1819					; 0000071bH
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN26@InverseAff:
__catch$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$0:

; 1837 : 
; 1838 : 	GEN_ENDGUARD;

	mov	ecx, DWORD PTR _e$2[ebp]
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BF@GBECBBKC@gen?3?3InverseAffine2D?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN27@InverseAff:
__catch$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$1:
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BF@GBECBBKC@gen?3?3InverseAffine2D?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN28@InverseAff:
$LN1@InverseAff:

; 1820 : 
; 1821 : 	// Calculate inverse of upper left 2x2
; 1822 : 	TFloat32 invDet = 1.0f / det;

	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm2

; 1823 : 	mOut.e00 = invDet * m.e11;

	mulss	xmm3, xmm1
	movss	DWORD PTR [ecx], xmm3

; 1824 : 	mOut.e01 = invDet * m.e01;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, xmm1

; 1825 : 	mOut.e02 = 0.0f;

	mov	DWORD PTR [ecx+8], 0
	movss	DWORD PTR [ecx+4], xmm0

; 1826 : 
; 1827 : 	mOut.e10 = invDet * m.e10;

	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+12], xmm0

; 1828 : 	mOut.e11 = invDet * m.e00;

	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm1

; 1829 : 	mOut.e12 = 0.0f;
; 1830 : 
; 1831 : 	// Transform negative translation by inverted 3x3 to get inverse
; 1832 : 	mOut.e20 = -m.e20*mOut.e00 - m.e21*mOut.e10;

	movss	xmm1, xmm3
	mov	DWORD PTR [ecx+20], 0
	movss	DWORD PTR [ecx+16], xmm0
	mulss	xmm1, DWORD PTR [eax+24]
	movss	xmm0, DWORD PTR [ecx+12]
	mulss	xmm0, DWORD PTR [eax+28]
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm1, xmm0

; 1833 : 	mOut.e21 = -m.e20*mOut.e01 - m.e21*mOut.e11;

	movss	xmm0, DWORD PTR [ecx+16]
	movss	DWORD PTR [ecx+24], xmm1
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, DWORD PTR [eax+24]
	mulss	xmm0, DWORD PTR [eax+28]

; 1834 : 	mOut.e22 = 1.0f;
; 1835 : 
; 1836 : 	return mOut;

	mov	eax, ecx
	mov	DWORD PTR [ecx+32], 1065353216		; 3f800000H
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm1, xmm0
	movss	DWORD PTR [ecx+28], xmm1

; 1839 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@InverseAff:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InverseAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@@Z ENDP	; gen::InverseAffine2D
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
_TEXT	SEGMENT
_e$2 = -252						; size = 4
$T3 = -248						; size = 76
$T4 = -172						; size = 76
$T5 = -96						; size = 76
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z PROC	; gen::InverseRotScale, COMDAT

; 1749 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1751 : 
; 1752 : 	CMatrix3x3 mOut;
; 1753 : 
; 1754 : 	// Get X, Y & Z scaling (squared)
; 1755 : 	TFloat32 scaleSqX = m.e00*m.e00 + m.e01*m.e01 + m.e02*m.e02;

	mov	ecx, DWORD PTR _m$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1750 : 	GEN_GUARD;

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1751 : 
; 1752 : 	CMatrix3x3 mOut;
; 1753 : 
; 1754 : 	// Get X, Y & Z scaling (squared)
; 1755 : 	TFloat32 scaleSqX = m.e00*m.e00 + m.e01*m.e01 + m.e02*m.e02;

	movss	xmm6, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [ecx+4]
	movaps	xmm7, xmm6
	movss	xmm0, DWORD PTR [ecx+8]

; 1756 : 	TFloat32 scaleSqY = m.e10*m.e10 + m.e11*m.e11 + m.e12*m.e12;

	movss	xmm4, DWORD PTR [ecx+12]

; 1757 : 	TFloat32 scaleSqZ = m.e20*m.e20 + m.e21*m.e21 + m.e22*m.e22;

	movss	xmm5, DWORD PTR [ecx+24]
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	mulss	xmm7, xmm6
	mulss	xmm4, xmm4
	addss	xmm7, xmm1
	mulss	xmm5, xmm5
	movss	xmm1, DWORD PTR [ecx+16]
	mulss	xmm1, xmm1
	addss	xmm7, xmm0
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, xmm0
	addss	xmm4, xmm1
	movss	xmm1, DWORD PTR [ecx+28]
	mulss	xmm1, xmm1
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, xmm0
	addss	xmm5, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movsd	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1757 : 	TFloat32 scaleSqZ = m.e20*m.e20 + m.e21*m.e21 + m.e22*m.e22;

	addss	xmm5, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm7
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1760 : 	GEN_ASSERT( !IsZero(scaleSqX) && !IsZero(scaleSqY) && !IsZero(scaleSqZ), "Singular matrix" );

	ja	$LN1@InverseRot
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm4
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1760 : 	GEN_ASSERT( !IsZero(scaleSqX) && !IsZero(scaleSqY) && !IsZero(scaleSqZ), "Singular matrix" );

	ja	$LN1@InverseRot
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm5
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1760 : 	GEN_ASSERT( !IsZero(scaleSqX) && !IsZero(scaleSqY) && !IsZero(scaleSqZ), "Singular matrix" );

	ja	$LN1@InverseRot

; 1761 : 	TFloat32 invScaleX = 1.0f / scaleSqX;

	movss	xmm3, DWORD PTR __real@3f800000
	movaps	xmm2, xmm3

; 1762 : 	TFloat32 invScaleY = 1.0f / scaleSqY;

	movaps	xmm1, xmm3
	divss	xmm2, xmm7
	divss	xmm1, xmm4

; 1763 : 	TFloat32 invScaleZ = 1.0f / scaleSqZ;

	divss	xmm3, xmm5

; 1764 : 
; 1765 : 	// Inverse is just the transpose with scaling inverse factored in
; 1766 : 	mOut.e00 = m.e00 * invScaleX;

	mulss	xmm6, xmm2
	movss	DWORD PTR [eax], xmm6

; 1767 : 	mOut.e01 = m.e10 * invScaleY;

	movss	xmm0, DWORD PTR [ecx+12]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+4], xmm0

; 1768 : 	mOut.e02 = m.e20 * invScaleZ;

	movss	xmm0, DWORD PTR [ecx+24]
	mulss	xmm0, xmm3
	movss	DWORD PTR [eax+8], xmm0

; 1769 : 	
; 1770 : 	mOut.e10 = m.e01 * invScaleX;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [eax+12], xmm0

; 1771 : 	mOut.e11 = m.e11 * invScaleY;

	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+16], xmm0

; 1772 : 	mOut.e12 = m.e21 * invScaleZ;

	movss	xmm0, DWORD PTR [ecx+28]
	mulss	xmm0, xmm3
	movss	DWORD PTR [eax+20], xmm0

; 1773 : 
; 1774 : 	mOut.e20 = m.e02 * invScaleX;

	mulss	xmm2, DWORD PTR [ecx+8]
	movss	DWORD PTR [eax+24], xmm2

; 1775 : 	mOut.e21 = m.e12 * invScaleY;

	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+28], xmm0

; 1776 : 	mOut.e22 = m.e22 * invScaleZ;

	mulss	xmm3, DWORD PTR [ecx+32]
	movss	DWORD PTR [eax+32], xmm3

; 1781 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@InverseRot:

; 1760 : 	GEN_ASSERT( !IsZero(scaleSqX) && !IsZero(scaleSqY) && !IsZero(scaleSqZ), "Singular matrix" );

	push	1760					; 000006e0H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN39@InverseRot:
__catch$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$0:

; 1777 : 
; 1778 : 	return mOut;
; 1779 : 
; 1780 : 	GEN_ENDGUARD;

	mov	ecx, DWORD PTR _e$2[ebp]
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BF@CDKPJIKO@gen?3?3InverseRotScale?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN40@InverseRot:
__catch$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z$1:
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BF@CDKPJIKO@gen?3?3InverseRotScale?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN41@InverseRot:
$LN38@InverseRot:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InverseRotScale@gen@@YA?AVCMatrix3x3@1@ABV21@@Z ENDP	; gen::InverseRotScale
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Transpose@gen@@YA?AVCMatrix3x3@1@ABV21@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
?Transpose@gen@@YA?AVCMatrix3x3@1@ABV21@@Z PROC		; gen::Transpose, COMDAT

; 1689 : {

	push	ebp
	mov	ebp, esp

; 1690 : 	CMatrix3x3 transMat;
; 1691 : 
; 1692 : 	transMat.e00 = m.e00;

	mov	edx, DWORD PTR _m$[ebp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 1693 : 	transMat.e01 = m.e10;
; 1694 : 	transMat.e02 = m.e20;
; 1695 : 
; 1696 : 	transMat.e10 = m.e01;
; 1697 : 	transMat.e11 = m.e11;

	mov	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+16], ecx

; 1698 : 	transMat.e12 = m.e21;

	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+20], ecx

; 1699 : 
; 1700 : 	transMat.e20 = m.e02;

	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [esi+24], ecx

; 1701 : 	transMat.e21 = m.e12;

	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+28], ecx

; 1702 : 	transMat.e22 = m.e22;

	mov	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR [esi+12], eax

; 1703 : 
; 1704 : 	return transMat;

	mov	eax, esi
	mov	DWORD PTR [esi+32], ecx
	pop	esi

; 1705 : }

	pop	ebp
	ret	0
?Transpose@gen@@YA?AVCMatrix3x3@1@ABV21@@Z ENDP		; gen::Transpose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z
_TEXT	SEGMENT
_e$2 = -280						; size = 4
tv254 = -276						; size = 4
$T3 = -272						; size = 76
$T4 = -192						; size = 76
$T5 = -112						; size = 76
__$ArrayPad$ = -28					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
_scale$ = 16						; size = 4
?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z PROC ; gen::Orthogonalise2x2, COMDAT

; 1625 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1626 : 	GEN_GUARD;
; 1627 : 
; 1628 : 	CMatrix3x3 mOut;
; 1629 : 
; 1630 : 	// Normalise first vector
; 1631 : 	TFloat32 origScaleX = m.e00*m.e00 + m.e01*m.e01;

	mov	edi, DWORD PTR _m$[ebx]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebx]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	movss	xmm1, DWORD PTR [edi]
	movss	xmm0, DWORD PTR [edi+4]
	movaps	xmm2, xmm1
	mulss	xmm0, xmm0
	mulss	xmm2, xmm1
	movss	DWORD PTR tv254[ebp], xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1632 : 	GEN_ASSERT( !IsZero(origScaleX), "Singular matrix" );

	jbe	$LN3@Orthogonal
	push	1632					; 00000660H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN34@Orthogonal:
__catch$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z$0:
	mov	ebx, DWORD PTR [ebp-20]

; 1658 : 
; 1659 : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BG@OLNACDHO@gen?3?3Orthogonalise2x2?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN35@Orthogonal:
__catch$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z$1:
	mov	ebx, DWORD PTR [ebp-20]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BG@OLNACDHO@gen?3?3Orthogonalise2x2?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN36@Orthogonal:
$LN3@Orthogonal:
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm2, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1634 : 	mOut.e00 = m.e00 * invOrigScaleX;

	movss	xmm0, DWORD PTR tv254[ebp]
	mulss	xmm0, xmm2
	movss	DWORD PTR [esi], xmm0

; 1635 : 	mOut.e01 = m.e01 * invOrigScaleX;
; 1636 : 
; 1637 : 	// Second vector is simply perpendicular to first, only need to select cw or ccw direction
; 1638 : 	TFloat32 ccwPerpDot = mOut.e00*m.e11 - mOut.e01*m.e10;

	movss	xmm3, xmm0
	mulss	xmm2, DWORD PTR [edi+4]
	movss	DWORD PTR [esi+4], xmm2
	movss	xmm1, DWORD PTR [edi+16]
	movss	xmm0, DWORD PTR [edi+12]
	mulss	xmm1, xmm3
	mulss	xmm0, xmm2
	subss	xmm1, xmm0

; 1639 : 	if (ccwPerpDot >= 0.0f)

	comiss	xmm1, DWORD PTR __real@00000000
	jb	SHORT $LN2@Orthogonal

; 1640 : 	{
; 1641 : 		mOut.e11 = mOut.e00;
; 1642 : 		mOut.e10 = -mOut.e01;

	movss	xmm0, xmm2
	movss	DWORD PTR [esi+16], xmm3
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0

; 1643 : 	}
; 1644 : 	else

	jmp	SHORT $LN1@Orthogonal
$LN2@Orthogonal:

; 1645 : 	{
; 1646 : 		mOut.e11 = -mOut.e00;
; 1647 : 		mOut.e10 = mOut.e01;

	mov	eax, DWORD PTR [esi+4]
	movaps	xmm0, xmm3
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+16], xmm0
	mov	DWORD PTR [esi+12], eax
$LN1@Orthogonal:

; 1648 : 	}
; 1649 : 
; 1650 : 	// Rescale each vector
; 1651 : 	mOut.e00 *= scale.x;

	mov	ecx, DWORD PTR _scale$[ebx]

; 1652 : 	mOut.e01 *= scale.x;
; 1653 : 
; 1654 : 	mOut.e10 *= scale.y;
; 1655 : 	mOut.e11 *= scale.y;
; 1656 : 
; 1657 : 	return mOut;

	mov	eax, esi
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, xmm3
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR [esi+12]
	movss	DWORD PTR [esi+12], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR [esi+16]
	movss	DWORD PTR [esi+16], xmm0

; 1660 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
$LN33@Orthogonal:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Orthogonalise2x2@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector2@1@@Z ENDP ; gen::Orthogonalise2x2
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z
_TEXT	SEGMENT
_e$2 = -364						; size = 4
tv458 = -360						; size = 4
tv459 = -356						; size = 4
tv398 = -356						; size = 4
$T3 = -352						; size = 76
$T4 = -272						; size = 76
$T5 = -192						; size = 76
$T6 = -112						; size = 76
__$ArrayPad$ = -28					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
_scale$ = 16						; size = 4
?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z PROC ; gen::Orthogonalise, COMDAT

; 1511 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1517 : 	TFloat32 origScaleX = m.e00*m.e00 + m.e01*m.e01 + m.e02*m.e02;

	mov	edi, DWORD PTR _m$[ebx]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebx]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	movss	xmm3, DWORD PTR [edi]
	movss	xmm1, DWORD PTR [edi+4]
	movaps	xmm2, xmm3
	movss	xmm0, DWORD PTR [edi+8]
	mulss	xmm2, xmm3
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	movss	DWORD PTR tv398[ebp], xmm3
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm1, DWORD PTR __real@350637bd
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1517 : 	TFloat32 origScaleX = m.e00*m.e00 + m.e01*m.e01 + m.e02*m.e02;

	addss	xmm2, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1518 : 	GEN_ASSERT( !IsZero(origScaleX), "Singular matrix" );

	jbe	SHORT $LN2@Orthogonal
	push	1518					; 000005eeH
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	__CxxThrowException@8
$LN45@Orthogonal:
$LN2@Orthogonal:
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm3, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1520 : 	mOut.e00 = m.e00 * invOrigScaleX;

	movss	xmm0, DWORD PTR tv398[ebp]
	mulss	xmm0, xmm3
	movss	DWORD PTR [esi], xmm0

; 1521 : 	mOut.e01 = m.e01 * invOrigScaleX;

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [edi+4]

; 1522 : 	mOut.e02 = m.e02 * invOrigScaleX;
; 1523 : 
; 1524 : 	// Orthogonalise second vector (y-axis) with first
; 1525 : 	TFloat32 proj10 = m.e10*mOut.e00 + m.e11*mOut.e01 + m.e12*mOut.e02;

	movss	xmm4, DWORD PTR [esi]
	movss	DWORD PTR tv458[ebp], xmm4
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm5, xmm0
	mulss	xmm3, DWORD PTR [edi+8]
	movaps	xmm0, xmm4
	movss	DWORD PTR tv459[ebp], xmm5
	movss	DWORD PTR [esi+8], xmm3
	movss	xmm1, DWORD PTR [edi+12]
	movss	xmm2, DWORD PTR [edi+16]
	mulss	xmm3, DWORD PTR [edi+20]
	mulss	xmm0, xmm1
	mulss	xmm2, xmm5
	addss	xmm2, xmm0

; 1526 : 	mOut.e10 = m.e10 - proj10 * mOut.e00;

	movaps	xmm0, xmm4
	addss	xmm2, xmm3
	mulss	xmm0, xmm2
	subss	xmm1, xmm0
	movss	DWORD PTR [esi+12], xmm1

; 1527 : 	mOut.e11 = m.e11 - proj10 * mOut.e01;

	movaps	xmm1, xmm5
	movss	xmm0, DWORD PTR [edi+16]
	mulss	xmm1, xmm2

; 1528 : 	mOut.e12 = m.e12 - proj10 * mOut.e02;

	mulss	xmm2, DWORD PTR [esi+8]
	subss	xmm0, xmm1
	movss	DWORD PTR [esi+16], xmm0
	movss	xmm1, DWORD PTR [edi+20]
	subss	xmm1, xmm2

; 1529 : 
; 1530 : 	// Normalise second vector
; 1531 : 	TFloat32 origScaleY = mOut.e10*mOut.e10 + mOut.e11*mOut.e11 + mOut.e12*mOut.e12;

	mulss	xmm0, xmm0
	movss	xmm2, DWORD PTR [esi+12]
	mulss	xmm2, xmm2
	movss	DWORD PTR [esi+20], xmm1
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	addss	xmm2, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm1, DWORD PTR __real@350637bd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1532 : 	GEN_ASSERT( !IsZero(origScaleY), "Singular matrix" );

	jbe	$LN1@Orthogonal
	push	1532					; 000005fcH
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN46@Orthogonal:
__catch$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z$0:
	mov	ebx, DWORD PTR [ebp-20]

; 1557 : 
; 1558 : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BD@MGLNMEBA@gen?3?3Orthogonalise?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN47@Orthogonal:
__catch$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z$1:
	mov	ebx, DWORD PTR [ebp-20]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BD@MGLNMEBA@gen?3?3Orthogonalise?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN48@Orthogonal:
$LN1@Orthogonal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm4, DWORD PTR __real@3f800000
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1556 : 	return mOut;

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1544 : 	mOut.e00 *= scale.x;

	mov	ecx, DWORD PTR _scale$[ebx]
	movss	xmm2, DWORD PTR [esi+16]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm4, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1536 : 	mOut.e12 *= invOrigScaleY;

	movss	xmm1, DWORD PTR [esi+20]

; 1537 : 
; 1538 : 	// Get third vector from cross product of first two (result is already normalised)
; 1539 : 	mOut.e20 = mOut.e01*mOut.e12 - mOut.e02*mOut.e11;

	movss	xmm5, DWORD PTR tv459[ebp]
	movss	xmm3, DWORD PTR [esi+12]
	mulss	xmm1, xmm4
	mulss	xmm2, xmm4
	movss	DWORD PTR [esi+20], xmm1
	mulss	xmm1, xmm5
	movaps	xmm0, xmm2
	mulss	xmm3, xmm4
	mulss	xmm0, DWORD PTR [esi+8]

; 1540 : 	mOut.e21 = mOut.e02*mOut.e10 - mOut.e00*mOut.e12;

	movss	xmm4, DWORD PTR tv458[ebp]
	movss	DWORD PTR [esi+12], xmm3
	subss	xmm1, xmm0
	movss	DWORD PTR [esi+16], xmm2
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [esi+20]
	movss	DWORD PTR [esi+24], xmm1
	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR [esi+8]
	subss	xmm1, xmm0

; 1541 : 	mOut.e22 = mOut.e00*mOut.e11 - mOut.e01*mOut.e10;

	movaps	xmm0, xmm3
	mulss	xmm0, xmm5
	movss	DWORD PTR [esi+28], xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, xmm4
	subss	xmm1, xmm0
	movss	DWORD PTR [esi+32], xmm1

; 1544 : 	mOut.e00 *= scale.x;

	mulss	xmm4, DWORD PTR [ecx]
	movss	DWORD PTR [esi], xmm4

; 1545 : 	mOut.e01 *= scale.x;

	mulss	xmm5, DWORD PTR [ecx]
	movss	DWORD PTR [esi+4], xmm5

; 1546 : 	mOut.e02 *= scale.x;

	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [esi+8]
	movss	DWORD PTR [esi+8], xmm0

; 1547 : 
; 1548 : 	mOut.e10 *= scale.y;

	mulss	xmm3, DWORD PTR [ecx+4]

; 1549 : 	mOut.e11 *= scale.y;
; 1550 : 	mOut.e12 *= scale.y;

	movss	xmm0, DWORD PTR [esi+20]
	movss	DWORD PTR [esi+12], xmm3
	mulss	xmm2, DWORD PTR [ecx+4]
	movss	DWORD PTR [esi+16], xmm2
	mulss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esi+20], xmm0

; 1551 : 
; 1552 : 	mOut.e20 *= scale.z;

	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [esi+24]
	movss	DWORD PTR [esi+24], xmm0

; 1553 : 	mOut.e21 *= scale.z;

	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [esi+28]
	movss	DWORD PTR [esi+28], xmm0

; 1554 : 	mOut.e22 *= scale.z;

	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+32], xmm0

; 1559 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
$LN44@Orthogonal:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-364]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Orthogonalise@gen@@YA?AVCMatrix3x3@1@ABV21@ABVCVector3@1@@Z ENDP ; gen::Orthogonalise
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MultiplyAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_m1$ = 12						; size = 4
_m2$ = 16						; size = 4
?MultiplyAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@0@Z PROC	; gen::MultiplyAffine2D, COMDAT

; 3198 : {

	push	ebp
	mov	ebp, esp

; 3199 : 	CMatrix3x3 mOut;
; 3200 : 
; 3201 : 	mOut.e00 = m1.e00*m2.e00 + m1.e01*m2.e10;

	mov	edx, DWORD PTR _m2$[ebp]
	mov	eax, DWORD PTR _m1$[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	movss	xmm7, DWORD PTR [edx+12]
	movss	xmm5, DWORD PTR [edx]
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR [eax+4]
	movaps	xmm1, xmm5

; 3202 : 	mOut.e01 = m1.e00*m2.e01 + m1.e01*m2.e11;
; 3203 : 	mOut.e02 = 0.0f;

	mov	DWORD PTR [ecx+8], 0
	mulss	xmm1, DWORD PTR [eax]

; 3204 : 
; 3205 : 	mOut.e10 = m1.e10*m2.e00 + m1.e11*m2.e10;
; 3206 : 	mOut.e11 = m1.e10*m2.e01 + m1.e11*m2.e11;
; 3207 : 	mOut.e12 = 0.0f;

	mov	DWORD PTR [ecx+20], 0
	movss	xmm6, DWORD PTR [edx+16]
	movss	xmm4, DWORD PTR [edx+4]
	addss	xmm1, xmm0
	movss	xmm3, DWORD PTR [eax+16]
	movss	xmm2, DWORD PTR [eax+12]
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax+4]

; 3208 : 
; 3209 : 	mOut.e20 = m1.e20*m2.e00 + m1.e21*m2.e10 + m2.e20;
; 3210 : 	mOut.e21 = m1.e20*m2.e01 + m1.e21*m2.e11 + m2.e21;
; 3211 : 	mOut.e22 = 1.0f;

	mov	DWORD PTR [ecx+32], 1065353216		; 3f800000H
	movss	DWORD PTR [ecx], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm3, xmm6
	mulss	xmm0, xmm7
	movss	DWORD PTR [ecx+4], xmm1
	movaps	xmm1, xmm2
	mulss	xmm2, xmm4
	mulss	xmm1, xmm5
	addss	xmm2, xmm3
	movss	xmm3, DWORD PTR [eax+28]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm7
	movss	DWORD PTR [ecx+16], xmm2
	movss	xmm2, DWORD PTR [eax+24]

; 3212 : 
; 3213 : 	return mOut;

	mov	eax, ecx
	movss	DWORD PTR [ecx+12], xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, xmm5
	mulss	xmm2, xmm4
	mulss	xmm3, xmm6
	addss	xmm1, xmm0
	addss	xmm2, xmm3
	addss	xmm1, DWORD PTR [edx+24]
	addss	xmm2, DWORD PTR [edx+28]
	movss	DWORD PTR [ecx+24], xmm1
	movss	DWORD PTR [ecx+28], xmm2

; 3214 : }

	pop	ebp
	ret	0
?MultiplyAffine2D@gen@@YA?AVCMatrix3x3@1@ABV21@0@Z ENDP	; gen::MultiplyAffine2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??Dgen@@YA?AVCMatrix3x3@0@ABV10@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_m1$ = 12						; size = 4
_m2$ = 16						; size = 4
??Dgen@@YA?AVCMatrix3x3@0@ABV10@0@Z PROC		; gen::operator*, COMDAT

; 3145 : {

	push	ebp
	mov	ebp, esp

; 3146 : 	CMatrix3x3 mOut;
; 3147 : 
; 3148 : 	mOut.e00 = m1.e00*m2.e00 + m1.e01*m2.e10 + m1.e02*m2.e20;

	mov	eax, DWORD PTR _m2$[ebp]
	mov	ecx, DWORD PTR _m1$[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	movss	xmm1, DWORD PTR [eax]
	movss	xmm4, DWORD PTR [ecx+4]
	movss	xmm2, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, xmm4
	movss	xmm3, DWORD PTR [ecx+8]
	mulss	xmm1, xmm2

; 3149 : 	mOut.e01 = m1.e00*m2.e01 + m1.e01*m2.e11 + m1.e02*m2.e21;
; 3150 : 	mOut.e02 = m1.e00*m2.e02 + m1.e01*m2.e12 + m1.e02*m2.e22;

	movss	xmm7, DWORD PTR [eax+20]
	movss	xmm5, DWORD PTR [eax+8]
	addss	xmm1, xmm0
	movss	xmm6, DWORD PTR [eax+32]
	movss	xmm0, DWORD PTR [eax+24]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+16]
	mulss	xmm0, xmm4
	movss	DWORD PTR [edx], xmm1
	movss	xmm1, DWORD PTR [eax+4]
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+28]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm4

; 3151 : 
; 3152 : 	mOut.e10 = m1.e10*m2.e00 + m1.e11*m2.e10 + m1.e12*m2.e20;

	movss	xmm4, DWORD PTR [ecx+12]
	movss	DWORD PTR [edx+4], xmm1
	movaps	xmm1, xmm5
	mulss	xmm1, xmm2
	movss	xmm2, DWORD PTR [ecx+20]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm3
	movss	xmm3, DWORD PTR [ecx+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [edx+8], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm1, xmm0

; 3153 : 	mOut.e11 = m1.e10*m2.e01 + m1.e11*m2.e11 + m1.e12*m2.e21;

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+16]

; 3154 : 	mOut.e12 = m1.e10*m2.e02 + m1.e11*m2.e12 + m1.e12*m2.e22;

	mulss	xmm3, xmm7
	movss	DWORD PTR [edx+12], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	mulss	xmm4, xmm5
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+28]
	addss	xmm4, xmm3
	mulss	xmm2, xmm6

; 3155 : 
; 3156 : 	mOut.e20 = m1.e20*m2.e00 + m1.e21*m2.e10 + m1.e22*m2.e20;

	movss	xmm3, DWORD PTR [ecx+28]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+12]
	addss	xmm4, xmm2
	movss	xmm2, DWORD PTR [ecx+32]
	movss	DWORD PTR [edx+16], xmm1
	movss	DWORD PTR [edx+20], xmm4
	movss	xmm4, DWORD PTR [ecx+24]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm1, xmm0

; 3157 : 	mOut.e21 = m1.e20*m2.e01 + m1.e21*m2.e11 + m1.e22*m2.e21;

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR [edx+24], xmm1
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+28]

; 3158 : 	mOut.e22 = m1.e20*m2.e02 + m1.e21*m2.e12 + m1.e22*m2.e22;
; 3159 : 
; 3160 : 	return mOut;

	mov	eax, edx
	mulss	xmm4, xmm5
	mulss	xmm3, xmm7
	addss	xmm1, xmm0
	mulss	xmm2, xmm6
	addss	xmm4, xmm3
	movss	DWORD PTR [edx+28], xmm1
	addss	xmm4, xmm2
	movss	DWORD PTR [edx+32], xmm4

; 3161 : }

	pop	ebp
	ret	0
??Dgen@@YA?AVCMatrix3x3@0@ABV10@0@Z ENDP		; gen::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??Dgen@@YA?AVCVector3@0@ABVCMatrix3x3@0@ABV10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
_v$ = 16						; size = 4
??Dgen@@YA?AVCVector3@0@ABVCMatrix3x3@0@ABV10@@Z PROC	; gen::operator*, COMDAT

; 3058 : {

	push	ebp
	mov	ebp, esp

; 3059 :     CVector3 vOut;
; 3060 :     vOut.x = m.e00*v.x + m.e01*v.y + m.e02*v.z;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	movss	xmm4, DWORD PTR [eax+4]
	movss	xmm2, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [eax+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm4
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 3061 :     vOut.y = m.e10*v.x + m.e11*v.y + m.e12*v.z;

	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, xmm4
	movss	DWORD PTR [eax], xmm1
	movss	xmm1, DWORD PTR [ecx+12]
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 3062 :     vOut.z = m.e20*v.x + m.e21*v.y + m.e22*v.z;

	movss	xmm0, DWORD PTR [ecx+28]
	mulss	xmm0, xmm4
	movss	DWORD PTR [eax+4], xmm1
	movss	xmm1, DWORD PTR [ecx+24]
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	movss	DWORD PTR [eax+8], xmm1

; 3063 : 
; 3064 :     return vOut;
; 3065 : }

	pop	ebp
	ret	0
??Dgen@@YA?AVCVector3@0@ABVCMatrix3x3@0@ABV10@@Z ENDP	; gen::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??Dgen@@YA?AVCVector3@0@ABV10@ABVCMatrix3x3@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
_m$ = 16						; size = 4
??Dgen@@YA?AVCVector3@0@ABV10@ABVCMatrix3x3@0@@Z PROC	; gen::operator*, COMDAT

; 3042 : {

	push	ebp
	mov	ebp, esp

; 3043 :     CVector3 vOut;
; 3044 :     vOut.x = v.x*m.e00 + v.y*m.e10 + v.z*m.e20;

	mov	ecx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [ecx+12]
	movss	xmm2, DWORD PTR [eax]
	movss	xmm4, DWORD PTR [eax+4]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [eax+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mulss	xmm1, xmm4
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+24]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 3045 :     vOut.y = v.x*m.e01 + v.y*m.e11 + v.z*m.e21;

	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, xmm4
	movss	DWORD PTR [eax], xmm1
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+28]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 3046 :     vOut.z = v.x*m.e02 + v.y*m.e12 + v.z*m.e22;

	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, xmm4
	movss	DWORD PTR [eax+4], xmm1
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	movss	DWORD PTR [eax+8], xmm1

; 3047 : 
; 3048 :     return vOut;
; 3049 : }

	pop	ebp
	ret	0
??Dgen@@YA?AVCVector3@0@ABV10@ABVCMatrix3x3@0@@Z ENDP	; gen::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??Kgen@@YA?AVCMatrix3x3@0@ABV10@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
_s$ = 16						; size = 4
??Kgen@@YA?AVCMatrix3x3@0@ABV10@M@Z PROC		; gen::operator/, COMDAT

; 3011 : {

	push	ebp
	mov	ebp, esp

; 3012 : 	GEN_GUARD_OPT;
; 3013 : 	GEN_ASSERT_OPT( !IsZero(s), "Invalid parameter" );
; 3014 : 
; 3015 : 	CMatrix3x3 mOut;
; 3016 :     mOut.e00 = m.e00 / s;

	mov	ecx, DWORD PTR _m$[ebp]
	movss	xmm1, DWORD PTR _s$[ebp]
	shufps	xmm1, xmm1, 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movups	xmm0, XMMWORD PTR [ecx]
	divps	xmm0, xmm1
	movups	XMMWORD PTR [eax], xmm0

; 3017 :     mOut.e01 = m.e01 / s;
; 3018 :     mOut.e02 = m.e02 / s;
; 3019 :     mOut.e10 = m.e10 / s;
; 3020 :     mOut.e11 = m.e11 / s;

	movups	xmm0, XMMWORD PTR [ecx+16]
	divps	xmm0, xmm1
	movups	XMMWORD PTR [eax+16], xmm0

; 3021 :     mOut.e12 = m.e12 / s;
; 3022 :     mOut.e20 = m.e20 / s;
; 3023 :     mOut.e21 = m.e21 / s;
; 3024 :     mOut.e22 = m.e22 / s;

	movss	xmm0, DWORD PTR [ecx+32]
	divss	xmm0, xmm1
	movss	DWORD PTR [eax+32], xmm0

; 3025 : 
; 3026 : 	return mOut;
; 3027 : 
; 3028 : 	GEN_ENDGUARD_OPT;
; 3029 : }

	pop	ebp
	ret	0
??Kgen@@YA?AVCMatrix3x3@0@ABV10@M@Z ENDP		; gen::operator/
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??Dgen@@YA?AVCMatrix3x3@0@ABV10@M@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_m$ = 12						; size = 4
_s$ = 16						; size = 4
??Dgen@@YA?AVCMatrix3x3@0@ABV10@M@Z PROC		; gen::operator*, COMDAT

; 2947 : {

	push	ebp
	mov	ebp, esp

; 2948 : 	CMatrix3x3 mOut;
; 2949 :     mOut.e00 = m.e00 * s;

	mov	ecx, DWORD PTR _m$[ebp]
	movss	xmm1, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	shufps	xmm1, xmm1, 0
	movups	xmm0, XMMWORD PTR [ecx]
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [eax], xmm0

; 2950 :     mOut.e01 = m.e01 * s;
; 2951 :     mOut.e02 = m.e02 * s;
; 2952 :     mOut.e10 = m.e10 * s;
; 2953 :     mOut.e11 = m.e11 * s;

	movups	xmm0, XMMWORD PTR [ecx+16]
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [eax+16], xmm0

; 2954 :     mOut.e12 = m.e12 * s;
; 2955 :     mOut.e20 = m.e20 * s;
; 2956 :     mOut.e21 = m.e21 * s;
; 2957 :     mOut.e22 = m.e22 * s;

	movss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+32], xmm0

; 2958 : 
; 2959 : 	return mOut;
; 2960 : }

	pop	ebp
	ret	0
??Dgen@@YA?AVCMatrix3x3@0@ABV10@M@Z ENDP		; gen::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??Dgen@@YA?AVCMatrix3x3@0@MABV10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
_m$ = 16						; size = 4
??Dgen@@YA?AVCMatrix3x3@0@MABV10@@Z PROC		; gen::operator*, COMDAT

; 2968 : {

	push	ebp
	mov	ebp, esp

; 2969 : 	CMatrix3x3 mOut;
; 2970 :     mOut.e00 = m.e00 * s;

	mov	ecx, DWORD PTR _m$[ebp]
	movss	xmm1, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	shufps	xmm1, xmm1, 0
	movups	xmm0, XMMWORD PTR [ecx]
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [eax], xmm0

; 2971 :     mOut.e01 = m.e01 * s;
; 2972 :     mOut.e02 = m.e02 * s;
; 2973 :     mOut.e10 = m.e10 * s;
; 2974 :     mOut.e11 = m.e11 * s;

	movups	xmm0, XMMWORD PTR [ecx+16]
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [eax+16], xmm0

; 2975 :     mOut.e12 = m.e12 * s;
; 2976 :     mOut.e20 = m.e20 * s;
; 2977 :     mOut.e21 = m.e21 * s;
; 2978 :     mOut.e22 = m.e22 * s;

	movss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, xmm1
	movss	DWORD PTR [eax+32], xmm0

; 2979 : 
; 2980 : 	return mOut;
; 2981 : }

	pop	ebp
	ret	0
??Dgen@@YA?AVCMatrix3x3@0@MABV10@@Z ENDP		; gen::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??9gen@@YA_NABVCMatrix3x3@0@0@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_x$ = 8							; size = 4
_x$ = 8							; size = 4
_x$ = 8							; size = 4
_m1$ = 8						; size = 4
_y$ = 12						; size = 4
_y$ = 12						; size = 4
_y$ = 12						; size = 4
_y$ = 12						; size = 4
_m2$ = 12						; size = 4
??9gen@@YA_NABVCMatrix3x3@0@0@Z PROC			; gen::operator!=, COMDAT

; 2915 : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	mov	ebx, DWORD PTR _m2$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _m1$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 406  :     if (xInt < 0)

	mov	esi, -2147483648			; 80000000H
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	movss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR _x$[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 405  :     TInt32 xInt = *(TInt32*)&x;

	mov	edx, DWORD PTR _x$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	movss	DWORD PTR _y$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 406  :     if (xInt < 0)

	test	edx, edx
	jns	SHORT $LN6@operator

; 407  : 	{
; 408  : 		// Reorder negative values so we can use integer comparison
; 409  :         xInt = 0x80000000 - xInt;

	mov	eax, esi
	sub	eax, edx
	mov	edx, eax
$LN6@operator:

; 410  : 	}
; 411  : 
; 412  : 	// Same with second value
; 413  :     TInt32 yInt = *(TInt32*)&y;

	mov	eax, DWORD PTR _y$[ebp]

; 414  :     if (yInt < 0)

	test	eax, eax
	jns	SHORT $LN5@operator

; 415  : 	{
; 416  :         yInt = 0x80000000 - yInt;

	mov	ecx, esi
	sub	ecx, eax
	mov	eax, ecx
$LN5@operator:

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	sub	edx, eax

; 78   : inline TUInt32 Abs( const TInt32 x ) { return abs( static_cast<int>(x) ); }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	cmp	eax, 4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	jae	$LN3@operator
	movss	xmm0, DWORD PTR [edi+4]
	movss	DWORD PTR _x$[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx+4]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 405  :     TInt32 xInt = *(TInt32*)&x;

	mov	edx, DWORD PTR _x$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	movss	DWORD PTR _y$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 406  :     if (xInt < 0)

	test	edx, edx
	jns	SHORT $LN12@operator

; 407  : 	{
; 408  : 		// Reorder negative values so we can use integer comparison
; 409  :         xInt = 0x80000000 - xInt;

	mov	eax, esi
	sub	eax, edx
	mov	edx, eax
$LN12@operator:

; 410  : 	}
; 411  : 
; 412  : 	// Same with second value
; 413  :     TInt32 yInt = *(TInt32*)&y;

	mov	eax, DWORD PTR _y$[ebp]

; 414  :     if (yInt < 0)

	test	eax, eax
	jns	SHORT $LN11@operator

; 415  : 	{
; 416  :         yInt = 0x80000000 - yInt;

	mov	ecx, esi
	sub	ecx, eax
	mov	eax, ecx
$LN11@operator:

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	sub	edx, eax

; 78   : inline TUInt32 Abs( const TInt32 x ) { return abs( static_cast<int>(x) ); }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	cmp	eax, 4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	jae	$LN3@operator
	movss	xmm0, DWORD PTR [edi+8]
	movss	DWORD PTR _x$[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx+8]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 405  :     TInt32 xInt = *(TInt32*)&x;

	mov	edx, DWORD PTR _x$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	movss	DWORD PTR _y$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 406  :     if (xInt < 0)

	test	edx, edx
	jns	SHORT $LN18@operator

; 407  : 	{
; 408  : 		// Reorder negative values so we can use integer comparison
; 409  :         xInt = 0x80000000 - xInt;

	mov	eax, esi
	sub	eax, edx
	mov	edx, eax
$LN18@operator:

; 410  : 	}
; 411  : 
; 412  : 	// Same with second value
; 413  :     TInt32 yInt = *(TInt32*)&y;

	mov	eax, DWORD PTR _y$[ebp]

; 414  :     if (yInt < 0)

	test	eax, eax
	jns	SHORT $LN17@operator

; 415  : 	{
; 416  :         yInt = 0x80000000 - yInt;

	mov	ecx, esi
	sub	ecx, eax
	mov	eax, ecx
$LN17@operator:

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	sub	edx, eax

; 78   : inline TUInt32 Abs( const TInt32 x ) { return abs( static_cast<int>(x) ); }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	cmp	eax, 4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	jae	$LN3@operator
	movss	xmm0, DWORD PTR [edi+12]
	movss	DWORD PTR _x$[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx+12]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 405  :     TInt32 xInt = *(TInt32*)&x;

	mov	ecx, DWORD PTR _x$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	movss	DWORD PTR _y$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 406  :     if (xInt < 0)

	test	ecx, ecx
	jns	SHORT $LN24@operator

; 407  : 	{
; 408  : 		// Reorder negative values so we can use integer comparison
; 409  :         xInt = 0x80000000 - xInt;

	mov	eax, esi
	sub	eax, ecx
	mov	ecx, eax
$LN24@operator:

; 410  : 	}
; 411  : 
; 412  : 	// Same with second value
; 413  :     TInt32 yInt = *(TInt32*)&y;

	mov	eax, DWORD PTR _y$[ebp]

; 414  :     if (yInt < 0)

	test	eax, eax
	jns	SHORT $LN23@operator

; 415  : 	{
; 416  :         yInt = 0x80000000 - yInt;

	sub	esi, eax
	mov	eax, esi
$LN23@operator:

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	sub	ecx, eax

; 78   : inline TUInt32 Abs( const TInt32 x ) { return abs( static_cast<int>(x) ); }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	cmp	eax, 4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	jae	$LN3@operator
	movss	xmm0, DWORD PTR [ebx+16]
	push	4
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+16]
	movss	DWORD PTR [esp], xmm0
	call	?AreEqual@gen@@YA_NMMI@Z		; gen::AreEqual
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN3@operator
	movss	xmm0, DWORD PTR [ebx+20]
	push	4
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+20]
	movss	DWORD PTR [esp], xmm0
	call	?AreEqual@gen@@YA_NMMI@Z		; gen::AreEqual
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN3@operator
	movss	xmm0, DWORD PTR [ebx+24]
	push	4
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+24]
	movss	DWORD PTR [esp], xmm0
	call	?AreEqual@gen@@YA_NMMI@Z		; gen::AreEqual
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN3@operator
	movss	xmm0, DWORD PTR [ebx+28]
	push	4
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+28]
	movss	DWORD PTR [esp], xmm0
	call	?AreEqual@gen@@YA_NMMI@Z		; gen::AreEqual
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN3@operator
	movss	xmm0, DWORD PTR [ebx+32]
	push	4
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+32]
	movss	DWORD PTR [esp], xmm0
	call	?AreEqual@gen@@YA_NMMI@Z		; gen::AreEqual
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN3@operator
	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 2919 : }

	pop	ebp
	ret	0
$LN3@operator:
	pop	edi
	pop	esi

; 2918 : 	       !AreEqual(m1.e20, m2.e20) || !AreEqual(m1.e21, m2.e21) || !AreEqual(m1.e22, m2.e22);

	mov	al, 1
	pop	ebx

; 2919 : }

	pop	ebp
	ret	0
??9gen@@YA_NABVCMatrix3x3@0@0@Z ENDP			; gen::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??8gen@@YA_NABVCMatrix3x3@0@0@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_x$ = 8							; size = 4
_x$ = 8							; size = 4
_x$ = 8							; size = 4
_m1$ = 8						; size = 4
_y$ = 12						; size = 4
_y$ = 12						; size = 4
_y$ = 12						; size = 4
_y$ = 12						; size = 4
_m2$ = 12						; size = 4
??8gen@@YA_NABVCMatrix3x3@0@0@Z PROC			; gen::operator==, COMDAT

; 2902 : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	mov	ebx, DWORD PTR _m2$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _m1$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 406  :     if (xInt < 0)

	mov	esi, -2147483648			; 80000000H
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	movss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR _x$[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 405  :     TInt32 xInt = *(TInt32*)&x;

	mov	edx, DWORD PTR _x$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	movss	DWORD PTR _y$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 406  :     if (xInt < 0)

	test	edx, edx
	jns	SHORT $LN6@operator

; 407  : 	{
; 408  : 		// Reorder negative values so we can use integer comparison
; 409  :         xInt = 0x80000000 - xInt;

	mov	eax, esi
	sub	eax, edx
	mov	edx, eax
$LN6@operator:

; 410  : 	}
; 411  : 
; 412  : 	// Same with second value
; 413  :     TInt32 yInt = *(TInt32*)&y;

	mov	eax, DWORD PTR _y$[ebp]

; 414  :     if (yInt < 0)

	test	eax, eax
	jns	SHORT $LN5@operator

; 415  : 	{
; 416  :         yInt = 0x80000000 - yInt;

	mov	ecx, esi
	sub	ecx, eax
	mov	eax, ecx
$LN5@operator:

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	sub	edx, eax

; 78   : inline TUInt32 Abs( const TInt32 x ) { return abs( static_cast<int>(x) ); }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	cmp	eax, 4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	jae	$LN3@operator
	movss	xmm0, DWORD PTR [edi+4]
	movss	DWORD PTR _x$[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx+4]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 405  :     TInt32 xInt = *(TInt32*)&x;

	mov	edx, DWORD PTR _x$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	movss	DWORD PTR _y$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 406  :     if (xInt < 0)

	test	edx, edx
	jns	SHORT $LN12@operator

; 407  : 	{
; 408  : 		// Reorder negative values so we can use integer comparison
; 409  :         xInt = 0x80000000 - xInt;

	mov	eax, esi
	sub	eax, edx
	mov	edx, eax
$LN12@operator:

; 410  : 	}
; 411  : 
; 412  : 	// Same with second value
; 413  :     TInt32 yInt = *(TInt32*)&y;

	mov	eax, DWORD PTR _y$[ebp]

; 414  :     if (yInt < 0)

	test	eax, eax
	jns	SHORT $LN11@operator

; 415  : 	{
; 416  :         yInt = 0x80000000 - yInt;

	mov	ecx, esi
	sub	ecx, eax
	mov	eax, ecx
$LN11@operator:

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	sub	edx, eax

; 78   : inline TUInt32 Abs( const TInt32 x ) { return abs( static_cast<int>(x) ); }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	cmp	eax, 4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	jae	$LN3@operator
	movss	xmm0, DWORD PTR [edi+8]
	movss	DWORD PTR _x$[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx+8]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 405  :     TInt32 xInt = *(TInt32*)&x;

	mov	edx, DWORD PTR _x$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	movss	DWORD PTR _y$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 406  :     if (xInt < 0)

	test	edx, edx
	jns	SHORT $LN18@operator

; 407  : 	{
; 408  : 		// Reorder negative values so we can use integer comparison
; 409  :         xInt = 0x80000000 - xInt;

	mov	eax, esi
	sub	eax, edx
	mov	edx, eax
$LN18@operator:

; 410  : 	}
; 411  : 
; 412  : 	// Same with second value
; 413  :     TInt32 yInt = *(TInt32*)&y;

	mov	eax, DWORD PTR _y$[ebp]

; 414  :     if (yInt < 0)

	test	eax, eax
	jns	SHORT $LN17@operator

; 415  : 	{
; 416  :         yInt = 0x80000000 - yInt;

	mov	ecx, esi
	sub	ecx, eax
	mov	eax, ecx
$LN17@operator:

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	sub	edx, eax

; 78   : inline TUInt32 Abs( const TInt32 x ) { return abs( static_cast<int>(x) ); }

	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	cmp	eax, 4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	jae	$LN3@operator
	movss	xmm0, DWORD PTR [edi+12]
	movss	DWORD PTR _x$[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx+12]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 405  :     TInt32 xInt = *(TInt32*)&x;

	mov	ecx, DWORD PTR _x$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	movss	DWORD PTR _y$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 406  :     if (xInt < 0)

	test	ecx, ecx
	jns	SHORT $LN24@operator

; 407  : 	{
; 408  : 		// Reorder negative values so we can use integer comparison
; 409  :         xInt = 0x80000000 - xInt;

	mov	eax, esi
	sub	eax, ecx
	mov	ecx, eax
$LN24@operator:

; 410  : 	}
; 411  : 
; 412  : 	// Same with second value
; 413  :     TInt32 yInt = *(TInt32*)&y;

	mov	eax, DWORD PTR _y$[ebp]

; 414  :     if (yInt < 0)

	test	eax, eax
	jns	SHORT $LN23@operator

; 415  : 	{
; 416  :         yInt = 0x80000000 - yInt;

	sub	esi, eax
	mov	eax, esi
$LN23@operator:

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	sub	ecx, eax

; 78   : inline TUInt32 Abs( const TInt32 x ) { return abs( static_cast<int>(x) ); }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	cmp	eax, 4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	jae	$LN3@operator
	movss	xmm0, DWORD PTR [ebx+16]
	push	4
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+16]
	movss	DWORD PTR [esp], xmm0
	call	?AreEqual@gen@@YA_NMMI@Z		; gen::AreEqual
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN3@operator
	movss	xmm0, DWORD PTR [ebx+20]
	push	4
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+20]
	movss	DWORD PTR [esp], xmm0
	call	?AreEqual@gen@@YA_NMMI@Z		; gen::AreEqual
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN3@operator
	movss	xmm0, DWORD PTR [ebx+24]
	push	4
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+24]
	movss	DWORD PTR [esp], xmm0
	call	?AreEqual@gen@@YA_NMMI@Z		; gen::AreEqual
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN3@operator
	movss	xmm0, DWORD PTR [ebx+28]
	push	4
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+28]
	movss	DWORD PTR [esp], xmm0
	call	?AreEqual@gen@@YA_NMMI@Z		; gen::AreEqual
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN3@operator
	movss	xmm0, DWORD PTR [ebx+32]
	push	4
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [edi+32]
	movss	DWORD PTR [esp], xmm0
	call	?AreEqual@gen@@YA_NMMI@Z		; gen::AreEqual
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN3@operator
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx

; 2906 : }

	pop	ebp
	ret	0
$LN3@operator:
	pop	edi
	pop	esi

; 2905 : 	       AreEqual(m1.e20, m2.e20) && AreEqual(m1.e21, m2.e21) && AreEqual(m1.e22, m2.e22);

	xor	al, al
	pop	ebx

; 2906 : }

	pop	ebp
	ret	0
??8gen@@YA_NABVCMatrix3x3@0@0@Z ENDP			; gen::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MultiplyAffine2D@CMatrix3x3@gen@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
$T1 = -48						; size = 36
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
$T5 = 8							; size = 4
_m$ = 8							; size = 4
?MultiplyAffine2D@CMatrix3x3@gen@@QAEAAV12@ABV12@@Z PROC ; gen::CMatrix3x3::MultiplyAffine2D, COMDAT
; _this$ = ecx

; 3166 : {

	push	ebp
	mov	ebp, esp

; 3167 : 	if ( this == &m )

	mov	eax, DWORD PTR _m$[ebp]
	sub	esp, 48					; 00000030H
	cmp	ecx, eax
	jne	$LN2@MultiplyAf

; 3191 : 
; 3192 : // Binary matrix-matrix multiplication assuming both matrices are affine - non-member version
; 3193 : CMatrix3x3 MultiplyAffine2D
; 3194 : (
; 3195 : 	const CMatrix3x3& m1,
; 3196 : 	const CMatrix3x3& m2
; 3197 : )
; 3198 : {
; 3199 : 	CMatrix3x3 mOut;
; 3200 : 
; 3201 : 	mOut.e00 = m1.e00*m2.e00 + m1.e01*m2.e10;

	movss	xmm3, DWORD PTR [eax]
	movss	xmm6, DWORD PTR [eax+4]
	movaps	xmm0, xmm3
	movss	xmm5, DWORD PTR [eax+12]
	movaps	xmm1, xmm6

; 3202 : 	mOut.e01 = m1.e00*m2.e01 + m1.e01*m2.e11;

	movss	xmm4, DWORD PTR [eax+16]
	mulss	xmm0, xmm3
	movaps	xmm2, xmm4
	mulss	xmm1, xmm5
	mulss	xmm2, xmm6
	addss	xmm0, xmm1
	movss	DWORD PTR $T5[ebp], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm6
	addss	xmm2, xmm0

; 3203 : 	mOut.e02 = 0.0f;
; 3204 : 
; 3205 : 	mOut.e10 = m1.e10*m2.e00 + m1.e11*m2.e10;

	movaps	xmm0, xmm3
	mulss	xmm0, xmm5
	movss	DWORD PTR $T4[ebp], xmm2
	movaps	xmm2, xmm4
	mulss	xmm2, xmm5
	addss	xmm2, xmm0

; 3206 : 	mOut.e11 = m1.e10*m2.e01 + m1.e11*m2.e11;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm0, xmm1
	movss	DWORD PTR $T3[ebp], xmm2

; 3207 : 	mOut.e12 = 0.0f;
; 3208 : 
; 3209 : 	mOut.e20 = m1.e20*m2.e00 + m1.e21*m2.e10 + m2.e20;

	movss	xmm2, DWORD PTR [eax+28]
	movss	xmm1, DWORD PTR [eax+24]

; 353  : 	if ( this != &m )

	lea	eax, DWORD PTR $T1[ebp]

; 3207 : 	mOut.e12 = 0.0f;
; 3208 : 
; 3209 : 	mOut.e20 = m1.e20*m2.e00 + m1.e21*m2.e10 + m2.e20;

	movaps	xmm7, xmm1

; 353  : 	if ( this != &m )

	cmp	ecx, eax

; 3207 : 	mOut.e12 = 0.0f;
; 3208 : 
; 3209 : 	mOut.e20 = m1.e20*m2.e00 + m1.e21*m2.e10 + m2.e20;

	mulss	xmm7, xmm3

; 3187 : 	}
; 3188 : 
; 3189 : 	return *this;

	mov	eax, ecx

; 3206 : 	mOut.e11 = m1.e10*m2.e01 + m1.e11*m2.e11;

	movss	DWORD PTR $T2[ebp], xmm0

; 3210 : 	mOut.e21 = m1.e20*m2.e01 + m1.e21*m2.e11 + m2.e21;

	movaps	xmm3, xmm2
	movaps	xmm0, xmm2
	mulss	xmm3, xmm4
	mulss	xmm0, xmm5
	addss	xmm7, xmm0
	addss	xmm7, xmm1
	mulss	xmm1, xmm6
	addss	xmm3, xmm1
	addss	xmm3, xmm2

; 353  : 	if ( this != &m )

	je	$LN1@MultiplyAf

; 354  : 	{
; 355  : 		e00 = m.e00;

	movss	xmm0, DWORD PTR $T5[ebp]
	movss	DWORD PTR [ecx], xmm0

; 356  : 		e01 = m.e01;

	movss	xmm0, DWORD PTR $T4[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 357  : 		e02 = m.e02;
; 358  : 
; 359  : 		e10 = m.e10;

	movss	xmm0, DWORD PTR $T3[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 360  : 		e11 = m.e11;

	movss	xmm0, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+8], 0
	movss	DWORD PTR [ecx+16], xmm0

; 361  : 		e12 = m.e12;

	mov	DWORD PTR [ecx+20], 0

; 362  : 
; 363  : 		e20 = m.e20;

	movss	DWORD PTR [ecx+24], xmm7

; 364  : 		e21 = m.e21;
; 365  : 		e22 = m.e22;

	mov	DWORD PTR [ecx+32], 1065353216		; 3f800000H

; 3185 : 		e21 = e20*m.e01 + e21*m.e11 + m.e21;

	movss	DWORD PTR [ecx+28], xmm3

; 3190 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@MultiplyAf:

; 3168 : 	{
; 3169 : 		// Special case of multiplying by self - no copy optimisations so use binary version
; 3170 : 		*this = gen::MultiplyAffine2D( m, m );
; 3171 : 	}
; 3172 : 	else
; 3173 : 	{
; 3174 : 		TFloat32 t;
; 3175 : 
; 3176 : 		t   = e00*m.e00 + e01*m.e10;

	movss	xmm3, DWORD PTR [ecx+4]
	movss	xmm2, DWORD PTR [ecx]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+12]
	mulss	xmm2, DWORD PTR [eax]

; 3177 : 		e01 = e00*m.e01 + e01*m.e11;

	mulss	xmm3, DWORD PTR [eax+16]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [ecx]
	addss	xmm3, xmm0

; 3178 : 		e00 = t;

	movss	DWORD PTR [ecx], xmm2

; 3179 : 
; 3180 : 		t   = e10*m.e00 + e11*m.e10;

	movss	xmm2, DWORD PTR [ecx+12]
	movss	DWORD PTR [ecx+4], xmm3
	mulss	xmm2, DWORD PTR [eax]
	movss	xmm3, DWORD PTR [ecx+16]
	movaps	xmm0, xmm3

; 3181 : 		e11 = e10*m.e01 + e11*m.e11;

	mulss	xmm3, DWORD PTR [eax+16]
	mulss	xmm0, DWORD PTR [eax+12]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [ecx+12]
	addss	xmm3, xmm0

; 3182 : 		e10 = t;

	movss	DWORD PTR [ecx+12], xmm2

; 3183 : 
; 3184 : 		t   = e20*m.e00 + e21*m.e10 + m.e20;

	movss	xmm2, DWORD PTR [ecx+24]
	movss	DWORD PTR [ecx+16], xmm3
	movss	xmm3, DWORD PTR [ecx+28]
	mulss	xmm2, DWORD PTR [eax]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+12]

; 3185 : 		e21 = e20*m.e01 + e21*m.e11 + m.e21;

	mulss	xmm3, DWORD PTR [eax+16]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [ecx+24]
	addss	xmm2, DWORD PTR [eax+24]
	addss	xmm3, xmm0
	addss	xmm3, DWORD PTR [eax+28]

; 3186 : 		e20 = t;

	movss	DWORD PTR [ecx+24], xmm2

; 3187 : 	}
; 3188 : 
; 3189 : 	return *this;

	mov	eax, ecx
	movss	DWORD PTR [ecx+28], xmm3
$LN1@MultiplyAf:

; 3190 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MultiplyAffine2D@CMatrix3x3@gen@@QAEAAV12@ABV12@@Z ENDP ; gen::CMatrix3x3::MultiplyAffine2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??XCMatrix3x3@gen@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 36
$T2 = -32						; size = 4
$T3 = -28						; size = 4
tv546 = -24						; size = 4
tv543 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
$T7 = -8						; size = 4
$T8 = -4						; size = 4
$T9 = 8							; size = 4
_m$ = 8							; size = 4
??XCMatrix3x3@gen@@QAEAAV01@ABV01@@Z PROC		; gen::CMatrix3x3::operator*=, COMDAT
; _this$ = ecx

; 3107 : {

	push	ebp
	mov	ebp, esp

; 3108 : 	if ( this == &m )

	mov	eax, DWORD PTR _m$[ebp]
	sub	esp, 68					; 00000044H
	cmp	ecx, eax
	jne	$LN2@operator

; 3137 : 
; 3138 : 
; 3139 : // Binary matrix-matrix multiplication - non-member version
; 3140 : CMatrix3x3 operator*
; 3141 : (
; 3142 : 	const CMatrix3x3& m1,
; 3143 : 	const CMatrix3x3& m2
; 3144 : )
; 3145 : {
; 3146 : 	CMatrix3x3 mOut;
; 3147 : 
; 3148 : 	mOut.e00 = m1.e00*m2.e00 + m1.e01*m2.e10 + m1.e02*m2.e20;

	movss	xmm7, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+4]
	movaps	xmm5, xmm7
	movss	xmm4, DWORD PTR [eax+8]
	movaps	xmm3, xmm1
	mulss	xmm3, DWORD PTR [eax+12]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax+24]
	mulss	xmm5, xmm7
	movss	DWORD PTR tv546[ebp], xmm0

; 3149 : 	mOut.e01 = m1.e00*m2.e01 + m1.e01*m2.e11 + m1.e02*m2.e21;

	movss	xmm6, DWORD PTR [eax+28]
	addss	xmm5, xmm3
	movss	DWORD PTR tv543[ebp], xmm1
	addss	xmm5, xmm0
	movss	DWORD PTR $T3[ebp], xmm5
	movss	xmm5, DWORD PTR [eax+16]
	movaps	xmm0, xmm5
	mulss	xmm0, xmm1
	movss	DWORD PTR $T9[ebp], xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR $T9[ebp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm4
	addss	xmm1, xmm0

; 3150 : 	mOut.e02 = m1.e00*m2.e02 + m1.e01*m2.e12 + m1.e02*m2.e22;

	movss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR $T4[ebp], xmm0
	movss	DWORD PTR $T9[ebp], xmm1
	movss	xmm1, DWORD PTR [eax+20]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR $T8[ebp], xmm0
	movaps	xmm0, xmm4
	movss	xmm2, DWORD PTR $T8[ebp]
	mulss	xmm0, xmm7
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR $T4[ebp]
	mulss	xmm0, xmm4

; 3151 : 
; 3152 : 	mOut.e10 = m1.e10*m2.e00 + m1.e11*m2.e10 + m1.e12*m2.e20;
; 3153 : 	mOut.e11 = m1.e10*m2.e01 + m1.e11*m2.e11 + m1.e12*m2.e21;
; 3154 : 	mOut.e12 = m1.e10*m2.e02 + m1.e11*m2.e12 + m1.e12*m2.e22;

	mulss	xmm4, DWORD PTR [eax+12]
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR $T7[ebp], xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR $T8[ebp], xmm2
	movss	xmm2, DWORD PTR $T7[ebp]
	addss	xmm2, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm0, xmm3
	movss	DWORD PTR $T7[ebp], xmm2
	movaps	xmm2, xmm1
	mulss	xmm2, xmm6
	addss	xmm0, xmm2
	movss	DWORD PTR $T2[ebp], xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm5
	addss	xmm0, xmm4
	movss	xmm4, DWORD PTR $T4[ebp]
	movss	DWORD PTR $T6[ebp], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR $T6[ebp]
	addss	xmm1, xmm0

; 3155 : 
; 3156 : 	mOut.e20 = m1.e20*m2.e00 + m1.e21*m2.e10 + m1.e22*m2.e20;

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR $T5[ebp], xmm0
	movss	xmm3, DWORD PTR $T5[ebp]
	movss	DWORD PTR $T6[ebp], xmm1
	movss	xmm1, DWORD PTR [eax+24]
	movaps	xmm0, xmm1
	mulss	xmm0, xmm7
	addss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm1
	addss	xmm3, xmm0

; 3157 : 	mOut.e21 = m1.e20*m2.e01 + m1.e21*m2.e11 + m1.e22*m2.e21;

	mulss	xmm1, DWORD PTR tv543[ebp]

; 353  : 	if ( this != &m )

	lea	eax, DWORD PTR $T1[ebp]
	cmp	ecx, eax

; 3132 : 		e20 = t0;
; 3133 : 		e21 = t1;
; 3134 : 	}
; 3135 : 	return *this;

	mov	eax, ecx

; 3158 : 	mOut.e22 = m1.e20*m2.e02 + m1.e21*m2.e12 + m1.e22*m2.e22;

	addss	xmm2, DWORD PTR tv546[ebp]
	movaps	xmm7, xmm6
	movaps	xmm0, xmm4
	mulss	xmm7, xmm5
	mulss	xmm0, xmm6
	addss	xmm7, xmm1
	mulss	xmm4, xmm4
	addss	xmm4, xmm2
	addss	xmm7, xmm0

; 353  : 	if ( this != &m )

	je	$LN1@operator

; 354  : 	{
; 355  : 		e00 = m.e00;

	movss	xmm0, DWORD PTR $T3[ebp]
	movss	DWORD PTR [ecx], xmm0

; 356  : 		e01 = m.e01;

	movss	xmm0, DWORD PTR $T9[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 357  : 		e02 = m.e02;

	movss	xmm0, DWORD PTR $T8[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 358  : 
; 359  : 		e10 = m.e10;

	movss	xmm0, DWORD PTR $T7[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 360  : 		e11 = m.e11;

	movss	xmm0, DWORD PTR $T2[ebp]
	movss	DWORD PTR [ecx+16], xmm0

; 361  : 		e12 = m.e12;

	movss	xmm0, DWORD PTR $T6[ebp]
	movss	DWORD PTR [ecx+20], xmm0

; 362  : 
; 363  : 		e20 = m.e20;

	movss	DWORD PTR [ecx+24], xmm3

; 364  : 		e21 = m.e21;

	movss	DWORD PTR [ecx+28], xmm7

; 365  : 		e22 = m.e22;

	movss	DWORD PTR [ecx+32], xmm4

; 3136 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@operator:

; 3109 : 	{
; 3110 : 		// Special case of multiplying by self - no copy optimisations so use binary version
; 3111 : 		*this = m * m;
; 3112 : 	}
; 3113 : 	else
; 3114 : 	{
; 3115 : 		TFloat32 t0, t1;
; 3116 : 
; 3117 : 		t0  = e00*m.e00 + e01*m.e10 + e02*m.e20;

	movss	xmm2, DWORD PTR [ecx+4]
	movss	xmm5, DWORD PTR [ecx]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+12]
	movaps	xmm4, xmm5
	mulss	xmm4, DWORD PTR [eax]

; 3118 : 		t1  = e00*m.e01 + e01*m.e11 + e02*m.e21;

	movaps	xmm1, xmm5
	movss	xmm3, DWORD PTR [ecx+8]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm4, xmm0

; 3119 : 		e02 = e00*m.e02 + e01*m.e12 + e02*m.e22;

	mulss	xmm5, DWORD PTR [eax+8]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm4, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax+28]
	mulss	xmm3, DWORD PTR [eax+32]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, xmm2

; 3120 : 		e00 = t0;
; 3121 : 		e01 = t1;
; 3122 : 
; 3123 : 		t0  = e10*m.e00 + e11*m.e10 + e12*m.e20;

	movss	xmm2, DWORD PTR [ecx+16]
	movss	DWORD PTR [ecx], xmm4
	addss	xmm0, xmm5
	movss	xmm4, DWORD PTR [ecx+20]
	movss	DWORD PTR [ecx+4], xmm1
	addss	xmm0, xmm3
	movss	xmm3, DWORD PTR [ecx+12]
	movaps	xmm5, xmm3

; 3124 : 		t1  = e10*m.e01 + e11*m.e11 + e12*m.e21;

	movaps	xmm1, xmm3
	movss	DWORD PTR [ecx+8], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+12]
	mulss	xmm5, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm5, xmm0

; 3125 : 		e12 = e10*m.e02 + e11*m.e12 + e12*m.e22;

	mulss	xmm3, DWORD PTR [eax+8]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm5, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax+28]
	mulss	xmm4, DWORD PTR [eax+32]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, xmm2

; 3126 : 		e10 = t0;
; 3127 : 		e11 = t1;
; 3128 : 
; 3129 : 		t0  = e20*m.e00 + e21*m.e10 + e22*m.e20;

	movss	xmm2, DWORD PTR [ecx+28]
	movss	DWORD PTR [ecx+12], xmm5
	addss	xmm0, xmm3
	movss	DWORD PTR [ecx+16], xmm1
	movss	xmm3, DWORD PTR [ecx+24]
	movaps	xmm5, xmm3

; 3130 : 		t1  = e20*m.e01 + e21*m.e11 + e22*m.e21;

	movaps	xmm1, xmm3
	addss	xmm0, xmm4
	movss	xmm4, DWORD PTR [ecx+32]
	movss	DWORD PTR [ecx+20], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+12]
	mulss	xmm5, DWORD PTR [eax]
	mulss	xmm1, DWORD PTR [eax+4]
	addss	xmm5, xmm0

; 3131 : 		e22 = e20*m.e02 + e21*m.e12 + e22*m.e22;

	mulss	xmm3, DWORD PTR [eax+8]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax+24]
	addss	xmm5, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+16]
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [eax+28]
	mulss	xmm4, DWORD PTR [eax+32]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+20]
	mulss	xmm0, xmm2
	addss	xmm0, xmm3
	addss	xmm0, xmm4
	movss	DWORD PTR [ecx+32], xmm0

; 3132 : 		e20 = t0;
; 3133 : 		e21 = t1;
; 3134 : 	}
; 3135 : 	return *this;

	mov	eax, ecx
	movss	DWORD PTR [ecx+24], xmm5
	movss	DWORD PTR [ecx+28], xmm1
$LN1@operator:

; 3136 : }

	mov	esp, ebp
	pop	ebp
	ret	4
??XCMatrix3x3@gen@@QAEAAV01@ABV01@@Z ENDP		; gen::CMatrix3x3::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?TransformPoint2D@CMatrix3x3@gen@@QBE?AVCVector2@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_p$ = 12						; size = 4
?TransformPoint2D@CMatrix3x3@gen@@QBE?AVCVector2@2@ABV32@@Z PROC ; gen::CMatrix3x3::TransformPoint2D, COMDAT
; _this$ = ecx

; 3093 : {

	push	ebp
	mov	ebp, esp

; 3094 : 	CVector2 pOut;
; 3095 : 	pOut.x = p.x*e00 + p.y*e10 + e20;

	mov	eax, DWORD PTR _p$[ebp]
	movss	xmm1, DWORD PTR [ecx+12]
	movss	xmm2, DWORD PTR [eax]
	movss	xmm3, DWORD PTR [eax+4]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mulss	xmm1, xmm3
	addss	xmm1, xmm0

; 3096 : 	pOut.y = p.x*e01 + p.y*e11 + e21;

	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, xmm3
	addss	xmm1, DWORD PTR [ecx+24]
	movss	DWORD PTR [eax], xmm1
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	addss	xmm1, DWORD PTR [ecx+28]
	movss	DWORD PTR [eax+4], xmm1

; 3097 : 
; 3098 : 	return pOut;
; 3099 : }

	pop	ebp
	ret	8
?TransformPoint2D@CMatrix3x3@gen@@QBE?AVCVector2@2@ABV32@@Z ENDP ; gen::CMatrix3x3::TransformPoint2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?TransformVector2D@CMatrix3x3@gen@@QBE?AVCVector2@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
?TransformVector2D@CMatrix3x3@gen@@QBE?AVCVector2@2@ABV32@@Z PROC ; gen::CMatrix3x3::TransformVector2D, COMDAT
; _this$ = ecx

; 3082 : {

	push	ebp
	mov	ebp, esp

; 3083 : 	CVector2 vOut;
; 3084 : 	vOut.x = v.x*e00 + v.y*e10;

	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [ecx+12]
	movss	xmm2, DWORD PTR [eax]
	movss	xmm3, DWORD PTR [eax+4]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mulss	xmm1, xmm3
	addss	xmm1, xmm0

; 3085 : 	vOut.y = v.x*e01 + v.y*e11;

	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, xmm3
	movss	DWORD PTR [eax], xmm1
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	DWORD PTR [eax+4], xmm1

; 3086 : 
; 3087 : 	return vOut;
; 3088 : }

	pop	ebp
	ret	8
?TransformVector2D@CMatrix3x3@gen@@QBE?AVCVector2@2@ABV32@@Z ENDP ; gen::CMatrix3x3::TransformVector2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Transform@CMatrix3x3@gen@@QBE?AVCVector3@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
?Transform@CMatrix3x3@gen@@QBE?AVCVector3@2@ABV32@@Z PROC ; gen::CMatrix3x3::Transform, COMDAT
; _this$ = ecx

; 3070 : {

	push	ebp
	mov	ebp, esp

; 3071 : 	CVector3 vOut;
; 3072 : 	vOut.x = v.x*e00 + v.y*e10 + v.z*e20;

	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm1, DWORD PTR [ecx+12]
	movss	xmm2, DWORD PTR [eax]
	movss	xmm4, DWORD PTR [eax+4]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [eax+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mulss	xmm1, xmm4
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+24]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 3073 : 	vOut.y = v.x*e01 + v.y*e11 + v.z*e21;

	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, xmm4
	movss	DWORD PTR [eax], xmm1
	movss	xmm1, DWORD PTR [ecx+4]
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+28]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0

; 3074 : 	vOut.z = v.x*e02 + v.y*e12 + v.z*e22;

	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, xmm4
	movss	DWORD PTR [eax+4], xmm1
	movss	xmm1, DWORD PTR [ecx+8]
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	movss	DWORD PTR [eax+8], xmm1

; 3075 : 
; 3076 : 	return vOut;
; 3077 : }

	pop	ebp
	ret	8
?Transform@CMatrix3x3@gen@@QBE?AVCVector3@2@ABV32@@Z ENDP ; gen::CMatrix3x3::Transform
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??_0CMatrix3x3@gen@@QAEAAV01@M@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??_0CMatrix3x3@gen@@QAEAAV01@M@Z PROC			; gen::CMatrix3x3::operator/=, COMDAT
; _this$ = ecx

; 2986 : {

	push	ebp
	mov	ebp, esp

; 2987 : 	GEN_GUARD_OPT;
; 2988 : 	GEN_ASSERT_OPT( !IsZero(s), "Invalid parameter" );
; 2989 : 
; 2990 : 	e00 /= s;

	movups	xmm0, XMMWORD PTR [ecx]

; 2991 : 	e01 /= s;
; 2992 : 	e02 /= s;
; 2993 : 	e10 /= s;
; 2994 : 	e11 /= s;
; 2995 : 	e12 /= s;
; 2996 : 	e20 /= s;
; 2997 : 	e21 /= s;
; 2998 : 	e22 /= s;
; 2999 : 
; 3000 : 	return *this;

	mov	eax, ecx
	movss	xmm1, DWORD PTR _s$[ebp]
	shufps	xmm1, xmm1, 0
	divps	xmm0, xmm1
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [ecx+16]
	divps	xmm0, xmm1
	movups	XMMWORD PTR [ecx+16], xmm0
	movss	xmm0, DWORD PTR [ecx+32]
	divss	xmm0, xmm1
	movss	DWORD PTR [ecx+32], xmm0

; 3001 : 
; 3002 : 	GEN_ENDGUARD_OPT;
; 3003 : }

	pop	ebp
	ret	4
??_0CMatrix3x3@gen@@QAEAAV01@M@Z ENDP			; gen::CMatrix3x3::operator/=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??XCMatrix3x3@gen@@QAEAAV01@M@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??XCMatrix3x3@gen@@QAEAAV01@M@Z PROC			; gen::CMatrix3x3::operator*=, COMDAT
; _this$ = ecx

; 2927 : {

	push	ebp
	mov	ebp, esp

; 2928 : 	e00 *= s;

	movups	xmm0, XMMWORD PTR [ecx]

; 2929 : 	e01 *= s;
; 2930 : 	e02 *= s;
; 2931 : 	e10 *= s;
; 2932 : 	e11 *= s;
; 2933 : 	e12 *= s;
; 2934 : 	e20 *= s;
; 2935 : 	e21 *= s;
; 2936 : 	e22 *= s;
; 2937 : 
; 2938 : 	return *this;

	mov	eax, ecx
	movss	xmm1, DWORD PTR _s$[ebp]
	shufps	xmm1, xmm1, 0
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [ecx+16]
	mulps	xmm0, xmm1
	movups	XMMWORD PTR [ecx+16], xmm0
	movss	xmm0, DWORD PTR [ecx+32]
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+32], xmm0

; 2939 : }

	pop	ebp
	ret	4
??XCMatrix3x3@gen@@QAEAAV01@M@Z ENDP			; gen::CMatrix3x3::operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?FaceDirection2D@CMatrix3x3@gen@@QAEXABVCVector2@2@_N1@Z
_TEXT	SEGMENT
_scale$2$ = -16						; size = 4
_scale$1$ = -12						; size = 4
_axis$ = -8						; size = 8
_direction$ = 8						; size = 4
_bUseYAxis$ = 12					; size = 1
_bLH$ = 16						; size = 1
?FaceDirection2D@CMatrix3x3@gen@@QAEXABVCVector2@2@_N1@Z PROC ; gen::CMatrix3x3::FaceDirection2D, COMDAT
; _this$ = ecx

; 2795 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H
	push	esi
	mov	esi, ecx

; 1331 : 	scale.x = Sqrt( e00*e00 + e01*e01 );

	movss	xmm1, DWORD PTR [esi+4]
	movss	xmm0, DWORD PTR [esi]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1332 : 	scale.y = Sqrt( e10*e10 + e11*e11 );

	movss	xmm1, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1332 : 	scale.y = Sqrt( e10*e10 + e11*e11 );

	mulss	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _scale$2$[esp+24], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1332 : 	scale.y = Sqrt( e10*e10 + e11*e11 );

	movss	xmm0, DWORD PTR [esi+12]
	mulss	xmm0, xmm0
	addss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2797 : 	CVector2 axis = Normalise( direction );

	push	DWORD PTR _direction$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2797 : 	CVector2 axis = Normalise( direction );

	lea	eax, DWORD PTR _axis$[esp+28]
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _scale$1$[esp+32], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2797 : 	CVector2 axis = Normalise( direction );

	call	?Normalise@gen@@YA?AVCVector2@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 168  : 		return gen::IsZero( x*x + y*y );

	movss	xmm2, DWORD PTR _axis$[esp+36]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2797 : 	CVector2 axis = Normalise( direction );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 168  : 		return gen::IsZero( x*x + y*y );

	movss	xmm3, DWORD PTR _axis$[esp+24]
	movaps	xmm1, xmm2
	movaps	xmm0, xmm3
	mulss	xmm1, xmm2
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2798 : 	if (axis.IsZero()) return;

	ja	$LN1@FaceDirect

; 2799 : 	if (bUseYAxis)

	cmp	BYTE PTR _bUseYAxis$[ebp], 0
	je	SHORT $LN6@FaceDirect

; 2800 : 	{
; 2801 : 		e10 = axis.x * scale.y;
; 2802 : 		e11 = axis.y * scale.y;
; 2803 : 		if (bLH)

	cmp	BYTE PTR _bLH$[ebp], 0
	movss	xmm0, DWORD PTR _scale$1$[esp+24]
	movaps	xmm1, xmm0
	mulss	xmm2, xmm0
	mulss	xmm1, xmm3
	movss	DWORD PTR [esi+16], xmm2

; 2804 : 		{
; 2805 : 			e00 = e11 * scale.x;

	mulss	xmm2, DWORD PTR _scale$2$[esp+24]
	movss	DWORD PTR [esi+12], xmm1

; 2806 : 			e01 = -e10 * scale.x;

	mulss	xmm1, DWORD PTR _scale$2$[esp+24]
	je	SHORT $LN5@FaceDirect
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi], xmm2
	movss	DWORD PTR [esi+4], xmm1

; 2827 : 		}
; 2828 : 	}
; 2829 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN5@FaceDirect:

; 2807 : 		}
; 2808 : 		else
; 2809 : 		{
; 2810 : 			e00 = -e11 * scale.x;

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi], xmm2

; 2811 : 			e01 = e10 * scale.x;

	movss	DWORD PTR [esi+4], xmm1

; 2827 : 		}
; 2828 : 	}
; 2829 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN6@FaceDirect:

; 2812 : 		}
; 2813 : 	}
; 2814 : 	else
; 2815 : 	{
; 2816 : 		e00 = axis.x * scale.x;
; 2817 : 		e01 = axis.y * scale.x;
; 2818 : 		if (bLH)

	cmp	BYTE PTR _bLH$[ebp], 0
	movss	xmm0, DWORD PTR _scale$2$[esp+24]
	movaps	xmm1, xmm0
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	movss	DWORD PTR [esi+4], xmm0

; 2819 : 		{
; 2820 : 			e11 = -e00 * scale.y;
; 2821 : 			e10 = e01 * scale.y;

	mulss	xmm0, DWORD PTR _scale$1$[esp+24]
	movss	DWORD PTR [esi], xmm1
	mulss	xmm1, DWORD PTR _scale$1$[esp+24]
	je	SHORT $LN2@FaceDirect

; 2822 : 		}
; 2823 : 		else
; 2824 : 		{
; 2825 : 			e11 = e00 * scale.y;
; 2826 : 			e10 = -e01 * scale.y;

	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movss	DWORD PTR [esi+16], xmm1

; 2827 : 		}
; 2828 : 	}
; 2829 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@FaceDirect:

; 2822 : 		}
; 2823 : 		else
; 2824 : 		{
; 2825 : 			e11 = e00 * scale.y;
; 2826 : 			e10 = -e01 * scale.y;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movss	DWORD PTR [esi+16], xmm1
$LN1@FaceDirect:

; 2827 : 		}
; 2828 : 	}
; 2829 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FaceDirection2D@CMatrix3x3@gen@@QAEXABVCVector2@2@_N1@Z ENDP ; gen::CMatrix3x3::FaceDirection2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?FaceTarget2D@CMatrix3x3@gen@@QAEXABVCVector2@2@_N1@Z
_TEXT	SEGMENT
_scale$1$ = -24						; size = 4
_scale$2$ = -20						; size = 4
$T1 = -16						; size = 8
_axis$ = -8						; size = 8
_target$ = 8						; size = 4
_bUseYAxis$ = 12					; size = 1
_bLH$ = 16						; size = 1
?FaceTarget2D@CMatrix3x3@gen@@QAEXABVCVector2@2@_N1@Z PROC ; gen::CMatrix3x3::FaceTarget2D, COMDAT
; _this$ = ecx

; 2694 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH
	push	esi
	mov	esi, ecx

; 1331 : 	scale.x = Sqrt( e00*e00 + e01*e01 );

	movss	xmm1, DWORD PTR [esi+4]
	movss	xmm0, DWORD PTR [esi]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1332 : 	scale.y = Sqrt( e10*e10 + e11*e11 );

	movss	xmm1, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1332 : 	scale.y = Sqrt( e10*e10 + e11*e11 );

	mulss	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _scale$1$[esp+32], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1332 : 	scale.y = Sqrt( e10*e10 + e11*e11 );

	movss	xmm0, DWORD PTR [esi+12]
	mulss	xmm0, xmm0
	addss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 366  : 	return CVector2(v1.x - v2.x, v1.y - v2.y);

	mov	eax, DWORD PTR _target$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _scale$2$[esp+32], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 366  : 	return CVector2(v1.x - v2.x, v1.y - v2.y);

	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [esi+24]

; 50   : 	{}

	movss	DWORD PTR $T1[esp+32], xmm0

; 366  : 	return CVector2(v1.x - v2.x, v1.y - v2.y);

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2696 : 	CVector2 axis = Normalise(target - GetPosition2D());

	lea	eax, DWORD PTR $T1[esp+32]
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 366  : 	return CVector2(v1.x - v2.x, v1.y - v2.y);

	subss	xmm0, DWORD PTR [esi+28]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2696 : 	CVector2 axis = Normalise(target - GetPosition2D());

	push	eax
	lea	eax, DWORD PTR _axis$[esp+36]
	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 50   : 	{}

	movss	DWORD PTR $T1[esp+44], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2696 : 	CVector2 axis = Normalise(target - GetPosition2D());

	call	?Normalise@gen@@YA?AVCVector2@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 168  : 		return gen::IsZero( x*x + y*y );

	movss	xmm2, DWORD PTR _axis$[esp+44]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2696 : 	CVector2 axis = Normalise(target - GetPosition2D());

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 168  : 		return gen::IsZero( x*x + y*y );

	movss	xmm3, DWORD PTR _axis$[esp+32]
	movaps	xmm1, xmm2
	movaps	xmm0, xmm3
	mulss	xmm1, xmm2
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2697 : 	if (axis.IsZero()) return;

	ja	$LN1@FaceTarget

; 2698 : 	if (bUseYAxis)

	cmp	BYTE PTR _bUseYAxis$[ebp], 0
	je	SHORT $LN6@FaceTarget

; 2699 : 	{
; 2700 : 		e10 = axis.x * scale.y;
; 2701 : 		e11 = axis.y * scale.y;
; 2702 : 		if (bLH)

	cmp	BYTE PTR _bLH$[ebp], 0
	movss	xmm0, DWORD PTR _scale$2$[esp+32]
	movaps	xmm1, xmm0
	mulss	xmm2, xmm0
	mulss	xmm1, xmm3
	movss	DWORD PTR [esi+16], xmm2

; 2703 : 		{
; 2704 : 			e00 = e11 * scale.x;

	mulss	xmm2, DWORD PTR _scale$1$[esp+32]
	movss	DWORD PTR [esi+12], xmm1

; 2705 : 			e01 = -e10 * scale.x;

	mulss	xmm1, DWORD PTR _scale$1$[esp+32]
	je	SHORT $LN5@FaceTarget
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi], xmm2
	movss	DWORD PTR [esi+4], xmm1

; 2726 : 		}
; 2727 : 	}
; 2728 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN5@FaceTarget:

; 2706 : 		}
; 2707 : 		else
; 2708 : 		{
; 2709 : 			e00 = -e11 * scale.x;

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi], xmm2

; 2710 : 			e01 = e10 * scale.x;

	movss	DWORD PTR [esi+4], xmm1

; 2726 : 		}
; 2727 : 	}
; 2728 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN6@FaceTarget:

; 2711 : 		}
; 2712 : 	}
; 2713 : 	else
; 2714 : 	{
; 2715 : 		e00 = axis.x * scale.x;
; 2716 : 		e01 = axis.y * scale.x;
; 2717 : 		if (bLH)

	cmp	BYTE PTR _bLH$[ebp], 0
	movss	xmm0, DWORD PTR _scale$1$[esp+32]
	movaps	xmm1, xmm0
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	movss	DWORD PTR [esi+4], xmm0

; 2718 : 		{
; 2719 : 			e11 = -e00 * scale.y;
; 2720 : 			e10 = e01 * scale.y;

	mulss	xmm0, DWORD PTR _scale$2$[esp+32]
	movss	DWORD PTR [esi], xmm1
	mulss	xmm1, DWORD PTR _scale$2$[esp+32]
	je	SHORT $LN2@FaceTarget

; 2721 : 		}
; 2722 : 		else
; 2723 : 		{
; 2724 : 			e11 = e00 * scale.y;
; 2725 : 			e10 = -e01 * scale.y;

	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movss	DWORD PTR [esi+16], xmm1

; 2726 : 		}
; 2727 : 	}
; 2728 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@FaceTarget:

; 2721 : 		}
; 2722 : 		else
; 2723 : 		{
; 2724 : 			e11 = e00 * scale.y;
; 2725 : 			e10 = -e01 * scale.y;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movss	DWORD PTR [esi+16], xmm1
$LN1@FaceTarget:

; 2726 : 		}
; 2727 : 	}
; 2728 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FaceTarget2D@CMatrix3x3@gen@@QAEXABVCVector2@2@_N1@Z ENDP ; gen::CMatrix3x3::FaceTarget2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?FaceDirection@CMatrix3x3@gen@@QAEXABVCVector3@2@0_N@Z
_TEXT	SEGMENT
$T1 = -52						; size = 12
$T2 = -52						; size = 12
$T3 = -52						; size = 12
$T4 = -40						; size = 12
$T5 = -40						; size = 12
$T6 = -40						; size = 12
$T7 = -40						; size = 12
_axisX$ = -28						; size = 12
_axisZ$ = -16						; size = 12
_axisZ$1$ = -4						; size = 4
_axisY$2$ = 8						; size = 4
_axisZ$2$ = 8						; size = 4
_direction$ = 8						; size = 4
_axisY$3$ = 12						; size = 4
_up$ = 12						; size = 4
_axisZ$3$ = 16						; size = 4
_bLH$ = 16						; size = 1
?FaceDirection@CMatrix3x3@gen@@QAEXABVCVector3@2@0_N@Z PROC ; gen::CMatrix3x3::FaceDirection, COMDAT
; _this$ = ecx

; 2632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2633 : 	CVector3 axisX, axisY, axisZ;
; 2634 : 	if (bLH)

	cmp	BYTE PTR _bLH$[ebp], 0
	push	esi
	mov	esi, ecx
	je	$LN6@FaceDirect

; 2636 : 		axisZ = Normalise( direction );

	push	DWORD PTR _direction$[ebp]
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	lea	ecx, DWORD PTR _axisZ$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2636 : 		axisZ = Normalise( direction );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	cmp	ecx, eax
	je	SHORT $LN91@FaceDirect

; 101  : 		{
; 102  : 			x = v.x;

	movss	xmm4, DWORD PTR [eax]

; 103  : 			y = v.y;

	movss	xmm5, DWORD PTR [eax+4]

; 104  : 			z = v.z;

	movss	xmm6, DWORD PTR [eax+8]
	jmp	SHORT $LN95@FaceDirect
$LN91@FaceDirect:
	movss	xmm6, DWORD PTR _axisZ$[ebp+8]
	movss	xmm5, DWORD PTR _axisZ$[ebp+4]
	movss	xmm4, DWORD PTR _axisZ$[ebp]
$LN95@FaceDirect:

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm1, xmm4

; 104  : 			z = v.z;

	movss	DWORD PTR _axisZ$1$[ebp], xmm4

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm0, xmm5
	mulss	xmm1, xmm4
	mulss	xmm0, xmm5

; 104  : 			z = v.z;

	movss	DWORD PTR _axisZ$2$[ebp], xmm5
	movss	DWORD PTR _axisZ$3$[ebp], xmm6

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2637 : 		if (axisZ.IsZero()) return;

	ja	$LN89@FaceDirect
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	mov	eax, DWORD PTR _up$[ebp]
	movss	xmm3, DWORD PTR [eax+4]
	movss	xmm2, DWORD PTR [eax+8]
	movaps	xmm1, xmm3
	movaps	xmm0, xmm2
	mulss	xmm1, xmm6
	mulss	xmm0, xmm5
	mulss	xmm2, xmm4
	subss	xmm1, xmm0
	mulss	xmm3, xmm4

; 51   : 	{}

	movss	DWORD PTR $T6[ebp], xmm1

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	xmm1, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2638 : 		axisX = Normalise( Cross( up, axisZ ) );

	lea	eax, DWORD PTR $T6[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movaps	xmm0, xmm1
	mulss	xmm1, xmm5
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2638 : 		axisX = Normalise( Cross( up, axisZ ) );

	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	mulss	xmm0, xmm6
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2638 : 		axisX = Normalise( Cross( up, axisZ ) );

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	subss	xmm1, xmm3
	subss	xmm2, xmm0

; 51   : 	{}

	movss	DWORD PTR $T6[ebp+8], xmm1
	movss	DWORD PTR $T6[ebp+4], xmm2
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2638 : 		axisX = Normalise( Cross( up, axisZ ) );

	call	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	lea	ecx, DWORD PTR _axisX$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2638 : 		axisX = Normalise( Cross( up, axisZ ) );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	cmp	ecx, eax
	je	SHORT $LN92@FaceDirect

; 101  : 		{
; 102  : 			x = v.x;

	movss	xmm4, DWORD PTR [eax]

; 103  : 			y = v.y;

	movss	xmm5, DWORD PTR [eax+4]

; 104  : 			z = v.z;

	movss	xmm6, DWORD PTR [eax+8]
	jmp	SHORT $LN30@FaceDirect
$LN92@FaceDirect:
	movss	xmm6, DWORD PTR _axisX$[ebp+8]
	movss	xmm5, DWORD PTR _axisX$[ebp+4]
	movss	xmm4, DWORD PTR _axisX$[ebp]
$LN30@FaceDirect:

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm1, xmm5
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2639 : 		if (axisX.IsZero()) return;

	ja	$LN89@FaceDirect
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	xmm2, DWORD PTR _axisZ$2$[ebp]
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _axisZ$3$[ebp]
	movaps	xmm7, xmm6
	movss	xmm1, DWORD PTR _axisZ$1$[ebp]
	mulss	xmm7, xmm2
	subss	xmm7, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _axisZ$3$[ebp]
	movss	DWORD PTR _axisY$2$[ebp], xmm0
	movaps	xmm0, xmm6
	movss	xmm3, DWORD PTR _axisY$2$[ebp]
	mulss	xmm0, xmm1
	subss	xmm3, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm2
	movss	DWORD PTR _axisY$2$[ebp], xmm3
	movaps	xmm3, xmm5
	mulss	xmm3, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2642 : 	else

	jmp	$LN96@FaceDirect
$LN6@FaceDirect:
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	mov	eax, DWORD PTR _direction$[ebp]
	movss	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm0, DWORD PTR [eax]
	xorps	xmm0, xmm1

; 51   : 	{}

	movss	DWORD PTR $T5[ebp], xmm0

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	movss	xmm0, DWORD PTR [eax+4]
	xorps	xmm0, xmm1

; 51   : 	{}

	movss	DWORD PTR $T5[ebp+4], xmm0

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	movss	xmm0, DWORD PTR [eax+8]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2644 : 		axisZ = Normalise( -direction );

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	xorps	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2644 : 		axisZ = Normalise( -direction );

	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 51   : 	{}

	movss	DWORD PTR $T5[ebp+8], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2644 : 		axisZ = Normalise( -direction );

	call	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	lea	ecx, DWORD PTR _axisZ$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2644 : 		axisZ = Normalise( -direction );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	cmp	ecx, eax
	je	SHORT $LN93@FaceDirect

; 101  : 		{
; 102  : 			x = v.x;

	movss	xmm4, DWORD PTR [eax]

; 103  : 			y = v.y;

	movss	xmm5, DWORD PTR [eax+4]

; 104  : 			z = v.z;

	movss	xmm6, DWORD PTR [eax+8]
	jmp	SHORT $LN97@FaceDirect
$LN93@FaceDirect:
	movss	xmm6, DWORD PTR _axisZ$[ebp+8]
	movss	xmm5, DWORD PTR _axisZ$[ebp+4]
	movss	xmm4, DWORD PTR _axisZ$[ebp]
$LN97@FaceDirect:

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm1, xmm4

; 104  : 			z = v.z;

	movss	DWORD PTR _axisZ$1$[ebp], xmm4

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm0, xmm5
	mulss	xmm1, xmm4
	mulss	xmm0, xmm5

; 104  : 			z = v.z;

	movss	DWORD PTR _axisZ$2$[ebp], xmm5
	movss	DWORD PTR _axisZ$3$[ebp], xmm6

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2645 : 		if (axisZ.IsZero()) return;

	ja	$LN89@FaceDirect
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	mov	eax, DWORD PTR _up$[ebp]
	movss	xmm2, DWORD PTR [eax+8]
	movss	xmm3, DWORD PTR [eax+4]
	movaps	xmm1, xmm2
	movaps	xmm0, xmm3
	mulss	xmm1, xmm5
	mulss	xmm0, xmm6
	mulss	xmm2, xmm4
	subss	xmm1, xmm0
	mulss	xmm3, xmm4

; 51   : 	{}

	movss	DWORD PTR $T4[ebp], xmm1

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	xmm1, DWORD PTR [eax]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2646 : 		axisX = Normalise( Cross( axisZ, up ) );

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movaps	xmm0, xmm1
	mulss	xmm1, xmm5
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2646 : 		axisX = Normalise( Cross( axisZ, up ) );

	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	mulss	xmm0, xmm6
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2646 : 		axisX = Normalise( Cross( axisZ, up ) );

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	subss	xmm3, xmm1
	subss	xmm0, xmm2

; 51   : 	{}

	movss	DWORD PTR $T4[ebp+8], xmm3
	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2646 : 		axisX = Normalise( Cross( axisZ, up ) );

	call	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	lea	ecx, DWORD PTR _axisX$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2646 : 		axisX = Normalise( Cross( axisZ, up ) );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 100  : 		if ( this != &v )

	cmp	ecx, eax
	je	SHORT $LN94@FaceDirect

; 101  : 		{
; 102  : 			x = v.x;

	movss	xmm4, DWORD PTR [eax]

; 103  : 			y = v.y;

	movss	xmm5, DWORD PTR [eax+4]

; 104  : 			z = v.z;

	movss	xmm6, DWORD PTR [eax+8]
	jmp	SHORT $LN67@FaceDirect
$LN94@FaceDirect:
	movss	xmm6, DWORD PTR _axisX$[ebp+8]
	movss	xmm5, DWORD PTR _axisX$[ebp+4]
	movss	xmm4, DWORD PTR _axisX$[ebp]
$LN67@FaceDirect:

; 105  : 		}
; 106  : 		return *this;
; 107  : 	}
; 108  : 
; 109  : 
; 110  : 	/*-----------------------------------------------------------------------------------------
; 111  : 		Setters
; 112  : 	-----------------------------------------------------------------------------------------*/
; 113  : 
; 114  : 	// Set all three vector components
; 115  :     void Set
; 116  : 	(
; 117  : 		const TFloat32 xIn,
; 118  : 		const TFloat32 yIn,
; 119  : 		const TFloat32 zIn
; 120  : 	)
; 121  : 	{
; 122  : 		x = xIn;
; 123  : 		y = yIn;
; 124  : 		z = zIn;
; 125  : 	}
; 126  : 
; 127  : 	// Set the vector through a pointer to three floats
; 128  :     void Set( const TFloat32* pfElts )
; 129  : 	{
; 130  : 		x = pfElts[0];
; 131  : 		y = pfElts[1];
; 132  : 		z = pfElts[2];
; 133  : 	}
; 134  : 
; 135  : 	// Set as vector between two points (p1 to p2)
; 136  :     void Set
; 137  : 	(
; 138  : 		const CVector3& p1,
; 139  : 		const CVector3& p2
; 140  : 	)
; 141  : 	{
; 142  : 		x = p2.x - p1.x;
; 143  : 		y = p2.y - p1.y;
; 144  : 		z = p2.z - p1.z;
; 145  : 	}
; 146  : 
; 147  : 	// Set the vector to (0,0,0)
; 148  :     void SetZero()
; 149  : 	{
; 150  : 		x = y = z = 0.0f;
; 151  : 	}
; 152  : 
; 153  : 
; 154  : 	/*-----------------------------------------------------------------------------------------
; 155  : 		Array access
; 156  : 	-----------------------------------------------------------------------------------------*/
; 157  : 
; 158  : 	// Access the x, y & z components in array style (i.e. v[0], v[1], v[2] same as v.x, v.y, v.z)
; 159  : 	// No validation on index
; 160  :     TFloat32& operator[]( const TUInt32 index )
; 161  : 	{
; 162  : 		return (&x)[index];
; 163  : 	}
; 164  : 
; 165  : 	// Access the x, y & z elements in array style - const result
; 166  : 	// No validation on index
; 167  : 	const TFloat32& operator[]( const TUInt32 index ) const
; 168  : 	{
; 169  : 		return (&x)[index];
; 170  : 	}
; 171  : 
; 172  : 
; 173  : 	/*-----------------------------------------------------------------------------------------
; 174  : 		Comparisons
; 175  : 	-----------------------------------------------------------------------------------------*/
; 176  : 	// Equality operators defined as non-member operations after the class definition
; 177  : 
; 178  : 	// Test if the vector is zero length (i.e. = (0,0,0))
; 179  : 	// Uses BaseMath.h float approximation function 'IsZero' with default epsilon (margin of error)
; 180  : 	bool IsZero() const
; 181  : 	{
; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movaps	xmm1, xmm5
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2647 : 		if (axisX.IsZero()) return;

	ja	$LN89@FaceDirect
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	xmm2, DWORD PTR _axisZ$2$[ebp]
	movaps	xmm0, xmm6
	movss	xmm1, DWORD PTR _axisZ$1$[ebp]
	movaps	xmm7, xmm5
	mulss	xmm7, DWORD PTR _axisZ$3$[ebp]
	mulss	xmm0, xmm2
	subss	xmm7, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm1
	movss	DWORD PTR _axisY$2$[ebp], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR _axisZ$3$[ebp]
	movss	xmm3, DWORD PTR _axisY$2$[ebp]
	subss	xmm3, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm1
	movss	DWORD PTR _axisY$2$[ebp], xmm3
	movaps	xmm3, xmm4
	mulss	xmm3, xmm2
$LN96@FaceDirect:
	subss	xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 478  : 	pfElts[0] = v.x;

	movss	DWORD PTR [esi], xmm4

; 479  : 	pfElts[1] = v.y;

	movss	xmm0, DWORD PTR _axisY$2$[ebp]
	movss	DWORD PTR [esi+4], xmm5

; 480  : 	pfElts[2] = v.z;

	movss	DWORD PTR [esi+8], xmm6

; 479  : 	pfElts[1] = v.y;

	movss	DWORD PTR [esi+16], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	DWORD PTR _axisY$3$[ebp], xmm3
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 480  : 	pfElts[2] = v.z;

	movss	xmm0, DWORD PTR _axisY$3$[ebp]
	movss	xmm3, DWORD PTR _axisZ$3$[ebp]

; 478  : 	pfElts[0] = v.x;

	movss	DWORD PTR [esi+12], xmm7

; 480  : 	pfElts[2] = v.z;

	movss	DWORD PTR [esi+20], xmm0

; 478  : 	pfElts[0] = v.x;

	movss	DWORD PTR [esi+24], xmm1

; 479  : 	pfElts[1] = v.y;

	movss	DWORD PTR [esi+28], xmm2

; 480  : 	pfElts[2] = v.z;

	movss	DWORD PTR [esi+32], xmm3
$LN89@FaceDirect:
	pop	esi

; 2648 : 		axisY = Cross( axisX, axisZ ); // Will already be normalised
; 2649 : 	}
; 2650 : 	SetRow( 0, axisX );
; 2651 : 	SetRow( 1, axisY );
; 2652 : 	SetRow( 2, axisZ );
; 2653 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FaceDirection@CMatrix3x3@gen@@QAEXABVCVector3@2@0_N@Z ENDP ; gen::CMatrix3x3::FaceDirection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeScaling2D@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
_fScale$ = 8						; size = 4
?MakeScaling2D@CMatrix3x3@gen@@QAEXM@Z PROC		; gen::CMatrix3x3::MakeScaling2D, COMDAT
; _this$ = ecx

; 2513 : {

	push	ebp
	mov	ebp, esp

; 2514 : 	e00 = fScale;

	movss	xmm1, DWORD PTR _fScale$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 2515 : 	e01 = 0.0f;

	mov	DWORD PTR [ecx+4], 0

; 2516 : 	e02 = 0.0f;

	mov	DWORD PTR [ecx+8], 0

; 2517 : 
; 2518 : 	e10 = 0.0f;

	mov	DWORD PTR [ecx+12], 0

; 2519 : 	e11 = fScale;

	movss	DWORD PTR [ecx+16], xmm1

; 2520 : 	e12 = 0.0f;

	mov	DWORD PTR [ecx+20], 0

; 2521 : 
; 2522 : 	e20 = 0.0f;

	mov	DWORD PTR [ecx+24], 0

; 2523 : 	e21 = 0.0f;

	mov	DWORD PTR [ecx+28], 0

; 2524 : 	e22 = 1.0f;

	mov	DWORD PTR [ecx+32], 1065353216		; 3f800000H

; 2525 : }

	pop	ebp
	ret	4
?MakeScaling2D@CMatrix3x3@gen@@QAEXM@Z ENDP		; gen::CMatrix3x3::MakeScaling2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeScaling2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z
_TEXT	SEGMENT
_scale$ = 8						; size = 4
?MakeScaling2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z PROC ; gen::CMatrix3x3::MakeScaling2D, COMDAT
; _this$ = ecx

; 2497 : {

	push	ebp
	mov	ebp, esp

; 2498 : 	e00 = scale.x;

	mov	edx, DWORD PTR _scale$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 2499 : 	e01 = 0.0f;

	mov	DWORD PTR [ecx+4], 0

; 2500 : 	e02 = 0.0f;

	mov	DWORD PTR [ecx+8], 0

; 2501 : 
; 2502 : 	e10 = 0.0f;

	mov	DWORD PTR [ecx+12], 0

; 2503 : 	e11 = scale.y;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+16], eax

; 2504 : 	e12 = 0.0f;

	mov	DWORD PTR [ecx+20], 0

; 2505 : 
; 2506 : 	e20 = 0.0f;

	mov	DWORD PTR [ecx+24], 0

; 2507 : 	e21 = 0.0f;

	mov	DWORD PTR [ecx+28], 0

; 2508 : 	e22 = 1.0f;

	mov	DWORD PTR [ecx+32], 1065353216		; 3f800000H

; 2509 : }

	pop	ebp
	ret	4
?MakeScaling2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z ENDP ; gen::CMatrix3x3::MakeScaling2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeRotation2D@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
_s$1$ = -4						; size = 4
_fAngle$ = 8						; size = 4
?MakeRotation2D@CMatrix3x3@gen@@QAEXM@Z PROC		; gen::CMatrix3x3::MakeRotation2D, COMDAT
; _this$ = ecx

; 2477 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _fAngle$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	push	esi
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2477 : {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _s$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _fAngle$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2482 : 	e01 = s;

	movss	xmm2, DWORD PTR _s$1$[ebp]
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2483 : 	e02 = 0.0f;

	mov	DWORD PTR [esi+8], 0

; 2484 : 
; 2485 : 	e10 = -s;
; 2486 : 	e11 = c;
; 2487 : 	e12 = 0.0f;

	mov	DWORD PTR [esi+20], 0

; 2488 : 
; 2489 : 	e20 = 0.0f;

	mov	DWORD PTR [esi+24], 0

; 2490 : 	e21 = 0.0f;

	mov	DWORD PTR [esi+28], 0
	movss	DWORD PTR [esi+4], xmm2
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi], xmm1
	movss	DWORD PTR [esi+12], xmm2
	movss	DWORD PTR [esi+16], xmm1

; 2491 : 	e22 = 1.0f;

	mov	DWORD PTR [esi+32], 1065353216		; 3f800000H
	pop	esi

; 2492 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MakeRotation2D@CMatrix3x3@gen@@QAEXM@Z ENDP		; gen::CMatrix3x3::MakeRotation2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeTranslation2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z
_TEXT	SEGMENT
_translate$ = 8						; size = 4
?MakeTranslation2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z PROC ; gen::CMatrix3x3::MakeTranslation2D, COMDAT
; _this$ = ecx

; 2460 : {

	push	ebp
	mov	ebp, esp
	mov	edx, ecx

; 2461 : 	e00 = 1.0f;
; 2462 : 	e01 = 0.0f;
; 2463 : 	e02 = 0.0f;
; 2464 : 
; 2465 : 	e10 = 0.0f;
; 2466 : 	e11 = 1.0f;
; 2467 : 	e12 = 0.0f;
; 2468 : 
; 2469 : 	e20 = translate.x;

	mov	ecx, DWORD PTR _translate$[ebp]
	mov	DWORD PTR [edx], 1065353216		; 3f800000H
	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 1065353216		; 3f800000H
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+24], eax

; 2470 : 	e21 = translate.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+28], eax

; 2471 : 	e22 = 1.0f;

	mov	DWORD PTR [edx+32], 1065353216		; 3f800000H

; 2472 : }

	pop	ebp
	ret	4
?MakeTranslation2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z ENDP ; gen::CMatrix3x3::MakeTranslation2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeScaling@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
_fScale$ = 8						; size = 4
?MakeScaling@CMatrix3x3@gen@@QAEXM@Z PROC		; gen::CMatrix3x3::MakeScaling, COMDAT
; _this$ = ecx

; 2134 : {

	push	ebp
	mov	ebp, esp

; 2135 : 	e00 = fScale;

	movss	xmm1, DWORD PTR _fScale$[ebp]
	movss	DWORD PTR [ecx], xmm1

; 2136 : 	e01 = 0.0f;

	mov	DWORD PTR [ecx+4], 0

; 2137 : 	e02 = 0.0f;

	mov	DWORD PTR [ecx+8], 0

; 2138 : 
; 2139 : 	e10 = 0.0f;

	mov	DWORD PTR [ecx+12], 0

; 2140 : 	e11 = fScale;

	movss	DWORD PTR [ecx+16], xmm1

; 2141 : 	e12 = 0.0f;

	mov	DWORD PTR [ecx+20], 0

; 2142 : 
; 2143 : 	e20 = 0.0f;

	mov	DWORD PTR [ecx+24], 0

; 2144 : 	e21 = 0.0f;

	mov	DWORD PTR [ecx+28], 0

; 2145 : 	e22 = fScale;

	movss	DWORD PTR [ecx+32], xmm1

; 2146 : }

	pop	ebp
	ret	4
?MakeScaling@CMatrix3x3@gen@@QAEXM@Z ENDP		; gen::CMatrix3x3::MakeScaling
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeScaling@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z
_TEXT	SEGMENT
_scale$ = 8						; size = 4
?MakeScaling@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z PROC	; gen::CMatrix3x3::MakeScaling, COMDAT
; _this$ = ecx

; 2118 : {

	push	ebp
	mov	ebp, esp

; 2119 : 	e00 = scale.x;

	mov	edx, DWORD PTR _scale$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 2120 : 	e01 = 0.0f;

	mov	DWORD PTR [ecx+4], 0

; 2121 : 	e02 = 0.0f;

	mov	DWORD PTR [ecx+8], 0

; 2122 : 
; 2123 : 	e10 = 0.0f;

	mov	DWORD PTR [ecx+12], 0

; 2124 : 	e11 = scale.y;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+16], eax

; 2125 : 	e12 = 0.0f;

	mov	DWORD PTR [ecx+20], 0

; 2126 : 
; 2127 : 	e20 = 0.0f;

	mov	DWORD PTR [ecx+24], 0

; 2128 : 	e21 = 0.0f;

	mov	DWORD PTR [ecx+28], 0

; 2129 : 	e22 = scale.z;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+32], eax

; 2130 : }

	pop	ebp
	ret	4
?MakeScaling@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z ENDP	; gen::CMatrix3x3::MakeScaling
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z
_TEXT	SEGMENT
_e$2 = -276						; size = 4
_t$1$ = -272						; size = 4
_axisNorm$3 = -268					; size = 12
_c$1$ = -256						; size = 4
_sx$1$ = -252						; size = 4
_s$1$ = -252						; size = 4
$T4 = -248						; size = 76
$T5 = -172						; size = 76
$T6 = -96						; size = 76
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_axis$ = 8						; size = 4
_fAngle$ = 12						; size = 4
?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z PROC ; gen::CMatrix3x3::MakeRotation, COMDAT
; _this$ = ecx

; 2081 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	movss	xmm0, DWORD PTR _fAngle$[ebp]
	mov	edi, DWORD PTR _axis$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2082 : 	GEN_GUARD;

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _s$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _fAngle$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	xorps	xmm1, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2088 : 	CVector3 axisNorm = Normalise( axis );

	lea	eax, DWORD PTR _axisNorm$3[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2088 : 	CVector3 axisNorm = Normalise( axis );

	push	edi
	push	eax
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	movss	DWORD PTR _c$1$[ebp], xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2086 : 	TFloat32 t = 1.0f - c;

	movss	DWORD PTR _t$1$[ebp], xmm0

; 2088 : 	CVector3 axisNorm = Normalise( axis );

	call	?Normalise@gen@@YA?AVCVector3@1@ABV21@@Z ; gen::Normalise
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movss	xmm2, DWORD PTR _axisNorm$3[ebp+4]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2088 : 	CVector3 axisNorm = Normalise( axis );

	add	esp, 8
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movss	xmm4, DWORD PTR _axisNorm$3[ebp]
	movaps	xmm1, xmm2
	movss	xmm6, DWORD PTR _axisNorm$3[ebp+8]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 2089 : 	GEN_ASSERT( !axisNorm.IsZero(), "Zero length axis" );

	jbe	SHORT $LN1@MakeRotati
	push	2089					; 00000829H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BB@OPALDBID@Zero?5length?5axis?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN36@MakeRotati:
$LN1@MakeRotati:

; 2090 : 
; 2091 : 	TFloat32 sx = s * axisNorm.x;

	movss	xmm1, DWORD PTR _s$1$[ebp]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm1

; 2092 : 	TFloat32 sy = s * axisNorm.y;

	movaps	xmm7, xmm2
	mulss	xmm7, xmm1

; 2093 : 	TFloat32 sz = s * axisNorm.z;

	movaps	xmm5, xmm6
	mulss	xmm5, xmm1

; 2094 : 	TFloat32 tx = t * axisNorm.x;  
; 2095 : 	TFloat32 ty = t * axisNorm.y;

	movaps	xmm3, xmm2
	movss	xmm1, DWORD PTR _t$1$[ebp]
	movss	DWORD PTR _sx$1$[ebp], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm1
	mulss	xmm3, xmm1

; 2096 : 	TFloat32 tz = t * axisNorm.z;

	mulss	xmm6, xmm1

; 2097 : 	TFloat32 txy = ty * axisNorm.x;

	movaps	xmm1, xmm3

; 2098 : 	TFloat32 tyz = tz * axisNorm.y;
; 2099 : 	TFloat32 tzx = tx * axisNorm.z;
; 2100 : 
; 2101 : 	e00 = tx * axisNorm.x + c;
; 2102 : 	e01 = txy + sz;
; 2103 : 	e02 = tzx - sy;
; 2104 : 
; 2105 : 	e10 = txy - sz; 
; 2106 : 	e11 = ty * axisNorm.y + c;

	mulss	xmm3, DWORD PTR _axisNorm$3[ebp+4]
	mulss	xmm1, xmm4
	movaps	xmm4, xmm6
	mulss	xmm4, xmm2
	movaps	xmm2, xmm0
	mulss	xmm0, DWORD PTR _axisNorm$3[ebp]
	mulss	xmm2, DWORD PTR _axisNorm$3[ebp+8]
	addss	xmm0, DWORD PTR _c$1$[ebp]

; 2107 : 	e12 = tyz + sx;
; 2108 : 
; 2109 : 	e20 = tzx + sy;
; 2110 : 	e21 = tyz - sx;
; 2111 : 	e22 = tz * axisNorm.z + c;

	mulss	xmm6, DWORD PTR _axisNorm$3[ebp+8]
	addss	xmm3, DWORD PTR _c$1$[ebp]
	addss	xmm6, DWORD PTR _c$1$[ebp]
	movss	DWORD PTR [esi], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, xmm5
	subss	xmm1, xmm5
	movss	DWORD PTR [esi+16], xmm3
	movss	DWORD PTR [esi+32], xmm6
	movss	DWORD PTR [esi+4], xmm0
	movaps	xmm0, xmm2
	subss	xmm0, xmm7
	movss	DWORD PTR [esi+12], xmm1
	addss	xmm2, xmm7
	movss	DWORD PTR [esi+8], xmm0
	movaps	xmm0, xmm4
	addss	xmm0, DWORD PTR _sx$1$[ebp]
	subss	xmm4, DWORD PTR _sx$1$[ebp]
	movss	DWORD PTR [esi+24], xmm2
	movss	DWORD PTR [esi+20], xmm0
	movss	DWORD PTR [esi+28], xmm4

; 2114 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z$0:

; 2112 : 
; 2113 : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BO@FPKFHDMJ@gen?3?3CMatrix3x3?3?3MakeRotation?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	__CxxThrowException@8
$LN37@MakeRotati:
__catch$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z$1:
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BO@FPKFHDMJ@gen?3?3CMatrix3x3?3?3MakeRotation?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN38@MakeRotati:
$LN35@MakeRotati:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z ENDP ; gen::CMatrix3x3::MakeRotation
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z
_TEXT	SEGMENT
_e$2 = -272						; size = 4
_sZ$1$ = -268						; size = 4
_cY$1$ = -264						; size = 4
_sY$1$ = -260						; size = 4
_sX$1$ = -256						; size = 4
_cX$1$ = -252						; size = 4
$T3 = -248						; size = 76
$T4 = -172						; size = 76
$T5 = -96						; size = 76
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_angles$ = 8						; size = 12
_eRotOrder$ = 20					; size = 4
?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z PROC ; gen::CMatrix3x3::MakeRotation, COMDAT
; _this$ = ecx

; 1967 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	movss	xmm0, DWORD PTR _angles$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1968 : 	GEN_GUARD;

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sX$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _angles$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cX$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _angles$[ebp+4]

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sY$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _angles$[ebp+4]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _cY$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _angles$[ebp+8]

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sZ$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _angles$[ebp+8]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1975 : 	switch (eRotOrder)

	mov	eax, DWORD PTR _eRotOrder$[ebp]
	xorps	xmm6, xmm6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm6, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1975 : 	switch (eRotOrder)

	cmp	eax, 5
	ja	$LN1@MakeRotati
	jmp	DWORD PTR $LN58@MakeRotati[eax*4]
$LN7@MakeRotati:

; 1976 : 	{
; 1977 : 		case kZYX:
; 1978 : 		{
; 1979 : 			e00 = cZ * cY;

	movss	xmm4, DWORD PTR _cY$1$[ebp]
	movaps	xmm0, xmm6

; 1980 : 			e01 = sZ * cX + cZ * sY * sX;

	movss	xmm5, DWORD PTR _sY$1$[ebp]
	movaps	xmm2, xmm6
	movss	xmm3, DWORD PTR _sZ$1$[ebp]
	movss	xmm7, DWORD PTR _sX$1$[ebp]
	mulss	xmm0, xmm4
	mulss	xmm2, xmm5
	movss	DWORD PTR [esi], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	movaps	xmm1, xmm2

; 1981 : 			e02 = sZ * sX + -cZ * sY * cX;
; 1982 : 
; 1983 : 			e10 = -sZ * cY;
; 1984 : 			e11 = cZ * cX + -sZ * sY * sX;
; 1985 : 			e12 = cZ * sX + sZ * sY * cX;
; 1986 : 
; 1987 : 			e20 = sY;

	movss	DWORD PTR [esi+24], xmm5
	mulss	xmm2, DWORD PTR _cX$1$[ebp]
	mulss	xmm1, xmm7
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm7
	subss	xmm0, xmm2
	movss	DWORD PTR [esi+4], xmm1
	movaps	xmm1, xmm6
	mulss	xmm6, xmm7
	mulss	xmm1, DWORD PTR _cX$1$[ebp]
	movss	DWORD PTR [esi+8], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm4
	mulss	xmm3, xmm5
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movaps	xmm0, xmm3
	mulss	xmm3, DWORD PTR _cX$1$[ebp]
	mulss	xmm0, xmm7
	addss	xmm3, xmm6
	subss	xmm1, xmm0

; 1988 : 			e21 = -cY * sX;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm7
	movss	DWORD PTR [esi+20], xmm3
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+16], xmm1
	movss	DWORD PTR [esi+28], xmm0
$LN56@MakeRotati:

; 1989 : 			e22 = cY * cX;

	mulss	xmm4, DWORD PTR _cX$1$[ebp]
$LN57@MakeRotati:
	movss	DWORD PTR [esi+32], xmm4
$LN16@MakeRotati:

; 2073 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN6@MakeRotati:

; 1990 : 			break;
; 1991 : 		}
; 1992 : 		case kYZX:
; 1993 : 		{
; 1994 : 			e00 = cY * cZ;

	movss	xmm4, DWORD PTR _cY$1$[ebp]
	movaps	xmm0, xmm6

; 1995 : 			e01 = cY * sZ * cX + sY * sX;

	movss	xmm3, DWORD PTR _sZ$1$[ebp]
	movss	xmm5, DWORD PTR _sY$1$[ebp]
	movaps	xmm2, xmm3
	movss	xmm7, DWORD PTR _sX$1$[ebp]
	mulss	xmm0, xmm4
	mulss	xmm2, xmm4
	movss	DWORD PTR [esi], xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm7
	movaps	xmm1, xmm2

; 1996 : 			e02 = cY * sZ * sX + -sY * cX;

	mulss	xmm2, xmm7
	mulss	xmm1, DWORD PTR _cX$1$[ebp]
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	subss	xmm2, xmm0
	movss	DWORD PTR [esi+4], xmm1

; 1997 : 
; 1998 : 			e10 = -sZ;

	movaps	xmm0, xmm3

; 1999 : 			e11 = cZ * cX;
; 2000 : 			e12 = cZ * sX;
; 2001 : 
; 2002 : 			e20 = sY * cZ;
; 2003 : 			e21 = sY * sZ * cX + -cY * sX;

	mulss	xmm3, xmm5
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movaps	xmm0, xmm6
	movss	DWORD PTR [esi+8], xmm2
	movaps	xmm1, xmm3
	movss	xmm2, DWORD PTR _cX$1$[ebp]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm2
	movss	DWORD PTR [esi+16], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm7

; 2004 : 			e22 = sY * sZ * sX + cY * cX;

	mulss	xmm3, xmm7
	movss	DWORD PTR [esi+20], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm7
	mulss	xmm4, xmm2
	subss	xmm1, xmm0
	mulss	xmm6, xmm5
	addss	xmm3, xmm4
	movss	DWORD PTR [esi+24], xmm6
	movss	DWORD PTR [esi+28], xmm1
	movss	DWORD PTR [esi+32], xmm3

; 2005 : 			break;

	jmp	$LN16@MakeRotati
$LN5@MakeRotati:

; 2006 : 		}
; 2007 : 		case kXZY:
; 2008 : 		{
; 2009 : 			e00 = cZ * cY;

	movss	xmm5, DWORD PTR _cY$1$[ebp]
	movaps	xmm0, xmm6

; 2010 : 			e01 = sZ;
; 2011 : 			e02 = -cZ * sY;

	movss	xmm7, DWORD PTR _sY$1$[ebp]
	movss	xmm4, DWORD PTR _sZ$1$[ebp]

; 2012 : 
; 2013 : 			e10 = -cX * sZ * cY + sX * sY;

	movaps	xmm1, xmm7
	mulss	xmm1, DWORD PTR _sX$1$[ebp]
	movaps	xmm2, xmm4
	mulss	xmm2, DWORD PTR _cX$1$[ebp]
	mulss	xmm0, xmm5
	movss	DWORD PTR [esi+4], xmm4

; 2014 : 			e11 = cX * cZ;
; 2015 : 			e12 = cX * sZ * sY + sX * cY;
; 2016 : 
; 2017 : 			e20 = sX * sZ * cY + cX * sY;

	mulss	xmm4, DWORD PTR _sX$1$[ebp]
	movss	DWORD PTR [esi], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm7
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+8], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm5
	mulss	xmm2, xmm7
	subss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR _cX$1$[ebp]

; 2018 : 			e21 = -sX * cZ;

	mulss	xmm6, DWORD PTR _sX$1$[ebp]
	movss	DWORD PTR [esi+16], xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _sX$1$[ebp]
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm1
	movaps	xmm1, xmm4
	addss	xmm2, xmm0
	mulss	xmm1, xmm5

; 2019 : 			e22 = -sX * sZ * sY + cX * cY;

	mulss	xmm5, DWORD PTR _cX$1$[ebp]
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	mulss	xmm4, xmm7
	addss	xmm1, xmm0
	movss	DWORD PTR [esi+20], xmm2
	movss	DWORD PTR [esi+28], xmm6
	subss	xmm5, xmm4
	movss	DWORD PTR [esi+24], xmm1
	movss	DWORD PTR [esi+32], xmm5

; 2020 : 			break;

	jmp	$LN16@MakeRotati
$LN4@MakeRotati:

; 2021 : 		}
; 2022 : 		case kZXY:
; 2023 : 		{
; 2024 : 			e00 = cZ * cY + sZ * sX * sY;

	movss	xmm3, DWORD PTR _sZ$1$[ebp]
	movaps	xmm0, xmm6
	movss	xmm7, DWORD PTR _sX$1$[ebp]
	movaps	xmm2, xmm3
	movss	xmm5, DWORD PTR _sY$1$[ebp]
	movss	xmm4, DWORD PTR _cY$1$[ebp]
	mulss	xmm2, xmm7
	mulss	xmm0, xmm4
	movaps	xmm1, xmm2

; 2025 : 			e01 = sZ * cX;
; 2026 : 			e02 = -cZ * sY + sZ * sX * cY;

	mulss	xmm2, xmm4
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	movss	DWORD PTR [esi+4], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm5
	movss	DWORD PTR [esi], xmm1
	subss	xmm2, xmm0

; 2027 : 
; 2028 : 			e10 = -sZ * cY + cZ * sX * sY;

	movaps	xmm0, xmm3
	mulss	xmm0, xmm4

; 2029 : 			e11 = cZ * cX;
; 2030 : 			e12 = sZ * sY + cZ * sX * cY;

	mulss	xmm3, xmm5
	movss	DWORD PTR [esi+8], xmm2
	movaps	xmm2, xmm6
	mulss	xmm2, xmm7

; 2031 : 
; 2032 : 			e20 = cX * sY;
; 2033 : 			e21 = -sX;

	xorps	xmm7, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+28], xmm7
	movaps	xmm1, xmm2
	mulss	xmm2, xmm4
	mulss	xmm1, xmm5
	addss	xmm2, xmm3
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR _cX$1$[ebp]
	mulss	xmm6, xmm0
	mulss	xmm5, xmm0
	movss	DWORD PTR [esi+12], xmm1
	movss	DWORD PTR [esi+16], xmm6
	movss	DWORD PTR [esi+20], xmm2
	movss	DWORD PTR [esi+24], xmm5

; 2034 : 			e22 = cX * cY;

	mulss	xmm4, xmm0

; 2035 : 			break;

	jmp	$LN57@MakeRotati
$LN3@MakeRotati:

; 2036 : 		}
; 2037 : 		case kYXZ:
; 2038 : 		{
; 2039 : 			e00 = cY * cZ + -sY * sX * sZ;

	movss	xmm5, DWORD PTR _sY$1$[ebp]
	movaps	xmm1, xmm6
	movss	xmm7, DWORD PTR _sX$1$[ebp]
	movaps	xmm2, xmm5
	movss	xmm3, DWORD PTR _sZ$1$[ebp]
	movss	xmm4, DWORD PTR _cY$1$[ebp]
	mulss	xmm2, xmm7
	mulss	xmm1, xmm4
	movaps	xmm0, xmm2

; 2040 : 			e01 = cY * sZ + sY * sX * cZ;
; 2041 : 			e02 = -sY * cX;
; 2042 : 
; 2043 : 			e10 = -cX * sZ;
; 2044 : 			e11 = cX * cZ;
; 2045 : 			e12 = sX;

	movss	DWORD PTR [esi+20], xmm7
	mulss	xmm0, xmm3
	mulss	xmm2, xmm6
	subss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm4
	addss	xmm2, xmm0
	movss	DWORD PTR [esi], xmm1
	movaps	xmm0, xmm5
	movss	DWORD PTR [esi+4], xmm2
	movss	xmm2, DWORD PTR _cX$1$[ebp]
	mulss	xmm0, xmm2
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+8], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm2
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm2

; 2046 : 
; 2047 : 			e20 = sY * cZ + cY * sX * sZ;

	movaps	xmm2, xmm4
	mulss	xmm2, xmm7
	movss	DWORD PTR [esi+16], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm5
	movaps	xmm1, xmm2

; 2048 : 			e21 = sY * sZ + -cY * sX * cZ;

	mulss	xmm2, xmm6
	mulss	xmm1, xmm3
	mulss	xmm3, xmm5
	addss	xmm1, xmm0
	subss	xmm3, xmm2
	movss	DWORD PTR [esi+24], xmm1
	movss	DWORD PTR [esi+28], xmm3

; 2049 : 			e22 = cY * cX;
; 2050 : 			break;

	jmp	$LN56@MakeRotati
$LN2@MakeRotati:

; 2051 : 		}
; 2052 : 		case kXYZ:
; 2053 : 		{
; 2054 : 			e00 = cY * cZ;

	movss	xmm4, DWORD PTR _cY$1$[ebp]
	movaps	xmm0, xmm6

; 2055 : 			e01 = cY * sZ;

	movss	xmm3, DWORD PTR _sZ$1$[ebp]

; 2056 : 			e02 = -sY;

	movss	xmm5, DWORD PTR _sY$1$[ebp]

; 2057 : 
; 2058 : 			e10 = sX * sY * cZ + -cX * sZ;

	movss	xmm7, DWORD PTR _sX$1$[ebp]
	movaps	xmm2, xmm5
	mulss	xmm0, xmm4
	mulss	xmm2, xmm7
	movss	DWORD PTR [esi], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm4
	movaps	xmm1, xmm2

; 2059 : 			e11 = sX * sY * sZ + cX * cZ;

	mulss	xmm2, xmm3
	movss	DWORD PTR [esi+4], xmm0
	movaps	xmm0, xmm5
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000

; 2060 : 			e12 = sX * cY;
; 2061 : 
; 2062 : 			e20 = cX * sY * cZ + sX * sZ;

	mulss	xmm5, DWORD PTR _cX$1$[ebp]
	movss	DWORD PTR [esi+8], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	mulss	xmm1, xmm6
	subss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR _cX$1$[ebp]
	addss	xmm2, xmm0
	movss	DWORD PTR [esi+12], xmm1
	movaps	xmm0, xmm4
	movaps	xmm1, xmm5
	mulss	xmm0, xmm7
	mulss	xmm1, xmm6
	movss	DWORD PTR [esi+20], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm7

; 2063 : 			e21 = cX * sY * sZ + -sX * cZ;

	mulss	xmm5, xmm3
	mulss	xmm6, xmm7
	addss	xmm1, xmm0
	movss	DWORD PTR [esi+16], xmm2
	subss	xmm5, xmm6
	movss	DWORD PTR [esi+24], xmm1
	movss	DWORD PTR [esi+28], xmm5
	jmp	$LN56@MakeRotati
$LN1@MakeRotati:

; 2064 : 			e22 = cX * cY;
; 2065 : 			break;
; 2066 : 		}
; 2067 : 
; 2068 : 		default:
; 2069 : 			GEN_ERROR( "Invalid parameter" );

	push	2069					; 00000815H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BC@DBAKKFEN@Invalid?5parameter?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN59@MakeRotati:
__catch$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z$0:

; 2070 : 	}
; 2071 : 
; 2072 : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BO@FPKFHDMJ@gen?3?3CMatrix3x3?3?3MakeRotation?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN60@MakeRotati:
__catch$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z$1:
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BO@FPKFHDMJ@gen?3?3CMatrix3x3?3?3MakeRotation?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN61@MakeRotati:
$LN55@MakeRotati:
	npad	1
$LN58@MakeRotati:

; 2073 : }

	DD	$LN2@MakeRotati
	DD	$LN5@MakeRotati
	DD	$LN6@MakeRotati
	DD	$LN3@MakeRotati
	DD	$LN4@MakeRotati
	DD	$LN7@MakeRotati
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z ENDP ; gen::CMatrix3x3::MakeRotation
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeRotationZ@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
_sZ$1$ = -4						; size = 4
_z$ = 8							; size = 4
?MakeRotationZ@CMatrix3x3@gen@@QAEXM@Z PROC		; gen::CMatrix3x3::MakeRotationZ, COMDAT
; _this$ = ecx

; 1943 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _z$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	push	esi
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1943 : {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sZ$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _z$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1948 : 	e01 = sZ;

	movss	xmm2, DWORD PTR _sZ$1$[ebp]
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1949 : 	e02 = 0.0f;

	mov	DWORD PTR [esi+8], 0

; 1950 : 
; 1951 : 	e10 = -sZ;
; 1952 : 	e11 = cZ;
; 1953 : 	e12 = 0.0f;

	mov	DWORD PTR [esi+20], 0

; 1954 : 
; 1955 : 	e20 = 0.0f;

	mov	DWORD PTR [esi+24], 0

; 1956 : 	e21 = 0.0f;

	mov	DWORD PTR [esi+28], 0
	movss	DWORD PTR [esi+4], xmm2
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi], xmm1
	movss	DWORD PTR [esi+12], xmm2
	movss	DWORD PTR [esi+16], xmm1

; 1957 : 	e22 = 1.0f;

	mov	DWORD PTR [esi+32], 1065353216		; 3f800000H
	pop	esi

; 1958 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MakeRotationZ@CMatrix3x3@gen@@QAEXM@Z ENDP		; gen::CMatrix3x3::MakeRotationZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeRotationY@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
_sY$1$ = -4						; size = 4
_y$ = 8							; size = 4
?MakeRotationY@CMatrix3x3@gen@@QAEXM@Z PROC		; gen::CMatrix3x3::MakeRotationY, COMDAT
; _this$ = ecx

; 1924 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	push	esi
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1924 : {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sY$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1930 : 	e02 = -sY;

	movss	xmm2, DWORD PTR _sY$1$[ebp]
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1929 : 	e01 = 0.0f;

	mov	DWORD PTR [esi+4], 0

; 1931 : 
; 1932 : 	e10 = 0.0f;

	mov	DWORD PTR [esi+12], 0

; 1933 : 	e11 = 1.0f;

	mov	DWORD PTR [esi+16], 1065353216		; 3f800000H

; 1934 : 	e12 = 0.0f;

	mov	DWORD PTR [esi+20], 0
	movaps	xmm0, xmm2

; 1935 : 
; 1936 : 	e20 = sY;

	movss	DWORD PTR [esi+24], xmm2
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi], xmm1
	movss	DWORD PTR [esi+8], xmm0

; 1937 : 	e21 = 0.0f;

	mov	DWORD PTR [esi+28], 0

; 1938 : 	e22 = cY;

	movss	DWORD PTR [esi+32], xmm1
	pop	esi

; 1939 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MakeRotationY@CMatrix3x3@gen@@QAEXM@Z ENDP		; gen::CMatrix3x3::MakeRotationY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeRotationX@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
_sX$1$ = -4						; size = 4
_x$ = 8							; size = 4
?MakeRotationX@CMatrix3x3@gen@@QAEXM@Z PROC		; gen::CMatrix3x3::MakeRotationX, COMDAT
; _this$ = ecx

; 1905 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	push	esi
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1905 : {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _sX$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	xorps	xmm1, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1909 : 	e00 = 1.0f;

	mov	DWORD PTR [esi], 1065353216		; 3f800000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1910 : 	e01 = 0.0f;

	mov	DWORD PTR [esi+4], 0

; 1911 : 	e02 = 0.0f;

	mov	DWORD PTR [esi+8], 0

; 1912 : 
; 1913 : 	e10 = 0.0f;

	mov	DWORD PTR [esi+12], 0

; 1914 : 	e11 = cX;
; 1915 : 	e12 = sX;
; 1916 : 
; 1917 : 	e20 = 0.0f;

	mov	DWORD PTR [esi+24], 0
	movss	xmm0, DWORD PTR _sX$1$[ebp]
	movss	DWORD PTR [esi+20], xmm0

; 1918 : 	e21 = -sX;

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+16], xmm1
	movss	DWORD PTR [esi+28], xmm0

; 1919 : 	e22 = cX;

	movss	DWORD PTR [esi+32], xmm1
	pop	esi

; 1920 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MakeRotationX@CMatrix3x3@gen@@QAEXM@Z ENDP		; gen::CMatrix3x3::MakeRotationX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeIdentity@CMatrix3x3@gen@@QAEXXZ
_TEXT	SEGMENT
?MakeIdentity@CMatrix3x3@gen@@QAEXXZ PROC		; gen::CMatrix3x3::MakeIdentity, COMDAT
; _this$ = ecx

; 1889 : 	e00 = 1.0f;

	mov	DWORD PTR [ecx], 1065353216		; 3f800000H

; 1890 : 	e01 = 0.0f;

	mov	DWORD PTR [ecx+4], 0

; 1891 : 	e02 = 0.0f; 

	mov	DWORD PTR [ecx+8], 0

; 1892 : 
; 1893 : 	e10 = 0.0f;

	mov	DWORD PTR [ecx+12], 0

; 1894 : 	e11 = 1.0f;

	mov	DWORD PTR [ecx+16], 1065353216		; 3f800000H

; 1895 : 	e12 = 0.0f;

	mov	DWORD PTR [ecx+20], 0

; 1896 : 
; 1897 : 	e20 = 0.0f;

	mov	DWORD PTR [ecx+24], 0

; 1898 : 	e21 = 0.0f;

	mov	DWORD PTR [ecx+28], 0

; 1899 : 	e22 = 1.0f;

	mov	DWORD PTR [ecx+32], 1065353216		; 3f800000H

; 1900 : }

	ret	0
?MakeIdentity@CMatrix3x3@gen@@QAEXXZ ENDP		; gen::CMatrix3x3::MakeIdentity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Invert@CMatrix3x3@gen@@QAEXXZ
_TEXT	SEGMENT
$T1 = -36						; size = 36
?Invert@CMatrix3x3@gen@@QAEXXZ PROC			; gen::CMatrix3x3::Invert, COMDAT
; _this$ = ecx

; 1844 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1845 : 	*this = Inverse( *this ); // TODO: Just use non-member version

	lea	eax, DWORD PTR $T1[ebp]
	push	esi
	mov	esi, ecx
	push	esi
	push	eax
	call	?Inverse@gen@@YA?AVCMatrix3x3@1@ABV21@@Z ; gen::Inverse
	mov	edx, eax
	add	esp, 8

; 353  : 	if ( this != &m )

	cmp	esi, edx
	je	SHORT $LN3@Invert

; 354  : 	{
; 355  : 		e00 = m.e00;

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ecx

; 356  : 		e01 = m.e01;

	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ecx

; 357  : 		e02 = m.e02;

	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], ecx

; 358  : 
; 359  : 		e10 = m.e10;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax

; 360  : 		e11 = m.e11;

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax

; 361  : 		e12 = m.e12;

	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax

; 362  : 
; 363  : 		e20 = m.e20;

	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [esi+24], eax

; 364  : 		e21 = m.e21;

	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [esi+28], eax

; 365  : 		e22 = m.e22;

	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [esi+32], eax
$LN3@Invert:
	pop	esi

; 1846 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Invert@CMatrix3x3@gen@@QAEXXZ ENDP			; gen::CMatrix3x3::Invert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ
_TEXT	SEGMENT
_e$2 = -252						; size = 4
$T3 = -248						; size = 76
$T4 = -172						; size = 76
$T5 = -96						; size = 76
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ PROC		; gen::CMatrix3x3::InvertAffine2D, COMDAT
; _this$ = ecx

; 1786 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1787 : 	GEN_GUARD;
; 1788 : 
; 1789 : 	// Calculate determinant of upper left 2x2
; 1790 : 	TFloat32 det = e00*e11 - e01*e10;

	movss	xmm6, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [ecx+4]
	movaps	xmm2, xmm6
	mulss	xmm0, DWORD PTR [ecx+12]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mulss	xmm2, DWORD PTR [ecx+16]
	subss	xmm2, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1791 : 	GEN_ASSERT( !IsZero(det), "Singular matrix" );

	jbe	$LN1@InvertAffi
	push	1791					; 000006ffH
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN24@InvertAffi:
__catch$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ$0:

; 1806 : 
; 1807 : 	GEN_ENDGUARD;

	mov	ecx, DWORD PTR _e$2[ebp]
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CA@GCJMOFPA@gen?3?3CMatrix3x3?3?3InvertAffine2D?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN25@InvertAffi:
__catch$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ$1:
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CA@GCJMOFPA@gen?3?3CMatrix3x3?3?3InvertAffine2D?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN26@InvertAffi:
$LN1@InvertAffi:

; 1792 : 
; 1793 : 	// Calculate inverse of upper left 2x2
; 1794 : 	TFloat32 invDet = 1.0f / det;

	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm2

; 1795 : 	TFloat32 t;
; 1796 : 	t   = invDet * e00;
; 1797 : 	e00 = invDet * e11;
; 1798 : 	e11 = t;
; 1799 : 
; 1800 : 	e01 *= invDet;
; 1801 : 	e10 *= invDet;

	movss	xmm2, DWORD PTR [ecx+12]

; 1802 : 
; 1803 : 	// Transform negative translation by inverted 3x3 to get inverse
; 1804 : 	e20 = -e20*e00 - e21*e10;

	movss	xmm4, DWORD PTR [ecx+28]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [ecx+16]
	movss	xmm3, DWORD PTR [ecx+24]
	movss	xmm5, DWORD PTR [ecx+4]
	mulss	xmm3, xmm0
	mulss	xmm2, xmm1
	movss	DWORD PTR [ecx], xmm0
	movaps	xmm0, xmm4
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, xmm2
	mulss	xmm5, xmm1
	subss	xmm3, xmm0
	mulss	xmm6, xmm1
	movss	DWORD PTR [ecx+4], xmm5
	movss	DWORD PTR [ecx+12], xmm2

; 1805 : 	e21 = -e20*e01 - e21*e11;

	mulss	xmm4, xmm6
	movss	DWORD PTR [ecx+24], xmm3
	mulss	xmm3, xmm5
	movss	DWORD PTR [ecx+16], xmm6
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	subss	xmm3, xmm4
	movss	DWORD PTR [ecx+28], xmm3

; 1808 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@InvertAffi:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?InvertAffine2D@CMatrix3x3@gen@@QAEXXZ ENDP		; gen::CMatrix3x3::InvertAffine2D
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?InvertRotScale@CMatrix3x3@gen@@QAEXXZ
_TEXT	SEGMENT
_e$2 = -268						; size = 4
tv206 = -264						; size = 4
_t$2$ = -260						; size = 4
_t$1$ = -256						; size = 4
_t$3$ = -252						; size = 4
$T3 = -248						; size = 76
$T4 = -172						; size = 76
$T5 = -96						; size = 76
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?InvertRotScale@CMatrix3x3@gen@@QAEXXZ PROC		; gen::CMatrix3x3::InvertRotScale, COMDAT
; _this$ = ecx

; 1711 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1712 : 	GEN_GUARD;
; 1713 : 
; 1714 : 	// Get X, Y & Z scaling (squared)
; 1715 : 	TFloat32 scaleSqX = e00*e00 + e01*e01 + e02*e02;

	movss	xmm1, DWORD PTR [ecx+4]
	movss	xmm6, DWORD PTR [ecx]
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR [ecx+8]
	movaps	xmm5, xmm6

; 1716 : 	TFloat32 scaleSqY = e10*e10 + e11*e11 + e12*e12;

	movss	xmm7, DWORD PTR [ecx+16]
	movss	xmm3, DWORD PTR [ecx+12]
	mulss	xmm0, xmm1
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1717 : 	TFloat32 scaleSqZ = e20*e20 + e21*e21 + e22*e22;

	movss	xmm4, DWORD PTR [ecx+24]
	mulss	xmm5, xmm6
	mulss	xmm3, xmm3
	addss	xmm5, xmm0
	movss	DWORD PTR _t$1$[ebp], xmm1
	movss	xmm1, DWORD PTR [ecx+20]
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR _t$2$[ebp], xmm2
	movss	xmm2, DWORD PTR [ecx+28]
	addss	xmm5, xmm0
	mulss	xmm4, xmm4
	movaps	xmm0, xmm7
	movss	DWORD PTR _t$3$[ebp], xmm1
	mulss	xmm0, xmm7
	addss	xmm3, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR [ecx+32]
	movss	DWORD PTR tv206[ebp], xmm1
	addss	xmm3, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1717 : 	TFloat32 scaleSqZ = e20*e20 + e21*e21 + e22*e22;

	addss	xmm4, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movsd	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1717 : 	TFloat32 scaleSqZ = e20*e20 + e21*e21 + e22*e22;

	addss	xmm4, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm5
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1720 : 	GEN_ASSERT( !IsZero(scaleSqX) && !IsZero(scaleSqY) && !IsZero(scaleSqZ), "Singular matrix" );

	ja	$LN1@InvertRotS
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm3
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1720 : 	GEN_ASSERT( !IsZero(scaleSqX) && !IsZero(scaleSqY) && !IsZero(scaleSqZ), "Singular matrix" );

	ja	$LN1@InvertRotS
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm4
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1720 : 	GEN_ASSERT( !IsZero(scaleSqX) && !IsZero(scaleSqY) && !IsZero(scaleSqZ), "Singular matrix" );

	ja	$LN1@InvertRotS

; 1721 : 	TFloat32 invScaleX = 1.0f / scaleSqX;

	movss	xmm2, DWORD PTR __real@3f800000
	movaps	xmm0, xmm2

; 1722 : 	TFloat32 invScaleY = 1.0f / scaleSqY;

	movaps	xmm1, xmm2
	divss	xmm1, xmm3

; 1723 : 	TFloat32 invScaleZ = 1.0f / scaleSqZ;

	divss	xmm2, xmm4

; 1724 : 
; 1725 : 	// Inverse is just the transpose with scaling inverse factored in
; 1726 : 	TFloat32 t;
; 1727 : 	e00 *= invScaleX;
; 1728 : 	e11 *= invScaleY;
; 1729 : 	e22 *= invScaleZ;

	movss	xmm3, DWORD PTR tv206[ebp]
	divss	xmm0, xmm5
	mulss	xmm3, xmm2
	mulss	xmm6, xmm0
	movss	DWORD PTR [ecx+32], xmm3

; 1730 : 
; 1731 : 	t   = e01;
; 1732 : 	e01 = e10 * invScaleY;

	movss	xmm3, DWORD PTR [ecx+12]
	mulss	xmm3, xmm1
	mulss	xmm7, xmm1
	movss	DWORD PTR [ecx+4], xmm3

; 1733 : 	e10 = t * invScaleX;

	movss	xmm3, DWORD PTR _t$1$[ebp]
	mulss	xmm3, xmm0
	movss	DWORD PTR [ecx], xmm6
	movss	DWORD PTR [ecx+16], xmm7
	movss	DWORD PTR [ecx+12], xmm3

; 1734 : 
; 1735 : 	t   = e02;
; 1736 : 	e02 = e20 * invScaleZ;

	movss	xmm3, DWORD PTR [ecx+24]
	mulss	xmm3, xmm2
	movss	DWORD PTR [ecx+8], xmm3

; 1737 : 	e20 = t  * invScaleX;

	movss	xmm3, DWORD PTR _t$2$[ebp]
	mulss	xmm3, xmm0

; 1738 : 
; 1739 : 	t   = e12;
; 1740 : 	e12 = e21 * invScaleZ;

	movss	xmm0, DWORD PTR [ecx+28]
	mulss	xmm0, xmm2
	movss	DWORD PTR [ecx+24], xmm3
	movss	DWORD PTR [ecx+20], xmm0

; 1741 : 	e21 = t * invScaleY;

	movss	xmm0, DWORD PTR _t$3$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+28], xmm0

; 1744 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@InvertRotS:

; 1720 : 	GEN_ASSERT( !IsZero(scaleSqX) && !IsZero(scaleSqY) && !IsZero(scaleSqZ), "Singular matrix" );

	push	1720					; 000006b8H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN37@InvertRotS:
__catch$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ$0:

; 1742 : 
; 1743 : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CA@CAHBGMPM@gen?3?3CMatrix3x3?3?3InvertRotScale?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN38@InvertRotS:
__catch$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ$1:
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CA@CAHBGMPM@gen?3?3CMatrix3x3?3?3InvertRotScale?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN39@InvertRotS:
$LN36@InvertRotS:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InvertRotScale@CMatrix3x3@gen@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?InvertRotScale@CMatrix3x3@gen@@QAEXXZ ENDP		; gen::CMatrix3x3::InvertRotScale
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Transpose@CMatrix3x3@gen@@QAEXXZ
_TEXT	SEGMENT
?Transpose@CMatrix3x3@gen@@QAEXXZ PROC			; gen::CMatrix3x3::Transpose, COMDAT
; _this$ = ecx

; 1671 : 	TFloat32 t;
; 1672 : 
; 1673 : 	t   = e01;

	movss	xmm0, DWORD PTR [ecx+4]

; 1674 : 	e01 = e10;

	mov	eax, DWORD PTR [ecx+12]

; 1675 : 	e10 = t;

	movss	DWORD PTR [ecx+12], xmm0

; 1676 : 
; 1677 : 	t   = e02;

	movss	xmm0, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+4], eax

; 1678 : 	e02 = e20;

	mov	eax, DWORD PTR [ecx+24]

; 1679 : 	e20 = t;

	movss	DWORD PTR [ecx+24], xmm0

; 1680 : 
; 1681 : 	t   = e12;

	movss	xmm0, DWORD PTR [ecx+20]
	mov	DWORD PTR [ecx+8], eax

; 1682 : 	e12 = e21;

	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [ecx+20], eax

; 1683 : 	e21 = t;

	movss	DWORD PTR [ecx+28], xmm0

; 1684 : }

	ret	0
?Transpose@CMatrix3x3@gen@@QAEXXZ ENDP			; gen::CMatrix3x3::Transpose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z
_TEXT	SEGMENT
_e$2 = -276						; size = 4
$T3 = -272						; size = 76
$T4 = -192						; size = 76
$T5 = -112						; size = 76
__$ArrayPad$ = -28					; size = 4
__$EHRec$ = -16						; size = 16
_scale$ = 8						; size = 4
?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z PROC ; gen::CMatrix3x3::Orthogonalise2x2, COMDAT
; _this$ = ecx

; 1583 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1584 : 	GEN_GUARD;
; 1585 : 
; 1586 : 	// Normalise first vector
; 1587 : 	TFloat32 origScaleX = e00*e00 + e01*e01;

	movss	xmm0, DWORD PTR [esi+4]
	movss	xmm2, DWORD PTR [esi]
	mulss	xmm0, xmm0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mulss	xmm2, xmm2
	addss	xmm2, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1588 : 	GEN_ASSERT( !IsZero(origScaleX), "Singular matrix" );

	jbe	$LN3@Orthogonal
	push	1588					; 00000634H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN32@Orthogonal:
__catch$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z$0:
	mov	ebx, DWORD PTR [ebp-20]

; 1612 : 
; 1613 : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CC@DNFNCOGI@gen?3?3CMatrix3x3?3?3Orthogonalise2x@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN33@Orthogonal:
__catch$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z$1:
	mov	ebx, DWORD PTR [ebp-20]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CC@DNFNCOGI@gen?3?3CMatrix3x3?3?3Orthogonalise2x@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN34@Orthogonal:
$LN3@Orthogonal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm2, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1590 : 	e00 *= invOrigScaleX;

	movss	xmm3, DWORD PTR [esi]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1594 : 	TFloat32 ccwPerpDot = e00*e11 - e01*e10;

	movss	xmm1, DWORD PTR [esi+16]
	movss	xmm0, DWORD PTR [esi+12]
	mulss	xmm3, xmm2
	mulss	xmm2, DWORD PTR [esi+4]
	mulss	xmm1, xmm3
	mulss	xmm0, xmm2
	movss	DWORD PTR [esi], xmm3
	movss	DWORD PTR [esi+4], xmm2
	subss	xmm1, xmm0

; 1595 : 	if (ccwPerpDot >= 0.0f)

	comiss	xmm1, DWORD PTR __real@00000000
	jb	SHORT $LN2@Orthogonal

; 1596 : 	{
; 1597 : 		e11 = e00;
; 1598 : 		e10 = -e01;

	movaps	xmm0, xmm2
	movss	DWORD PTR [esi+16], xmm3
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0

; 1599 : 	}
; 1600 : 	else

	jmp	SHORT $LN1@Orthogonal
$LN2@Orthogonal:

; 1601 : 	{
; 1602 : 		e11 = -e00;

	movaps	xmm0, xmm3

; 1603 : 		e10 = e01;

	movss	DWORD PTR [esi+12], xmm2
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+16], xmm0
$LN1@Orthogonal:

; 1604 : 	}
; 1605 : 
; 1606 : 	// Rescale each vector
; 1607 : 	e00 *= scale.x;

	mov	eax, DWORD PTR _scale$[ebx]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm3
	movss	DWORD PTR [esi], xmm0

; 1608 : 	e01 *= scale.x;

	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm2
	movss	DWORD PTR [esi+4], xmm0

; 1609 : 
; 1610 : 	e10 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [esi+12]
	movss	DWORD PTR [esi+12], xmm0

; 1611 : 	e11 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [esi+16]
	movss	DWORD PTR [esi+16], xmm0

; 1614 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
$LN31@Orthogonal:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Orthogonalise2x2@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z ENDP ; gen::CMatrix3x3::Orthogonalise2x2
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?IsOrthonormal2x2@CMatrix3x3@gen@@QBE_NXZ
_TEXT	SEGMENT
?IsOrthonormal2x2@CMatrix3x3@gen@@QBE_NXZ PROC		; gen::CMatrix3x3::IsOrthonormal2x2, COMDAT
; _this$ = ecx

; 1576 : 	       IsZero( e00*e10 + e01*e11 ) && IsZero( e10*e20 + e11*e21 );

	movss	xmm6, DWORD PTR [ecx+4]
	movss	xmm7, DWORD PTR [ecx]
	movaps	xmm0, xmm6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movsd	xmm2, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1576 : 	       IsZero( e00*e10 + e01*e11 ) && IsZero( e10*e20 + e11*e21 );

	movaps	xmm1, xmm7
	mulss	xmm0, xmm6
	mulss	xmm1, xmm7
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm3, DWORD PTR __real@350637bd
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1576 : 	       IsZero( e00*e10 + e01*e11 ) && IsZero( e10*e20 + e11*e21 );

	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	subss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, xmm2
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1576 : 	       IsZero( e00*e10 + e01*e11 ) && IsZero( e10*e20 + e11*e21 );

	jbe	$LN3@IsOrthonor
	movss	xmm4, DWORD PTR [ecx+16]
	movss	xmm5, DWORD PTR [ecx+12]
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	movaps	xmm1, xmm5
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	subss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, xmm2
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1576 : 	       IsZero( e00*e10 + e01*e11 ) && IsZero( e10*e20 + e11*e21 );

	jbe	SHORT $LN3@IsOrthonor
	movaps	xmm0, xmm4
	movaps	xmm1, xmm5
	mulss	xmm0, xmm6
	mulss	xmm1, xmm7
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, xmm2
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1576 : 	       IsZero( e00*e10 + e01*e11 ) && IsZero( e10*e20 + e11*e21 );

	jbe	SHORT $LN3@IsOrthonor
	movss	xmm0, DWORD PTR [ecx+28]
	movss	xmm1, DWORD PTR [ecx+24]
	mulss	xmm0, xmm4
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm2
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1576 : 	       IsZero( e00*e10 + e01*e11 ) && IsZero( e10*e20 + e11*e21 );

	jbe	SHORT $LN3@IsOrthonor
	mov	al, 1

; 1577 : }

	ret	0
$LN3@IsOrthonor:

; 1576 : 	       IsZero( e00*e10 + e01*e11 ) && IsZero( e10*e20 + e11*e21 );

	xor	al, al

; 1577 : }

	ret	0
?IsOrthonormal2x2@CMatrix3x3@gen@@QBE_NXZ ENDP		; gen::CMatrix3x3::IsOrthonormal2x2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?IsOrthogonal2x2@CMatrix3x3@gen@@QBE_NXZ
_TEXT	SEGMENT
?IsOrthogonal2x2@CMatrix3x3@gen@@QBE_NXZ PROC		; gen::CMatrix3x3::IsOrthogonal2x2, COMDAT
; _this$ = ecx

; 1567 : 	return IsZero( e00*e10 + e01*e11) && IsZero( e10*e20 + e11*e21);

	movss	xmm3, DWORD PTR [ecx+12]
	movss	xmm2, DWORD PTR [ecx+16]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movsd	xmm4, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm5, DWORD PTR __real@350637bd
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1567 : 	return IsZero( e00*e10 + e01*e11) && IsZero( e10*e20 + e11*e21);

	mulss	xmm1, xmm2
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm4
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm5, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1567 : 	return IsZero( e00*e10 + e01*e11) && IsZero( e10*e20 + e11*e21);

	jbe	SHORT $LN3@IsOrthogon
	movss	xmm0, DWORD PTR [ecx+28]
	movss	xmm1, DWORD PTR [ecx+24]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm4
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm5, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1567 : 	return IsZero( e00*e10 + e01*e11) && IsZero( e10*e20 + e11*e21);

	jbe	SHORT $LN3@IsOrthogon
	mov	al, 1

; 1568 : }

	ret	0
$LN3@IsOrthogon:

; 1567 : 	return IsZero( e00*e10 + e01*e11) && IsZero( e10*e20 + e11*e21);

	xor	al, al

; 1568 : }

	ret	0
?IsOrthogonal2x2@CMatrix3x3@gen@@QBE_NXZ ENDP		; gen::CMatrix3x3::IsOrthogonal2x2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z
_TEXT	SEGMENT
_e$2 = -380						; size = 4
tv432 = -376						; size = 4
_invOrigScaleX$1$ = -372				; size = 4
tv473 = -368						; size = 4
tv471 = -364						; size = 4
tv474 = -360						; size = 4
tv429 = -356						; size = 4
$T3 = -352						; size = 76
$T4 = -272						; size = 76
$T5 = -192						; size = 76
$T6 = -112						; size = 76
__$ArrayPad$ = -28					; size = 4
__$EHRec$ = -16						; size = 16
_scale$ = 8						; size = 4
?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z PROC ; gen::CMatrix3x3::Orthogonalise, COMDAT
; _this$ = ecx

; 1456 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 1460 : 	TFloat32 origScaleX = e00*e00 + e01*e01 + e02*e02;

	movss	xmm1, DWORD PTR [esi+4]
	movss	xmm2, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [esi+8]
	mulss	xmm2, xmm2
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm1, DWORD PTR __real@350637bd
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1460 : 	TFloat32 origScaleX = e00*e00 + e01*e01 + e02*e02;

	addss	xmm2, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1461 : 	GEN_ASSERT( !IsZero(origScaleX), "Singular matrix" );

	jbe	SHORT $LN2@Orthogonal
	push	1461					; 000005b5H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	__CxxThrowException@8
$LN43@Orthogonal:
$LN2@Orthogonal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm3, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1463 : 	e00 *= invOrigScaleX;

	movss	xmm2, DWORD PTR [esi]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1468 : 	TFloat32 proj10 = e10*e00 + e11*e01 + e12*e02;

	movss	xmm1, DWORD PTR [esi+16]
	movss	xmm0, DWORD PTR [esi+12]
	movaps	xmm5, xmm3
	mulss	xmm5, DWORD PTR [esi+4]
	mulss	xmm2, xmm3
	mulss	xmm3, DWORD PTR [esi+8]
	mulss	xmm0, xmm2

; 1469 : 	e10 -= proj10 * e00;

	movss	xmm4, DWORD PTR [esi+12]
	mulss	xmm1, xmm5
	movss	DWORD PTR tv429[ebp], xmm2
	movss	DWORD PTR [esi], xmm2
	addss	xmm1, xmm0
	movss	DWORD PTR _invOrigScaleX$1$[ebp], xmm3
	movaps	xmm0, xmm3
	movss	DWORD PTR [esi+8], xmm3
	mulss	xmm0, DWORD PTR [esi+20]
	movss	DWORD PTR tv432[ebp], xmm5
	movss	DWORD PTR [esi+4], xmm5
	addss	xmm1, xmm0
	movaps	xmm0, xmm2

; 1470 : 	e11 -= proj10 * e01;

	movss	xmm2, DWORD PTR [esi+16]
	mulss	xmm0, xmm1
	subss	xmm4, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm1
	subss	xmm2, xmm0
	movss	DWORD PTR tv473[ebp], xmm4

; 1471 : 	e12 -= proj10 * e02;

	movaps	xmm0, xmm3
	movss	DWORD PTR [esi+12], xmm4
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR [esi+20]

; 1474 : 	TFloat32 origScaleY = e10*e10 + e11*e11 + e12*e12;

	movaps	xmm3, xmm2
	movss	DWORD PTR tv474[ebp], xmm2
	subss	xmm1, xmm0
	mulss	xmm3, xmm2
	movaps	xmm0, xmm4
	movss	DWORD PTR [esi+16], xmm2
	mulss	xmm0, xmm4
	movss	DWORD PTR tv471[ebp], xmm1
	movss	DWORD PTR [esi+20], xmm1
	addss	xmm3, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm1, DWORD PTR __real@350637bd
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1474 : 	TFloat32 origScaleY = e10*e10 + e11*e11 + e12*e12;

	addss	xmm3, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm3
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1475 : 	GEN_ASSERT( !IsZero(origScaleY), "Singular matrix" );

	jbe	$LN1@Orthogonal
	push	1475					; 000005c3H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN44@Orthogonal:
__catch$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z$0:
	mov	ebx, DWORD PTR [ebp-20]

; 1498 : 
; 1499 : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BP@PMPEPEBF@gen?3?3CMatrix3x3?3?3Orthogonalise?$AA@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN45@Orthogonal:
__catch$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z$1:
	mov	ebx, DWORD PTR [ebp-20]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0BP@PMPEPEBF@gen?3?3CMatrix3x3?3?3Orthogonalise?$AA@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN46@Orthogonal:
$LN1@Orthogonal:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm3
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1487 : 	e00 *= scale.x;

	mov	eax, DWORD PTR _scale$[ebx]
	movss	xmm4, DWORD PTR tv471[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1478 : 	e11 *= invOrigScaleY;

	movss	xmm2, DWORD PTR tv474[ebp]
	movss	xmm5, DWORD PTR tv473[ebp]

; 1479 : 	e12 *= invOrigScaleY;
; 1480 : 
; 1481 : 	// Get third vector from cross product of first two (result is already normalised)
; 1482 : 	e20 = e01*e12 - e02*e11;

	movss	xmm6, DWORD PTR tv432[ebp]
	movss	xmm3, DWORD PTR _invOrigScaleX$1$[ebp]
	mulss	xmm2, xmm1
	mulss	xmm4, xmm1
	mulss	xmm5, xmm1
	movaps	xmm0, xmm2
	mulss	xmm0, xmm3
	movaps	xmm1, xmm4
	mulss	xmm1, xmm6
	movss	DWORD PTR [esi+16], xmm2
	movss	DWORD PTR [esi+12], xmm5
	subss	xmm1, xmm0
	movss	DWORD PTR [esi+20], xmm4

; 1483 : 	e21 = e02*e10 - e00*e12;

	movaps	xmm0, xmm5

; 1484 : 	e22 = e00*e11 - e01*e10;

	mulss	xmm5, xmm6
	mulss	xmm0, xmm3
	movss	DWORD PTR [esi+24], xmm1
	movss	xmm1, DWORD PTR tv429[ebp]
	mulss	xmm4, xmm1
	mulss	xmm2, xmm1
	subss	xmm0, xmm4
	subss	xmm2, xmm5
	movss	DWORD PTR [esi+28], xmm0
	movss	DWORD PTR [esi+32], xmm2

; 1487 : 	e00 *= scale.x;

	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0

; 1488 : 	e01 *= scale.x;

	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm6
	movss	DWORD PTR [esi+4], xmm0

; 1489 : 	e02 *= scale.x;

	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm3
	movss	DWORD PTR [esi+8], xmm0

; 1490 : 
; 1491 : 	e10 *= scale.y;

	movss	xmm0, DWORD PTR [esi+12]
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esi+12], xmm0

; 1492 : 	e11 *= scale.y;

	movss	xmm0, DWORD PTR [esi+16]
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esi+16], xmm0

; 1493 : 	e12 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [esi+20]
	movss	DWORD PTR [esi+20], xmm0

; 1494 : 
; 1495 : 	e20 *= scale.z;

	movss	xmm0, DWORD PTR [esi+24]
	mulss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esi+24], xmm0

; 1496 : 	e21 *= scale.z;

	movss	xmm0, DWORD PTR [esi+28]
	mulss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esi+28], xmm0

; 1497 : 	e22 *= scale.z;

	movss	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esi+32], xmm0

; 1500 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
$LN42@Orthogonal:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-380]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Orthogonalise@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z ENDP ; gen::CMatrix3x3::Orthogonalise
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?IsOrthonormal@CMatrix3x3@gen@@QBE_NXZ
_TEXT	SEGMENT
?IsOrthonormal@CMatrix3x3@gen@@QBE_NXZ PROC		; gen::CMatrix3x3::IsOrthonormal, COMDAT
; _this$ = ecx

; 1449 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	movss	xmm7, DWORD PTR [ecx+4]
	movss	xmm1, DWORD PTR [ecx]
	movaps	xmm0, xmm7
	movss	xmm2, DWORD PTR [ecx+8]
	movss	xmm6, DWORD PTR __real@3f800000
	mulss	xmm0, xmm7
	mulss	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movsd	xmm3, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm4, DWORD PTR __real@350637bd
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1449 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	subss	xmm1, xmm6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm4, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1449 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	jbe	$LN3@IsOrthonor
	movss	xmm2, DWORD PTR [ecx+16]
	movss	xmm1, DWORD PTR [ecx+12]
	movaps	xmm0, xmm2
	movss	xmm5, DWORD PTR [ecx+20]
	mulss	xmm0, xmm2
	mulss	xmm1, xmm1
	addss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm5
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	subss	xmm1, xmm6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm4, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1449 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	jbe	$LN3@IsOrthonor
	movss	xmm5, DWORD PTR [ecx+28]
	movss	xmm2, DWORD PTR [ecx+24]
	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [ecx+32]
	movaps	xmm1, xmm2
	mulss	xmm0, xmm5
	mulss	xmm1, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm6
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	subss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, xmm1
	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm4, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1449 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	jbe	$LN3@IsOrthonor
	movss	xmm0, DWORD PTR [ecx+16]
	movss	xmm1, DWORD PTR [ecx+12]
	mulss	xmm1, DWORD PTR [ecx]
	mulss	xmm0, xmm7
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+20]
	mulss	xmm0, DWORD PTR [ecx+8]
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm4, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1449 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	jbe	SHORT $LN3@IsOrthonor
	movaps	xmm0, xmm5
	movaps	xmm1, xmm2
	mulss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm1, DWORD PTR [ecx+12]
	addss	xmm1, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [ecx+20]
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm4, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1449 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	jbe	SHORT $LN3@IsOrthonor
	mulss	xmm2, DWORD PTR [ecx]
	mulss	xmm6, DWORD PTR [ecx+8]
	mulss	xmm5, xmm7
	addss	xmm2, xmm5
	addss	xmm2, xmm6
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, xmm3
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm4, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1449 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	jbe	SHORT $LN3@IsOrthonor
	mov	al, 1

; 1450 : }

	ret	0
$LN3@IsOrthonor:

; 1449 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	xor	al, al

; 1450 : }

	ret	0
?IsOrthonormal@CMatrix3x3@gen@@QBE_NXZ ENDP		; gen::CMatrix3x3::IsOrthonormal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?IsOrthogonal@CMatrix3x3@gen@@QBE_NXZ
_TEXT	SEGMENT
?IsOrthogonal@CMatrix3x3@gen@@QBE_NXZ PROC		; gen::CMatrix3x3::IsOrthogonal, COMDAT
; _this$ = ecx

; 1436 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	movss	xmm7, DWORD PTR [ecx+4]
	movss	xmm1, DWORD PTR [ecx]
	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm1, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movsd	xmm5, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm6, DWORD PTR __real@350637bd
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1436 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm0, DWORD PTR [ecx+20]
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm5
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm6, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1436 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	jbe	SHORT $LN3@IsOrthogon
	movss	xmm3, DWORD PTR [ecx+28]
	movss	xmm2, DWORD PTR [ecx+24]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [ecx+16]
	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR [ecx+12]
	movss	xmm4, DWORD PTR [ecx+32]
	addss	xmm1, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR [ecx+20]
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, xmm5
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm6, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1436 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	jbe	SHORT $LN3@IsOrthogon
	mulss	xmm2, DWORD PTR [ecx]
	mulss	xmm4, DWORD PTR [ecx+8]
	mulss	xmm3, xmm7
	addss	xmm2, xmm3
	addss	xmm2, xmm4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, xmm5
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm6, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1436 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	jbe	SHORT $LN3@IsOrthogon
	mov	al, 1

; 1437 : }

	ret	0
$LN3@IsOrthogon:

; 1436 : 	       IsZero( e20*e00 + e21*e01 + e22*e02 );

	xor	al, al

; 1437 : }

	ret	0
?IsOrthogonal@CMatrix3x3@gen@@QBE_NXZ ENDP		; gen::CMatrix3x3::IsOrthogonal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?IsIdentity@CMatrix3x3@gen@@QBE_NXZ
_TEXT	SEGMENT
?IsIdentity@CMatrix3x3@gen@@QBE_NXZ PROC		; gen::CMatrix3x3::IsIdentity, COMDAT
; _this$ = ecx

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	movss	xmm0, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movsd	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	subss	xmm0, xmm3
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	jbe	$LN3@IsIdentity
	movss	xmm0, DWORD PTR [ecx+16]
	subss	xmm0, xmm3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	jbe	$LN3@IsIdentity
	movss	xmm0, DWORD PTR [ecx+32]
	subss	xmm0, xmm3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	jbe	$LN3@IsIdentity
	movss	xmm0, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	jbe	SHORT $LN3@IsIdentity
	movss	xmm0, DWORD PTR [ecx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	jbe	SHORT $LN3@IsIdentity
	movss	xmm0, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	jbe	SHORT $LN3@IsIdentity
	movss	xmm0, DWORD PTR [ecx+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	jbe	SHORT $LN3@IsIdentity
	movss	xmm0, DWORD PTR [ecx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	jbe	SHORT $LN3@IsIdentity
	movss	xmm0, DWORD PTR [ecx+28]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	jbe	SHORT $LN3@IsIdentity
	mov	al, 1

; 1420 : }

	ret	0
$LN3@IsIdentity:

; 1419 : 	       IsZero( e20 ) && IsZero( e21 );

	xor	al, al

; 1420 : }

	ret	0
?IsIdentity@CMatrix3x3@gen@@QBE_NXZ ENDP		; gen::CMatrix3x3::IsIdentity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetScale2D@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
tv169 = -8						; size = 4
tv147 = -8						; size = 4
tv168 = -4						; size = 4
tv154 = -4						; size = 4
_fScale$ = 8						; size = 4
?SetScale2D@CMatrix3x3@gen@@QAEXM@Z PROC		; gen::CMatrix3x3::SetScale2D, COMDAT
; _this$ = ecx

; 1388 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 1389 : 	TFloat32 rescale;
; 1390 : 	TFloat32 scaleSq = Sqrt( e00*e00 + e01*e01 );

	movss	xmm0, DWORD PTR [esi]
	movss	xmm2, DWORD PTR [esi+4]
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv147[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv154[esp+16], xmm2
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1391 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN2@SetScale2D
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1394 : 		e00 *= rescale;

	movss	xmm0, DWORD PTR tv147[esp+16]
	mulss	xmm1, DWORD PTR _fScale$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0

; 1395 : 		e01 *= rescale;

	movss	xmm0, DWORD PTR tv154[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+4], xmm0
$LN2@SetScale2D:

; 1396 : 	}
; 1397 : 	
; 1398 : 	scaleSq = Sqrt( e10*e10 + e11*e11 );

	movss	xmm0, DWORD PTR [esi+12]
	movss	xmm2, DWORD PTR [esi+16]
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv168[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv169[esp+16], xmm2
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1399 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN1@SetScale2D
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1402 : 		e10 *= rescale;

	movss	xmm0, DWORD PTR tv168[esp+16]
	mulss	xmm1, DWORD PTR _fScale$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+12], xmm0

; 1403 : 		e11 *= rescale;

	movss	xmm0, DWORD PTR tv169[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+16], xmm0
$LN1@SetScale2D:

; 1404 : 	}
; 1405 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale2D@CMatrix3x3@gen@@QAEXM@Z ENDP		; gen::CMatrix3x3::SetScale2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetScale2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z
_TEXT	SEGMENT
tv191 = -8						; size = 4
tv78 = -8						; size = 4
tv190 = -4						; size = 4
tv82 = -4						; size = 4
_scale$ = 8						; size = 4
?SetScale2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z PROC	; gen::CMatrix3x3::SetScale2D, COMDAT
; _this$ = ecx

; 1366 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi

; 1367 : 	TFloat32 rescale;
; 1368 : 	TFloat32 scaleSq = Sqrt( e00*e00 + e01*e01 );

	movss	xmm0, DWORD PTR [esi]
	movss	xmm2, DWORD PTR [esi+4]
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv78[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv82[esp+16], xmm2
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	xorps	xmm1, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1369 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	mov	edi, DWORD PTR _scale$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1369 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN2@SetScale2D
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1372 : 		e00 *= rescale;

	movss	xmm0, DWORD PTR tv78[esp+16]
	mulss	xmm1, DWORD PTR [edi]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0

; 1373 : 		e01 *= rescale;

	movss	xmm0, DWORD PTR tv82[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+4], xmm0
$LN2@SetScale2D:

; 1374 : 	}
; 1375 : 	
; 1376 : 	scaleSq = Sqrt( e10*e10 + e11*e11 );

	movss	xmm0, DWORD PTR [esi+12]
	movss	xmm2, DWORD PTR [esi+16]
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv190[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv191[esp+16], xmm2
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1377 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN1@SetScale2D
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1380 : 		e10 *= rescale;

	movss	xmm0, DWORD PTR tv190[esp+16]
	mulss	xmm1, DWORD PTR [edi+4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+12], xmm0

; 1381 : 		e11 *= rescale;

	movss	xmm0, DWORD PTR tv191[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+16], xmm0
$LN1@SetScale2D:

; 1382 : 	}
; 1383 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale2D@CMatrix3x3@gen@@QAEXABVCVector2@2@@Z ENDP	; gen::CMatrix3x3::SetScale2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetScaleY2D@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
tv129 = -8						; size = 4
tv142 = -4						; size = 4
_y$ = 8							; size = 4
?SetScaleY2D@CMatrix3x3@gen@@QAEXM@Z PROC		; gen::CMatrix3x3::SetScaleY2D, COMDAT
; _this$ = ecx

; 1353 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 1354 : 	TFloat32 scaleSq = Sqrt( e10*e10 + e11*e11 );

	movss	xmm0, DWORD PTR [esi+12]
	movss	xmm2, DWORD PTR [esi+16]
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv129[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv142[esp+16], xmm2
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
	xorps	xmm2, xmm2
	cvtsd2ss xmm2, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1355 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN1@SetScaleY2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1358 : 		e10 *= rescale;

	movss	xmm0, DWORD PTR tv129[esp+16]
	mulss	xmm1, DWORD PTR _y$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+12], xmm0

; 1359 : 		e11 *= rescale;

	movss	xmm0, DWORD PTR tv142[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+16], xmm0
$LN1@SetScaleY2:

; 1360 : 	}
; 1361 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScaleY2D@CMatrix3x3@gen@@QAEXM@Z ENDP		; gen::CMatrix3x3::SetScaleY2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetScaleX2D@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
tv142 = -8						; size = 4
tv144 = -4						; size = 4
_x$ = 8							; size = 4
?SetScaleX2D@CMatrix3x3@gen@@QAEXM@Z PROC		; gen::CMatrix3x3::SetScaleX2D, COMDAT
; _this$ = ecx

; 1340 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 1341 : 	TFloat32 scaleSq = Sqrt( e00*e00 + e01*e01 );

	movss	xmm0, DWORD PTR [esi]
	movss	xmm2, DWORD PTR [esi+4]
	movaps	xmm1, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR tv142[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv144[esp+16], xmm2
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
	xorps	xmm2, xmm2
	cvtsd2ss xmm2, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1342 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN1@SetScaleX2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1345 : 		e00 *= rescale;

	movss	xmm0, DWORD PTR tv142[esp+16]
	mulss	xmm1, DWORD PTR _x$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0

; 1346 : 		e01 *= rescale;

	movss	xmm0, DWORD PTR tv144[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+4], xmm0
$LN1@SetScaleX2:

; 1347 : 	}
; 1348 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScaleX2D@CMatrix3x3@gen@@QAEXM@Z ENDP		; gen::CMatrix3x3::SetScaleX2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?GetScale2D@CMatrix3x3@gen@@QBE?AVCVector2@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetScale2D@CMatrix3x3@gen@@QBE?AVCVector2@2@XZ PROC	; gen::CMatrix3x3::GetScale2D, COMDAT
; _this$ = ecx

; 1329 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	esi
	push	edi
	mov	edi, ecx

; 1331 : 	scale.x = Sqrt( e00*e00 + e01*e01 );

	movss	xmm1, DWORD PTR [edi+4]
	movss	xmm0, DWORD PTR [edi]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1331 : 	scale.x = Sqrt( e00*e00 + e01*e01 );

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 1332 : 	scale.y = Sqrt( e10*e10 + e11*e11 );

	movss	xmm1, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1332 : 	scale.y = Sqrt( e10*e10 + e11*e11 );

	mulss	xmm1, xmm1
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR [edi+12]
	mulss	xmm0, xmm0
	addss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1334 : }

	pop	edi
	mov	eax, esi
	movss	DWORD PTR [esi+4], xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetScale2D@CMatrix3x3@gen@@QBE?AVCVector2@2@XZ ENDP	; gen::CMatrix3x3::GetScale2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.h
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.h
;	COMDAT ?GetPosition2D@CMatrix3x3@gen@@QBE?AVCVector2@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetPosition2D@CMatrix3x3@gen@@QBE?AVCVector2@2@XZ PROC	; gen::CMatrix3x3::GetPosition2D, COMDAT
; _this$ = ecx

; 771  : 	{

	push	ebp
	mov	ebp, esp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 50   : 	{}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.h

; 773  : 	}

	pop	ebp
	ret	4
?GetPosition2D@CMatrix3x3@gen@@QBE?AVCVector2@2@XZ ENDP	; gen::CMatrix3x3::GetPosition2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetScale@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
tv213 = -12						; size = 4
tv189 = -12						; size = 4
tv66 = -12						; size = 4
tv188 = -8						; size = 4
tv131 = -8						; size = 4
tv65 = -8						; size = 4
tv215 = -4						; size = 4
tv191 = -4						; size = 4
tv130 = -4						; size = 4
_fScale$ = 8						; size = 4
?SetScale@CMatrix3x3@gen@@QAEXM@Z PROC			; gen::CMatrix3x3::SetScale, COMDAT
; _this$ = ecx

; 1292 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 1293 : 	TFloat32 rescale;
; 1294 : 	TFloat32 scaleSq = Sqrt( e00*e00 + e01*e01 + e02*e02 );

	movss	xmm0, DWORD PTR [esi]
	movss	xmm2, DWORD PTR [esi+4]
	movaps	xmm1, xmm0
	movss	xmm3, DWORD PTR [esi+8]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv189[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv188[esp+16], xmm2
	movss	DWORD PTR tv191[esp+16], xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1295 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN3@SetScale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1298 : 		e00 *= rescale;

	movss	xmm0, DWORD PTR tv189[esp+16]
	mulss	xmm1, DWORD PTR _fScale$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0

; 1299 : 		e01 *= rescale;

	movss	xmm0, DWORD PTR tv188[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+4], xmm0

; 1300 : 		e02 *= rescale;

	movss	xmm0, DWORD PTR tv191[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+8], xmm0
$LN3@SetScale:

; 1301 : 	}
; 1302 : 	
; 1303 : 	scaleSq = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movss	xmm0, DWORD PTR [esi+12]
	movss	xmm2, DWORD PTR [esi+16]
	movaps	xmm1, xmm0
	movss	xmm3, DWORD PTR [esi+20]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv130[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv131[esp+16], xmm2
	movss	DWORD PTR tv213[esp+16], xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1304 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN2@SetScale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1307 : 		e10 *= rescale;

	movss	xmm0, DWORD PTR tv130[esp+16]
	mulss	xmm1, DWORD PTR _fScale$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+12], xmm0

; 1308 : 		e11 *= rescale;

	movss	xmm0, DWORD PTR tv131[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+16], xmm0

; 1309 : 		e12 *= rescale;

	movss	xmm0, DWORD PTR tv213[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+20], xmm0
$LN2@SetScale:

; 1310 : 	}
; 1311 : 
; 1312 : 	scaleSq = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	movss	xmm0, DWORD PTR [esi+28]
	movss	xmm2, DWORD PTR [esi+24]
	movaps	xmm1, xmm0
	movss	xmm3, DWORD PTR [esi+32]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv65[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv215[esp+16], xmm2
	movss	DWORD PTR tv66[esp+16], xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1313 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN1@SetScale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1316 : 		e20 *= rescale;

	movss	xmm0, DWORD PTR tv215[esp+16]
	mulss	xmm1, DWORD PTR _fScale$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+24], xmm0

; 1317 : 		e21 *= rescale;

	movss	xmm0, DWORD PTR tv65[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+28], xmm0

; 1318 : 		e22 *= rescale;

	movss	xmm0, DWORD PTR tv66[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+32], xmm0
$LN1@SetScale:

; 1319 : 	}
; 1320 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale@CMatrix3x3@gen@@QAEXM@Z ENDP			; gen::CMatrix3x3::SetScale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetScale@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z
_TEXT	SEGMENT
tv245 = -12						; size = 4
tv132 = -12						; size = 4
tv66 = -12						; size = 4
tv265 = -8						; size = 4
tv244 = -8						; size = 4
tv65 = -8						; size = 4
tv267 = -4						; size = 4
tv243 = -4						; size = 4
tv184 = -4						; size = 4
_scale$ = 8						; size = 4
?SetScale@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z PROC	; gen::CMatrix3x3::SetScale, COMDAT
; _this$ = ecx

; 1259 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx
	push	edi

; 1260 : 	TFloat32 rescale;
; 1261 : 	TFloat32 scaleSq = Sqrt( e00*e00 + e01*e01 + e02*e02 );

	movss	xmm0, DWORD PTR [esi]
	movss	xmm2, DWORD PTR [esi+4]
	movaps	xmm1, xmm0
	movss	xmm3, DWORD PTR [esi+8]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv132[esp+24], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv265[esp+24], xmm2
	movss	DWORD PTR tv267[esp+24], xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	xorps	xmm1, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1262 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	mov	edi, DWORD PTR _scale$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1262 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN3@SetScale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1265 : 		e00 *= rescale;

	movss	xmm0, DWORD PTR tv132[esp+24]
	mulss	xmm1, DWORD PTR [edi]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0

; 1266 : 		e01 *= rescale;

	movss	xmm0, DWORD PTR tv265[esp+24]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+4], xmm0

; 1267 : 		e02 *= rescale;

	movss	xmm0, DWORD PTR tv267[esp+24]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+8], xmm0
$LN3@SetScale:

; 1268 : 	}
; 1269 : 	
; 1270 : 	scaleSq = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movss	xmm0, DWORD PTR [esi+12]
	movss	xmm2, DWORD PTR [esi+16]
	movaps	xmm1, xmm0
	movss	xmm3, DWORD PTR [esi+20]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv184[esp+24], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv65[esp+24], xmm2
	movss	DWORD PTR tv66[esp+24], xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1271 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN2@SetScale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1274 : 		e10 *= rescale;

	movss	xmm0, DWORD PTR tv184[esp+24]
	mulss	xmm1, DWORD PTR [edi+4]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+12], xmm0

; 1275 : 		e11 *= rescale;

	movss	xmm0, DWORD PTR tv65[esp+24]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+16], xmm0

; 1276 : 		e12 *= rescale;

	movss	xmm0, DWORD PTR tv66[esp+24]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+20], xmm0
$LN2@SetScale:

; 1277 : 	}
; 1278 : 
; 1279 : 	scaleSq = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	movss	xmm0, DWORD PTR [esi+24]
	movss	xmm2, DWORD PTR [esi+28]
	movaps	xmm1, xmm0
	movss	xmm3, DWORD PTR [esi+32]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv243[esp+24], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv244[esp+24], xmm2
	movss	DWORD PTR tv245[esp+24], xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm1
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1280 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN1@SetScale
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1283 : 		e20 *= rescale;

	movss	xmm0, DWORD PTR tv243[esp+24]
	mulss	xmm1, DWORD PTR [edi+8]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+24], xmm0

; 1284 : 		e21 *= rescale;

	movss	xmm0, DWORD PTR tv244[esp+24]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+28], xmm0

; 1285 : 		e22 *= rescale;

	movss	xmm0, DWORD PTR tv245[esp+24]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+32], xmm0
$LN1@SetScale:

; 1286 : 	}
; 1287 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScale@CMatrix3x3@gen@@QAEXABVCVector3@2@@Z ENDP	; gen::CMatrix3x3::SetScale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetScaleZ@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
tv133 = -12						; size = 4
tv134 = -8						; size = 4
tv146 = -4						; size = 4
_z$ = 8							; size = 4
?SetScaleZ@CMatrix3x3@gen@@QAEXM@Z PROC			; gen::CMatrix3x3::SetScaleZ, COMDAT
; _this$ = ecx

; 1245 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 1246 : 	TFloat32 scaleSq = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	movss	xmm0, DWORD PTR [esi+24]
	movss	xmm2, DWORD PTR [esi+28]
	movaps	xmm1, xmm0
	movss	xmm3, DWORD PTR [esi+32]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv133[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv134[esp+16], xmm2
	movss	DWORD PTR tv146[esp+16], xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
	xorps	xmm2, xmm2
	cvtsd2ss xmm2, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1247 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN1@SetScaleZ
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1250 : 		e20 *= rescale;

	movss	xmm0, DWORD PTR tv133[esp+16]
	mulss	xmm1, DWORD PTR _z$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+24], xmm0

; 1251 : 		e21 *= rescale;

	movss	xmm0, DWORD PTR tv134[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+28], xmm0

; 1252 : 		e22 *= rescale;

	movss	xmm0, DWORD PTR tv146[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+32], xmm0
$LN1@SetScaleZ:

; 1253 : 	}
; 1254 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScaleZ@CMatrix3x3@gen@@QAEXM@Z ENDP			; gen::CMatrix3x3::SetScaleZ
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetScaleY@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
tv133 = -12						; size = 4
tv134 = -8						; size = 4
tv146 = -4						; size = 4
_y$ = 8							; size = 4
?SetScaleY@CMatrix3x3@gen@@QAEXM@Z PROC			; gen::CMatrix3x3::SetScaleY, COMDAT
; _this$ = ecx

; 1231 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 1232 : 	TFloat32 scaleSq = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movss	xmm0, DWORD PTR [esi+12]
	movss	xmm2, DWORD PTR [esi+16]
	movaps	xmm1, xmm0
	movss	xmm3, DWORD PTR [esi+20]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv133[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv134[esp+16], xmm2
	movss	DWORD PTR tv146[esp+16], xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
	xorps	xmm2, xmm2
	cvtsd2ss xmm2, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1233 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN1@SetScaleY
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1236 : 		e10 *= rescale;

	movss	xmm0, DWORD PTR tv133[esp+16]
	mulss	xmm1, DWORD PTR _y$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+12], xmm0

; 1237 : 		e11 *= rescale;

	movss	xmm0, DWORD PTR tv134[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+16], xmm0

; 1238 : 		e12 *= rescale;

	movss	xmm0, DWORD PTR tv146[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+20], xmm0
$LN1@SetScaleY:

; 1239 : 	}
; 1240 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScaleY@CMatrix3x3@gen@@QAEXM@Z ENDP			; gen::CMatrix3x3::SetScaleY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetScaleX@CMatrix3x3@gen@@QAEXM@Z
_TEXT	SEGMENT
tv134 = -12						; size = 4
tv146 = -8						; size = 4
tv149 = -4						; size = 4
_x$ = 8							; size = 4
?SetScaleX@CMatrix3x3@gen@@QAEXM@Z PROC			; gen::CMatrix3x3::SetScaleX, COMDAT
; _this$ = ecx

; 1217 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 1218 : 	TFloat32 scaleSq = Sqrt( e00*e00 + e01*e01 + e02*e02 );

	movss	xmm0, DWORD PTR [esi]
	movss	xmm2, DWORD PTR [esi+4]
	movaps	xmm1, xmm0
	movss	xmm3, DWORD PTR [esi+8]
	mulss	xmm1, xmm0
	movss	DWORD PTR tv134[esp+16], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	movss	DWORD PTR tv146[esp+16], xmm2
	movss	DWORD PTR tv149[esp+16], xmm3
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
	xorps	xmm2, xmm2
	cvtsd2ss xmm2, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1219 : 	if (!IsZero(scaleSq)) // No effect on zero axes

	ja	SHORT $LN1@SetScaleX
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1222 : 		e00 *= rescale;

	movss	xmm0, DWORD PTR tv134[esp+16]
	mulss	xmm1, DWORD PTR _x$[ebp]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0

; 1223 : 		e01 *= rescale;

	movss	xmm0, DWORD PTR tv146[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+4], xmm0

; 1224 : 		e02 *= rescale;

	movss	xmm0, DWORD PTR tv149[esp+16]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+8], xmm0
$LN1@SetScaleX:

; 1225 : 	}
; 1226 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScaleX@CMatrix3x3@gen@@QAEXM@Z ENDP			; gen::CMatrix3x3::SetScaleX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?GetScale@CMatrix3x3@gen@@QBE?AVCVector3@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetScale@CMatrix3x3@gen@@QBE?AVCVector3@2@XZ PROC	; gen::CMatrix3x3::GetScale, COMDAT
; _this$ = ecx

; 1205 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	esi
	push	edi
	mov	edi, ecx

; 1206 : 	CVector3 scale;
; 1207 : 	scale.x = Sqrt( e00*e00 + e01*e01 + e02*e02 );

	movss	xmm1, DWORD PTR [edi+4]
	movss	xmm2, DWORD PTR [edi]
	movss	xmm0, DWORD PTR [edi+8]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1208 : 	scale.y = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movss	xmm1, DWORD PTR [edi+16]
	movss	xmm2, DWORD PTR [edi+12]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1208 : 	scale.y = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR [edi+20]
	addss	xmm2, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1209 : 	scale.z = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	movss	xmm1, DWORD PTR [edi+28]
	movss	xmm2, DWORD PTR [edi+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1209 : 	scale.z = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm0, DWORD PTR [edi+32]
	addss	xmm2, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1211 : }

	pop	edi
	mov	eax, esi
	movss	DWORD PTR [esi+8], xmm0
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetScale@CMatrix3x3@gen@@QBE?AVCVector3@2@XZ ENDP	; gen::CMatrix3x3::GetScale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z
_TEXT	SEGMENT
_e$2 = -300						; size = 4
tv280 = -296						; size = 8
tv277 = -296						; size = 8
_scaleY$1$ = -284					; size = 4
_scaleX$1$ = -280					; size = 4
_pfAngle$GSCopy$1$ = -276				; size = 4
$T3 = -272						; size = 76
$T4 = -192						; size = 76
$T5 = -112						; size = 76
__$ArrayPad$ = -28					; size = 4
__$EHRec$ = -16						; size = 16
_pPosition$ = 8						; size = 4
_pfAngle$ = 12						; size = 4
_pScale$ = 16						; size = 4
?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z PROC ; gen::CMatrix3x3::DecomposeAffine2D, COMDAT
; _this$ = ecx

; 1164 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	edx, DWORD PTR _pPosition$[ebx]
	mov	eax, DWORD PTR _pfAngle$[ebx]
	mov	esi, DWORD PTR _pScale$[ebx]
	mov	DWORD PTR _pfAngle$GSCopy$1$[ebp], eax

; 1165 : 	GEN_GUARD;

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1166 : 
; 1167 : 	// Get position if required
; 1168 : 	if (pPosition)

	test	edx, edx
	je	SHORT $LN5@DecomposeA

; 1169 : 	{
; 1170 : 		pPosition->x = e20;

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [edx], eax

; 1171 : 		pPosition->y = e21;

	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [edx+4], eax
$LN5@DecomposeA:

; 1172 : 	}
; 1173 : 
; 1174 : 	// Calculate matrix scaling
; 1175 : 	TFloat32 scaleX = Sqrt( e00*e00 + e01*e01 );

	movss	xmm2, DWORD PTR [edi+4]
	movss	xmm1, DWORD PTR [edi]
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	mulss	xmm1, xmm1
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1176 : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 );

	movss	xmm1, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1176 : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 );

	mulss	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _scaleX$1$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1176 : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 );

	movss	xmm0, DWORD PTR [edi+16]
	mulss	xmm0, xmm0
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1179 : 	if (pfAngle)

	cmp	DWORD PTR _pfAngle$GSCopy$1$[ebp], 0
	xorps	xmm4, xmm4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm4, xmm0
	movss	DWORD PTR _scaleY$1$[ebp], xmm4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1179 : 	if (pfAngle)

	je	$LN4@DecomposeA
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm2, DWORD PTR _scaleX$1$[ebp]
	movsd	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm3, DWORD PTR __real@350637bd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1182 : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY), "Singular matrix" );

	ja	$LN2@DecomposeA
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm4
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1182 : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY), "Singular matrix" );

	ja	$LN2@DecomposeA

; 1183 : 		TFloat32 invScaleX = 1.0f / scaleX;

	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm2

; 1185 : 		*pfAngle = ATan( e01 * invScaleX, e00 * invScaleX );

	movss	xmm0, DWORD PTR [edi+4]
	mulss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv280[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1185 : 		*pfAngle = ATan( e01 * invScaleX, e00 * invScaleX );

	movss	xmm0, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

	fld	QWORD PTR tv280[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1185 : 		*pfAngle = ATan( e01 * invScaleX, e00 * invScaleX );

	mulss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv277[ebp], xmm0
	fld	QWORD PTR tv277[ebp]
	call	__CIatan2
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1185 : 		*pfAngle = ATan( e01 * invScaleX, e00 * invScaleX );

	mov	eax, DWORD PTR _pfAngle$GSCopy$1$[ebp]
	movss	xmm4, DWORD PTR _scaleY$1$[ebp]
	fstp	DWORD PTR [eax]
$LN4@DecomposeA:

; 1186 : 	}
; 1187 : 
; 1188 : 	// Return scale if required
; 1189 : 	if (pScale)

	test	esi, esi
	je	SHORT $LN1@DecomposeA

; 1190 : 	{
; 1191 : 		pScale->x = scaleX;

	movss	xmm0, DWORD PTR _scaleX$1$[ebp]
	movss	DWORD PTR [esi], xmm0

; 1192 : 		pScale->y = scaleY;

	movss	DWORD PTR [esi+4], xmm4
$LN1@DecomposeA:

; 1196 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	12					; 0000000cH
$LN2@DecomposeA:

; 1182 : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY), "Singular matrix" );

	push	1182					; 0000049eH
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN46@DecomposeA:
__catch$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z$0:
	mov	ebx, DWORD PTR [ebp-20]

; 1193 : 	}
; 1194 : 
; 1195 : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CD@GODDIFLH@gen?3?3CMatrix3x3?3?3DecomposeAffine@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN47@DecomposeA:
__catch$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z$1:
	mov	ebx, DWORD PTR [ebp-20]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CD@GODDIFLH@gen?3?3CMatrix3x3?3?3DecomposeAffine@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN48@DecomposeA:
$LN45@DecomposeA:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-300]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DecomposeAffine2D@CMatrix3x3@gen@@QBEXPAVCVector2@2@PAM0@Z ENDP ; gen::CMatrix3x3::DecomposeAffine2D
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeAffine2D@CMatrix3x3@gen@@QAEXABVCVector2@2@M0@Z
_TEXT	SEGMENT
_s$1$ = -4						; size = 4
_position$ = 8						; size = 4
_fAngle$ = 12						; size = 4
_scale$ = 16						; size = 4
?MakeAffine2D@CMatrix3x3@gen@@QAEXABVCVector2@2@M0@Z PROC ; gen::CMatrix3x3::MakeAffine2D, COMDAT
; _this$ = ecx

; 1139 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _fAngle$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	push	esi
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1139 : {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _s$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _fAngle$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1143 : 	e00 = c * scale.x;

	mov	eax, DWORD PTR _scale$[ebp]
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1151 : 	e20 = position.x;

	mov	ecx, DWORD PTR _position$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _s$1$[ebp]
	mov	DWORD PTR [esi+8], 0
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR _s$1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, xmm1
	mov	DWORD PTR [esi+20], 0
	movss	DWORD PTR [esi+16], xmm0
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+24], eax

; 1152 : 	e21 = position.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+28], eax

; 1153 : 	e22 = 1.0f;

	mov	DWORD PTR [esi+32], 1065353216		; 3f800000H
	pop	esi

; 1154 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MakeAffine2D@CMatrix3x3@gen@@QAEXABVCVector2@2@M0@Z ENDP ; gen::CMatrix3x3::MakeAffine2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?DecomposeTransformAxisAngle@CMatrix3x3@gen@@QBEXPAVCVector3@2@PAM0@Z
_TEXT	SEGMENT
_scaleZ$1$ = -132					; size = 4
_diagZ$1$ = -128					; size = 4
_diagX$1$ = -124					; size = 4
_diagY$1$ = -120					; size = 4
_scaleX$1$ = -116					; size = 4
_pfAngle$GSCopy$1$ = -112				; size = 4
_scaleY$1$ = -108					; size = 4
_zIn$1$ = -104						; size = 4
_invScaleY$1$ = -100					; size = 4
_pScale$GSCopy$1$ = -96					; size = 4
_invScaleZ$1$ = -92					; size = 4
$T1 = -88						; size = 76
__$ArrayPad$ = -4					; size = 4
_pAxis$ = 8						; size = 4
_pfAngle$ = 12						; size = 4
_pScale$ = 16						; size = 4
?DecomposeTransformAxisAngle@CMatrix3x3@gen@@QBEXPAVCVector3@2@PAM0@Z PROC ; gen::CMatrix3x3::DecomposeTransformAxisAngle, COMDAT
; _this$ = ecx

; 1025 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+136], eax
	push	esi
	mov	eax, DWORD PTR _pfAngle$[ebp]
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR _pAxis$[ebp]
	mov	DWORD PTR _pfAngle$GSCopy$1$[esp+144], eax
	mov	eax, DWORD PTR _pScale$[ebp]
	mov	DWORD PTR _pScale$GSCopy$1$[esp+144], eax

; 1026 : 	// Calculate matrix scaling
; 1027 : 	TFloat32 scaleX = Sqrt( e00*e00 + e01*e01 + e02*e02 );

	movss	xmm3, DWORD PTR [edi]
	movss	xmm2, DWORD PTR [edi+4]
	movaps	xmm0, xmm3
	movss	xmm1, DWORD PTR [edi+8]
	mulss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR _diagX$1$[esp+144], xmm3
	addss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1028 : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movss	xmm3, DWORD PTR [edi+16]
	movss	xmm2, DWORD PTR [edi+12]
	movss	xmm1, DWORD PTR [edi+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1028 : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	mulss	xmm2, xmm2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _scaleX$1$[esp+144], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1028 : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	movss	DWORD PTR _diagY$1$[esp+144], xmm3
	addss	xmm2, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1029 : 	TFloat32 scaleZ = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	movss	xmm1, DWORD PTR [edi+24]
	movss	xmm2, DWORD PTR [edi+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1029 : 	TFloat32 scaleZ = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	mulss	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _scaleY$1$[esp+144], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1029 : 	TFloat32 scaleZ = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	movss	xmm0, DWORD PTR [edi+28]
	mulss	xmm0, xmm0
	movss	DWORD PTR _diagZ$1$[esp+144], xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
	xorps	xmm5, xmm5
	cvtsd2ss xmm5, xmm0
	movss	DWORD PTR _scaleZ$1$[esp+144], xmm5
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1032 : 	if (pAxis || pfAngle)

	test	esi, esi
	jne	SHORT $LN16@DecomposeT
	cmp	DWORD PTR _pfAngle$GSCopy$1$[esp+144], esi
	je	$LN2@DecomposeT
$LN16@DecomposeT:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm3, DWORD PTR _scaleX$1$[esp+144]
	movsd	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm3
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1035 : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	ja	$LN87@DecomposeT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm4, DWORD PTR _scaleY$1$[esp+144]
	cvtps2pd xmm0, xmm4
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1035 : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	ja	$LN87@DecomposeT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm5
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1035 : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	ja	$LN87@DecomposeT

; 1036 : 		TFloat32 invScaleX = 1.0f / scaleX;

	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm1

; 1037 : 		TFloat32 invScaleY = 1.0f / scaleY;

	movaps	xmm2, xmm1
	divss	xmm0, xmm3
	divss	xmm2, xmm4

; 1038 : 		TFloat32 invScaleZ = 1.0f / scaleZ;
; 1039 : 
; 1040 : 		// Calculate rotation using trace of matrix (the sum of diagonal elements) 
; 1041 : 		TFloat32 diagX = e00 * invScaleX; // Remove scaling

	movss	xmm3, DWORD PTR _diagX$1$[esp+144]
	movaps	xmm4, xmm1
	divss	xmm4, xmm5
	mulss	xmm3, xmm0
	movss	DWORD PTR _zIn$1$[esp+144], xmm0

; 1042 : 		TFloat32 diagY = e11 * invScaleY;

	movss	xmm0, DWORD PTR _diagY$1$[esp+144]
	mulss	xmm0, xmm2
	movss	DWORD PTR _invScaleY$1$[esp+144], xmm2

; 1043 : 		TFloat32 diagZ = e22 * invScaleZ;

	movss	xmm2, DWORD PTR _diagZ$1$[esp+144]
	movss	DWORD PTR _diagY$1$[esp+144], xmm0

; 1044 : 		TFloat32 cosAngle = (diagX + diagY + diagZ - 1.0f) * 0.5f;

	addss	xmm0, xmm3
	mulss	xmm2, xmm4
	movss	DWORD PTR _invScaleZ$1$[esp+144], xmm4
	movss	DWORD PTR _diagX$1$[esp+144], xmm3
	addss	xmm0, xmm2
	movss	DWORD PTR _diagZ$1$[esp+144], xmm2
	subss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 639  :     return (float)acos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_acos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1048 : 		if (pfAngle)

	mov	eax, DWORD PTR _pfAngle$GSCopy$1$[esp+144]
	xorps	xmm3, xmm3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 639  :     return (float)acos(_X);

	cvtsd2ss xmm3, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1048 : 		if (pfAngle)

	test	eax, eax
	je	SHORT $LN13@DecomposeT

; 1049 : 		{
; 1050 : 			*pfAngle = angle;

	movss	DWORD PTR [eax], xmm3
$LN13@DecomposeT:

; 1051 : 		}
; 1052 : 
; 1053 : 		// Get axis if required
; 1054 : 		if (pAxis)

	test	esi, esi
	je	$LN84@DecomposeT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movsd	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm3
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1057 : 			if (IsZero( angle ))

	jbe	SHORT $LN11@DecomposeT

; 1058 : 			{
; 1059 : 				*pAxis = CVector3::kZAxis;

	push	OFFSET ?kZAxis@CVector3@gen@@2V12@B	; gen::CVector3::kZAxis
	mov	ecx, esi
	call	??4CVector3@gen@@QAEAAV01@ABV01@@Z	; gen::CVector3::operator=

; 1063 : 			else if (!IsZero( angle - kfPi ))

	jmp	$LN84@DecomposeT
$LN11@DecomposeT:
	subss	xmm3, DWORD PTR __real@40490fdb
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm3
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1063 : 			else if (!IsZero( angle - kfPi ))

	ja	SHORT $LN9@DecomposeT

; 1067 : 							e01 *invScaleX - e10 * invScaleY );

	movss	xmm2, DWORD PTR [edi+24]

; 1068 : 				pAxis->Normalise();

	mov	ecx, esi
	movss	xmm3, DWORD PTR _zIn$1$[esp+144]
	mulss	xmm2, DWORD PTR _invScaleZ$1$[esp+144]
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [edi+8]
	mulss	xmm3, DWORD PTR [edi+4]
	movss	xmm1, DWORD PTR [edi+20]
	subss	xmm2, xmm0
	movss	xmm0, DWORD PTR [edi+12]
	mulss	xmm0, DWORD PTR _invScaleY$1$[esp+144]
	mulss	xmm1, DWORD PTR _invScaleY$1$[esp+144]
	subss	xmm3, xmm0
	movss	xmm0, DWORD PTR [edi+28]
	mulss	xmm0, DWORD PTR _invScaleZ$1$[esp+144]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 123  : 		y = yIn;

	movss	DWORD PTR [esi+4], xmm2
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1067 : 							e01 *invScaleX - e10 * invScaleY );

	subss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 124  : 		z = zIn;

	movss	DWORD PTR [esi+8], xmm3
	movss	DWORD PTR [esi], xmm1
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1068 : 				pAxis->Normalise();

	call	?Normalise@CVector3@gen@@QAEXXZ		; gen::CVector3::Normalise

; 1069 : 			}
; 1070 : 
; 1071 : 			// Or if rotation is 180 degrees
; 1072 : 			else

	jmp	$LN84@DecomposeT
$LN9@DecomposeT:

; 1073 : 			{
; 1074 : 				// Find largest x,y or z axis component by manipulating diagonal elts
; 1075 : 				TFloat32 maxAxis, invMaxAxis;
; 1076 : 				if (diagX > diagY)

	movss	xmm1, DWORD PTR _diagX$1$[esp+144]
	movss	xmm2, DWORD PTR _diagY$1$[esp+144]
	comiss	xmm1, xmm2

; 1077 : 				{
; 1078 : 					if (diagX > diagZ)

	movss	xmm0, DWORD PTR _diagZ$1$[esp+144]
	jbe	SHORT $LN7@DecomposeT
	comiss	xmm1, xmm0
	jbe	$LN3@DecomposeT

; 1079 : 					{
; 1080 : 						maxAxis = Sqrt(diagX - diagY - diagZ + 1.0f);

	subss	xmm1, xmm2
	subss	xmm1, xmm0
	addss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1083 : 						invMaxAxis = 1.0f / maxAxis;

	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1083 : 						invMaxAxis = 1.0f / maxAxis;

	divss	xmm2, xmm1
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esi], xmm0

; 1084 : 						pAxis->y = e01 * invMaxAxis;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [edi+4]
	movss	DWORD PTR [esi+4], xmm0

; 1085 : 						pAxis->z = e02 * invMaxAxis;

	mulss	xmm2, DWORD PTR [edi+8]
	movss	DWORD PTR [esi+8], xmm2

; 1086 : 					}
; 1087 : 					else
; 1088 : 					{
; 1089 : 						maxAxis = Sqrt(diagZ - diagX - diagY + 1.0f);
; 1090 : 						pAxis->z = 0.5f * maxAxis;
; 1091 : 						invMaxAxis = 1.0f / maxAxis;
; 1092 : 						pAxis->x = e02 * invMaxAxis;
; 1093 : 						pAxis->y = e12 * invMaxAxis;
; 1094 : 					}

	jmp	$LN84@DecomposeT
$LN7@DecomposeT:

; 1095 : 				}
; 1096 : 				else if (diagY > diagZ)

	comiss	xmm2, xmm0
	jbe	SHORT $LN3@DecomposeT

; 1097 : 				{
; 1098 : 					maxAxis = Sqrt(diagY - diagZ - diagX + 1.0f);

	subss	xmm2, xmm0
	subss	xmm2, xmm1
	addss	xmm2, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1100 : 					invMaxAxis = 1.0f / maxAxis;

	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1100 : 					invMaxAxis = 1.0f / maxAxis;

	divss	xmm2, xmm1
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esi+4], xmm0

; 1101 : 					pAxis->x = e01 * invMaxAxis;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [edi+4]
	movss	DWORD PTR [esi], xmm0

; 1102 : 					pAxis->z = e12 * invMaxAxis;

	movss	xmm0, DWORD PTR [edi+20]
	mulss	xmm0, xmm2
	movss	DWORD PTR [esi+8], xmm0

; 1103 : 				}
; 1104 : 				else

	jmp	SHORT $LN84@DecomposeT
$LN3@DecomposeT:

; 1105 : 				{
; 1106 : 					maxAxis = Sqrt(diagZ - diagX - diagY + 1.0f);

	subss	xmm0, xmm1
	subss	xmm0, xmm2
	addss	xmm0, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1108 : 					invMaxAxis = 1.0f / maxAxis;

	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 1108 : 					invMaxAxis = 1.0f / maxAxis;

	divss	xmm2, xmm1
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR [esi+8], xmm0

; 1109 : 					pAxis->x = e02 * invMaxAxis;

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [edi+8]
	movss	DWORD PTR [esi], xmm0

; 1110 : 					pAxis->y = e12 * invMaxAxis;

	movss	xmm0, DWORD PTR [edi+20]
	mulss	xmm0, xmm2
	movss	DWORD PTR [esi+4], xmm0
$LN84@DecomposeT:
	movss	xmm5, DWORD PTR _scaleZ$1$[esp+144]
$LN2@DecomposeT:

; 1111 : 				}
; 1112 : 			}
; 1113 : 		}
; 1114 : 	}
; 1115 : 
; 1116 : 	// Get scale if required
; 1117 : 	if (pScale)

	mov	eax, DWORD PTR _pScale$GSCopy$1$[esp+144]
	test	eax, eax
	je	SHORT $LN1@DecomposeT

; 1118 : 	{
; 1119 : 		pScale->x = scaleX;

	movss	xmm0, DWORD PTR _scaleX$1$[esp+144]
	movss	DWORD PTR [eax], xmm0

; 1120 : 		pScale->y = scaleY;

	movss	xmm0, DWORD PTR _scaleY$1$[esp+144]
	movss	DWORD PTR [eax+4], xmm0

; 1121 : 		pScale->z = scaleZ;

	movss	DWORD PTR [eax+8], xmm5
$LN1@DecomposeT:

; 1122 : 	}
; 1123 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+144]
	pop	edi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN87@DecomposeT:

; 1035 : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	push	1035					; 0000040bH
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T1[esp+156]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T1[esp+148]
	push	eax
	call	__CxxThrowException@8
$LN88@DecomposeT:
$LN85@DecomposeT:
	int	3
?DecomposeTransformAxisAngle@CMatrix3x3@gen@@QBEXPAVCVector3@2@PAM0@Z ENDP ; gen::CMatrix3x3::DecomposeTransformAxisAngle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?DecomposeTransformQuaternion@CMatrix3x3@gen@@QBEXPAVCQuaternion@2@PAVCVector3@2@@Z
_TEXT	SEGMENT
_scaleZ$1$ = -116					; size = 4
_invScaleY$1$ = -112					; size = 4
_invScaleX$1$ = -108					; size = 4
_invScaleZ$1$ = -104					; size = 4
_scaleX$1$ = -100					; size = 4
_scaleY$1$ = -96					; size = 4
_pScale$GSCopy$1$ = -92					; size = 4
$T1 = -88						; size = 76
__$ArrayPad$ = -4					; size = 4
_pQuat$ = 8						; size = 4
_pScale$ = 12						; size = 4
?DecomposeTransformQuaternion@CMatrix3x3@gen@@QBEXPAVCQuaternion@2@PAVCVector3@2@@Z PROC ; gen::CMatrix3x3::DecomposeTransformQuaternion, COMDAT
; _this$ = ecx

; 929  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+120], eax
	mov	eax, DWORD PTR _pScale$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _pScale$GSCopy$1$[esp+124], eax
	push	edi
	mov	edi, DWORD PTR _pQuat$[ebp]

; 930  : 	// Calculate matrix scaling
; 931  : 	TFloat32 scaleX = Sqrt( e00*e00 + e01*e01 + e02*e02 );

	movss	xmm2, DWORD PTR [esi+4]
	movss	xmm0, DWORD PTR [esi]
	movss	xmm1, DWORD PTR [esi+8]
	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm0, xmm2
	addss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 932  : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movss	xmm2, DWORD PTR [esi+12]
	movss	xmm1, DWORD PTR [esi+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 932  : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	mulss	xmm2, xmm2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _scaleX$1$[esp+128], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 932  : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movss	xmm0, DWORD PTR [esi+16]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	addss	xmm2, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 933  : 	TFloat32 scaleZ = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	movss	xmm1, DWORD PTR [esi+24]
	movss	xmm2, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 933  : 	TFloat32 scaleZ = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	mulss	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _scaleY$1$[esp+128], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 933  : 	TFloat32 scaleZ = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	movss	xmm0, DWORD PTR [esi+28]
	mulss	xmm0, xmm0
	addss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
	xorps	xmm6, xmm6
	cvtsd2ss xmm6, xmm0
	movss	DWORD PTR _scaleZ$1$[esp+128], xmm6
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 936  : 	if (pQuat)

	test	edi, edi
	je	$LN2@DecomposeT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm3, DWORD PTR _scaleX$1$[esp+128]
	movsd	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm3
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 939  : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	ja	$LN67@DecomposeT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm4, DWORD PTR _scaleY$1$[esp+128]
	cvtps2pd xmm0, xmm4
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 939  : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	ja	$LN67@DecomposeT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm6
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 939  : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	ja	$LN67@DecomposeT

; 940  : 		TFloat32 invScaleX = 1.0f / scaleX;

	movss	xmm5, DWORD PTR __real@3f800000
	movaps	xmm0, xmm5

; 941  : 		TFloat32 invScaleY = 1.0f / scaleY;
; 942  : 		TFloat32 invScaleZ = 1.0f / scaleZ;
; 943  : 
; 944  : 		// Calculate trace of matrix (the sum of diagonal elements)
; 945  : 		TFloat32 diagX = e00 * invScaleX; // Remove scaling
; 946  : 		TFloat32 diagY = e11 * invScaleY;

	movss	xmm2, DWORD PTR [esi+16]
	divss	xmm0, xmm3
	movaps	xmm3, xmm5
	movss	xmm1, DWORD PTR [esi]
	divss	xmm3, xmm4
	movaps	xmm4, xmm5
	mulss	xmm1, xmm0
	divss	xmm4, xmm6
	mulss	xmm2, xmm3
	movss	DWORD PTR _invScaleY$1$[esp+128], xmm3
	movss	DWORD PTR _invScaleX$1$[esp+128], xmm0

; 947  : 		TFloat32 diagZ = e22 * invScaleZ;

	movss	xmm0, DWORD PTR [esi+32]

; 948  : 		TFloat32 trace = diagX + diagY + diagZ;

	movaps	xmm3, xmm2
	addss	xmm3, xmm1
	mulss	xmm0, xmm4
	movss	DWORD PTR _invScaleZ$1$[esp+128], xmm4
	addss	xmm3, xmm0

; 949  : 
; 950  : 		// Simple method if trace is positive
; 951  : 		if (trace > 0.0f)

	comiss	xmm3, DWORD PTR __real@00000000
	jbe	$LN9@DecomposeT

; 952  : 		{
; 953  : 			// Derive quaternion from remaining elements
; 954  : 			TFloat32 cosAng = Sqrt( trace + 1.0f );

	addss	xmm3, xmm5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm3
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 955  : 			pQuat->w = cosAng * 0.5f;

	movss	xmm2, DWORD PTR __real@3f000000
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 958  : 			pQuat->y = (e20*invScaleZ - e02*invScaleX) * invCosAng;

	movss	xmm3, DWORD PTR _invScaleX$1$[esp+128]
	movaps	xmm0, xmm1
	mulss	xmm0, xmm2
	divss	xmm2, xmm1
	movss	DWORD PTR [edi], xmm0
	movss	xmm1, DWORD PTR [esi+20]
	movss	xmm0, DWORD PTR [esi+28]
	mulss	xmm1, DWORD PTR _invScaleY$1$[esp+128]
	mulss	xmm0, DWORD PTR _invScaleZ$1$[esp+128]
	subss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm1, xmm2
	movss	DWORD PTR [edi+4], xmm1
	movss	xmm1, DWORD PTR [esi+24]
	mulss	xmm0, DWORD PTR [esi+8]
	mulss	xmm1, DWORD PTR _invScaleZ$1$[esp+128]
	subss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [edi+8], xmm1

; 959  : 			pQuat->z = (e01*invScaleX - e10*invScaleY) * invCosAng;

	movss	xmm0, DWORD PTR [esi+12]
	mulss	xmm3, DWORD PTR [esi+4]
	mulss	xmm0, DWORD PTR _invScaleY$1$[esp+128]
	subss	xmm3, xmm0
	mulss	xmm3, xmm2
	movss	DWORD PTR [edi+12], xmm3
$LN66@DecomposeT:

; 984  : 				}

	movss	xmm6, DWORD PTR _scaleZ$1$[esp+128]
$LN2@DecomposeT:

; 996  : 			{
; 997  : 				maxAxis = Sqrt( diagZ - diagX - diagY + 1.0f );
; 998  : 				pQuat->z = 0.5f * maxAxis;
; 999  : 				invMaxAxis = 0.5f / maxAxis;
; 1000 : 				pQuat->x = (e20*invScaleZ + e02*invScaleX) * invMaxAxis;
; 1001 : 				pQuat->y = (e12*invScaleY + e21*invScaleZ) * invMaxAxis;
; 1002 : 				pQuat->w = (e01*invScaleX - e10*invScaleY) * invMaxAxis;
; 1003 : 			}
; 1004 : 		}
; 1005 : 	}
; 1006 : 
; 1007 : 	// Return scale if required
; 1008 : 	if (pScale)

	mov	eax, DWORD PTR _pScale$GSCopy$1$[esp+128]
	test	eax, eax
	je	SHORT $LN1@DecomposeT

; 1009 : 	{
; 1010 : 		pScale->x = scaleX;

	movss	xmm0, DWORD PTR _scaleX$1$[esp+128]
	movss	DWORD PTR [eax], xmm0

; 1011 : 		pScale->y = scaleY;

	movss	xmm0, DWORD PTR _scaleY$1$[esp+128]
	movss	DWORD PTR [eax+4], xmm0

; 1012 : 		pScale->z = scaleZ;

	movss	DWORD PTR [eax+8], xmm6
$LN1@DecomposeT:

; 1013 : 	}
; 1014 : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+128]
	pop	edi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN9@DecomposeT:

; 960  : 		}
; 961  : 		else
; 962  : 		{
; 963  : 			// Find largest x,y or z axis component by manipulating diagonal elts
; 964  : 			TFloat32 maxAxis, invMaxAxis;
; 965  : 			if (diagX > diagY)

	comiss	xmm1, xmm2
	jbe	$LN7@DecomposeT

; 966  : 			{
; 967  : 				if (diagX > diagZ)

	comiss	xmm1, xmm0
	jbe	$LN6@DecomposeT

; 968  : 				{
; 969  : 					maxAxis = Sqrt( diagX - diagY - diagZ + 1.0f );

	subss	xmm1, xmm2
	subss	xmm1, xmm0
	addss	xmm1, xmm5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 970  : 					pQuat->x = 0.5f * maxAxis;

	movss	xmm2, DWORD PTR __real@3f000000
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 972  : 					pQuat->y = (e01*invScaleX + e10*invScaleY) * invMaxAxis;

	movss	xmm3, DWORD PTR _invScaleX$1$[esp+128]
	movaps	xmm0, xmm1
	mulss	xmm0, xmm2
	divss	xmm2, xmm1
	movss	DWORD PTR [edi+4], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [esi+4]
	movss	xmm1, DWORD PTR [esi+12]
	mulss	xmm1, DWORD PTR _invScaleY$1$[esp+128]
	addss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [edi+8], xmm1

; 973  : 					pQuat->z = (e20*invScaleZ + e02*invScaleX) * invMaxAxis;

	movss	xmm0, DWORD PTR [esi+24]
	mulss	xmm0, DWORD PTR _invScaleZ$1$[esp+128]
	mulss	xmm3, DWORD PTR [esi+8]
	addss	xmm0, xmm3
	mulss	xmm0, xmm2
	movss	DWORD PTR [edi+12], xmm0

; 974  : 					pQuat->w = (e12*invScaleY - e21*invScaleZ) * invMaxAxis;

	movss	xmm1, DWORD PTR [esi+20]
	movss	xmm0, DWORD PTR [esi+28]
	mulss	xmm1, DWORD PTR _invScaleY$1$[esp+128]
	mulss	xmm0, DWORD PTR _invScaleZ$1$[esp+128]
	subss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [edi], xmm1

; 975  : 				}
; 976  : 				else

	jmp	$LN66@DecomposeT
$LN6@DecomposeT:

; 977  : 				{
; 978  : 					maxAxis = Sqrt( diagZ - diagX - diagY + 1.0f );

	subss	xmm0, xmm1
	subss	xmm0, xmm2
	addss	xmm0, xmm5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 979  : 					pQuat->z = 0.5f * maxAxis;

	movss	xmm2, DWORD PTR __real@3f000000
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 981  : 					pQuat->x = (e20*invScaleZ + e02*invScaleX) * invMaxAxis;

	movss	xmm3, DWORD PTR _invScaleX$1$[esp+128]
	movaps	xmm0, xmm1
	mulss	xmm0, xmm2
	divss	xmm2, xmm1
	movss	DWORD PTR [edi+12], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [esi+8]
	movss	xmm1, DWORD PTR [esi+24]
	mulss	xmm1, DWORD PTR _invScaleZ$1$[esp+128]
	addss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [edi+4], xmm1

; 982  : 					pQuat->y = (e12*invScaleY + e21*invScaleZ) * invMaxAxis;

	movss	xmm0, DWORD PTR [esi+20]
	movss	xmm1, DWORD PTR [esi+28]
	mulss	xmm0, DWORD PTR _invScaleY$1$[esp+128]
	mulss	xmm1, DWORD PTR _invScaleZ$1$[esp+128]
	addss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [edi+8], xmm1

; 983  : 					pQuat->w = (e01*invScaleX - e10*invScaleY) * invMaxAxis;

	movss	xmm0, DWORD PTR [esi+12]
	mulss	xmm3, DWORD PTR [esi+4]
	mulss	xmm0, DWORD PTR _invScaleY$1$[esp+128]
	subss	xmm3, xmm0
	mulss	xmm3, xmm2
	movss	DWORD PTR [edi], xmm3

; 984  : 				}

	jmp	$LN66@DecomposeT
$LN7@DecomposeT:

; 985  : 			}
; 986  : 			else if (diagY > diagZ)

	comiss	xmm2, xmm0
	jbe	$LN6@DecomposeT

; 987  : 			{
; 988  : 				maxAxis = Sqrt( diagY - diagZ - diagX + 1.0f );

	subss	xmm2, xmm0
	subss	xmm2, xmm1
	addss	xmm2, xmm5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm2
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 989  : 				pQuat->y = 0.5f * maxAxis;

	movss	xmm2, DWORD PTR __real@3f000000
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 992  : 				pQuat->x = (e01*invScaleX + e10*invScaleY) * invMaxAxis;

	movss	xmm3, DWORD PTR _invScaleX$1$[esp+128]
	movaps	xmm0, xmm1
	mulss	xmm0, xmm2
	divss	xmm2, xmm1
	movss	DWORD PTR [edi+8], xmm0
	movss	xmm1, DWORD PTR [esi+28]
	movss	xmm0, DWORD PTR [esi+20]
	mulss	xmm0, DWORD PTR _invScaleY$1$[esp+128]
	mulss	xmm1, DWORD PTR _invScaleZ$1$[esp+128]
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm1, xmm2
	movss	DWORD PTR [edi+12], xmm1
	mulss	xmm0, DWORD PTR [esi+4]
	movss	xmm1, DWORD PTR [esi+12]
	mulss	xmm1, DWORD PTR _invScaleY$1$[esp+128]
	addss	xmm1, xmm0
	mulss	xmm1, xmm2
	movss	DWORD PTR [edi+4], xmm1

; 993  : 				pQuat->w = (e20*invScaleZ - e02*invScaleX) * invMaxAxis;

	movss	xmm0, DWORD PTR [esi+24]
	mulss	xmm0, DWORD PTR _invScaleZ$1$[esp+128]
	mulss	xmm3, DWORD PTR [esi+8]
	subss	xmm0, xmm3
	mulss	xmm0, xmm2
	movss	DWORD PTR [edi], xmm0

; 994  : 			}
; 995  : 			else

	jmp	$LN66@DecomposeT
$LN67@DecomposeT:

; 939  : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	push	939					; 000003abH
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T1[esp+140]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T1[esp+132]
	push	eax
	call	__CxxThrowException@8
$LN68@DecomposeT:
$LN65@DecomposeT:
	int	3
?DecomposeTransformQuaternion@CMatrix3x3@gen@@QBEXPAVCQuaternion@2@PAVCVector3@2@@Z ENDP ; gen::CMatrix3x3::DecomposeTransformQuaternion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z
_TEXT	SEGMENT
_e$2 = -416						; size = 4
_scaleZ$1$ = -412					; size = 4
_scaleX$1$ = -408					; size = 4
_scaleY$1$ = -404					; size = 4
tv909 = -400						; size = 8
tv906 = -400						; size = 8
tv898 = -400						; size = 8
tv895 = -400						; size = 8
_pAngles$GSCopy$1$ = -396				; size = 4
tv920 = -392						; size = 8
tv917 = -392						; size = 8
_sX$1$ = -388						; size = 4
tv877 = -388						; size = 4
_invScaleY$1$ = -380					; size = 4
_invScaleZ$1$ = -376					; size = 4
_invScaleX$1$ = -372					; size = 4
_cY$1$ = -368						; size = 4
_cZ$1$ = -364						; size = 4
_sY$1$ = -360						; size = 4
_sZ$1$ = -356						; size = 4
$T3 = -352						; size = 76
$T4 = -272						; size = 76
$T5 = -192						; size = 76
$T6 = -112						; size = 76
__$ArrayPad$ = -28					; size = 4
__$EHRec$ = -16						; size = 16
_pAngles$ = 8						; size = 4
_pScale$ = 12						; size = 4
_eRotOrder$ = 16					; size = 4
?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z PROC ; gen::CMatrix3x3::DecomposeTransformEuler, COMDAT
; _this$ = ecx

; 732  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	sub	esp, 400				; 00000190H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx

; 733  : 	GEN_GUARD;
; 734  : 
; 735  : 	// Calculate matrix scaling
; 736  : 	TFloat32 scaleX = Sqrt( e00*e00 + e01*e01 + e02*e02 );

	movss	xmm2, DWORD PTR [edi+4]
	movss	xmm1, DWORD PTR [edi]
	movaps	xmm0, xmm2
	movss	xmm3, DWORD PTR [edi+8]
	mov	eax, DWORD PTR _pAngles$[ebx]
	mov	esi, DWORD PTR _pScale$[ebx]
	mulss	xmm0, xmm2
	mov	DWORD PTR _pAngles$GSCopy$1$[ebp], eax
	mulss	xmm1, xmm1
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 737  : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movss	xmm2, DWORD PTR [edi+16]
	movss	xmm3, DWORD PTR [edi+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 737  : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movss	DWORD PTR tv877[ebp], xmm3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _scaleX$1$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 737  : 	TFloat32 scaleY = Sqrt( e10*e10 + e11*e11 + e12*e12 );

	movss	xmm0, DWORD PTR [edi+12]
	movaps	xmm1, xmm0
	movss	DWORD PTR _sZ$1$[ebp], xmm0
	mulss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 738  : 	TFloat32 scaleZ = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	movss	xmm2, DWORD PTR [edi+28]
	movss	xmm3, DWORD PTR [edi+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _scaleY$1$[ebp], xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 738  : 	TFloat32 scaleZ = Sqrt( e20*e20 + e21*e21 + e22*e22 );

	movss	xmm0, DWORD PTR [edi+24]
	movaps	xmm1, xmm0
	movss	DWORD PTR _sY$1$[ebp], xmm0
	mulss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, xmm1
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 741  : 	if (pAngles)

	cmp	DWORD PTR _pAngles$GSCopy$1$[ebp], 0
	xorps	xmm5, xmm5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm5, xmm0
	movss	DWORD PTR _scaleZ$1$[ebp], xmm5
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 741  : 	if (pAngles)

	je	$LN25@DecomposeT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm3, DWORD PTR _scaleX$1$[ebp]
	movsd	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm2, DWORD PTR __real@350637bd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm3
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 744  : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	ja	$LN23@DecomposeT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm4, DWORD PTR _scaleY$1$[ebp]
	cvtps2pd xmm0, xmm4
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 744  : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	ja	$LN23@DecomposeT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm5
	andpd	xmm0, xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm2, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 744  : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	ja	$LN23@DecomposeT

; 745  : 		TFloat32 invScaleX = 1.0f / scaleX;

	movss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm1, xmm0

; 746  : 		TFloat32 invScaleY = 1.0f / scaleY;
; 747  : 		TFloat32 invScaleZ = 1.0f / scaleZ;
; 748  : 
; 749  : 		TFloat32 sX, cX, sY, cY, sZ, cZ;
; 750  : 		switch (eRotOrder)

	mov	eax, DWORD PTR _eRotOrder$[ebx]
	divss	xmm1, xmm3
	movaps	xmm3, xmm0
	movss	DWORD PTR _invScaleX$1$[ebp], xmm1
	divss	xmm3, xmm4
	movaps	xmm4, xmm0
	movss	DWORD PTR _invScaleY$1$[ebp], xmm3
	divss	xmm4, xmm5
	movss	DWORD PTR _invScaleZ$1$[ebp], xmm4
	cmp	eax, 5
	ja	$LN2@DecomposeT
	jmp	DWORD PTR $LN145@DecomposeT[eax*4]
$LN20@DecomposeT:

; 751  : 		{
; 752  : 			case kZYX:
; 753  : 			{
; 754  : 				sY = e20 * invScaleX;

	movss	xmm2, DWORD PTR _sY$1$[ebp]
	mulss	xmm2, xmm1

; 755  : 				cY = Sqrt( 1.0f - sY*sY );

	movaps	xmm1, xmm2
	movss	DWORD PTR _sY$1$[ebp], xmm2
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm1, DWORD PTR __real@350637bd
	xorps	xmm2, xmm2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm2, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _cY$1$[ebp], xmm2

; 687  :     return (float)fabs(_X);

	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 760  : 					TFloat32 invCY = 1.0f / cY;

	movss	xmm1, DWORD PTR __real@3f800000
	ja	SHORT $LN19@DecomposeT
	divss	xmm1, xmm2

; 761  : 					sZ = -e10 * invCY * invScaleY;

	movss	xmm2, DWORD PTR _sZ$1$[ebp]

; 762  : 					cZ =  e00 * invCY * invScaleX;
; 763  : 					sX = -e21 * invCY * invScaleZ;

	movss	xmm3, DWORD PTR [edi+28]

; 764  : 					cX =  e22 * invCY * invScaleZ;

	movss	xmm0, DWORD PTR [edi+32]
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
	mulss	xmm2, DWORD PTR _invScaleY$1$[ebp]
	mulss	xmm3, DWORD PTR _invScaleZ$1$[ebp]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sZ$1$[ebp], xmm2
	movss	xmm2, DWORD PTR [edi]
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm2, xmm1
	mulss	xmm0, xmm1
	mulss	xmm2, DWORD PTR _invScaleX$1$[ebp]
	mulss	xmm0, DWORD PTR _invScaleZ$1$[ebp]
	movss	DWORD PTR _cZ$1$[ebp], xmm2
	movaps	xmm4, xmm0

; 765  : 				}
; 766  : 				else

	jmp	$LN3@DecomposeT
$LN19@DecomposeT:

; 767  : 				{
; 768  : 					// Gimbal lock - force Z angle to 0
; 769  : 					sZ = 0.0f;
; 770  : 					cZ = 1.0f;
; 771  : 					sX = e12 * invScaleY;

	movss	xmm3, DWORD PTR tv877[ebp]
	xorps	xmm0, xmm0

; 772  : 					cX = e11 * invScaleY;

	movss	xmm4, DWORD PTR [edi+16]
	mulss	xmm3, DWORD PTR _invScaleY$1$[ebp]
	mulss	xmm4, DWORD PTR _invScaleY$1$[ebp]
	movss	DWORD PTR _sZ$1$[ebp], xmm0
	movss	DWORD PTR _cZ$1$[ebp], xmm1

; 773  : 				}
; 774  : 				break;

	jmp	$LN3@DecomposeT
$LN17@DecomposeT:

; 775  : 			}
; 776  : 
; 777  : 			case kYZX:
; 778  : 			{
; 779  : 				sZ = -e10 * invScaleY;

	movss	xmm2, DWORD PTR _sZ$1$[ebp]
	mulss	xmm2, xmm3
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000

; 780  : 				cZ = Sqrt( 1.0f - sZ*sZ );

	movaps	xmm1, xmm2
	movss	DWORD PTR _sZ$1$[ebp], xmm2
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm1, DWORD PTR __real@350637bd
	xorps	xmm2, xmm2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm2, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _cZ$1$[ebp], xmm2

; 687  :     return (float)fabs(_X);

	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 785  : 					TFloat32 invCZ = 1.0f / cZ;

	movss	xmm1, DWORD PTR __real@3f800000
	ja	SHORT $LN16@DecomposeT
	divss	xmm1, xmm2

; 786  : 					sY = e20 * invCZ * invScaleZ;

	movss	xmm0, DWORD PTR _sY$1$[ebp]

; 787  : 					cY = e00 * invCZ * invScaleX;
; 788  : 					sX = e12 * invCZ * invScaleY;

	movss	xmm3, DWORD PTR tv877[ebp]

; 789  : 					cX = e11 * invCZ * invScaleY;

	movss	xmm4, DWORD PTR [edi+16]
	mulss	xmm0, xmm1
	mulss	xmm3, xmm1
	mulss	xmm0, DWORD PTR _invScaleZ$1$[ebp]
	mulss	xmm3, DWORD PTR _invScaleY$1$[ebp]
	movss	DWORD PTR _sY$1$[ebp], xmm0
	movss	xmm0, DWORD PTR [edi]
	mulss	xmm0, xmm1
	mulss	xmm4, xmm1
	mulss	xmm0, DWORD PTR _invScaleX$1$[ebp]
	mulss	xmm4, DWORD PTR _invScaleY$1$[ebp]
	movss	DWORD PTR _cY$1$[ebp], xmm0

; 790  : 				}
; 791  : 				else

	jmp	$LN3@DecomposeT
$LN16@DecomposeT:

; 792  : 				{
; 793  : 					// Gimbal lock - force Y angle to 0
; 794  : 					sY = 0.0f;
; 795  : 					cY = 1.0f;
; 796  : 					sX = -e21 * invScaleZ;

	movss	xmm3, DWORD PTR [edi+28]
	xorps	xmm0, xmm0
	mulss	xmm3, DWORD PTR _invScaleZ$1$[ebp]

; 797  : 					cX =  e22 * invScaleZ;

	movss	xmm4, DWORD PTR [edi+32]
	mulss	xmm4, DWORD PTR _invScaleZ$1$[ebp]
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sY$1$[ebp], xmm0
	movss	DWORD PTR _cY$1$[ebp], xmm1

; 798  : 				}
; 799  : 				break;

	jmp	$LN3@DecomposeT
$LN14@DecomposeT:

; 800  : 			}
; 801  : 
; 802  : 			case kXZY:
; 803  : 			{
; 804  : 				sZ = e01 * invScaleX;

	movss	xmm2, DWORD PTR [edi+4]
	mulss	xmm2, xmm1

; 805  : 				cZ = Sqrt( 1.0f - sZ*sZ );

	movaps	xmm1, xmm2
	movss	DWORD PTR _sZ$1$[ebp], xmm2
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm1, DWORD PTR __real@350637bd
	xorps	xmm2, xmm2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm2, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _cZ$1$[ebp], xmm2

; 687  :     return (float)fabs(_X);

	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 808  : 				if (!IsZero( cZ ))

	ja	SHORT $LN13@DecomposeT

; 809  : 				{
; 810  : 					TFloat32 invCZ = 1.0f / cZ;

	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm2

; 811  : 					sX = -e21 * invCZ * invScaleZ;
; 812  : 					cX =  e11 * invCZ * invScaleY;
; 813  : 					sY = -e02 * invCZ * invScaleX;

	movss	xmm2, DWORD PTR [edi+8]
	movss	xmm3, DWORD PTR [edi+28]

; 814  : 					cY =  e00 * invCZ * invScaleX;

	movss	xmm0, DWORD PTR [edi]
	movss	xmm4, DWORD PTR [edi+16]
	mulss	xmm2, xmm1
	mulss	xmm3, xmm1
	mulss	xmm2, DWORD PTR _invScaleX$1$[ebp]
	mulss	xmm3, DWORD PTR _invScaleZ$1$[ebp]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, xmm1
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm4, xmm1
	mulss	xmm0, DWORD PTR _invScaleX$1$[ebp]
	mulss	xmm4, DWORD PTR _invScaleY$1$[ebp]
	movss	DWORD PTR _sY$1$[ebp], xmm2
	movss	DWORD PTR _cY$1$[ebp], xmm0

; 815  : 				}
; 816  : 				else

	jmp	$LN3@DecomposeT
$LN13@DecomposeT:

; 817  : 				{
; 818  : 					// Gimbal lock - force X angle to 0
; 819  : 					sX = 0.0f;
; 820  : 					cX = 1.0f;
; 821  : 					sY = e20 * invScaleZ;

	movss	xmm0, DWORD PTR _sY$1$[ebp]
	mulss	xmm0, DWORD PTR _invScaleZ$1$[ebp]
	movss	DWORD PTR _sY$1$[ebp], xmm0

; 822  : 					cY = e22 * invScaleZ;

	movss	xmm0, DWORD PTR [edi+32]
	mulss	xmm0, DWORD PTR _invScaleZ$1$[ebp]
	movss	DWORD PTR _cY$1$[ebp], xmm0

; 823  : 				}
; 824  : 				break;

	jmp	$LN144@DecomposeT
$LN11@DecomposeT:

; 825  : 			}
; 826  : 
; 827  : 			case kZXY:
; 828  : 			{
; 829  : 				sX = -e21 * invScaleZ;

	movss	xmm2, DWORD PTR [edi+28]
	mulss	xmm2, xmm4
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000

; 830  : 				cX = Sqrt( 1.0f - sX*sX );

	movaps	xmm1, xmm2
	movss	DWORD PTR _sX$1$[ebp], xmm2
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm1, DWORD PTR __real@350637bd
	xorps	xmm4, xmm4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 841  : 				else

	movss	xmm3, DWORD PTR _sX$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm4, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm4
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 835  : 					TFloat32 invCX = 1.0f / cX;

	movss	xmm1, DWORD PTR __real@3f800000
	ja	SHORT $LN10@DecomposeT
	divss	xmm1, xmm4

; 836  : 					sZ = e01 * invCX * invScaleX;

	movss	xmm2, DWORD PTR [edi+4]
	movaps	xmm0, xmm2

; 837  : 					cZ = e11 * invCX * invScaleY;

	movss	xmm2, DWORD PTR [edi+16]
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _invScaleX$1$[ebp]
	movss	DWORD PTR _sZ$1$[ebp], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _invScaleY$1$[ebp]
	movss	DWORD PTR _cZ$1$[ebp], xmm0

; 838  : 					sY = e20 * invCX * invScaleZ;

	movss	xmm0, DWORD PTR _sY$1$[ebp]
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _invScaleZ$1$[ebp]
	movss	DWORD PTR _sY$1$[ebp], xmm0

; 839  : 					cY = e22 * invCX * invScaleZ;

	movss	xmm0, DWORD PTR [edi+32]
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _invScaleZ$1$[ebp]
	movss	DWORD PTR _cY$1$[ebp], xmm0

; 841  : 				else

	jmp	$LN3@DecomposeT
$LN10@DecomposeT:

; 842  : 				{
; 843  : 					// Gimbal lock - force Z angle to 0
; 844  : 					sZ = 0.0f;
; 845  : 					cZ = 1.0f;
; 846  : 					sY = -e02 * invScaleX;

	movss	xmm2, DWORD PTR [edi+8]
	xorps	xmm0, xmm0
	movss	DWORD PTR _sZ$1$[ebp], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _invScaleX$1$[ebp]
	movss	DWORD PTR _cZ$1$[ebp], xmm1
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sY$1$[ebp], xmm0

; 847  : 					cY =  e00 * invScaleX;

	movss	xmm0, DWORD PTR [edi]
	mulss	xmm0, DWORD PTR _invScaleX$1$[ebp]
	movss	DWORD PTR _cY$1$[ebp], xmm0

; 848  : 				}
; 849  : 				break;

	jmp	$LN3@DecomposeT
$LN8@DecomposeT:

; 850  : 			}
; 851  : 
; 852  : 			case kYXZ:
; 853  : 			{
; 854  : 				sX = e12 * invScaleY;

	movss	xmm2, DWORD PTR tv877[ebp]
	mulss	xmm2, xmm3

; 855  : 				cX = Sqrt( 1.0f - sX*sX );

	movaps	xmm1, xmm2
	movss	DWORD PTR _sX$1$[ebp], xmm2
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm1, DWORD PTR __real@350637bd
	xorps	xmm4, xmm4
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 866  : 				else

	movss	xmm3, DWORD PTR _sX$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm4, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm4
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 860  : 					TFloat32 invCX = 1.0f / cX;

	movss	xmm1, DWORD PTR __real@3f800000
	ja	$LN7@DecomposeT
	divss	xmm1, xmm4

; 861  : 					sY = -e02 * invCX * invScaleX;

	movss	xmm2, DWORD PTR [edi+8]
	mulss	xmm2, xmm1
	mulss	xmm2, DWORD PTR _invScaleX$1$[ebp]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sY$1$[ebp], xmm2

; 862  : 					cY =  e22 * invCX * invScaleZ;

	movss	xmm2, DWORD PTR [edi+32]
	mulss	xmm2, xmm1
	mulss	xmm2, DWORD PTR _invScaleZ$1$[ebp]
	movss	DWORD PTR _cY$1$[ebp], xmm2

; 863  : 					sZ = -e10 * invCX * invScaleY;

	movss	xmm2, DWORD PTR _sZ$1$[ebp]
	mulss	xmm2, xmm1
	mulss	xmm2, DWORD PTR _invScaleY$1$[ebp]
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sZ$1$[ebp], xmm2

; 864  : 					cZ =  e11 * invCX * invScaleY;

	movss	xmm2, DWORD PTR [edi+16]
	movaps	xmm0, xmm2
	mulss	xmm0, xmm1
	mulss	xmm0, DWORD PTR _invScaleY$1$[ebp]
	movss	DWORD PTR _cZ$1$[ebp], xmm0

; 866  : 				else

	jmp	$LN3@DecomposeT
$LN7@DecomposeT:

; 867  : 				{
; 868  : 					// Gimbal lock - force Y angle to 0
; 869  : 					sY = 0.0f;
; 870  : 					cY = 1.0f;
; 871  : 					sZ = e01 * invScaleX;

	movss	xmm2, DWORD PTR [edi+4]
	xorps	xmm0, xmm0
	movss	DWORD PTR _sY$1$[ebp], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _invScaleX$1$[ebp]
	movss	DWORD PTR _cY$1$[ebp], xmm1
	movss	DWORD PTR _sZ$1$[ebp], xmm0

; 872  : 					cZ = e00 * invScaleX;

	movss	xmm0, DWORD PTR [edi]
	mulss	xmm0, DWORD PTR _invScaleX$1$[ebp]
	movss	DWORD PTR _cZ$1$[ebp], xmm0

; 873  : 				}
; 874  : 				break;

	jmp	$LN3@DecomposeT
$LN5@DecomposeT:

; 875  : 			}
; 876  : 
; 877  : 			case kXYZ:
; 878  : 			{
; 879  : 				sY = -e02 * invScaleX;

	movss	xmm2, DWORD PTR [edi+8]
	mulss	xmm2, xmm1
	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000

; 880  : 				cY = Sqrt( 1.0f - sY*sY );

	movaps	xmm1, xmm2
	movss	DWORD PTR _sY$1$[ebp], xmm2
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm1, DWORD PTR __real@350637bd
	xorps	xmm2, xmm2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm2, xmm0

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2

; 775  :     return (float)sqrt(_X);

	movss	DWORD PTR _cY$1$[ebp], xmm2

; 687  :     return (float)fabs(_X);

	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	comiss	xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 883  : 				if (!IsZero( cY ))

	ja	SHORT $LN4@DecomposeT

; 884  : 				{
; 885  : 					TFloat32 invCY = 1.0f / cY;

	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm2

; 886  : 					sX = e12 * invCY * invScaleY;
; 887  : 					cX = e22 * invCY * invScaleZ;
; 888  : 					sZ = e01 * invCY * invScaleX;

	movss	xmm2, DWORD PTR [edi+4]
	movss	xmm3, DWORD PTR tv877[ebp]
	movaps	xmm0, xmm2
	movss	xmm4, DWORD PTR [edi+32]
	mulss	xmm0, xmm1
	mulss	xmm3, xmm1
	mulss	xmm0, DWORD PTR _invScaleX$1$[ebp]
	mulss	xmm3, DWORD PTR _invScaleY$1$[ebp]
	movss	DWORD PTR _sZ$1$[ebp], xmm0

; 889  : 					cZ = e00 * invCY * invScaleX;

	movss	xmm0, DWORD PTR [edi]
	mulss	xmm0, xmm1
	mulss	xmm4, xmm1
	mulss	xmm0, DWORD PTR _invScaleX$1$[ebp]
	mulss	xmm4, DWORD PTR _invScaleZ$1$[ebp]
	movss	DWORD PTR _cZ$1$[ebp], xmm0

; 890  : 				}
; 891  : 				else

	jmp	SHORT $LN3@DecomposeT
$LN4@DecomposeT:

; 896  : 					sZ = -e10 * invScaleY;

	movss	xmm0, DWORD PTR _sZ$1$[ebp]
	mulss	xmm0, DWORD PTR _invScaleY$1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sZ$1$[ebp], xmm0

; 897  : 					cZ =  e11 * invScaleY;

	movss	xmm0, DWORD PTR [edi+16]
	mulss	xmm0, DWORD PTR _invScaleY$1$[ebp]
	movss	DWORD PTR _cZ$1$[ebp], xmm0
$LN144@DecomposeT:

; 892  : 				{
; 893  : 					// Gimbal lock - force X angle to 0
; 894  : 					sX = 0.0f;
; 895  : 					cX = 1.0f;

	movss	xmm4, DWORD PTR __real@3f800000
	xorps	xmm3, xmm3
$LN3@DecomposeT:
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

	cvtss2sd xmm0, xmm3
	movsd	QWORD PTR tv920[ebp], xmm0
	xorps	xmm0, xmm0
	fld	QWORD PTR tv920[ebp]
	cvtss2sd xmm0, xmm4
	movsd	QWORD PTR tv917[ebp], xmm0
	fld	QWORD PTR tv917[ebp]
	call	__CIatan2
	movss	xmm0, DWORD PTR _sY$1$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 906  : 		pAngles->x = ATan( sX, cX );

	mov	edi, DWORD PTR _pAngles$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

	cvtps2pd xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 906  : 		pAngles->x = ATan( sX, cX );

	fstp	DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

	movsd	QWORD PTR tv909[ebp], xmm0
	movss	xmm0, DWORD PTR _cY$1$[ebp]
	fld	QWORD PTR tv909[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv906[ebp], xmm0
	fld	QWORD PTR tv906[ebp]
	call	__CIatan2
	movss	xmm0, DWORD PTR _sZ$1$[ebp]
	cvtps2pd xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 907  : 		pAngles->y = ATan( sY, cY );

	fstp	DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

	movsd	QWORD PTR tv898[ebp], xmm0
	movss	xmm0, DWORD PTR _cZ$1$[ebp]
	fld	QWORD PTR tv898[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv895[ebp], xmm0
	fld	QWORD PTR tv895[ebp]
	call	__CIatan2
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 908  : 		pAngles->z = ATan( sZ, cZ );

	movss	xmm5, DWORD PTR _scaleZ$1$[ebp]
	fstp	DWORD PTR [edi+8]
$LN25@DecomposeT:

; 909  : 	}
; 910  : 
; 911  : 	// Return scale if required
; 912  : 	if (pScale)

	test	esi, esi
	je	SHORT $LN1@DecomposeT

; 913  : 	{
; 914  : 		pScale->x = scaleX;

	movss	xmm0, DWORD PTR _scaleX$1$[ebp]
	movss	DWORD PTR [esi], xmm0

; 915  : 		pScale->y = scaleY;

	movss	xmm0, DWORD PTR _scaleY$1$[ebp]
	movss	DWORD PTR [esi+4], xmm0

; 916  : 		pScale->z = scaleZ;

	movss	DWORD PTR [esi+8], xmm5
$LN1@DecomposeT:

; 920  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	12					; 0000000cH
$LN2@DecomposeT:

; 898  : 				}
; 899  : 				break;
; 900  : 			}
; 901  : 
; 902  : 			default:
; 903  : 				GEN_ERROR( "Invalid parameter" );

	push	903					; 00000387H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BC@DBAKKFEN@Invalid?5parameter?$AA@
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	__CxxThrowException@8
$LN146@DecomposeT:
$LN23@DecomposeT:

; 744  : 		GEN_ASSERT( !IsZero(scaleX) && !IsZero(scaleY) && !IsZero(scaleZ), "Singular matrix" );

	push	744					; 000002e8H
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	push	OFFSET ??_C@_0BA@EJDDFENM@Singular?5matrix?$AA@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0CFatalException@gen@@QAE@PBD0H@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__CxxThrowException@8
$LN147@DecomposeT:
__catch$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z$0:
	mov	ebx, DWORD PTR [ebp-20]

; 917  : 	}
; 918  : 
; 919  : 	GEN_ENDGUARD;

	mov	esi, DWORD PTR _e$2[ebp]
	mov	ecx, esi
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CJ@DHMHJNHL@gen?3?3CMatrix3x3?3?3DecomposeTransf@
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack
	push	esi
	lea	ecx, DWORD PTR $T6[ebp]
	call	??0CFatalException@gen@@QAE@ABV01@@Z
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	__CxxThrowException@8
$LN148@DecomposeT:
__catch$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z$1:
	mov	ebx, DWORD PTR [ebp-20]
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	OFFSET ??_C@_0CJ@DHMHJNHL@gen?3?3CMatrix3x3?3?3DecomposeTransf@
	push	OFFSET ??_C@_0BL@OAOLJHMJ@Import?2Math?2CMatrix3x3?4cpp?$AA@
	lea	ecx, DWORD PTR $T5[ebp]
	call	??0CFatalException@gen@@QAE@PBD00@Z	; gen::CFatalException::CFatalException
	push	OFFSET __TI1?AVCFatalException@gen@@
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	__CxxThrowException@8
$LN149@DecomposeT:
$LN143@DecomposeT:
	npad	2
$LN145@DecomposeT:

; 920  : }

	DD	$LN5@DecomposeT
	DD	$LN14@DecomposeT
	DD	$LN17@DecomposeT
	DD	$LN8@DecomposeT
	DD	$LN11@DecomposeT
	DD	$LN20@DecomposeT
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-420]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DecomposeTransformEuler@CMatrix3x3@gen@@QBEXPAVCVector3@2@0W4ERotationOrder@2@@Z ENDP ; gen::CMatrix3x3::DecomposeTransformEuler
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeTransformAxisAngle@CMatrix3x3@gen@@QAEXABVCVector3@2@M0@Z
_TEXT	SEGMENT
_axis$ = 8						; size = 4
_fAngle$ = 12						; size = 4
_scale$ = 16						; size = 4
?MakeTransformAxisAngle@CMatrix3x3@gen@@QAEXABVCVector3@2@M0@Z PROC ; gen::CMatrix3x3::MakeTransformAxisAngle, COMDAT
; _this$ = ecx

; 704  : {

	push	ebp
	mov	ebp, esp

; 705  : 	// First build rotation matrix
; 706  : 	MakeRotation( axis, fAngle );

	movss	xmm0, DWORD PTR _fAngle$[ebp]
	push	esi
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	esi, ecx
	push	DWORD PTR _axis$[ebp]
	call	?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z ; gen::CMatrix3x3::MakeRotation

; 707  : 
; 708  : 	// Scale matrix
; 709  : 	e00 *= scale.x;

	mov	eax, DWORD PTR _scale$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR [esi], xmm0

; 710  : 	e01 *= scale.x;

	movss	xmm0, DWORD PTR [esi+4]
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esi+4], xmm0

; 711  : 	e02 *= scale.x;

	movss	xmm0, DWORD PTR [esi+8]
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esi+8], xmm0

; 712  : 
; 713  : 	e10 *= scale.y;

	movss	xmm0, DWORD PTR [esi+12]
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esi+12], xmm0

; 714  : 	e11 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [esi+16]
	movss	DWORD PTR [esi+16], xmm0

; 715  : 	e12 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [esi+20]
	movss	DWORD PTR [esi+20], xmm0

; 716  : 
; 717  : 	e20 *= scale.z;

	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [esi+24]
	movss	DWORD PTR [esi+24], xmm0

; 718  : 	e21 *= scale.z;

	movss	xmm0, DWORD PTR [esi+28]
	mulss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esi+28], xmm0

; 719  : 	e22 *= scale.z;

	movss	xmm0, DWORD PTR [esi+32]
	mulss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esi+32], xmm0
	pop	esi

; 720  : }

	pop	ebp
	ret	12					; 0000000cH
?MakeTransformAxisAngle@CMatrix3x3@gen@@QAEXABVCVector3@2@M0@Z ENDP ; gen::CMatrix3x3::MakeTransformAxisAngle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeTransformQuaternion@CMatrix3x3@gen@@QAEXABVCQuaternion@2@ABVCVector3@2@@Z
_TEXT	SEGMENT
_yz$1$ = -16						; size = 4
_zx$1$ = -12						; size = 4
_zz$2$ = -8						; size = 4
_xx$2$ = -4						; size = 4
_yy$2$ = 8						; size = 4
_quat$ = 8						; size = 4
_scale$ = 12						; size = 4
?MakeTransformQuaternion@CMatrix3x3@gen@@QAEXABVCQuaternion@2@ABVCVector3@2@@Z PROC ; gen::CMatrix3x3::MakeTransformQuaternion, COMDAT
; _this$ = ecx

; 666  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 667  : 	// Efficiently precalculate some values from the quaternion
; 668  : 	TFloat32 xx = 2*quat.x;

	mov	eax, DWORD PTR _quat$[ebp]
	movss	xmm0, DWORD PTR __real@40000000

; 669  : 	TFloat32 yy = 2*quat.y;
; 670  : 	TFloat32 zz = 2*quat.z;

	movss	xmm4, DWORD PTR [eax+12]
	movss	xmm6, DWORD PTR [eax+4]
	movaps	xmm1, xmm4
	movss	xmm5, DWORD PTR [eax+8]
	movaps	xmm3, xmm6
	mulss	xmm1, xmm0
	movaps	xmm2, xmm5
	mulss	xmm3, xmm0
	mulss	xmm2, xmm0

; 671  : 	TFloat32 xy = xx*quat.y;
; 672  : 	TFloat32 yz = yy*quat.z;
; 673  : 	TFloat32 zx = zz*quat.x;

	movaps	xmm0, xmm6
	mulss	xmm0, xmm1
	movss	DWORD PTR _xx$2$[ebp], xmm6
	movss	DWORD PTR _zz$2$[ebp], xmm4
	movss	DWORD PTR _zx$1$[ebp], xmm0

; 674  : 	TFloat32 wx = quat.w*xx;
; 675  : 	TFloat32 wy = quat.w*yy;
; 676  : 	TFloat32 wz = quat.w*zz;
; 677  : 	xx *= quat.x;

	movss	xmm0, DWORD PTR _xx$2$[ebp]
	mulss	xmm0, xmm3
	mulss	xmm4, xmm2
	movss	DWORD PTR _xx$2$[ebp], xmm0
	movss	DWORD PTR _yy$2$[ebp], xmm5

; 678  : 	yy *= quat.y;

	movss	xmm0, DWORD PTR _yy$2$[ebp]
	mulss	xmm0, xmm2
	mulss	xmm5, xmm3
	movss	DWORD PTR _yy$2$[ebp], xmm0
	movss	DWORD PTR _yz$1$[ebp], xmm4
	movss	xmm4, DWORD PTR [eax]

; 679  : 	zz *= quat.z;
; 680  : 
; 681  : 	// Fill upper 3x3 matrix, combining scaling with rotation values from the quaternion
; 682  : 	e00  = scale.x * (1 - yy - zz);

	mov	eax, DWORD PTR _scale$[ebp]
	movaps	xmm7, xmm4
	mulss	xmm7, xmm3
	movaps	xmm6, xmm4
	movss	xmm3, DWORD PTR _zz$2$[ebp]
	mulss	xmm3, xmm1
	mulss	xmm4, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm1
	mulss	xmm6, xmm2
	subss	xmm0, DWORD PTR _yy$2$[ebp]

; 683  : 	e01  = scale.x * (xy + wz);
; 684  : 	e02  = scale.x * (zx - wy);

	movss	xmm2, DWORD PTR _zx$1$[ebp]

; 685  : 
; 686  : 	e10  = scale.y * (xy - wz);
; 687  : 	e11  = scale.y * (1 - xx - zz);

	subss	xmm1, DWORD PTR _xx$2$[ebp]
	subss	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0
	movaps	xmm0, xmm4
	addss	xmm0, xmm5
	subss	xmm5, xmm4
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx+4], xmm0
	movaps	xmm0, xmm2
	subss	xmm0, xmm6

; 688  : 	e12  = scale.y * (yz + wx);
; 689  : 
; 690  : 	e20  = scale.z * (zx + wy);

	addss	xmm6, xmm2
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx+8], xmm0
	movaps	xmm0, xmm1
	mulss	xmm5, DWORD PTR [eax+4]
	subss	xmm0, xmm3
	movss	xmm3, DWORD PTR _yz$1$[ebp]

; 691  : 	e21  = scale.z * (yz - wx);
; 692  : 	e22 = scale.z * (1 - xx - yy);

	subss	xmm1, DWORD PTR _yy$2$[ebp]
	movss	DWORD PTR [ecx+12], xmm5
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+16], xmm0
	movaps	xmm0, xmm7
	addss	xmm0, xmm3
	subss	xmm3, xmm7
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+20], xmm0
	mulss	xmm6, DWORD PTR [eax+8]
	movss	DWORD PTR [ecx+24], xmm6
	mulss	xmm3, DWORD PTR [eax+8]
	movss	DWORD PTR [ecx+28], xmm3
	mulss	xmm1, DWORD PTR [eax+8]
	movss	DWORD PTR [ecx+32], xmm1

; 693  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MakeTransformQuaternion@CMatrix3x3@gen@@QAEXABVCQuaternion@2@ABVCVector3@2@@Z ENDP ; gen::CMatrix3x3::MakeTransformQuaternion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?MakeTransformEuler@CMatrix3x3@gen@@QAEXABVCVector3@2@W4ERotationOrder@2@0@Z
_TEXT	SEGMENT
_angles$ = 8						; size = 4
_eRotOrder$ = 12					; size = 4
_scale$ = 16						; size = 4
?MakeTransformEuler@CMatrix3x3@gen@@QAEXABVCVector3@2@W4ERotationOrder@2@0@Z PROC ; gen::CMatrix3x3::MakeTransformEuler, COMDAT
; _this$ = ecx

; 641  : {

	push	ebp
	mov	ebp, esp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 95   : 	{}

	mov	edx, DWORD PTR _angles$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 641  : {

	push	esi
	push	edi

; 643  : 	MakeRotation( angles, eRotOrder );

	push	DWORD PTR _eRotOrder$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 95   : 	{}

	mov	eax, DWORD PTR [edx]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 641  : {

	mov	edi, ecx

; 643  : 	MakeRotation( angles, eRotOrder );

	sub	esp, 12					; 0000000cH
	mov	esi, esp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 95   : 	{}

	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 643  : 	MakeRotation( angles, eRotOrder );

	call	?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z ; gen::CMatrix3x3::MakeRotation

; 644  : 
; 645  : 	// Scale matrix
; 646  : 	e00 *= scale.x;

	mov	eax, DWORD PTR _scale$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR [edi], xmm0

; 647  : 	e01 *= scale.x;

	movss	xmm0, DWORD PTR [edi+4]
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [edi+4], xmm0

; 648  : 	e02 *= scale.x;

	movss	xmm0, DWORD PTR [edi+8]
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [edi+8], xmm0

; 649  : 
; 650  : 	e10 *= scale.y;

	movss	xmm0, DWORD PTR [edi+12]
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [edi+12], xmm0

; 651  : 	e11 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [edi+16]
	movss	DWORD PTR [edi+16], xmm0

; 652  : 	e12 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [edi+20]
	movss	DWORD PTR [edi+20], xmm0

; 653  : 
; 654  : 	e20 *= scale.z;

	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [edi+24]
	movss	DWORD PTR [edi+24], xmm0

; 655  : 	e21 *= scale.z;

	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [edi+28]
	movss	DWORD PTR [edi+28], xmm0

; 656  : 	e22 *= scale.z;

	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [edi+32]
	movss	DWORD PTR [edi+32], xmm0

; 657  : }

	pop	edi
	pop	esi
	pop	ebp
	ret	12					; 0000000cH
?MakeTransformEuler@CMatrix3x3@gen@@QAEXABVCVector3@2@W4ERotationOrder@2@0@Z ENDP ; gen::CMatrix3x3::MakeTransformEuler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetColumns@CMatrix3x3@gen@@QAEXABVCVector2@2@00@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
?SetColumns@CMatrix3x3@gen@@QAEXABVCVector2@2@00@Z PROC	; gen::CMatrix3x3::SetColumns, COMDAT
; _this$ = ecx

; 612  : {

	push	ebp
	mov	ebp, esp

; 613  : 	e00 = v0.x;

	mov	edx, DWORD PTR _v0$[ebp]
	push	esi
	mov	esi, ecx

; 614  : 	e10 = v0.y;
; 615  : 
; 616  : 	e01 = v1.x;
; 617  : 	e11 = v1.y;
; 618  : 
; 619  : 	e02 = v2.x;

	mov	ecx, DWORD PTR _v2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _v1$[ebp]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax

; 620  : 	e12 = v2.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+20], eax

; 621  : 
; 622  : 	e20 = 0.0f;

	mov	DWORD PTR [esi+24], 0

; 623  : 	e21 = 0.0f;

	mov	DWORD PTR [esi+28], 0

; 624  : 	e22 = 1.0f;

	mov	DWORD PTR [esi+32], 1065353216		; 3f800000H
	pop	esi

; 625  : }

	pop	ebp
	ret	12					; 0000000cH
?SetColumns@CMatrix3x3@gen@@QAEXABVCVector2@2@00@Z ENDP	; gen::CMatrix3x3::SetColumns
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetColumns@CMatrix3x3@gen@@QAEXABVCVector3@2@00@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
?SetColumns@CMatrix3x3@gen@@QAEXABVCVector3@2@00@Z PROC	; gen::CMatrix3x3::SetColumns, COMDAT
; _this$ = ecx

; 590  : {

	push	ebp
	mov	ebp, esp

; 591  : 	e00 = v0.x;

	mov	edx, DWORD PTR _v0$[ebp]
	push	esi
	mov	esi, ecx

; 592  : 	e10 = v0.y;
; 593  : 	e20 = v0.z;
; 594  : 
; 595  : 	e01 = v1.x;
; 596  : 	e11 = v1.y;
; 597  : 	e21 = v1.z;
; 598  : 
; 599  : 	e02 = v2.x;

	mov	ecx, DWORD PTR _v2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _v1$[ebp]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+28], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax

; 600  : 	e12 = v2.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+20], eax

; 601  : 	e22 = v2.z;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+32], eax
	pop	esi

; 602  : }

	pop	ebp
	ret	12					; 0000000cH
?SetColumns@CMatrix3x3@gen@@QAEXABVCVector3@2@00@Z ENDP	; gen::CMatrix3x3::SetColumns
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetRows@CMatrix3x3@gen@@QAEXABVCVector2@2@00@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
?SetRows@CMatrix3x3@gen@@QAEXABVCVector2@2@00@Z PROC	; gen::CMatrix3x3::SetRows, COMDAT
; _this$ = ecx

; 568  : {

	push	ebp
	mov	ebp, esp

; 569  : 	e00 = v0.x;

	mov	edx, DWORD PTR _v0$[ebp]
	push	esi
	mov	esi, ecx

; 570  : 	e01 = v0.y;
; 571  : 	e02 = 0.0f;
; 572  : 
; 573  : 	e10 = v1.x;
; 574  : 	e11 = v1.y;
; 575  : 	e12 = 0.0f;
; 576  : 
; 577  : 	e20 = v2.x;

	mov	ecx, DWORD PTR _v2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _v1$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 0
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], 0
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+24], eax

; 578  : 	e21 = v2.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+28], eax

; 579  : 	e22 = 1.0f;

	mov	DWORD PTR [esi+32], 1065353216		; 3f800000H
	pop	esi

; 580  : }

	pop	ebp
	ret	12					; 0000000cH
?SetRows@CMatrix3x3@gen@@QAEXABVCVector2@2@00@Z ENDP	; gen::CMatrix3x3::SetRows
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetRows@CMatrix3x3@gen@@QAEXABVCVector3@2@00@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
?SetRows@CMatrix3x3@gen@@QAEXABVCVector3@2@00@Z PROC	; gen::CMatrix3x3::SetRows, COMDAT
; _this$ = ecx

; 546  : {

	push	ebp
	mov	ebp, esp

; 547  : 	e00 = v0.x;

	mov	edx, DWORD PTR _v0$[ebp]
	push	esi
	mov	esi, ecx

; 548  : 	e01 = v0.y;
; 549  : 	e02 = v0.z;
; 550  : 
; 551  : 	e10 = v1.x;
; 552  : 	e11 = v1.y;
; 553  : 	e12 = v1.z;
; 554  : 
; 555  : 	e20 = v2.x;

	mov	ecx, DWORD PTR _v2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _v1$[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+24], eax

; 556  : 	e21 = v2.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+28], eax

; 557  : 	e22 = v2.z;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+32], eax
	pop	esi

; 558  : }

	pop	ebp
	ret	12					; 0000000cH
?SetRows@CMatrix3x3@gen@@QAEXABVCVector3@2@00@Z ENDP	; gen::CMatrix3x3::SetRows
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetColumn@CMatrix3x3@gen@@QAEXIABVCVector2@2@@Z
_TEXT	SEGMENT
_iCol$ = 8						; size = 4
_v$ = 12						; size = 4
?SetColumn@CMatrix3x3@gen@@QAEXIABVCVector2@2@@Z PROC	; gen::CMatrix3x3::SetColumn, COMDAT
; _this$ = ecx

; 527  : {

	push	ebp
	mov	ebp, esp

; 528  : 	GEN_GUARD_OPT;
; 529  : 	GEN_ASSERT_OPT( iCol < 3, "Invalid parameter" );
; 530  : 
; 531  : 	TFloat32* pfElts = &e00 + iCol;
; 532  : 	pfElts[0] = v.x;

	mov	edx, DWORD PTR _v$[ebp]
	push	esi
	mov	esi, DWORD PTR _iCol$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+esi*4], eax

; 533  : 	pfElts[3] = v.y;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+esi*4+12], eax
	pop	esi

; 534  : 
; 535  : 	GEN_ENDGUARD_OPT;
; 536  : }

	pop	ebp
	ret	8
?SetColumn@CMatrix3x3@gen@@QAEXIABVCVector2@2@@Z ENDP	; gen::CMatrix3x3::SetColumn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetColumn@CMatrix3x3@gen@@QAEXIABVCVector3@2@@Z
_TEXT	SEGMENT
_iCol$ = 8						; size = 4
_v$ = 12						; size = 4
?SetColumn@CMatrix3x3@gen@@QAEXIABVCVector3@2@@Z PROC	; gen::CMatrix3x3::SetColumn, COMDAT
; _this$ = ecx

; 509  : {

	push	ebp
	mov	ebp, esp

; 510  : 	GEN_GUARD_OPT;
; 511  : 	GEN_ASSERT_OPT( iCol < 3, "Invalid parameter" );
; 512  : 
; 513  : 	TFloat32* pfElts = &e00 + iCol;
; 514  : 	pfElts[0] = v.x;

	mov	edx, DWORD PTR _v$[ebp]
	push	esi
	mov	esi, DWORD PTR _iCol$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+esi*4], eax

; 515  : 	pfElts[3] = v.y;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+esi*4+12], eax

; 516  : 	pfElts[6] = v.z;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+esi*4+24], eax
	pop	esi

; 517  : 
; 518  : 	GEN_ENDGUARD_OPT;
; 519  : }

	pop	ebp
	ret	8
?SetColumn@CMatrix3x3@gen@@QAEXIABVCVector3@2@@Z ENDP	; gen::CMatrix3x3::SetColumn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetRow@CMatrix3x3@gen@@QAEXIABVCVector2@2@@Z
_TEXT	SEGMENT
_iRow$ = 8						; size = 4
_v$ = 12						; size = 4
?SetRow@CMatrix3x3@gen@@QAEXIABVCVector2@2@@Z PROC	; gen::CMatrix3x3::SetRow, COMDAT
; _this$ = ecx

; 491  : {

	push	ebp
	mov	ebp, esp

; 492  : 	GEN_GUARD_OPT;
; 493  : 	GEN_ASSERT_OPT( iRow < 3, "Invalid parameter" );
; 494  : 
; 495  : 	TFloat32* pfElts = &e00 + iRow * 3;

	mov	eax, DWORD PTR _iRow$[ebp]

; 496  : 	pfElts[0] = v.x;

	mov	edx, DWORD PTR _v$[ebp]
	push	esi
	lea	esi, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+esi*4], eax

; 497  : 	pfElts[1] = v.y;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+esi*4+4], eax
	pop	esi

; 498  : 
; 499  : 	GEN_ENDGUARD_OPT;
; 500  : }

	pop	ebp
	ret	8
?SetRow@CMatrix3x3@gen@@QAEXIABVCVector2@2@@Z ENDP	; gen::CMatrix3x3::SetRow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?SetRow@CMatrix3x3@gen@@QAEXIABVCVector3@2@@Z
_TEXT	SEGMENT
_iRow$ = 8						; size = 4
_v$ = 12						; size = 4
?SetRow@CMatrix3x3@gen@@QAEXIABVCVector3@2@@Z PROC	; gen::CMatrix3x3::SetRow, COMDAT
; _this$ = ecx

; 473  : {

	push	ebp
	mov	ebp, esp

; 474  : 	GEN_GUARD_OPT;
; 475  : 	GEN_ASSERT_OPT( iRow < 3, "Invalid parameter" );
; 476  : 
; 477  : 	TFloat32* pfElts = &e00 + iRow * 3;

	mov	eax, DWORD PTR _iRow$[ebp]

; 478  : 	pfElts[0] = v.x;

	mov	edx, DWORD PTR _v$[ebp]
	push	esi
	lea	esi, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+esi*4], eax

; 479  : 	pfElts[1] = v.y;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+esi*4+4], eax

; 480  : 	pfElts[2] = v.z;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+esi*4+8], eax
	pop	esi

; 481  : 
; 482  : 	GEN_ENDGUARD_OPT;
; 483  : }

	pop	ebp
	ret	8
?SetRow@CMatrix3x3@gen@@QAEXIABVCVector3@2@@Z ENDP	; gen::CMatrix3x3::SetRow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?GetColumn@CMatrix3x3@gen@@QBE?AVCVector3@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_iCol$ = 12						; size = 4
?GetColumn@CMatrix3x3@gen@@QBE?AVCVector3@2@I@Z PROC	; gen::CMatrix3x3::GetColumn, COMDAT
; _this$ = ecx

; 456  : {

	push	ebp
	mov	ebp, esp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 51   : 	{}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 456  : {

	mov	esi, ecx

; 457  : 	GEN_GUARD_OPT;
; 458  : 	GEN_ASSERT_OPT( iCol < 3, "Invalid parameter" );
; 459  : 
; 460  : 	const TFloat32* pfElts = &e00 + iCol;

	mov	ecx, DWORD PTR _iCol$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 51   : 	{}

	mov	edx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+ecx*4+12]
	mov	ecx, DWORD PTR [esi+ecx*4+24]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	pop	esi
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 464  : }

	pop	ebp
	ret	8
?GetColumn@CMatrix3x3@gen@@QBE?AVCVector3@2@I@Z ENDP	; gen::CMatrix3x3::GetColumn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?GetRow@CMatrix3x3@gen@@QBE?AVCVector3@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_iRow$ = 12						; size = 4
?GetRow@CMatrix3x3@gen@@QBE?AVCVector3@2@I@Z PROC	; gen::CMatrix3x3::GetRow, COMDAT
; _this$ = ecx

; 445  : {

	push	ebp
	mov	ebp, esp

; 446  : 	GEN_GUARD_OPT;
; 447  : 	GEN_ASSERT_OPT( iRow < 3, "Invalid parameter" );
; 448  : 
; 449  : 	return CVector3( &e00 + iRow * 3 );

	mov	eax, DWORD PTR _iRow$[ebp]
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [eax+eax*2]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 59   : 		x = pfElts[0];

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax], edx

; 60   : 		y = pfElts[1];

	mov	edx, DWORD PTR [esi+ecx*4+4]

; 61   : 		z = pfElts[2];

	mov	ecx, DWORD PTR [esi+ecx*4+8]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	pop	esi
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 452  : }

	pop	ebp
	ret	8
?GetRow@CMatrix3x3@gen@@QBE?AVCVector3@2@I@Z ENDP	; gen::CMatrix3x3::GetRow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Set@CMatrix3x3@gen@@QAEXPBM_N@Z
_TEXT	SEGMENT
_pfElts$ = 8						; size = 4
_bRows$ = 12						; size = 1
?Set@CMatrix3x3@gen@@QAEXPBM_N@Z PROC			; gen::CMatrix3x3::Set, COMDAT
; _this$ = ecx

; 402  : {

	push	ebp
	mov	ebp, esp

; 403  : 	GEN_GUARD_OPT;
; 404  : 	GEN_ASSERT_OPT( pfElts, "Invalid parameter" );
; 405  : 
; 406  : 	if (bRows)

	cmp	BYTE PTR _bRows$[ebp], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN2@Set

; 407  : 	{
; 408  : 		e00 = pfElts[0];

	mov	edx, DWORD PTR _pfElts$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 409  : 		e01 = pfElts[1];

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 410  : 		e02 = pfElts[2];

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax

; 411  : 
; 412  : 		e10 = pfElts[3];

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax

; 413  : 		e11 = pfElts[4];

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax

; 414  : 		e12 = pfElts[5];

	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax

; 415  : 
; 416  : 		e20 = pfElts[6];

	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [esi+24], eax

; 417  : 		e21 = pfElts[7];

	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [esi+28], eax

; 418  : 		e22 = pfElts[8];

	mov	eax, DWORD PTR [edx+32]

; 432  : 		e22 = pfElts[8];

	mov	DWORD PTR [esi+32], eax
	pop	esi

; 433  : 	}
; 434  : 
; 435  : 	GEN_ENDGUARD_OPT;
; 436  : }

	pop	ebp
	ret	8
$LN2@Set:

; 419  : 	}
; 420  : 	else
; 421  : 	{
; 422  : 		e00 = pfElts[0];

	mov	ecx, DWORD PTR _pfElts$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax

; 423  : 		e10 = pfElts[1];

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+12], eax

; 424  : 		e20 = pfElts[2];

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+24], eax

; 425  : 
; 426  : 		e01 = pfElts[3];

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+4], eax

; 427  : 		e11 = pfElts[4];

	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi+16], eax

; 428  : 		e21 = pfElts[5];

	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [esi+28], eax

; 429  : 
; 430  : 		e02 = pfElts[6];

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [esi+8], eax

; 431  : 		e12 = pfElts[7];

	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [esi+20], eax

; 432  : 		e22 = pfElts[8];

	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [esi+32], eax
	pop	esi

; 433  : 	}
; 434  : 
; 435  : 	GEN_ENDGUARD_OPT;
; 436  : }

	pop	ebp
	ret	8
?Set@CMatrix3x3@gen@@QAEXPBM_N@Z ENDP			; gen::CMatrix3x3::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ?Set@CMatrix3x3@gen@@QAEXMMMMMMMMM@Z
_TEXT	SEGMENT
_elt00$ = 8						; size = 4
_elt01$ = 12						; size = 4
_elt02$ = 16						; size = 4
_elt10$ = 20						; size = 4
_elt11$ = 24						; size = 4
_elt12$ = 28						; size = 4
_elt20$ = 32						; size = 4
_elt21$ = 36						; size = 4
_elt22$ = 40						; size = 4
?Set@CMatrix3x3@gen@@QAEXMMMMMMMMM@Z PROC		; gen::CMatrix3x3::Set, COMDAT
; _this$ = ecx

; 382  : {

	push	ebp
	mov	ebp, esp

; 383  : 	e00 = elt00;

	movss	xmm0, DWORD PTR _elt00$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 384  : 	e01 = elt01;

	movss	xmm0, DWORD PTR _elt01$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 385  : 	e02 = elt02;

	movss	xmm0, DWORD PTR _elt02$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 386  : 
; 387  : 	e10 = elt10;

	movss	xmm0, DWORD PTR _elt10$[ebp]
	movss	DWORD PTR [ecx+12], xmm0

; 388  : 	e11 = elt11;

	movss	xmm0, DWORD PTR _elt11$[ebp]
	movss	DWORD PTR [ecx+16], xmm0

; 389  : 	e12 = elt12;

	movss	xmm0, DWORD PTR _elt12$[ebp]
	movss	DWORD PTR [ecx+20], xmm0

; 390  : 
; 391  : 	e20 = elt20;

	movss	xmm0, DWORD PTR _elt20$[ebp]
	movss	DWORD PTR [ecx+24], xmm0

; 392  : 	e21 = elt21;

	movss	xmm0, DWORD PTR _elt21$[ebp]
	movss	DWORD PTR [ecx+28], xmm0

; 393  : 	e22 = elt22;

	movss	xmm0, DWORD PTR _elt22$[ebp]
	movss	DWORD PTR [ecx+32], xmm0

; 394  : }

	pop	ebp
	ret	36					; 00000024H
?Set@CMatrix3x3@gen@@QAEXMMMMMMMMM@Z ENDP		; gen::CMatrix3x3::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??4CMatrix3x3@gen@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_m$ = 8							; size = 4
??4CMatrix3x3@gen@@QAEAAV01@ABV01@@Z PROC		; gen::CMatrix3x3::operator=, COMDAT
; _this$ = ecx

; 352  : {

	push	ebp
	mov	ebp, esp

; 353  : 	if ( this != &m )

	mov	edx, DWORD PTR _m$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@operator

; 354  : 	{
; 355  : 		e00 = m.e00;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 356  : 		e01 = m.e01;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 357  : 		e02 = m.e02;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 358  : 
; 359  : 		e10 = m.e10;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 360  : 		e11 = m.e11;

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax

; 361  : 		e12 = m.e12;

	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax

; 362  : 
; 363  : 		e20 = m.e20;

	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax

; 364  : 		e21 = m.e21;

	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax

; 365  : 		e22 = m.e22;

	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
$LN4@operator:

; 366  : 	}
; 367  : 	return *this;

	mov	eax, ecx

; 368  : }

	pop	ebp
	ret	4
??4CMatrix3x3@gen@@QAEAAV01@ABV01@@Z ENDP		; gen::CMatrix3x3::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@ABV01@@Z
_TEXT	SEGMENT
_m$ = 8							; size = 4
??0CMatrix3x3@gen@@QAE@ABV01@@Z PROC			; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 336  : {

	push	ebp
	mov	ebp, esp

; 337  : 	e00 = m.e00;

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 338  : 	e01 = m.e01;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 339  : 	e02 = m.e02;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 340  : 
; 341  : 	e10 = m.e10;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 342  : 	e11 = m.e11;

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax

; 343  : 	e12 = m.e12;

	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax

; 344  : 
; 345  : 	e20 = m.e20;

	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax

; 346  : 	e21 = m.e21;

	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax

; 347  : 	e22 = m.e22;

	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax

; 348  : }

	mov	eax, ecx
	pop	ebp
	ret	4
??0CMatrix3x3@gen@@QAE@ABV01@@Z ENDP			; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@ABVCMatrix2x2@1@ABVCVector2@1@@Z
_TEXT	SEGMENT
_m$ = 8							; size = 4
_position$ = 12						; size = 4
??0CMatrix3x3@gen@@QAE@ABVCMatrix2x2@1@ABVCVector2@1@@Z PROC ; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 317  : {

	push	ebp
	mov	ebp, esp

; 318  : 	// Copy 2x2 elements, adding extra identity elements
; 319  : 	e00 = m.e00;

	mov	edx, DWORD PTR _m$[ebp]
	push	esi
	mov	esi, ecx

; 320  : 	e01 = m.e01;
; 321  : 	e02 = 0.0f;
; 322  : 
; 323  : 	e10 = m.e10;
; 324  : 	e11 = m.e11;
; 325  : 	e12 = 0.0f;
; 326  : 
; 327  : 	// Put position (translation) in bottom row
; 328  : 	e20 = position.x;

	mov	ecx, DWORD PTR _position$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 0
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], 0
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+24], eax

; 329  : 	e21 = position.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+28], eax

; 330  : 	e22 = 1.0f;
; 331  : }

	mov	eax, esi
	mov	DWORD PTR [esi+32], 1065353216		; 3f800000H
	pop	esi
	pop	ebp
	ret	8
??0CMatrix3x3@gen@@QAE@ABVCMatrix2x2@1@ABVCVector2@1@@Z ENDP ; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@ABVCVector2@1@M0@Z
_TEXT	SEGMENT
_s$1$ = -4						; size = 4
_position$ = 8						; size = 4
_fAngle$ = 12						; size = 4
_scale$ = 16						; size = 4
??0CMatrix3x3@gen@@QAE@ABVCVector2@1@M0@Z PROC		; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 292  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR _fAngle$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	push	esi
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 292  : {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _s$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _fAngle$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 296  : 	e00 = c * scale.x;

	mov	eax, DWORD PTR _scale$[ebp]
	xorps	xmm1, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 304  : 	e20 = position.x;

	mov	ecx, DWORD PTR _position$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _s$1$[ebp]
	mov	DWORD PTR [esi+8], 0
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR _s$1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esi+12], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, xmm1
	mov	DWORD PTR [esi+20], 0
	movss	DWORD PTR [esi+16], xmm0
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+24], eax

; 305  : 	e21 = position.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+28], eax

; 306  : 	e22 = 1.0f;
; 307  : }

	mov	eax, esi
	mov	DWORD PTR [esi+32], 1065353216		; 3f800000H
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0CMatrix3x3@gen@@QAE@ABVCVector2@1@M0@Z ENDP		; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@ABVCVector2@1@@Z
_TEXT	SEGMENT
_position$ = 8						; size = 4
??0CMatrix3x3@gen@@QAE@ABVCVector2@1@@Z PROC		; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 267  : {

	push	ebp
	mov	ebp, esp
	mov	edx, ecx

; 268  : 	// Take most elements from identity
; 269  : 	e00 = 1.0f;
; 270  : 	e01 = 0.0f;
; 271  : 	e02 = 0.0f;
; 272  : 
; 273  : 	e10 = 0.0f;
; 274  : 	e11 = 1.0f;
; 275  : 	e12 = 0.0f;
; 276  : 
; 277  : 	// Put position (translation) in bottom row
; 278  : 	e20 = position.x;

	mov	ecx, DWORD PTR _position$[ebp]
	mov	DWORD PTR [edx], 1065353216		; 3f800000H
	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 1065353216		; 3f800000H
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+24], eax

; 279  : 	e21 = position.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+28], eax

; 280  : 	e22 = 1.0f;
; 281  : }

	mov	eax, edx
	mov	DWORD PTR [edx+32], 1065353216		; 3f800000H
	pop	ebp
	ret	4
??0CMatrix3x3@gen@@QAE@ABVCVector2@1@@Z ENDP		; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@ABVCVector3@1@M0@Z
_TEXT	SEGMENT
_axis$ = 8						; size = 4
_fAngle$ = 12						; size = 4
_scale$ = 16						; size = 4
??0CMatrix3x3@gen@@QAE@ABVCVector3@1@M0@Z PROC		; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 246  : {

	push	ebp
	mov	ebp, esp

; 247  : 	// First build rotation matrix
; 248  : 	MakeRotation( axis, fAngle );

	movss	xmm0, DWORD PTR _fAngle$[ebp]
	push	esi
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	esi, ecx
	push	DWORD PTR _axis$[ebp]
	call	?MakeRotation@CMatrix3x3@gen@@QAEXABVCVector3@2@M@Z ; gen::CMatrix3x3::MakeRotation

; 249  : 
; 250  : 	// Scale matrix
; 251  : 	e00 *= scale.x;

	mov	eax, DWORD PTR _scale$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR [esi], xmm0

; 252  : 	e01 *= scale.x;

	movss	xmm0, DWORD PTR [esi+4]
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esi+4], xmm0

; 253  : 	e02 *= scale.x;

	movss	xmm0, DWORD PTR [esi+8]
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esi+8], xmm0

; 254  : 
; 255  : 	e10 *= scale.y;

	movss	xmm0, DWORD PTR [esi+12]
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esi+12], xmm0

; 256  : 	e11 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [esi+16]
	movss	DWORD PTR [esi+16], xmm0

; 257  : 	e12 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [esi+20]
	movss	DWORD PTR [esi+20], xmm0

; 258  : 
; 259  : 	e20 *= scale.z;

	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [esi+24]
	movss	DWORD PTR [esi+24], xmm0

; 260  : 	e21 *= scale.z;

	movss	xmm0, DWORD PTR [esi+28]
	mulss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esi+28], xmm0

; 261  : 	e22 *= scale.z;

	movss	xmm0, DWORD PTR [esi+32]
	mulss	xmm0, DWORD PTR [eax+8]

; 262  : }

	mov	eax, esi
	movss	DWORD PTR [esi+32], xmm0
	pop	esi
	pop	ebp
	ret	12					; 0000000cH
??0CMatrix3x3@gen@@QAE@ABVCVector3@1@M0@Z ENDP		; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@ABVCQuaternion@1@ABVCVector3@1@@Z
_TEXT	SEGMENT
_yz$1$ = -16						; size = 4
_zx$1$ = -12						; size = 4
_zz$2$ = -8						; size = 4
_xx$2$ = -4						; size = 4
_yy$2$ = 8						; size = 4
_quat$ = 8						; size = 4
_scale$ = 12						; size = 4
??0CMatrix3x3@gen@@QAE@ABVCQuaternion@1@ABVCVector3@1@@Z PROC ; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 210  : 	// Efficiently precalculate some values from the quaternion
; 211  : 	TFloat32 xx = 2*quat.x;

	mov	eax, DWORD PTR _quat$[ebp]
	movss	xmm0, DWORD PTR __real@40000000

; 212  : 	TFloat32 yy = 2*quat.y;
; 213  : 	TFloat32 zz = 2*quat.z;

	movss	xmm4, DWORD PTR [eax+12]
	movss	xmm6, DWORD PTR [eax+4]
	movaps	xmm1, xmm4
	movss	xmm5, DWORD PTR [eax+8]
	movaps	xmm3, xmm6
	mulss	xmm1, xmm0
	movaps	xmm2, xmm5
	mulss	xmm3, xmm0
	mulss	xmm2, xmm0

; 214  : 	TFloat32 xy = xx*quat.y;
; 215  : 	TFloat32 yz = yy*quat.z;
; 216  : 	TFloat32 zx = zz*quat.x;

	movaps	xmm0, xmm6
	mulss	xmm0, xmm1
	movss	DWORD PTR _xx$2$[ebp], xmm6
	movss	DWORD PTR _zz$2$[ebp], xmm4
	movss	DWORD PTR _zx$1$[ebp], xmm0

; 217  : 	TFloat32 wx = quat.w*xx;
; 218  : 	TFloat32 wy = quat.w*yy;
; 219  : 	TFloat32 wz = quat.w*zz;
; 220  : 	xx *= quat.x;

	movss	xmm0, DWORD PTR _xx$2$[ebp]
	mulss	xmm0, xmm3
	mulss	xmm4, xmm2
	movss	DWORD PTR _xx$2$[ebp], xmm0
	movss	DWORD PTR _yy$2$[ebp], xmm5

; 221  : 	yy *= quat.y;

	movss	xmm0, DWORD PTR _yy$2$[ebp]
	mulss	xmm0, xmm2
	mulss	xmm5, xmm3
	movss	DWORD PTR _yy$2$[ebp], xmm0
	movss	DWORD PTR _yz$1$[ebp], xmm4
	movss	xmm4, DWORD PTR [eax]

; 222  : 	zz *= quat.z;
; 223  : 
; 224  : 	// Fill upper 3x3 matrix, combining scaling with rotation values from the quaternion
; 225  : 	e00 = scale.x * (1 - yy - zz);

	mov	eax, DWORD PTR _scale$[ebp]
	movaps	xmm7, xmm4
	mulss	xmm7, xmm3
	movaps	xmm6, xmm4
	movss	xmm3, DWORD PTR _zz$2$[ebp]
	mulss	xmm3, xmm1
	mulss	xmm4, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm1
	mulss	xmm6, xmm2
	subss	xmm0, DWORD PTR _yy$2$[ebp]

; 226  : 	e01 = scale.x * (xy + wz);
; 227  : 	e02 = scale.x * (zx - wy);

	movss	xmm2, DWORD PTR _zx$1$[ebp]

; 228  : 
; 229  : 	e10 = scale.y * (xy - wz);
; 230  : 	e11 = scale.y * (1 - xx - zz);

	subss	xmm1, DWORD PTR _xx$2$[ebp]
	subss	xmm0, xmm3
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0
	movaps	xmm0, xmm4
	addss	xmm0, xmm5
	subss	xmm5, xmm4
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx+4], xmm0
	movaps	xmm0, xmm2
	subss	xmm0, xmm6

; 231  : 	e12 = scale.y * (yz + wx);
; 232  : 
; 233  : 	e20 = scale.z * (zx + wy);

	addss	xmm6, xmm2
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx+8], xmm0
	movaps	xmm0, xmm1
	mulss	xmm5, DWORD PTR [eax+4]
	subss	xmm0, xmm3
	movss	xmm3, DWORD PTR _yz$1$[ebp]

; 234  : 	e21 = scale.z * (yz - wx);
; 235  : 	e22 = scale.z * (1 - xx - yy);

	subss	xmm1, DWORD PTR _yy$2$[ebp]
	movss	DWORD PTR [ecx+12], xmm5
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+16], xmm0
	movaps	xmm0, xmm7
	addss	xmm0, xmm3
	subss	xmm3, xmm7
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+20], xmm0
	mulss	xmm6, DWORD PTR [eax+8]
	movss	DWORD PTR [ecx+24], xmm6
	mulss	xmm3, DWORD PTR [eax+8]
	movss	DWORD PTR [ecx+28], xmm3
	mulss	xmm1, DWORD PTR [eax+8]

; 236  : }

	mov	eax, ecx
	movss	DWORD PTR [ecx+32], xmm1
	mov	esp, ebp
	pop	ebp
	ret	8
??0CMatrix3x3@gen@@QAE@ABVCQuaternion@1@ABVCVector3@1@@Z ENDP ; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@ABVCVector3@1@W4ERotationOrder@1@0@Z
_TEXT	SEGMENT
_angles$ = 8						; size = 4
_eRotOrder$ = 12					; size = 4
_scale$ = 16						; size = 4
??0CMatrix3x3@gen@@QAE@ABVCVector3@1@W4ERotationOrder@1@0@Z PROC ; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 184  : {

	push	ebp
	mov	ebp, esp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 95   : 	{}

	mov	edx, DWORD PTR _angles$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 184  : {

	push	esi
	push	edi

; 186  : 	MakeRotation( angles, eRotOrder );

	push	DWORD PTR _eRotOrder$[ebp]
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 95   : 	{}

	mov	eax, DWORD PTR [edx]
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 184  : {

	mov	edi, ecx

; 186  : 	MakeRotation( angles, eRotOrder );

	sub	esp, 12					; 0000000cH
	mov	esi, esp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 95   : 	{}

	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp

; 186  : 	MakeRotation( angles, eRotOrder );

	call	?MakeRotation@CMatrix3x3@gen@@QAEXVCVector3@2@W4ERotationOrder@2@@Z ; gen::CMatrix3x3::MakeRotation

; 187  : 
; 188  : 	// Scale matrix
; 189  : 	e00 *= scale.x;

	mov	eax, DWORD PTR _scale$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR [edi], xmm0

; 190  : 	e01 *= scale.x;

	movss	xmm0, DWORD PTR [edi+4]
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [edi+4], xmm0

; 191  : 	e02 *= scale.x;

	movss	xmm0, DWORD PTR [edi+8]
	mulss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [edi+8], xmm0

; 192  : 
; 193  : 	e10 *= scale.y;

	movss	xmm0, DWORD PTR [edi+12]
	mulss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [edi+12], xmm0

; 194  : 	e11 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [edi+16]
	movss	DWORD PTR [edi+16], xmm0

; 195  : 	e12 *= scale.y;

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [edi+20]
	movss	DWORD PTR [edi+20], xmm0

; 196  : 
; 197  : 	e20 *= scale.z;

	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [edi+24]
	movss	DWORD PTR [edi+24], xmm0

; 198  : 	e21 *= scale.z;

	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [edi+28]
	movss	DWORD PTR [edi+28], xmm0

; 199  : 	e22 *= scale.z;

	movss	xmm0, DWORD PTR [eax+8]

; 200  : }

	mov	eax, edi
	mulss	xmm0, DWORD PTR [edi+32]
	movss	DWORD PTR [edi+32], xmm0
	pop	edi
	pop	esi
	pop	ebp
	ret	12					; 0000000cH
??0CMatrix3x3@gen@@QAE@ABVCVector3@1@W4ERotationOrder@1@0@Z ENDP ; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@ABVCVector2@1@00_N@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_bRows$ = 20						; size = 1
??0CMatrix3x3@gen@@QAE@ABVCVector2@1@00_N@Z PROC	; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 143  : {

	push	ebp
	mov	ebp, esp

; 144  : 	if (bRows)

	cmp	BYTE PTR _bRows$[ebp], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN2@CMatrix3x3

; 145  : 	{
; 146  : 		e00 = v0.x;

	mov	edx, DWORD PTR _v0$[ebp]

; 147  : 		e01 = v0.y;
; 148  : 		e02 = 0.0f;
; 149  : 
; 150  : 		e10 = v1.x;

	mov	ecx, DWORD PTR _v1$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], 0
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+12], eax

; 151  : 		e11 = v1.y;

	mov	eax, DWORD PTR [ecx+4]

; 152  : 		e12 = 0.0f;
; 153  : 
; 154  : 		e20 = v2.x;

	mov	ecx, DWORD PTR _v2$[ebp]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], 0
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+24], eax

; 155  : 		e21 = v2.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+28], eax

; 168  : 
; 169  : 		e20 = 0.0f;
; 170  : 		e21 = 0.0f;
; 171  : 		e22 = 1.0f;
; 172  : 	}
; 173  : }

	mov	eax, esi
	mov	DWORD PTR [esi+32], 0
	pop	esi
	pop	ebp
	ret	16					; 00000010H
$LN2@CMatrix3x3:

; 156  : 		e22 = 0.0f;
; 157  : 	}
; 158  : 	else
; 159  : 	{
; 160  : 		e00 = v0.x;

	mov	ecx, DWORD PTR _v0$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax

; 161  : 		e10 = v0.y;

	mov	eax, DWORD PTR [ecx+4]

; 162  : 
; 163  : 		e01 = v1.x;

	mov	ecx, DWORD PTR _v1$[ebp]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+4], eax

; 164  : 		e11 = v1.y;

	mov	eax, DWORD PTR [ecx+4]

; 165  : 
; 166  : 		e02 = v2.x;

	mov	ecx, DWORD PTR _v2$[ebp]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax

; 167  : 		e12 = v2.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+20], eax

; 168  : 
; 169  : 		e20 = 0.0f;
; 170  : 		e21 = 0.0f;
; 171  : 		e22 = 1.0f;
; 172  : 	}
; 173  : }

	mov	eax, esi
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 1065353216		; 3f800000H
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??0CMatrix3x3@gen@@QAE@ABVCVector2@1@00_N@Z ENDP	; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@ABVCVector3@1@00_N@Z
_TEXT	SEGMENT
_v0$ = 8						; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_bRows$ = 20						; size = 1
??0CMatrix3x3@gen@@QAE@ABVCVector3@1@00_N@Z PROC	; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp

; 104  : 	if (bRows)

	cmp	BYTE PTR _bRows$[ebp], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN2@CMatrix3x3

; 105  : 	{
; 106  : 		e00 = v0.x;

	mov	edx, DWORD PTR _v0$[ebp]

; 107  : 		e01 = v0.y;
; 108  : 		e02 = v0.z;
; 109  : 
; 110  : 		e10 = v1.x;

	mov	ecx, DWORD PTR _v1$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+12], eax

; 111  : 		e11 = v1.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+16], eax

; 112  : 		e12 = v1.z;

	mov	eax, DWORD PTR [ecx+8]

; 113  : 
; 114  : 		e20 = v2.x;

	mov	ecx, DWORD PTR _v2$[ebp]
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+24], eax

; 115  : 		e21 = v2.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+28], eax

; 130  : 		e22 = v2.z;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+32], eax

; 131  : 	}
; 132  : }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	16					; 00000010H
$LN2@CMatrix3x3:

; 116  : 		e22 = v2.z;
; 117  : 	}
; 118  : 	else
; 119  : 	{
; 120  : 		e00 = v0.x;

	mov	ecx, DWORD PTR _v0$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax

; 121  : 		e10 = v0.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+12], eax

; 122  : 		e20 = v0.z;

	mov	eax, DWORD PTR [ecx+8]

; 123  : 
; 124  : 		e01 = v1.x;

	mov	ecx, DWORD PTR _v1$[ebp]
	mov	DWORD PTR [esi+24], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+4], eax

; 125  : 		e11 = v1.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+16], eax

; 126  : 		e21 = v1.z;

	mov	eax, DWORD PTR [ecx+8]

; 127  : 
; 128  : 		e02 = v2.x;

	mov	ecx, DWORD PTR _v2$[ebp]
	mov	DWORD PTR [esi+28], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+8], eax

; 129  : 		e12 = v2.y;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+20], eax

; 130  : 		e22 = v2.z;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+32], eax

; 131  : 	}
; 132  : }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??0CMatrix3x3@gen@@QAE@ABVCVector3@1@00_N@Z ENDP	; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@PBM_N@Z
_TEXT	SEGMENT
_pfElts$ = 8						; size = 4
_bRows$ = 12						; size = 1
??0CMatrix3x3@gen@@QAE@PBM_N@Z PROC			; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 59   : {

	push	ebp
	mov	ebp, esp

; 60   : 	GEN_GUARD_OPT;
; 61   : 	GEN_ASSERT_OPT( pfElts, "Invalid parameter" );
; 62   : 
; 63   : 	if (bRows)

	cmp	BYTE PTR _bRows$[ebp], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN2@CMatrix3x3

; 64   : 	{
; 65   : 		e00 = pfElts[0];

	mov	edx, DWORD PTR _pfElts$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 66   : 		e01 = pfElts[1];

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 67   : 		e02 = pfElts[2];

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax

; 68   : 
; 69   : 		e10 = pfElts[3];

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax

; 70   : 		e11 = pfElts[4];

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax

; 71   : 		e12 = pfElts[5];

	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [esi+20], eax

; 72   : 
; 73   : 		e20 = pfElts[6];

	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [esi+24], eax

; 74   : 		e21 = pfElts[7];

	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [esi+28], eax

; 75   : 		e22 = pfElts[8];

	mov	eax, DWORD PTR [edx+32]

; 89   : 		e22 = pfElts[8];

	mov	DWORD PTR [esi+32], eax

; 90   : 	}
; 91   : 
; 92   : 	GEN_ENDGUARD_OPT;
; 93   : }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
$LN2@CMatrix3x3:

; 76   : 	}
; 77   : 	else
; 78   : 	{
; 79   : 		e00 = pfElts[0];

	mov	ecx, DWORD PTR _pfElts$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax

; 80   : 		e10 = pfElts[1];

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+12], eax

; 81   : 		e20 = pfElts[2];

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+24], eax

; 82   : 
; 83   : 		e01 = pfElts[3];

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+4], eax

; 84   : 		e11 = pfElts[4];

	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi+16], eax

; 85   : 		e21 = pfElts[5];

	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [esi+28], eax

; 86   : 
; 87   : 		e02 = pfElts[6];

	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [esi+8], eax

; 88   : 		e12 = pfElts[7];

	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [esi+20], eax

; 89   : 		e22 = pfElts[8];

	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR [esi+32], eax

; 90   : 	}
; 91   : 
; 92   : 	GEN_ENDGUARD_OPT;
; 93   : }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0CMatrix3x3@gen@@QAE@PBM_N@Z ENDP			; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.cpp
;	COMDAT ??0CMatrix3x3@gen@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT
_elt00$ = 8						; size = 4
_elt01$ = 12						; size = 4
_elt02$ = 16						; size = 4
_elt10$ = 20						; size = 4
_elt11$ = 24						; size = 4
_elt12$ = 28						; size = 4
_elt20$ = 32						; size = 4
_elt21$ = 36						; size = 4
_elt22$ = 40						; size = 4
??0CMatrix3x3@gen@@QAE@MMMMMMMMM@Z PROC			; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 39   : {

	push	ebp
	mov	ebp, esp

; 40   : 	e00 = elt00;

	movss	xmm0, DWORD PTR _elt00$[ebp]

; 41   : 	e01 = elt01;
; 42   : 	e02 = elt02;
; 43   : 
; 44   : 	e10 = elt10;
; 45   : 	e11 = elt11;
; 46   : 	e12 = elt12;
; 47   : 
; 48   : 	e20 = elt20;
; 49   : 	e21 = elt21;
; 50   : 	e22 = elt22;
; 51   : }

	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _elt01$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR _elt02$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR _elt10$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	movss	xmm0, DWORD PTR _elt11$[ebp]
	movss	DWORD PTR [ecx+16], xmm0
	movss	xmm0, DWORD PTR _elt12$[ebp]
	movss	DWORD PTR [ecx+20], xmm0
	movss	xmm0, DWORD PTR _elt20$[ebp]
	movss	DWORD PTR [ecx+24], xmm0
	movss	xmm0, DWORD PTR _elt21$[ebp]
	movss	DWORD PTR [ecx+28], xmm0
	movss	xmm0, DWORD PTR _elt22$[ebp]
	movss	DWORD PTR [ecx+32], xmm0
	pop	ebp
	ret	36					; 00000024H
??0CMatrix3x3@gen@@QAE@MMMMMMMMM@Z ENDP			; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cmatrix3x3.h
;	COMDAT ??0CMatrix3x3@gen@@QAE@XZ
_TEXT	SEGMENT
??0CMatrix3x3@gen@@QAE@XZ PROC				; gen::CMatrix3x3::CMatrix3x3, COMDAT
; _this$ = ecx

; 84   : 	CMatrix3x3() {}

	mov	eax, ecx
	ret	0
??0CMatrix3x3@gen@@QAE@XZ ENDP				; gen::CMatrix3x3::CMatrix3x3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
;	COMDAT ?Cross@gen@@YA?AVCVector3@1@ABV21@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
?Cross@gen@@YA?AVCVector3@1@ABV21@0@Z PROC		; gen::Cross, COMDAT

; 463  : {

	push	ebp
	mov	ebp, esp

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	mov	eax, DWORD PTR _v2$[ebp]
	mov	edx, DWORD PTR _v1$[ebp]

; 51   : 	{}

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movss	xmm1, DWORD PTR [eax+8]
	mulss	xmm1, DWORD PTR [edx+4]
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [edx+8]
	movss	xmm3, DWORD PTR [eax]
	movss	xmm2, DWORD PTR [edx]
	subss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [eax+8]
	mulss	xmm2, DWORD PTR [eax+4]
	mov	eax, ecx

; 51   : 	{}

	movss	DWORD PTR [ecx], xmm1

; 464  : 	return CVector3(v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);

	movaps	xmm1, xmm3
	mulss	xmm1, DWORD PTR [edx+8]
	mulss	xmm3, DWORD PTR [edx+4]
	subss	xmm1, xmm0
	subss	xmm2, xmm3

; 51   : 	{}

	movss	DWORD PTR [ecx+4], xmm1
	movss	DWORD PTR [ecx+8], xmm2

; 465  : }

	pop	ebp
	ret	0
?Cross@gen@@YA?AVCVector3@1@ABV21@0@Z ENDP		; gen::Cross
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
;	COMDAT ??Ggen@@YA?AVCVector3@0@ABV10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
??Ggen@@YA?AVCVector3@0@ABV10@@Z PROC			; gen::operator-, COMDAT

; 400  : {

	push	ebp
	mov	ebp, esp

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	mov	ecx, DWORD PTR _v$[ebp]

; 51   : 	{}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	movss	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm0, DWORD PTR [ecx]
	xorps	xmm0, xmm1

; 51   : 	{}

	movss	DWORD PTR [eax], xmm0

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	movss	xmm0, DWORD PTR [ecx+4]
	xorps	xmm0, xmm1

; 51   : 	{}

	movss	DWORD PTR [eax+4], xmm0

; 401  : 	return CVector3(-v.x, -v.y, -v.z);

	movss	xmm0, DWORD PTR [ecx+8]
	xorps	xmm0, xmm1

; 51   : 	{}

	movss	DWORD PTR [eax+8], xmm0

; 402  : }

	pop	ebp
	ret	0
??Ggen@@YA?AVCVector3@0@ABV10@@Z ENDP			; gen::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
;	COMDAT ?IsZero@CVector3@gen@@QBE_NXZ
_TEXT	SEGMENT
?IsZero@CVector3@gen@@QBE_NXZ PROC			; gen::CVector3::IsZero, COMDAT
; _this$ = ecx

; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movss	xmm1, DWORD PTR [ecx+4]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	xor	eax, eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 182  : 		return gen::IsZero( x*x + y*y + z*z );

	movss	xmm2, DWORD PTR [ecx]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm2
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
	seta	al
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h

; 183  : 	}

	ret	0
?IsZero@CVector3@gen@@QBE_NXZ ENDP			; gen::CVector3::IsZero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
;	COMDAT ?Set@CVector3@gen@@QAEXMMM@Z
_TEXT	SEGMENT
_xIn$ = 8						; size = 4
_yIn$ = 12						; size = 4
_zIn$ = 16						; size = 4
?Set@CVector3@gen@@QAEXMMM@Z PROC			; gen::CVector3::Set, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp

; 122  : 		x = xIn;

	movss	xmm0, DWORD PTR _xIn$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 123  : 		y = yIn;

	movss	xmm0, DWORD PTR _yIn$[ebp]
	movss	DWORD PTR [ecx+4], xmm0

; 124  : 		z = zIn;

	movss	xmm0, DWORD PTR _zIn$[ebp]
	movss	DWORD PTR [ecx+8], xmm0

; 125  : 	}

	pop	ebp
	ret	12					; 0000000cH
?Set@CVector3@gen@@QAEXMMM@Z ENDP			; gen::CVector3::Set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
;	COMDAT ??4CVector3@gen@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??4CVector3@gen@@QAEAAV01@ABV01@@Z PROC			; gen::CVector3::operator=, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp

; 100  : 		if ( this != &v )

	mov	edx, DWORD PTR _v$[ebp]
	cmp	ecx, edx
	je	SHORT $LN4@operator

; 101  : 		{
; 102  : 			x = v.x;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 103  : 			y = v.y;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 104  : 			z = v.z;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
$LN4@operator:

; 105  : 		}
; 106  : 		return *this;

	mov	eax, ecx

; 107  : 	}

	pop	ebp
	ret	4
??4CVector3@gen@@QAEAAV01@ABV01@@Z ENDP			; gen::CVector3::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
;	COMDAT ??0CVector3@gen@@QAE@ABV01@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??0CVector3@gen@@QAE@ABV01@@Z PROC			; gen::CVector3::CVector3, COMDAT
; _this$ = ecx

; 95   : 	{}

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0CVector3@gen@@QAE@ABV01@@Z ENDP			; gen::CVector3::CVector3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
;	COMDAT ??0CVector3@gen@@QAE@PBM@Z
_TEXT	SEGMENT
_pfElts$ = 8						; size = 4
??0CVector3@gen@@QAE@PBM@Z PROC				; gen::CVector3::CVector3, COMDAT
; _this$ = ecx

; 54   : 	explicit CVector3( const TFloat32* pfElts )

	push	ebp
	mov	ebp, esp

; 55   : 	{
; 56   : 		GEN_GUARD_OPT;
; 57   : 		GEN_ASSERT_OPT( pfElts, "Invalid parameter" );
; 58   : 
; 59   : 		x = pfElts[0];

	mov	edx, DWORD PTR _pfElts$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 60   : 		y = pfElts[1];

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 61   : 		z = pfElts[2];

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 62   : 
; 63   : 		GEN_ENDGUARD_OPT;
; 64   : 	}

	mov	eax, ecx
	pop	ebp
	ret	4
??0CVector3@gen@@QAE@PBM@Z ENDP				; gen::CVector3::CVector3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
;	COMDAT ??0CVector3@gen@@QAE@MMM@Z
_TEXT	SEGMENT
_xIn$ = 8						; size = 4
_yIn$ = 12						; size = 4
_zIn$ = 16						; size = 4
??0CVector3@gen@@QAE@MMM@Z PROC				; gen::CVector3::CVector3, COMDAT
; _this$ = ecx

; 51   : 	{}

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _xIn$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _yIn$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR _zIn$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	pop	ebp
	ret	12					; 0000000cH
??0CVector3@gen@@QAE@MMM@Z ENDP				; gen::CVector3::CVector3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector3.h
;	COMDAT ??0CVector3@gen@@QAE@XZ
_TEXT	SEGMENT
??0CVector3@gen@@QAE@XZ PROC				; gen::CVector3::CVector3, COMDAT
; _this$ = ecx

; 42   : 	CVector3() {}

	mov	eax, ecx
	ret	0
??0CVector3@gen@@QAE@XZ ENDP				; gen::CVector3::CVector3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
;	COMDAT ??Ggen@@YA?AVCVector2@0@ABV10@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??Ggen@@YA?AVCVector2@0@ABV10@0@Z PROC			; gen::operator-, COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp

; 366  : 	return CVector2(v1.x - v2.x, v1.y - v2.y);

	mov	edx, DWORD PTR _v1$[ebp]
	mov	ecx, DWORD PTR _v2$[ebp]

; 50   : 	{}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 366  : 	return CVector2(v1.x - v2.x, v1.y - v2.y);

	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR [ecx]

; 50   : 	{}

	movss	DWORD PTR [eax], xmm0

; 366  : 	return CVector2(v1.x - v2.x, v1.y - v2.y);

	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [ecx+4]

; 50   : 	{}

	movss	DWORD PTR [eax+4], xmm0

; 367  : }

	pop	ebp
	ret	0
??Ggen@@YA?AVCVector2@0@ABV10@0@Z ENDP			; gen::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
;	COMDAT ?IsZero@CVector2@gen@@QBE_NXZ
_TEXT	SEGMENT
?IsZero@CVector2@gen@@QBE_NXZ PROC			; gen::CVector2::IsZero, COMDAT
; _this$ = ecx

; 168  : 		return gen::IsZero( x*x + y*y );

	movss	xmm1, DWORD PTR [ecx+4]
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	xor	eax, eax
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 168  : 		return gen::IsZero( x*x + y*y );

	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm0, xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR __real@350637bd
	comiss	xmm0, xmm1
	seta	al
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h

; 169  : 	}

	ret	0
?IsZero@CVector2@gen@@QBE_NXZ ENDP			; gen::CVector2::IsZero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
;	COMDAT ??0CVector2@gen@@QAE@ABV01@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??0CVector2@gen@@QAE@ABV01@@Z PROC			; gen::CVector2::CVector2, COMDAT
; _this$ = ecx

; 88   : 	{}

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0CVector2@gen@@QAE@ABV01@@Z ENDP			; gen::CVector2::CVector2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
;	COMDAT ??0CVector2@gen@@QAE@MM@Z
_TEXT	SEGMENT
_xIn$ = 8						; size = 4
_yIn$ = 12						; size = 4
??0CVector2@gen@@QAE@MM@Z PROC				; gen::CVector2::CVector2, COMDAT
; _this$ = ecx

; 50   : 	{}

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _xIn$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _yIn$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	pop	ebp
	ret	8
??0CVector2@gen@@QAE@MM@Z ENDP				; gen::CVector2::CVector2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\cvector2.h
;	COMDAT ??0CVector2@gen@@QAE@XZ
_TEXT	SEGMENT
??0CVector2@gen@@QAE@XZ PROC				; gen::CVector2::CVector2, COMDAT
; _this$ = ecx

; 42   : 	CVector2() {}

	mov	eax, ecx
	ret	0
??0CVector2@gen@@QAE@XZ ENDP				; gen::CVector2::CVector2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?AreEqual@gen@@YA_NMMI@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_iEpsilonFrac$ = 16					; size = 4
?AreEqual@gen@@YA_NMMI@Z PROC				; gen::AreEqual, COMDAT

; 403  : {

	push	ebp
	mov	ebp, esp

; 404  : 	// Reinterpret 32-bit float as 32-bit unsigned int
; 405  :     TInt32 xInt = *(TInt32*)&x;

	mov	ecx, DWORD PTR _x$[ebp]

; 406  :     if (xInt < 0)

	mov	edx, -2147483648			; 80000000H
	test	ecx, ecx
	jns	SHORT $LN2@AreEqual

; 407  : 	{
; 408  : 		// Reorder negative values so we can use integer comparison
; 409  :         xInt = 0x80000000 - xInt;

	mov	eax, edx
	sub	eax, ecx
	mov	ecx, eax
$LN2@AreEqual:

; 410  : 	}
; 411  : 
; 412  : 	// Same with second value
; 413  :     TInt32 yInt = *(TInt32*)&y;

	mov	eax, DWORD PTR _y$[ebp]

; 414  :     if (yInt < 0)

	test	eax, eax
	jns	SHORT $LN1@AreEqual

; 415  : 	{
; 416  :         yInt = 0x80000000 - yInt;

	sub	edx, eax
	mov	eax, edx
$LN1@AreEqual:

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	sub	ecx, eax

; 78   : inline TUInt32 Abs( const TInt32 x ) { return abs( static_cast<int>(x) ); }

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 417  : 	}
; 418  : 
; 419  : 	// Values are equal if integer representations are near enough
; 420  :     return Abs( xInt - yInt ) < iEpsilonFrac;

	cmp	eax, DWORD PTR _iEpsilonFrac$[ebp]
	sbb	eax, eax
	neg	eax

; 421  : }

	pop	ebp
	ret	0
?AreEqual@gen@@YA_NMMI@Z ENDP				; gen::AreEqual
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?IsZero@gen@@YA_NMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_fEpsilon$ = 12						; size = 4
?IsZero@gen@@YA_NMM@Z PROC				; gen::IsZero, COMDAT

; 291  : {

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _x$[ebp]

; 292  : 	return Abs( x ) < fEpsilon;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm1, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 292  : 	return Abs( x ) < fEpsilon;

	movss	xmm0, DWORD PTR _fEpsilon$[ebp]
	comiss	xmm0, xmm1
	seta	al

; 293  : }

	pop	ebp
	ret	0
?IsZero@gen@@YA_NMM@Z ENDP				; gen::IsZero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?SinCos@gen@@YAXMPAM0@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_pSin$ = 12						; size = 4
_pCos$ = 16						; size = 4
?SinCos@gen@@YAXMPAM0@Z PROC				; gen::SinCos, COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 193  :     *pSin = Sin( x );

	mov	eax, DWORD PTR _pSin$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 193  :     *pSin = Sin( x );

	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 194  :     *pCos = Cos( x );

	mov	eax, DWORD PTR _pCos$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 194  :     *pCos = Cos( x );

	movss	DWORD PTR [eax], xmm0

; 195  : }

	pop	ebp
	ret	0
?SinCos@gen@@YAXMPAM0@Z ENDP				; gen::SinCos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?InvSqrt@gen@@YAMM@Z
_TEXT	SEGMENT
tv74 = -4						; size = 4
_x$ = 8							; size = 4
?InvSqrt@gen@@YAMM@Z PROC				; gen::InvSqrt, COMDAT

; 158  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 162  : 	return 1.0f / Sqrt( x );

	divss	xmm1, xmm0
	movss	DWORD PTR tv74[esp+8], xmm1
	fld	DWORD PTR tv74[esp+8]

; 163  : 
; 164  : 	GEN_ENDGUARD_OPT;
; 165  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InvSqrt@gen@@YAMM@Z ENDP				; gen::InvSqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?ATan@gen@@YAMMM@Z
_TEXT	SEGMENT
tv83 = -8						; size = 8
tv77 = -8						; size = 8
tv65 = -8						; size = 8
tv85 = 8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?ATan@gen@@YAMMM@Z PROC					; gen::ATan, COMDAT

; 146  : inline TFloat32 ATan( const TFloat32 x, const TFloat32 y ) { return atan2f( x, y ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 649  :     return (float)atan2(_Y, _X);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv65[ebp], xmm0
	movss	xmm0, DWORD PTR _y$[ebp]
	fld	QWORD PTR tv65[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv77[ebp], xmm0
	fld	QWORD PTR tv77[ebp]
	call	__CIatan2
	fstp	QWORD PTR tv83[ebp]
	movsd	xmm0, QWORD PTR tv83[ebp]
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 146  : inline TFloat32 ATan( const TFloat32 x, const TFloat32 y ) { return atan2f( x, y ); }

	movss	DWORD PTR tv85[ebp], xmm0
	fld	DWORD PTR tv85[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?ATan@gen@@YAMMM@Z ENDP					; gen::ATan
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?ACos@gen@@YAMM@Z
_TEXT	SEGMENT
tv65 = 8						; size = 4
_x$ = 8							; size = 4
?ACos@gen@@YAMM@Z PROC					; gen::ACos, COMDAT

; 142  : inline TFloat32 ACos( const TFloat32 x ) { return acosf( x ); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 639  :     return (float)acos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_acos_precise
	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 142  : inline TFloat32 ACos( const TFloat32 x ) { return acosf( x ); }

	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]
	pop	ebp
	ret	0
?ACos@gen@@YAMM@Z ENDP					; gen::ACos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?Cos@gen@@YAMM@Z
_TEXT	SEGMENT
tv65 = 8						; size = 4
_x$ = 8							; size = 4
?Cos@gen@@YAMM@Z PROC					; gen::Cos, COMDAT

; 135  : inline TFloat32 Cos( const TFloat32 x ) { return cosf( x ); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 135  : inline TFloat32 Cos( const TFloat32 x ) { return cosf( x ); }

	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]
	pop	ebp
	ret	0
?Cos@gen@@YAMM@Z ENDP					; gen::Cos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?Sin@gen@@YAMM@Z
_TEXT	SEGMENT
tv65 = 8						; size = 4
_x$ = 8							; size = 4
?Sin@gen@@YAMM@Z PROC					; gen::Sin, COMDAT

; 133  : inline TFloat32 Sin( const TFloat32 x ) { return sinf( x ); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 133  : inline TFloat32 Sin( const TFloat32 x ) { return sinf( x ); }

	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]
	pop	ebp
	ret	0
?Sin@gen@@YAMM@Z ENDP					; gen::Sin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?Sqrt@gen@@YAMM@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
_x$ = 8							; size = 4
?Sqrt@gen@@YAMM@Z PROC					; gen::Sqrt, COMDAT

; 107  : inline TFloat32 Sqrt( const TFloat32 x ) { return sqrtf( x ); }

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
	cvtsd2ss xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 107  : inline TFloat32 Sqrt( const TFloat32 x ) { return sqrtf( x ); }

	movss	DWORD PTR tv65[esp+8], xmm0
	fld	DWORD PTR tv65[esp+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?Sqrt@gen@@YAMM@Z ENDP					; gen::Sqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?Abs@gen@@YAMM@Z
_TEXT	SEGMENT
tv65 = 8						; size = 4
_x$ = 8							; size = 4
?Abs@gen@@YAMM@Z PROC					; gen::Abs, COMDAT

; 80   : inline TFloat32 Abs( const TFloat32 x ) { return fabsf( x ); }

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _x$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h

; 80   : inline TFloat32 Abs( const TFloat32 x ) { return fabsf( x ); }

	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]
	pop	ebp
	ret	0
?Abs@gen@@YAMM@Z ENDP					; gen::Abs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\math\basemath.h
;	COMDAT ?Abs@gen@@YAIH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?Abs@gen@@YAIH@Z PROC					; gen::Abs, COMDAT

; 78   : inline TUInt32 Abs( const TInt32 x ) { return abs( static_cast<int>(x) ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _x$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	pop	ebp
	ret	0
?Abs@gen@@YAIH@Z ENDP					; gen::Abs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0CFatalException@gen@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0CFatalException@gen@@QAE@ABV01@@Z PROC		; gen::CFatalException::CFatalException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CFatalException@gen@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 726  : 		assign(_Right, 0, npos);

	mov	esi, DWORD PTR ___that$[ebp]
	push	-1
	push	0

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 726  : 		assign(_Right, 0, npos);

	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	-1
	lea	ecx, DWORD PTR [edi+24]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR [esi+24]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 726  : 		assign(_Right, 0, npos);

	push	0

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 726  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+48]
	lea	ecx, DWORD PTR [edi+52]
	mov	DWORD PTR [edi+48], eax
	lea	eax, DWORD PTR [esi+52]
	push	-1
	push	0

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 726  : 		assign(_Right, 0, npos);

	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFatalException@gen@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CFatalException@gen@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0CFatalException@gen@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CFatalException@gen@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CFatalException@gen@@QAE@ABV01@@Z ENDP		; gen::CFatalException::CFatalException
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??1CFatalException@gen@@QAE@XZ
_TEXT	SEGMENT
??1CFatalException@gen@@QAE@XZ PROC			; gen::CFatalException::~CFatalException, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+72], 16			; 00000010H
	jb	SHORT $LN23@CFatalExce
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi+52]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN23@CFatalExce:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+72], 15			; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+68], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi+52], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+44], 16			; 00000010H
	jb	SHORT $LN55@CFatalExce
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi+24]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN55@CFatalExce:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+44], 15			; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN87@CFatalExce
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN87@CFatalExce:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
	ret	0
??1CFatalException@gen@@QAE@XZ ENDP			; gen::CFatalException::~CFatalException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h
;	COMDAT ??0CFatalException@gen@@QAE@PBD00@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_sFileName$ = 8						; size = 4
_sFunction$ = 12					; size = 4
_sObject$ = 16						; size = 4
??0CFatalException@gen@@QAE@PBD00@Z PROC		; gen::CFatalException::CFatalException, COMDAT
; _this$ = ecx

; 51   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CFatalException@gen@@QAE@PBD00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	19					; 00000013H

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_0BE@HBKCGNOA@Unhandled?5Exception?$AA@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edi, DWORD PTR _sFileName$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+44], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi+24], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edi], 0
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h

; 51   : 	{

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	jne	SHORT $LN92@CFatalExce
	xor	ecx, ecx
	jmp	SHORT $LN93@CFatalExce
$LN92@CFatalExce:
	mov	ecx, edi
	lea	ebx, DWORD PTR [ecx+1]
$LL138@CFatalExce:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL138@CFatalExce
	sub	ecx, ebx
$LN93@CFatalExce:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edi
	lea	ecx, DWORD PTR [esi+24]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h

; 51   : 	{

	lea	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+48], -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h

; 51   : 	{

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h

; 52   : 		AppendToCallStack( sFunction, sObject );

	push	0
	push	DWORD PTR _sObject$[ebp]
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	DWORD PTR _sFunction$[ebp]
	call	?AppendToCallStack@CFatalException@gen@@QAEXPBD0_N@Z ; gen::CFatalException::AppendToCallStack

; 53   : 	}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFatalException@gen@@QAE@PBD00@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CFatalException@gen@@QAE@PBD00@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CFatalException@gen@@QAE@PBD00@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0CFatalException@gen@@QAE@PBD00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CFatalException@gen@@QAE@PBD00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CFatalException@gen@@QAE@PBD00@Z ENDP		; gen::CFatalException::CFatalException
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h
;	COMDAT ??0CFatalException@gen@@QAE@PBD0H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_sDescription$ = 8					; size = 4
_sFileName$ = 12					; size = 4
_iLineNum$ = 16						; size = 4
??0CFatalException@gen@@QAE@PBD0H@Z PROC		; gen::CFatalException::CFatalException, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CFatalException@gen@@QAE@PBD0H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edx, DWORD PTR _sDescription$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN48@CFatalExce
	xor	ecx, ecx
	jmp	SHORT $LN49@CFatalExce
$LN48@CFatalExce:
	mov	ecx, edx
	lea	edi, DWORD PTR [ecx+1]
	npad	3
$LL138@CFatalExce:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL138@CFatalExce
	sub	ecx, edi
$LN49@CFatalExce:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edi, DWORD PTR _sFileName$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+44], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi+24], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edi], 0
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h

; 40   : 	{

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	jne	SHORT $LN92@CFatalExce
	xor	ecx, ecx
	jmp	SHORT $LN93@CFatalExce
$LN92@CFatalExce:
	mov	ecx, edi
	lea	ebx, DWORD PTR [ecx+1]
	npad	4
$LL139@CFatalExce:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL139@CFatalExce
	sub	ecx, ebx
$LN93@CFatalExce:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edi
	lea	ecx, DWORD PTR [esi+24]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h

; 40   : 	{

	mov	eax, DWORD PTR _iLineNum$[ebp]
	lea	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+48], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h

; 40   : 	{

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\import\common\cfatalexception.h

; 41   : 	}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFatalException@gen@@QAE@PBD0H@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CFatalException@gen@@QAE@PBD0H@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0CFatalException@gen@@QAE@PBD0H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CFatalException@gen@@QAE@PBD0H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CFatalException@gen@@QAE@PBD0H@Z ENDP		; gen::CFatalException::CFatalException
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\common\gendefines.h
;	COMDAT ?ObjectName@gen@@YAPBDXZ
_TEXT	SEGMENT
?ObjectName@gen@@YAPBDXZ PROC				; gen::ObjectName, COMDAT

; 98   : inline const char* ObjectName() { return ""; }

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	ret	0
?ObjectName@gen@@YAPBDXZ ENDP				; gen::ObjectName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??__FksNewline@gen@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__FksNewline@gen@@YAXXZ PROC				; gen::`dynamic atexit destructor for 'ksNewline'', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR _ksNewline+20, 16		; 00000010H
	jb	SHORT $LN23@dynamic
	push	esi

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	esi, DWORD PTR _ksNewline

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	push	OFFSET _ksNewline
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
$LN23@dynamic:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _ksNewline+20, 15		; 0000000fH

; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR _ksNewline+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR _ksNewline, 0
	mov	esp, ebp
	pop	ebp
	ret	0
??__FksNewline@gen@@YAXXZ ENDP				; gen::`dynamic atexit destructor for 'ksNewline''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
;	COMDAT ??__EksNewline@gen@@YAXXZ
text$di	SEGMENT
??__EksNewline@gen@@YAXXZ PROC				; gen::`dynamic initializer for 'ksNewline'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, OFFSET _ksNewline
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h

; 86   : const string ksNewline = "\n";

	push	OFFSET ??__FksNewline@gen@@YAXXZ	; gen::`dynamic atexit destructor for 'ksNewline''
	call	_atexit
	pop	ecx
	ret	0
??__EksNewline@gen@@YAXXZ ENDP				; gen::`dynamic initializer for 'ksNewline''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??__FksPathSeparator@gen@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__FksPathSeparator@gen@@YAXXZ PROC			; gen::`dynamic atexit destructor for 'ksPathSeparator'', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR _ksPathSeparator+20, 16	; 00000010H
	jb	SHORT $LN23@dynamic
	push	esi

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	esi, DWORD PTR _ksPathSeparator

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	push	OFFSET _ksPathSeparator
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
$LN23@dynamic:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _ksPathSeparator+20, 15	; 0000000fH

; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR _ksPathSeparator+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR _ksPathSeparator, 0
	mov	esp, ebp
	pop	ebp
	ret	0
??__FksPathSeparator@gen@@YAXXZ ENDP			; gen::`dynamic atexit destructor for 'ksPathSeparator''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
;	COMDAT ??__EksPathSeparator@gen@@YAXXZ
text$di	SEGMENT
??__EksPathSeparator@gen@@YAXXZ PROC			; gen::`dynamic initializer for 'ksPathSeparator'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01KICIPPFI@?2?$AA@
	mov	ecx, OFFSET _ksPathSeparator
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h

; 85   : const string ksPathSeparator = "\\";

	push	OFFSET ??__FksPathSeparator@gen@@YAXXZ	; gen::`dynamic atexit destructor for 'ksPathSeparator''
	call	_atexit
	pop	ecx
	ret	0
??__EksPathSeparator@gen@@YAXXZ ENDP			; gen::`dynamic initializer for 'ksPathSeparator''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??__FksCompiler@gen@@YAXXZ
text$yd	SEGMENT
$T1 = -1						; size = 1
$T2 = -1						; size = 1
??__FksCompiler@gen@@YAXXZ PROC				; gen::`dynamic atexit destructor for 'ksCompiler'', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR _ksCompiler+20, 16		; 00000010H
	jb	SHORT $LN23@dynamic
	push	esi

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	esi, DWORD PTR _ksCompiler

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	push	OFFSET _ksCompiler
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 684  : 		return (_Alty());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
$LN23@dynamic:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _ksCompiler+20, 15		; 0000000fH

; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR _ksCompiler+16, 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR _ksCompiler, 0
	mov	esp, ebp
	pop	ebp
	ret	0
??__FksCompiler@gen@@YAXXZ ENDP				; gen::`dynamic atexit destructor for 'ksCompiler''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h
;	COMDAT ??__EksCompiler@gen@@YAXXZ
text$di	SEGMENT
??__EksCompiler@gen@@YAXXZ PROC				; gen::`dynamic initializer for 'ksCompiler'', COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	32					; 00000020H
	push	OFFSET ??_C@_0CB@NBMGHEOM@Visual?5C?$CL?$CL?58?40?5?$CI2005?$CJ?5or?5greater@
	mov	ecx, OFFSET _ksCompiler
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\simon\documents\github\post-processing\import\common\msdefines.h

; 80   : 	static const string ksCompiler = "Visual C++ 8.0 (2005) or greater";

	push	OFFSET ??__FksCompiler@gen@@YAXXZ	; gen::`dynamic atexit destructor for 'ksCompiler''
	call	_atexit
	pop	ecx
	ret	0
??__EksCompiler@gen@@YAXXZ ENDP				; gen::`dynamic initializer for 'ksCompiler''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 614  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	esi

; 615  : 		if (_Syserror_map(_Errval))

	mov	esi, DWORD PTR __Errval$[ebp]
	push	esi
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax

; 299  : 		{	// construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi

; 615  : 		if (_Syserror_map(_Errval))

	je	SHORT $LN2@default_er

; 299  : 		{	// construct from error code and category

	mov	DWORD PTR [eax+4], OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	pop	esi

; 616  : 			return (error_condition(_Errval, generic_category()));
; 617  : 		else
; 618  : 			return (error_condition(_Errval, system_category()));
; 619  : 		}

	pop	ebp
	ret	8
$LN2@default_er:

; 299  : 		{	// construct from error code and category

	mov	DWORD PTR [eax+4], OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	pop	esi

; 616  : 			return (error_condition(_Errval, generic_category()));
; 617  : 		else
; 618  : 			return (error_condition(_Errval, system_category()));
; 619  : 		}

	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 607  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	push	DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 608  : 		const char *_Name = _Winerror_map(_Errcode);

	add	esp, 4

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	test	eax, eax
	mov	edx, OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
	cmovne	edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN47@message
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 610  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN47@message:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL49@message:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL49@message
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 609  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 610  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 603  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 604  : 		}

	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 597  : 	_System_error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7_System_error_category@std@@6B@

; 598  : 		{	// default constructor
; 599  : 		}

	mov	eax, ecx
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 584  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	push	ecx

; 585  : 		if (_Errcode == (int)io_errc::stream)

	mov	eax, DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 585  : 		if (_Errcode == (int)io_errc::stream)

	cmp	eax, 1
	jne	SHORT $LN2@message
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	21					; 00000015H

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 588  : 			return (_Generic_error_category::message(_Errcode));

	mov	eax, esi
	pop	esi

; 589  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@message:

; 588  : 			return (_Generic_error_category::message(_Errcode));

	push	eax
	push	esi
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, esi
	pop	esi

; 589  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 580  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 581  : 		}

	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 574  : 	_Iostream_error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@

; 575  : 		{	// default constructor
; 576  : 		}

	mov	eax, ecx
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN8@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 563  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	push	DWORD PTR __Errcode$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 564  : 		const char *_Name = _Syserror_map(_Errcode);

	add	esp, 4

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	test	eax, eax
	mov	edx, OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
	cmovne	edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN47@message
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 566  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN47@message:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
$LL49@message:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL49@message
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error

; 565  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	mov	eax, esi
	pop	esi

; 566  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 559  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 560  : 		}

	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 553  : 	_Generic_error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7_Generic_error_category@std@@6B@

; 554  : 		{	// default constructor
; 555  : 		}

	mov	eax, ecx
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 352  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp

; 177  : 		return (this == &_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	mov	al, 1

; 355  : 		}

	pop	ebp
	ret	4
$LN3@operator:

; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	xor	al, al

; 355  : 		}

	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 338  : 		return (*_Mycat);

	mov	eax, DWORD PTR [ecx+4]

; 339  : 		}

	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 333  : 		return (_Myval);

	mov	eax, DWORD PTR [ecx]

; 334  : 		}

	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 299  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 300  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR [ecx+4]

; 248  : 		}

	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 242  : 		return (_Myval);

	mov	eax, DWORD PTR [ecx]

; 243  : 		}

	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7error_category@std@@6B@
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 176  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp

; 177  : 		return (this == &_Right);

	xor	eax, eax
	cmp	ecx, DWORD PTR __Right$[ebp]
	sete	al

; 178  : 		}

	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 391  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp

; 177  : 		return (this == &_Right);

	mov	eax, DWORD PTR __Code$[ebp]
	cmp	ecx, DWORD PTR [eax+4]

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	jne	SHORT $LN3@equivalent
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	al, 1

; 393  : 	}

	pop	ebp
	ret	8
$LN3@equivalent:

; 392  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	xor	al, al

; 393  : 	}

	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 384  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T1[ebp]
	sub	esp, 8
	push	DWORD PTR __Errval$[ebp]
	push	edx
	call	DWORD PTR [eax+12]

; 177  : 		return (this == &_Right);

	mov	edx, DWORD PTR __Cond$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edx+4]

; 178  : 		}
; 179  : 
; 180  : 	bool operator!=(const error_category& _Right) const _NOEXCEPT
; 181  : 		{	// compare categories for inequality
; 182  : 		return (!(*this == _Right));
; 183  : 		}
; 184  : 
; 185  : 	bool operator<(const error_category& _Right) const _NOEXCEPT
; 186  : 		{	// compare categories for order
; 187  : 		return (this < &_Right);
; 188  : 		}
; 189  : 
; 190  : 	error_category(const error_category&) = delete;
; 191  : 	error_category& operator=(const error_category&) = delete;
; 192  : 	};
; 193  : 
; 194  : 		// CLASS error_code
; 195  : class error_code
; 196  : 	{	// store an implementation-specific error code and category
; 197  : public:
; 198  : 	typedef error_code _Myt;
; 199  : 
; 200  : 	error_code()
; 201  : 		: _Myval(0),
; 202  : 			_Mycat(&system_category())
; 203  : 		{	// construct non-error
; 204  : 		}
; 205  : 
; 206  : 	error_code(int _Val, const error_category& _Cat)
; 207  : 		: _Myval(_Val), _Mycat(&_Cat)
; 208  : 		{	// construct from error code and category
; 209  : 		}
; 210  : 
; 211  : 	template<class _Enum,
; 212  : 		class = typename enable_if<is_error_code_enum<_Enum>::value,
; 213  : 			void>::type>
; 214  : 		error_code(_Enum _Errcode)
; 215  : 		: _Myval(0), _Mycat(0)
; 216  : 		{	// construct from enumerated error code
; 217  : 		*this = make_error_code(_Errcode);	// using ADL
; 218  : 		}
; 219  : 
; 220  : 	void assign(int _Val, const error_category& _Cat)
; 221  : 		{	// assign error code and category
; 222  : 		_Myval = _Val;
; 223  : 		_Mycat = &_Cat;
; 224  : 		}
; 225  : 
; 226  : 	template<class _Enum>
; 227  : 		typename enable_if<is_error_code_enum<_Enum>::value,
; 228  : 			error_code>::type& operator=(_Enum _Errcode)
; 229  : 		{	// assign enumerated error code
; 230  : 		*this = make_error_code(_Errcode);	// using ADL
; 231  : 		return (*this);
; 232  : 		}
; 233  : 
; 234  : 	void clear() _NOEXCEPT
; 235  : 		{	// assign non-error
; 236  : 		_Myval = 0;
; 237  : 		_Mycat = &system_category();
; 238  : 		}
; 239  : 
; 240  : 	int value() const
; 241  : 		{	// get error code
; 242  : 		return (_Myval);
; 243  : 		}
; 244  : 
; 245  : 	const error_category& category() const
; 246  : 		{	// get category
; 247  : 		return (*_Mycat);
; 248  : 		}
; 249  : 
; 250  : 	error_condition default_error_condition() const;
; 251  : 
; 252  : 	string message() const
; 253  : 		{	// get name of error code
; 254  : 		return (category().message(value()));
; 255  : 		}
; 256  : 
; 257  : 	explicit operator bool() const _NOEXCEPT
; 258  : 		{	// test for actual error
; 259  : 		return (value() != 0);
; 260  : 		}
; 261  : 
; 262  : 	bool operator==(const error_code& _Right) const _NOEXCEPT
; 263  : 		{	// test if *this == _Right
; 264  : 		return (category() == _Right.category()
; 265  : 			&& value() == _Right.value());
; 266  : 		}
; 267  : 
; 268  : 	bool operator!=(const error_code& _Right) const _NOEXCEPT
; 269  : 		{	// test if *this != _Right
; 270  : 		return (!(*this == _Right));
; 271  : 		}
; 272  : 
; 273  : 	bool operator<(const error_code& _Right) const _NOEXCEPT
; 274  : 		{	// test if *this == _Right
; 275  : 		return (category() < _Right.category()
; 276  : 			|| (category() == _Right.category()
; 277  : 				&& value() < _Right.value()));
; 278  : 		}
; 279  : 
; 280  : private:
; 281  : 	int _Myval;	// the stored error number
; 282  : 	const error_category *_Mycat;	// pointer to error category
; 283  : 	};
; 284  : 
; 285  : 		// CLASS error_condition
; 286  : class error_condition
; 287  : 	{	// store an abstract error code and category
; 288  : public:
; 289  : 	typedef error_condition _Myt;
; 290  : 
; 291  : 	error_condition() _NOEXCEPT
; 292  : 		: _Myval(0),
; 293  : 			_Mycat(&generic_category())
; 294  : 		{	// construct non-error
; 295  : 		}
; 296  : 
; 297  : 	error_condition(int _Val, const error_category& _Cat) _NOEXCEPT
; 298  : 		: _Myval(_Val), _Mycat(&_Cat)
; 299  : 		{	// construct from error code and category
; 300  : 		}
; 301  : 
; 302  : 	template<class _Enum,
; 303  : 		class = typename enable_if<is_error_condition_enum<_Enum>::value,
; 304  : 			void>::type>
; 305  : 		error_condition(_Enum _Errcode) _NOEXCEPT
; 306  : 		: _Myval(0), _Mycat(0)
; 307  : 		{	// construct from enumerated error code
; 308  : 		*this = make_error_condition(_Errcode);	// using ADL
; 309  : 		}
; 310  : 
; 311  : 	void assign(int _Val, const error_category& _Cat) _NOEXCEPT
; 312  : 		{	// assign error code and category
; 313  : 		_Myval = _Val;
; 314  : 		_Mycat = &_Cat;
; 315  : 		}
; 316  : 
; 317  : 	template<class _Enum>
; 318  : 		typename enable_if<is_error_condition_enum<_Enum>::value,
; 319  : 			error_condition>::type& operator=(_Enum _Errcode) _NOEXCEPT
; 320  : 		{	// assign enumerated error code
; 321  : 		*this = make_error_condition(_Errcode);	// using ADL
; 322  : 		return (*this);
; 323  : 		}
; 324  : 
; 325  : 	void clear() _NOEXCEPT
; 326  : 		{	// assign non-error
; 327  : 		_Myval = 0;
; 328  : 		_Mycat = &generic_category();
; 329  : 		}
; 330  : 
; 331  : 	int value() const _NOEXCEPT
; 332  : 		{	// get error code
; 333  : 		return (_Myval);
; 334  : 		}
; 335  : 
; 336  : 	const error_category& category() const _NOEXCEPT
; 337  : 		{	// get category
; 338  : 		return (*_Mycat);
; 339  : 		}
; 340  : 
; 341  : 	string message() const
; 342  : 		{	// get name of error code
; 343  : 		return (category().message(value()));
; 344  : 		}
; 345  : 
; 346  : 	explicit operator bool() const _NOEXCEPT
; 347  : 		{	// test for actual error
; 348  : 		return (value() != 0);
; 349  : 		}
; 350  : 
; 351  : 	bool operator==(const error_condition& _Right) const _NOEXCEPT
; 352  : 		{	// test if *this == _Right
; 353  : 		return (category() == _Right.category()
; 354  : 			&& value() == _Right.value());

	jne	SHORT $LN5@equivalent
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN5@equivalent

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	mov	al, 1

; 386  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN5@equivalent:

; 385  : 	return (default_error_condition(_Errval) == _Cond);

	xor	al, al

; 386  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 377  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp

; 299  : 		{	// construct from error code and category

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Errval$[ebp]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 378  : 	return (error_condition(_Errval, *this));
; 379  : 	}

	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 160  : 		}

	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 154  : 	error_category()

	mov	DWORD PTR [ecx], OFFSET ??_7error_category@std@@6B@

; 155  : 		{	// default constructor
; 156  : 		}

	mov	eax, ecx
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 653  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 654  : 	}

	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 643  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 644  : 	}

	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 75   : 			}

	mov	eax, ecx
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2272 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 2273 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	je	SHORT $LN19@Tidy

; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN19@Tidy

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN14@Tidy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN14@Tidy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebx
$LN19@Tidy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2286 : 		}

	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2256 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	esi
	test	edx, edx
	je	SHORT $LN2@Inside

; 513  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN8@Inside
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN9@Inside
$LN8@Inside:
	mov	esi, ecx
$LN9@Inside:

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	edx, esi
	jb	SHORT $LN2@Inside

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN14@Inside
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN15@Inside
$LN14@Inside:
	mov	esi, ecx
$LN15@Inside:

; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	eax, DWORD PTR [ecx+16]
	add	eax, esi
	cmp	eax, edx
	jbe	SHORT $LN2@Inside

; 2260 : 		else
; 2261 : 			return (true);

	mov	al, 1
	pop	esi

; 2262 : 		}

	pop	ebp
	ret	4
$LN2@Inside:

; 2259 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2262 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ptr$1$ = 12						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2243 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	cmp	edi, -2					; fffffffeH
	ja	$LN67@Grow

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN5@Grow

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	DWORD PTR [esi+16]
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, edi
	pop	edi
	sbb	eax, eax
	neg	eax
	pop	esi

; 2253 : 		}

	pop	ebp
	ret	8
$LN5@Grow:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	cmp	BYTE PTR __Trim$[ebp], 0
	je	SHORT $LN3@Grow
	cmp	edi, 16					; 00000010H
	jae	SHORT $LN3@Grow

; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	push	ebx
	mov	ebx, DWORD PTR [esi+16]
	cmp	edi, ebx
	cmovb	ebx, edi

; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN44@Grow

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __Ptr$1$[ebp], eax

; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)

	test	ebx, ebx
	je	SHORT $LN39@Grow
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	ebx
	push	eax
	push	esi
	call	_memcpy
	mov	eax, DWORD PTR __Ptr$1$[ebp]
	add	esp, 12					; 0000000cH
$LN39@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN44@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);
; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	eax, edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ebx+esi], 0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	sbb	eax, eax
	pop	edi
	neg	eax
	pop	esi

; 2253 : 		}

	pop	ebp
	ret	8
$LN3@Grow:

; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN64@Grow

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);
; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN60@Grow
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, DWORD PTR [esi]
$LN60@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
$LN64@Grow:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, edi
	pop	edi
	sbb	eax, eax
	neg	eax
	pop	esi

; 2253 : 		}

	pop	ebp
	ret	8
$LN67@Grow:

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN69@Grow:
$LN66@Grow:
	int	3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2236 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN5@Eos
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2238 : 		}

	pop	ebp
	ret	4
$LN5@Eos:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2238 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$1$ = -20						; size = 4
__Newres$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
$T2 = 11						; size = 1
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, eax
	or	edi, 15					; 0000000fH

; 2203 : 		if (max_size() < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN9@Copy

; 2204 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax
	jmp	SHORT $LN47@Copy
$LN9@Copy:

; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	ebx, DWORD PTR [esi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN47@Copy

; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	eax, -2					; fffffffeH

; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN47@Copy

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);
; 521  : 		}
; 522  : 
; 523  : 	union _Bxty
; 524  : 		{	// storage for small buffer or pointer to larger one
; 525  : 		value_type _Buf[_BUF_SIZE];
; 526  : 		pointer _Ptr;
; 527  : 		char _Alias[_BUF_SIZE];	// to permit aliasing
; 528  : 		} _Bx;
; 529  : 
; 530  : 	size_type _Mysize;	// current length of string
; 531  : 	size_type _Myres;	// current storage reserved for string
; 532  : 	};
; 533  : 
; 534  : 		// TEMPLATE CLASS _String_alloc
; 535  : template<bool _Al_has_storage,
; 536  : 	class _Alloc_types>
; 537  : 	class _String_alloc
; 538  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 539  : 	{	// base class for basic_string to hold allocator with storage
; 540  : public:
; 541  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 542  : 
; 543  : 	typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 544  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 545  : 	typedef typename _Alloc_types::_Alty _Alty;
; 546  : 
; 547  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 548  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 549  : 		: _Alval(_Al)
; 550  : 		{	// construct allocator from _Al
; 551  : 		}
; 552  : 
; 553  : 	void _Change_alloc(const _Alty& _Al)
; 554  : 		{	// replace old allocator
; 555  : 		this->_Alval = _Al;
; 556  : 		}
; 557  : 
; 558  : 	void _Swap_alloc(_Myt& _Right)
; 559  : 		{	// swap allocators
; 560  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 561  : 		}
; 562  : 
; 563  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 564  : 	_String_alloc(const _Alloc& _Al = _Alloc())
; 565  : 		: _Alval(_Al)
; 566  : 		{	// construct allocator from _Al
; 567  : 		_Alloc_proxy();
; 568  : 		}
; 569  : 
; 570  : 	~_String_alloc() _NOEXCEPT
; 571  : 		{	// destroy the object
; 572  : 		_Free_proxy();
; 573  : 		}
; 574  : 
; 575  : 	void _Change_alloc(const _Alty& _Al)
; 576  : 		{	// replace old allocator
; 577  : 		_Free_proxy();
; 578  : 		this->_Alval = _Al;
; 579  : 		_Alloc_proxy();
; 580  : 		}
; 581  : 
; 582  : 	void _Swap_alloc(_Myt& _Right)
; 583  : 		{	// swap allocators
; 584  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 585  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 586  : 		}
; 587  : 
; 588  : 	void _Alloc_proxy()
; 589  : 		{	// construct proxy from _Alval
; 590  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 591  : 			_Alproxy(this->_Alval);
; 592  : 		this->_Myproxy = _Alproxy.allocate(1);
; 593  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 594  : 		this->_Myproxy->_Mycont = this;
; 595  : 		}
; 596  : 
; 597  : 	void _Free_proxy()
; 598  : 		{	// destroy proxy
; 599  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 600  : 			_Alproxy(this->_Alval);
; 601  : 		this->_Orphan_all();
; 602  : 		_Alproxy.destroy(this->_Myproxy);
; 603  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 604  : 		this->_Myproxy = 0;
; 605  : 		}
; 606  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 607  : 
; 608  : 	_Alty& _Getal()
; 609  : 		{	// get reference to allocator
; 610  : 		return (this->_Alval);
; 611  : 		}
; 612  : 
; 613  : 	const _Alty& _Getal() const
; 614  : 		{	// get reference to allocator
; 615  : 		return (this->_Alval);
; 616  : 		}
; 617  : 	};
; 618  : 
; 619  : template<class _Alloc_types>
; 620  : 	class _String_alloc<false, _Alloc_types>
; 621  : 		: public _String_val<typename _Alloc_types::_Val_types>
; 622  : 	{	// base class for basic_string to hold allocator with no storage
; 623  : public:
; 624  : 	typedef _String_alloc<false, _Alloc_types> _Myt;
; 625  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 626  : 
; 627  : 	typedef typename _Alloc_types::_Alty _Alty;
; 628  : 
; 629  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 630  : 	_String_alloc(const _Alloc& = _Alloc())
; 631  : 		{	// construct allocator from _Al
; 632  : 		}
; 633  : 
; 634  : 	void _Change_alloc(const _Alty&)
; 635  : 		{	// replace old allocator
; 636  : 		}
; 637  : 
; 638  : 	void _Swap_alloc(_Myt&)
; 639  : 		{	// swap allocators
; 640  : 		}
; 641  : 
; 642  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 643  : 	_String_alloc(const _Alloc& = _Alloc())
; 644  : 		{	// construct allocator from _Al
; 645  : 		_Alloc_proxy();
; 646  : 		}
; 647  : 
; 648  : 	~_String_alloc() _NOEXCEPT
; 649  : 		{	// destroy the object
; 650  : 		_Free_proxy();
; 651  : 		}
; 652  : 
; 653  : 	void _Change_alloc(const _Alty&)
; 654  : 		{	// replace old allocator
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 660  : 		}
; 661  : 
; 662  : 	void _Alloc_proxy()
; 663  : 		{	// construct proxy from _Alval
; 664  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 665  : 			_Alproxy;
; 666  : 		this->_Myproxy = _Alproxy.allocate(1);
; 667  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 668  : 		this->_Myproxy->_Mycont = this;
; 669  : 		}
; 670  : 
; 671  : 	void _Free_proxy()
; 672  : 		{	// destroy proxy
; 673  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 674  : 			_Alproxy;
; 675  : 		this->_Orphan_all();
; 676  : 		_Alproxy.destroy(this->_Myproxy);
; 677  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 678  : 		this->_Myproxy = 0;
; 679  : 		}
; 680  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 681  : 
; 682  : 	_Alty _Getal() const
; 683  : 		{	// get reference to allocator
; 684  : 		return (_Alty());
; 685  : 		}
; 686  : 	};
; 687  : 
; 688  : 		// TEMPLATE CLASS basic_string
; 689  : template<class _Elem,
; 690  : 	class _Traits,
; 691  : 	class _Alloc>
; 692  : 	class basic_string
; 693  : 		: public _String_alloc<!is_empty<_Alloc>::value,
; 694  : 			_String_base_types<_Elem, _Alloc> >
; 695  : 	{	// null-terminated transparent array of elements
; 696  : public:
; 697  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 698  : 	typedef _String_alloc<!is_empty<_Alloc>::value,
; 699  : 		_String_base_types<_Elem, _Alloc> > _Mybase;
; 700  : 	typedef _Traits traits_type;
; 701  : 	typedef _Alloc allocator_type;
; 702  : 
; 703  : 	typedef typename _Mybase::_Alty _Alty;
; 704  : 
; 705  : 	typedef typename _Mybase::value_type value_type;
; 706  : 	typedef typename _Mybase::size_type size_type;
; 707  : 	typedef typename _Mybase::difference_type difference_type;
; 708  : 	typedef typename _Mybase::pointer pointer;
; 709  : 	typedef typename _Mybase::const_pointer const_pointer;
; 710  : 	typedef typename _Mybase::reference reference;
; 711  : 	typedef typename _Mybase::const_reference const_reference;
; 712  : 
; 713  : 	typedef typename _Mybase::iterator iterator;
; 714  : 	typedef typename _Mybase::const_iterator const_iterator;
; 715  : 
; 716  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 717  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 718  : 
; 719  : 	basic_string(const _Myt& _Right)
; 720  : 
; 721  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 722  : 
; 723  : 
; 724  : 		{	// construct by copying _Right
; 725  : 		_Tidy();
; 726  : 		assign(_Right, 0, npos);
; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	edi, -2					; fffffffeH
$LN47@Copy:

; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

	xor	eax, eax
	mov	DWORD PTR __Ptr$1$[ebp], eax

; 24   : 
; 25   : 	if (_Count == 0)

	test	ecx, ecx
	je	SHORT $LN19@Copy

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	ecx, -1
	ja	SHORT $LN62@Copy
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$1$[ebp], eax
	test	eax, eax
	jne	SHORT $LN19@Copy
$LN62@Copy:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN174@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END

	mov	eax, $LN171@Copy
	ret	0
$LN171@Copy:

; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	edi, DWORD PTR __Newres$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], eax
$LN19@Copy:

; 2225 : 
; 2226 : 		if (0 < _Oldlen)

	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	je	SHORT $LN112@Copy

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN105@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN106@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN91@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN91@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2222 : 			_RERAISE;

	push	0

; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 2222 : 			_RERAISE;

	push	0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2222 : 			_RERAISE;

	call	__CxxThrowException@8
$LN175@Copy:
$LN105@Copy:

; 513  : 			: this->_Bx._Buf);

	mov	ecx, esi
$LN106@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	ebx, ebx
	je	SHORT $LN112@Copy
	push	ebx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN112@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN131@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN131@Copy:

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2231 : 		this->_Myres = _Newres;

	mov	DWORD PTR [esi+20], edi

; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 513  : 			: this->_Bx._Buf);

	cmp	edi, 16					; 00000010H
	jb	SHORT $LN166@Copy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	esi, eax
$LN166@Copy:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2233 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN173@Copy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1761 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1754 : 		return (this->_Mysize);

	mov	eax, DWORD PTR [ecx+16]

; 1755 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1343 : 		if (this->_Mysize < _Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	edi, ecx
	jb	SHORT $LN41@erase

; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, ecx
	cmp	eax, edx
	ja	SHORT $LN3@erase

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN14@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1354 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1355 : 		}

	pop	ebp
	ret	8
$LN14@erase:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1355 : 		}

	pop	ebp
	ret	8
$LN3@erase:

; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)

	test	edx, edx
	je	SHORT $LN38@erase

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN22@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN23@erase
$LN22@erase:
	mov	eax, esi
$LN23@erase:

; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;

	sub	edi, edx
	push	ebx
	lea	ebx, DWORD PTR [eax+ecx]

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	je	SHORT $LN29@erase
	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ebx+edx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH
$LN29@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi
	pop	ebx

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN34@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1354 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1355 : 		}

	pop	ebp
	ret	8
$LN34@erase:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN38@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1354 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1355 : 		}

	pop	ebp
	ret	8
$LN41@erase:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN43@erase:
$LN40@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1334 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp

; 1335 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN18@erase

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN11@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1338 : 		return (*this);

	mov	eax, ecx

; 1339 : 		}

	pop	ebp
	ret	4
$LN11@erase:

; 513  : 			: this->_Bx._Buf);

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1338 : 		return (*this);

	mov	eax, ecx

; 1339 : 		}

	pop	ebp
	ret	4
$LN18@erase:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN20@erase:
$LN17@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1167 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@assign
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1170 : 		}

	pop	ebp
	ret	4
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@assign:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@assign
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1170 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@assign

; 513  : 			: this->_Bx._Buf);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN13@assign
$LN12@assign:
	mov	eax, esi
$LN13@assign:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@assign

; 513  : 			: this->_Bx._Buf);

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN18@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN19@assign
$LN18@assign:
	mov	edx, esi
$LN19@assign:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@assign

; 513  : 			: this->_Bx._Buf);

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN24@assign

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN24@assign:

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi

; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	edi

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Count$[ebp]
	cmp	edi, -2					; fffffffeH
	ja	SHORT $LN118@assign

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN32@assign

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1157 : 
; 1158 : 		if (_Grow(_Count))

	je	SHORT $LN112@assign
$LN117@assign:

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN96@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN97@assign
$LN32@assign:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN117@assign

; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN87@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1163 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN87@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1164 : 		}

	pop	ebp
	ret	8
$LN96@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
$LN97@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	edi, edi
	je	SHORT $LN103@assign
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN103@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN108@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1163 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN108@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN112@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1163 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1164 : 		}

	pop	ebp
	ret	8
$LN118@assign:

; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN120@assign:
$LN115@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 1130 : 		if (_Right.size() < _Roff)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Roff$[ebp]
	mov	edi, DWORD PTR [ebx+16]
	cmp	edi, ecx
	jb	$LN125@assign

; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;

	sub	edi, ecx

; 1133 : 		if (_Count < _Num)

	cmp	DWORD PTR __Count$[ebp], edi
	cmovb	edi, DWORD PTR __Count$[ebp]

; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN3@assign

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	lea	eax, DWORD PTR [edi+ecx]

; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)

	cmp	DWORD PTR [esi+16], eax
	jb	$LN127@assign

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN25@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN25@assign:

; 513  : 			: this->_Bx._Buf);

	mov	edx, esi

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN3@assign:

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	$LN128@assign

; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN35@assign

; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Roff$[ebp]

; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1138 : 		else if (_Grow(_Num))

	je	SHORT $LN120@assign
$LN124@assign:

; 514  : 		}
; 515  : 
; 516  : 	const value_type *_Myptr() const
; 517  : 		{	// determine current pointer to buffer for nonmutable string
; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN98@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	ebx, DWORD PTR [ebx]
$LN98@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN104@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	jmp	SHORT $LN105@assign
$LN35@assign:

; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN124@assign

; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN90@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN90@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN104@assign:

; 513  : 			: this->_Bx._Buf);

	mov	edx, esi
$LN105@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	test	edi, edi
	je	SHORT $LN111@assign
	push	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1141 : 				_Right._Myptr() + _Roff, _Num);

	lea	eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN111@assign:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 513  : 			: this->_Bx._Buf);

	jb	SHORT $LN116@assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1144 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN116@assign:

; 513  : 			: this->_Bx._Buf);

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN120@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1144 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1145 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN125@assign:

; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN129@assign:
$LN127@assign:
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN130@assign:
$LN128@assign:

; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN131@assign:
$LN122@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 990  : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN21@basic_stri
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@basic_stri:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 992  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	ecx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN43@basic_stri
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
$LN43@basic_stri:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	mov	edx, ecx
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL45@basic_stri:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL45@basic_stri
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 724  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 726  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 727  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 683  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp

; 684  : 		return (_Alty());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 685  : 		}

	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 494  : 		_Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

	mov	eax, ecx

; 495  : 		_Myres = 0;

	mov	DWORD PTR [ecx+20], 0

; 631  : 		{	// construct allocator from _Al
; 632  : 		}

	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 521  : 		}

	ret	0
$LN3@Myptr:

; 518  : 		return (this->_BUF_SIZE <= this->_Myres
; 519  : 			? _STD addressof(*this->_Bx._Ptr)
; 520  : 			: this->_Bx._Buf);

	mov	eax, ecx

; 521  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 514  : 		}

	ret	0
$LN3@Myptr:

; 511  : 		return (this->_BUF_SIZE <= this->_Myres
; 512  : 			? _STD addressof(*this->_Bx._Ptr)
; 513  : 			: this->_Bx._Buf);

	mov	eax, ecx

; 514  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 493  : 		{	// initialize values
; 494  : 		_Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 495  : 		_Myres = 0;
; 496  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 858  : 		_Mybase::deallocate(_Ptr, _Count);
; 859  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 25   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN14@allocate
	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN14@allocate
$LN6@allocate:

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 848  : 		}

	pop	ebp
	ret	4
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN16@allocate:
$LN13@allocate:
	int	3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 807  : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 802  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 778  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : 		}

	pop	ebp
	ret	4
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@XZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 740  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 741  : 		return (_Al.select_on_container_copy_construction());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 742  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 735  : 		return (_Al.max_size());

	or	eax, -1

; 736  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 613  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 25   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	eax, -1
	ja	SHORT $LN11@allocate
	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	test	ecx, ecx
	je	SHORT $LN11@allocate
$LN4@allocate:

; 578  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, ecx

; 579  : 		}

	pop	ebp
	ret	4
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN13@allocate:
$LN10@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ PROC ; std::allocator<char>::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 532  : 		{	// return this allocator

	push	ebp
	mov	ebp, esp

; 533  : 		return (*this);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 534  : 		}

	pop	ebp
	ret	4
?select_on_container_copy_construction@?$allocator@D@std@@QBE?AV12@XZ ENDP ; std::allocator<char>::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]

; 554  : 		}

	pop	ebp
	ret	0
$LN3@move:

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	mov	DWORD PTR __Count$[ebp], eax

; 554  : 		}

	pop	ebp

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	jmp	_memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]

; 531  : 		}

	pop	ebp
	ret	0
$LN3@copy:

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	mov	DWORD PTR __Count$[ebp], eax

; 531  : 		}

	pop	ebp

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 524  : 		}

	pop	ebp
	ret	0
$LN3@length:

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	lea	edx, DWORD PTR [eax+1]
$LL5@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@length
	sub	eax, edx

; 524  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv68 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 774  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	movss	xmm0, DWORD PTR __X$[ebp]

; 775  :     return (float)sqrt(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sqrt_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv68[esp+8], xmm0
	fld	DWORD PTR tv68[esp+8]

; 776  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 764  : {

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 765  :     return (float)sin(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_sin_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]

; 766  : }

	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 686  : {

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 687  :     return (float)fabs(_X);

	cvtps2pd xmm0, xmm0
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]

; 688  : }

	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 663  : {

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 664  :     return (float)cos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_cos_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]

; 665  : }

	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _atan2f
_TEXT	SEGMENT
tv83 = -8						; size = 8
tv77 = -8						; size = 8
tv74 = -8						; size = 8
tv85 = 8						; size = 4
__Y$ = 8						; size = 4
__X$ = 12						; size = 4
_atan2f	PROC						; COMDAT

; 648  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	movss	xmm0, DWORD PTR __Y$[ebp]

; 649  :     return (float)atan2(_Y, _X);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv74[ebp], xmm0
	movss	xmm0, DWORD PTR __X$[ebp]
	fld	QWORD PTR tv74[ebp]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv77[ebp], xmm0
	fld	QWORD PTR tv77[ebp]
	call	__CIatan2
	fstp	QWORD PTR tv83[ebp]
	movsd	xmm0, QWORD PTR tv83[ebp]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR tv85[ebp], xmm0
	fld	DWORD PTR tv85[ebp]

; 650  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_atan2f	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _acosf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_acosf	PROC						; COMDAT

; 638  : {

	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 639  :     return (float)acos(_X);

	cvtps2pd xmm0, xmm0
	call	__libm_sse2_acos_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]

; 640  : }

	pop	ebp
	ret	0
_acosf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT _hypot
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 8
_hypot	PROC						; COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp

; 557  :     return _hypot(_X, _Y);

	movsd	xmm0, QWORD PTR __Y$[ebp]
	sub	esp, 16					; 00000010H
	movsd	QWORD PTR [esp+8], xmm0
	movsd	xmm0, QWORD PTR __X$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	__hypot
	add	esp, 16					; 00000010H

; 558  : }

	pop	ebp
	ret	0
_hypot	ENDP
_TEXT	ENDS
END
